{"filename": "contracts/Ladle.sol", "patch": "@@ -114,6 +114,16 @@ contract Ladle is LadleStorage, AccessControl() {\n \n     // ---- Batching ----\n \n+    /// @dev Return the cached vault if necessary, preceded by the current vaultId (needed if vaultId == bytes(0)) and cachedId (which is the same as the vaultId)\n+    /// If refreshing the cache, verifies that msg.sender is the owner of the vault\n+    function getCachedVault(bytes12 vaultId, bytes12 cachedId, DataTypes.Vault memory vault)\n+        private view\n+        returns (bytes12, bytes12, DataTypes.Vault memory)\n+    {\n+        require(vaultId != bytes12(0) || cachedId != bytes12(0), \"Vault not cached\");           // Can't use the cache\n+        if (vaultId == bytes12(0) || vaultId == cachedId) return (cachedId, cachedId, vault);   // Use the cache\n+        else return (vaultId, vaultId, getOwnedVault(vaultId));                                 // Refresh the cache\n+    } \n \n     /// @dev Submit a series of calls for execution.\n     /// Unlike `batch`, this function calls private functions, saving a CALL per function.\n@@ -132,8 +142,8 @@ contract Ladle is LadleStorage, AccessControl() {\n             Operation operation = operations[i];\n \n             if (operation == Operation.BUILD) {\n-                (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n-                (cachedId, vault) = (vaultId, _build(vaultId, seriesId, ilkId));   // Cache the vault that was just built\n+                (bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes6, bytes6));\n+                (cachedId, vault) = _build(seriesId, ilkId, 0);   // Cache the vault that was just built\n             \n             } else if (operation == Operation.FORWARD_PERMIT) {\n                 (bytes6 id, bool isAsset, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) =\n@@ -146,17 +156,17 @@ contract Ladle is LadleStorage, AccessControl() {\n             \n             } else if (operation == Operation.POUR) {\n                 (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 _pour(vaultId, vault, to, ink, art);\n             \n             } else if (operation == Operation.SERVE) {\n                 (bytes12 vaultId, address to, uint128 ink, uint128 base, uint128 max) = abi.decode(data[i], (bytes12, address, uint128, uint128, uint128));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 _serve(vaultId, vault, to, ink, base, max);\n \n             } else if (operation == Operation.ROLL) {\n                 (bytes12 vaultId, bytes6 newSeriesId, uint8 loan, uint128 max) = abi.decode(data[i], (bytes12, bytes6, uint8, uint128));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 (vault,) = _roll(vaultId, vault, newSeriesId, loan, max);\n             \n             } else if (operation == Operation.FORWARD_DAI_PERMIT) {\n@@ -182,22 +192,22 @@ contract Ladle is LadleStorage, AccessControl() {\n             \n             } else if (operation == Operation.CLOSE) {\n                 (bytes12 vaultId, address to, int128 ink, int128 art) = abi.decode(data[i], (bytes12, address, int128, int128));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 _close(vaultId, vault, to, ink, art);\n             \n             } else if (operation == Operation.REPAY) {\n                 (bytes12 vaultId, address to, int128 ink, uint128 min) = abi.decode(data[i], (bytes12, address, int128, uint128));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 _repay(vaultId, vault, to, ink, min);\n             \n             } else if (operation == Operation.REPAY_VAULT) {\n                 (bytes12 vaultId, address to, int128 ink, uint128 max) = abi.decode(data[i], (bytes12, address, int128, uint128));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 _repayVault(vaultId, vault, to, ink, max);\n \n             } else if (operation == Operation.REPAY_LADLE) {\n                 (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);\n                 _repayLadle(vaultId, vault);\n \n             } else if (operation == Operation.RETRIEVE) {\n@@ -220,19 +230,19 @@ contract Ladle is LadleStorage, AccessControl() {\n             \n             } else if (operation == Operation.TWEAK) {\n                 (bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) = abi.decode(data[i], (bytes12, bytes6, bytes6));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);  // Needed to verify ownership\n                 vault = _tweak(vaultId, seriesId, ilkId);\n \n             } else if (operation == Operation.GIVE) {\n                 (bytes12 vaultId, address to) = abi.decode(data[i], (bytes12, address));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);  // Needed to verify ownership\n                 vault = _give(vaultId, to);\n                 delete vault;   // Clear the cache, since the vault doesn't necessarily belong to msg.sender anymore\n                 cachedId = bytes12(0);\n \n             } else if (operation == Operation.DESTROY) {\n                 (bytes12 vaultId) = abi.decode(data[i], (bytes12));\n-                if (cachedId != vaultId) (cachedId, vault) = (vaultId, getOwnedVault(vaultId));\n+                (vaultId, cachedId, vault) = getCachedVault(vaultId, cachedId, vault);  // Needed to verify ownership\n                 _destroy(vaultId);\n                 delete vault;   // Clear the cache\n                 cachedId = bytes12(0);\n@@ -247,12 +257,22 @@ contract Ladle is LadleStorage, AccessControl() {\n \n     // ---- Vault management ----\n \n+    /// @dev Generate a vaultId. A keccak256 is cheaper than using a counter with a SSTORE, even accounting for eventual collision retries.\n+    function _generateVaultId(uint8 salt) private view returns (bytes12) {\n+        return bytes12(keccak256(abi.encodePacked(msg.sender, block.timestamp, salt)));\n+    }\n+\n     /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n-    function _build(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId)\n+    function _build(bytes6 seriesId, bytes6 ilkId, uint8 salt)\n         private\n-        returns(DataTypes.Vault memory vault)\n+        returns(bytes12, DataTypes.Vault memory)\n     {\n-        return cauldron.build(msg.sender, vaultId, seriesId, ilkId);\n+        bytes12 vaultId = _generateVaultId(salt);\n+        try cauldron.build(msg.sender, vaultId, seriesId, ilkId) returns (DataTypes.Vault memory vault) {\n+            return (vaultId, vault);\n+        } catch Error (string memory) {\n+            return _build(seriesId, ilkId, salt + 1);\n+        }\n     }\n \n     /// @dev Change a vault series or collateral.\n@@ -586,6 +606,8 @@ contract Ladle is LadleStorage, AccessControl() {\n     // ---- Module router ----\n \n     /// @dev Allow users to use functionality coded in a module, to be used with batch\n+    /// @notice Modules must not do any changes to the vault (owner, seriesId, ilkId),\n+    /// it would be disastrous in combination with batch vault caching \n     function _moduleCall(address module, bytes memory moduleCall)\n         private\n         returns (bool success, bytes memory result)", "project_link": "https://github.com/yieldprotocol/vault-v2/commit/e2cc08f255bb73cb6cbb6b7f7d14d3d6a89b894a", "solc_version": "0.6.4", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "08dbc62c17cb23b97a4a004728def3e459b4ccee"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "e2cc08f255bb73cb6cbb6b7f7d14d3d6a89b894a"}}