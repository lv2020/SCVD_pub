{"filename": "contracts/modules/RecoveryManager.sol", "patch": "@@ -129,10 +129,13 @@ contract RecoveryManager is BaseModule, RelayerModule {\n     function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n         RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n         require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n-        _wallet.setOwner(config.recovery);\n-        emit RecoveryFinalized(address(_wallet), config.recovery);\n-        guardianStorage.setLock(_wallet, 0);\n+        address recoveryOwner = config.recovery;\n         delete recoveryConfigs[address(_wallet)];\n+\n+        _wallet.setOwner(recoveryOwner);\n+        guardianStorage.setLock(_wallet, 0);\n+\n+        emit RecoveryFinalized(address(_wallet), config.recovery);\n     }\n \n     /**\n@@ -142,9 +145,10 @@ contract RecoveryManager is BaseModule, RelayerModule {\n      */\n     function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n         RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n-        emit RecoveryCanceled(address(_wallet), config.recovery);\n-        guardianStorage.setLock(_wallet, 0);\n         delete recoveryConfigs[address(_wallet)];\n+        guardianStorage.setLock(_wallet, 0);\n+\n+        emit RecoveryCanceled(address(_wallet), config.recovery);\n     }\n \n     /**", "project_link": "https://github.com/argentlabs/argent-contracts/commit/7f904ac5fe743711cfaf8461b8a867f001161434", "bug_version": {"raw_code": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\nimport \"./common/ArgentSafeMath.sol\";\nimport \"../wallet/BaseWallet.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./common/RelayerModule.sol\";\nimport \"./storage/GuardianStorage.sol\";\n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_RECOVERY_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_RECOVERY_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_RECOVERY_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n    bytes4 constant internal TRANSFER_OWNERSHIP_PREFIX = bytes4(keccak256(\"transferOwnership(address,address)\"));\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // Wallet specific storage\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n\n    // Recovery period\n    uint256 public recoveryPeriod;\n    // Lock period\n    uint256 public lockPeriod;\n    // Security period used for (non-recovery) ownership transfer\n    uint256 public securityPeriod;\n    // Security window used for (non-recovery) ownership transfer\n    uint256 public securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry,\n        GuardianStorage _guardianStorage,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow\n    )\n        BaseModule(_registry, _guardianStorage, NAME)\n        public\n    {\n        require(_lockPeriod >= _recoveryPeriod && _recoveryPeriod >= _securityPeriod + _securityWindow, \"RM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can\n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(address(_wallet), _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        _wallet.setOwner(config.recovery);\n        emit RecoveryFinalized(address(_wallet), config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete recoveryConfigs[address(_wallet)];\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        emit RecoveryCanceled(address(_wallet), config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete recoveryConfigs[address(_wallet)];\n    }\n\n    /**\n     * @dev Lets the owner start the execution of the ownership transfer procedure.\n     * Once triggered the ownership transfer is pending for the security period before it can\n     * be finalised.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(BaseWallet _wallet, address _newOwner) external onlyExecute onlyWhenUnlocked(_wallet) {\n        require(_newOwner != address(0), \"RM: new owner address cannot be null\");\n        _wallet.setOwner(_newOwner);\n\n        emit OwnershipTransfered(address(_wallet), _newOwner);\n    }\n\n    /**\n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == FINALIZE_RECOVERY_PREFIX) {\n            return (0, OwnerSignature.Required);\n        }\n        if (methodId == CANCEL_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(recoveryConfigs[address(_wallet)].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TRANSFER_OWNERSHIP_PREFIX) {\n            uint majorityGuardians = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            uint numberOfSignaturesRequired = SafeMath.add(majorityGuardians, 1);\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n\n        revert(\"RM: unknown method\");\n    }\n}", "flattened_code": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title ArgentSafeMath\n * @dev Math operations missing from the standard SafeMath libraries\n */\nlibrary ArgentSafeMath {\n    /**\n    * @dev Returns ceil(a / b).\n    */\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        if (a % b == 0) {\n            return c;\n        } else {\n            return c + 1;\n        }\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title Module\n * @dev Interface for a module.\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n * can never end up in a \"frozen\" state.\n * @author Julien Niset - <julien@argent.xyz>\n */\ninterface Module {\n\n    /**\n     * @dev Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external;\n\n    /**\n     * @dev Adds a module to a wallet.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external;\n\n    /**\n    * @dev Utility method to recover any ERC20 token that was sent to the\n    * module by mistake.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n}\n\n/**\n * @title BaseWallet\n * @dev Simple modular wallet that authorises modules to call its invoke() method.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract BaseWallet {\n\n    // The implementation of the proxy\n    address public implementation;\n    // The owner\n    address public owner;\n    // The authorised modules\n    mapping (address => bool) public authorised;\n    // The enabled static calls\n    mapping (bytes4 => address) public enabled;\n    // The number of modules\n    uint public modules;\n\n    event AuthorisedModule(address indexed module, bool value);\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n    event Received(uint indexed value, address indexed sender, bytes data);\n    event OwnerChanged(address owner);\n\n    /**\n     * @dev Throws if the sender is not an authorised module.\n     */\n    modifier moduleOnly {\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n        _;\n    }\n\n    /**\n     * @dev Inits the wallet by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] calldata _modules) external {\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\n        owner = _owner;\n        modules = _modules.length;\n        for (uint256 i = 0; i < _modules.length; i++) {\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n            authorised[_modules[i]] = true;\n            Module(_modules[i]).init(this);\n            emit AuthorisedModule(_modules[i], true);\n        }\n        if (address(this).balance > 0) {\n            emit Received(address(this).balance, address(0), \"\");\n        }\n    }\n\n    /**\n     * @dev Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to true to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external moduleOnly {\n        if (authorised[_module] != _value) {\n            emit AuthorisedModule(_module, _value);\n            if (_value == true) {\n                modules += 1;\n                authorised[_module] = true;\n                Module(_module).init(this);\n            } else {\n                modules -= 1;\n                require(modules > 0, \"BW: wallet must have at least one module\");\n                delete authorised[_module];\n            }\n        }\n    }\n\n    /**\n    * @dev Enables a static method by specifying the target module to which the call\n    * must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external moduleOnly {\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n        enabled[_method] = _module;\n        emit EnabledStaticCall(_module, _method);\n    }\n\n    /**\n     * @dev Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external moduleOnly {\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n\n    /**\n     * @dev Performs a generic transaction.\n     * @param _target The address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\n        bool success;\n        // solium-disable-next-line security/no-call-value\n        (success, _result) = _target.call.value(_value)(_data);\n        if (!success) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize)\n                revert(0, returndatasize)\n            }\n        }\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n\n    /**\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds\n     * to an enabled method, or logs the call otherwise.\n     */\n    function() external payable {\n        if (msg.data.length > 0) {\n            address module = enabled[msg.sig];\n            if (module == address(0)) {\n                emit Received(msg.value, msg.sender, msg.data);\n            } else {\n                require(authorised[module], \"BW: must be an authorised module for static call\");\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    calldatacopy(0, 0, calldatasize())\n                    let result := staticcall(gas, module, 0, calldatasize(), 0, 0)\n                    returndatacopy(0, 0, returndatasize())\n                    switch result\n                    case 0 {revert(0, returndatasize())}\n                    default {return (0, returndatasize())}\n                }\n            }\n        }\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title Owned\n * @dev Basic contract to define an owner.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract Owned {\n\n    // The owner\n    address public owner;\n\n    event OwnerChanged(address indexed _newOwner);\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\n     * @param _newOwner The new owner.\n     */\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Address must not be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n}\npragma solidity ^0.5.4;\n\n/**\n * ERC20 contract interface.\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint);\n    function decimals() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n}\n\n/**\n * @title ModuleRegistry\n * @dev Registry of authorised modules.\n * Modules must be registered before they can be authorised on a wallet.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract ModuleRegistry is Owned {\n\n    mapping (address => Info) internal modules;\n    mapping (address => Info) internal upgraders;\n\n    event ModuleRegistered(address indexed module, bytes32 name);\n    event ModuleDeRegistered(address module);\n    event UpgraderRegistered(address indexed upgrader, bytes32 name);\n    event UpgraderDeRegistered(address upgrader);\n\n    struct Info {\n        bool exists;\n        bytes32 name;\n    }\n\n    /**\n     * @dev Registers a module.\n     * @param _module The module.\n     * @param _name The unique name of the module.\n     */\n    function registerModule(address _module, bytes32 _name) external onlyOwner {\n        require(!modules[_module].exists, \"MR: module already exists\");\n        modules[_module] = Info({exists: true, name: _name});\n        emit ModuleRegistered(_module, _name);\n    }\n\n    /**\n     * @dev Deregisters a module.\n     * @param _module The module.\n     */\n    function deregisterModule(address _module) external onlyOwner {\n        require(modules[_module].exists, \"MR: module does not exist\");\n        delete modules[_module];\n        emit ModuleDeRegistered(_module);\n    }\n\n        /**\n     * @dev Registers an upgrader.\n     * @param _upgrader The upgrader.\n     * @param _name The unique name of the upgrader.\n     */\n    function registerUpgrader(address _upgrader, bytes32 _name) external onlyOwner {\n        require(!upgraders[_upgrader].exists, \"MR: upgrader already exists\");\n        upgraders[_upgrader] = Info({exists: true, name: _name});\n        emit UpgraderRegistered(_upgrader, _name);\n    }\n\n    /**\n     * @dev Deregisters an upgrader.\n     * @param _upgrader The _upgrader.\n     */\n    function deregisterUpgrader(address _upgrader) external onlyOwner {\n        require(upgraders[_upgrader].exists, \"MR: upgrader does not exist\");\n        delete upgraders[_upgrader];\n        emit UpgraderDeRegistered(_upgrader);\n    }\n\n    /**\n    * @dev Utility method enbaling the owner of the registry to claim any ERC20 token that was sent to the\n    * registry.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external onlyOwner {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, total);\n    }\n\n    /**\n     * @dev Gets the name of a module from its address.\n     * @param _module The module address.\n     * @return the name.\n     */\n    function moduleInfo(address _module) external view returns (bytes32) {\n        return modules[_module].name;\n    }\n\n    /**\n     * @dev Gets the name of an upgrader from its address.\n     * @param _upgrader The upgrader address.\n     * @return the name.\n     */\n    function upgraderInfo(address _upgrader) external view returns (bytes32) {\n        return upgraders[_upgrader].name;\n    }\n\n    /**\n     * @dev Checks if a module is registered.\n     * @param _module The module address.\n     * @return true if the module is registered.\n     */\n    function isRegisteredModule(address _module) external view returns (bool) {\n        return modules[_module].exists;\n    }\n\n    /**\n     * @dev Checks if a list of modules are registered.\n     * @param _modules The list of modules address.\n     * @return true if all the modules are registered.\n     */\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool) {\n        for (uint i = 0; i < _modules.length; i++) {\n            if (!modules[_modules[i]].exists) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Checks if an upgrader is registered.\n     * @param _upgrader The upgrader address.\n     * @return true if the upgrader is registered.\n     */\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool) {\n        return upgraders[_upgrader].exists;\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title Storage\n * @dev Base contract for the storage of a wallet.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract Storage {\n\n    /**\n     * @dev Throws if the caller is not an authorised module.\n     */\n    modifier onlyModule(BaseWallet _wallet) {\n        require(_wallet.authorised(msg.sender), \"TS: must be an authorized module to call this method\");\n        _;\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\ninterface IGuardianStorage{\n\n    /**\n     * @dev Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(BaseWallet _wallet, address _guardian) external;\n\n    /**\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external;\n\n    /**\n     * @dev Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool);\n}\n\n/**\n * @title GuardianStorage\n * @dev Contract storing the state of wallets related to guardians and lock.\n * The contract only defines basic setters and getters with no logic. Only modules authorised\n * for a wallet can modify its state.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract GuardianStorage is IGuardianStorage, Storage {\n\n    struct GuardianStorageConfig {\n        // the list of guardians\n        address[] guardians;\n        // the info about guardians\n        mapping (address => GuardianInfo) info;\n        // the lock's release timestamp\n        uint256 lock;\n        // the module that set the last lock\n        address locker;\n    }\n\n    struct GuardianInfo {\n        bool exists;\n        uint128 index;\n    }\n\n    // wallet specific storage\n    mapping (address => GuardianStorageConfig) internal configs;\n\n    // *************** External Functions ********************* //\n\n    /**\n     * @dev Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[address(_wallet)];\n        config.info[_guardian].exists = true;\n        config.info[_guardian].index = uint128(config.guardians.push(_guardian) - 1);\n    }\n\n    /**\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[address(_wallet)];\n        address lastGuardian = config.guardians[config.guardians.length - 1];\n        if (_guardian != lastGuardian) {\n            uint128 targetIndex = config.info[_guardian].index;\n            config.guardians[targetIndex] = lastGuardian;\n            config.info[lastGuardian].index = targetIndex;\n        }\n        config.guardians.length--;\n        delete config.info[_guardian];\n    }\n\n    /**\n     * @dev Returns the number of guardians for a wallet.\n     * @param _wallet The target wallet.\n     * @return the number of guardians.\n     */\n    function guardianCount(BaseWallet _wallet) external view returns (uint256) {\n        return configs[address(_wallet)].guardians.length;\n    }\n\n    /**\n     * @dev Gets the list of guaridans for a wallet.\n     * @param _wallet The target wallet.\n     * @return the list of guardians.\n     */\n    function getGuardians(BaseWallet _wallet) external view returns (address[] memory) {\n        GuardianStorageConfig storage config = configs[address(_wallet)];\n        address[] memory guardians = new address[](config.guardians.length);\n        for (uint256 i = 0; i < config.guardians.length; i++) {\n            guardians[i] = config.guardians[i];\n        }\n        return guardians;\n    }\n\n    /**\n     * @dev Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool) {\n        return configs[address(_wallet)].info[_guardian].exists;\n    }\n\n    /**\n     * @dev Lets an authorised module set the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @param _releaseAfter The epoch time at which the lock should automatically release.\n     */\n    function setLock(BaseWallet _wallet, uint256 _releaseAfter) external onlyModule(_wallet) {\n        configs[address(_wallet)].lock = _releaseAfter;\n        if (_releaseAfter != 0 && msg.sender != configs[address(_wallet)].locker) {\n            configs[address(_wallet)].locker = msg.sender;\n        }\n    }\n\n    /**\n     * @dev Checks if the lock is set for a wallet.\n     * @param _wallet The target wallet.\n     * @return true if the lock is set for the wallet.\n     */\n    function isLocked(BaseWallet _wallet) external view returns (bool) {\n        return configs[address(_wallet)].lock > now;\n    }\n\n    /**\n     * @dev Gets the time at which the lock of a wallet will release.\n     * @param _wallet The target wallet.\n     * @return the time at which the lock of a wallet will release, or zero if there is no lock set.\n     */\n    function getLock(BaseWallet _wallet) external view returns (uint256) {\n        return configs[address(_wallet)].lock;\n    }\n\n    /**\n     * @dev Gets the address of the last module that modified the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @return the address of the last module that modified the lock for a wallet.\n     */\n    function getLocker(BaseWallet _wallet) external view returns (address) {\n        return configs[address(_wallet)].locker;\n    }\n}\n\n/**\n * @title BaseModule\n * @dev Basic module that contains some methods common to all modules.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract BaseModule is Module {\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n\n    // The adddress of the module registry.\n    ModuleRegistry internal registry;\n    // The address of the Guardian storage\n    GuardianStorage internal guardianStorage;\n\n    /**\n     * @dev Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(BaseWallet _wallet) {\n        verifyUnlocked(_wallet);\n        _;\n    }\n\n    event ModuleCreated(bytes32 name);\n    event ModuleInitialised(address wallet);\n\n    constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage, bytes32 _name) public {\n        registry = _registry;\n        guardianStorage = _guardianStorage;\n        emit ModuleCreated(_name);\n    }\n\n    /**\n     * @dev Throws if the sender is not the target wallet of the call.\n     */\n    modifier onlyWallet(BaseWallet _wallet) {\n        require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet or the module itself.\n     */\n    modifier onlyWalletOwner(BaseWallet _wallet) {\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\n        verifyWalletOwner(_wallet);\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet.\n     */\n    modifier strictOnlyWalletOwner(BaseWallet _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\n        _;\n    }\n\n    /**\n     * @dev Inits the module for a wallet by logging an event.\n     * The method can only be called by the wallet itself.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) public onlyWallet(_wallet) {\n        emit ModuleInitialised(address(_wallet));\n    }\n\n    /**\n     * @dev Adds a module to a wallet. First checks that the module is registered.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external strictOnlyWalletOwner(_wallet) {\n        require(registry.isRegisteredModule(address(_module)), \"BM: module is not registered\");\n        _wallet.authoriseModule(address(_module), true);\n    }\n\n    /**\n    * @dev Utility method enbaling anyone to recover ERC20 token sent to the\n    * module by mistake and transfer them to the Module Registry.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(address(registry), total);\n    }\n\n    /**\n     * @dev Verify that the wallet is unlocked.\n     * @param _wallet The target wallet.\n     */\n    function verifyUnlocked(BaseWallet _wallet) internal view {\n        require(!guardianStorage.isLocked(_wallet), \"BM: wallet locked\");\n    }\n\n     /**\n     * @dev Verify that the caller is the module or the wallet owner.\n     * @param _wallet The target wallet.\n     */\n    function verifyWalletOwner(BaseWallet _wallet) internal view {\n        require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be wallet owner\");\n    }\n\n    /**\n     * @dev Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\n        return _wallet.owner() == _addr;\n    }\n\n    /**\n     * @dev Helper method to invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\n        bool success;\n        // solium-disable-next-line security/no-call-value\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\n        if (success && _res.length > 0) { //_res is empty if _wallet is an \"old\" BaseWallet that can't return output values\n            (_res) = abi.decode(_res, (bytes));\n        } else if (_res.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize)\n                revert(0, returndatasize)\n            }\n        } else if (!success) {\n            revert(\"BM: wallet invoke reverted\");\n        }\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\nlibrary GuardianUtils {\n\n    /**\n    * @dev Checks if an address is an account guardian or an account authorised to sign on behalf of a smart-contract guardian\n    * given a list of guardians.\n    * @param _guardians the list of guardians\n    * @param _guardian the address to test\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n    */\n    function isGuardian(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\n        if (_guardians.length == 0 || _guardian == address(0)) {\n            return (false, _guardians);\n        }\n        bool isFound = false;\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _guardians.length; i++) {\n            if (!isFound) {\n                // check if _guardian is an account guardian\n                if (_guardian == _guardians[i]) {\n                    isFound = true;\n                    continue;\n                }\n                // check if _guardian is the owner of a smart contract guardian\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n                    isFound = true;\n                    continue;\n                }\n            }\n            if (index < updatedGuardians.length) {\n                updatedGuardians[index] = _guardians[i];\n                index++;\n            }\n        }\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\n    }\n\n   /**\n    * @dev Checks if an address is a contract.\n    * @param _addr The address.\n    */\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n    * @dev Checks if an address is the owner of a guardian contract.\n    * The method does not revert if the call to the owner() method consumes more then 5000 gas.\n    * @param _guardian The guardian contract\n    * @param _owner The owner to verify.\n    */\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n        address owner = address(0);\n        bytes4 sig = bytes4(keccak256(\"owner()\"));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr,sig)\n            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)\n            if eq(result, 1) {\n                owner := mload(ptr)\n            }\n        }\n        return owner == _owner;\n    }\n}\n\n/**\n * @title RelayerModule\n * @dev Base module containing logic to execute transactions signed by eth-less accounts and sent by a relayer.\n * It is subclassed by all modules.\n * @author Julien Niset <julien@argent.xyz>, Olivier VDB <olivier@argent.xyz>\n */\ncontract RelayerModule is BaseModule {\n\n    uint256 constant internal BLOCKBOUND = 10000;\n\n    mapping (address => RelayerConfig) public relayer;\n\n    struct RelayerConfig {\n        uint256 nonce;\n        mapping (bytes32 => bool) executedTx;\n    }\n\n    enum OwnerSignature {\n        Required,\n        Optional,\n        Disallowed\n    }\n\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes returnData, bytes32 signedHash);\n\n    /**\n     * @dev Throws if the call did not go through the execute() method.\n     */\n    modifier onlyExecute {\n        require(msg.sender == address(this), \"RM: must be called via execute()\");\n        _;\n    }\n\n    /* ***************** Abstract methods ************************* */\n\n    /**\n    * @dev Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the wallet owner signature requirement.\n    */\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature);\n\n    /* ***************** External methods ************************* */\n\n    /**\n    * @dev Executes a relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function execute(\n        BaseWallet _wallet,\n        bytes calldata _data,\n        uint256 _nonce,\n        bytes calldata _signatures,\n        uint256 _gasPrice,\n        uint256 _gasLimit\n    )\n        external\n        returns (bool success)\n    {\n        uint startGas = gasleft();\n        bytes32 signHash = getSignHash(address(this), address(_wallet), 0, _data, _nonce, _gasPrice, _gasLimit);\n        require(checkAndUpdateUniqueness(_wallet, _nonce, signHash), \"RM: Duplicate request\");\n        require(verifyData(address(_wallet), _data), \"RM: Target of _data != _wallet\");\n        (uint256 requiredSignatures, OwnerSignature ownerSignatureRequirement) = getRequiredSignatures(_wallet, _data);\n        require(requiredSignatures * 65 == _signatures.length, \"RM: Wrong number of signatures\");\n        require(requiredSignatures == 0 || validateSignatures(_wallet, signHash, _signatures, ownerSignatureRequirement),\n         \"RM: Invalid signatures\");\n        // The correctness of the refund is checked on the next line using an `if` instead of a `require`\n        // in order to prevent a failing refund from being replayable in the future.\n        bytes memory returnData;\n        if (verifyRefund(_wallet, _gasLimit, _gasPrice, requiredSignatures)) {\n            // solium-disable-next-line security/no-call-value\n            (success, returnData) = address(this).call(_data);\n            refund(_wallet, startGas - gasleft(), _gasPrice, _gasLimit, requiredSignatures, msg.sender);\n        } else {\n            returnData = bytes(\"RM: refund failed\");\n        }\n\n        emit TransactionExecuted(address(_wallet), success, returnData, signHash);\n    }\n\n    /**\n    * @dev Gets the current nonce for a wallet.\n    * @param _wallet The target wallet.\n    */\n    function getNonce(BaseWallet _wallet) external view returns (uint256 nonce) {\n        return relayer[address(_wallet)].nonce;\n    }\n\n    /* ***************** Internal & Private methods ************************* */\n\n    /**\n    * @dev Generates the signed hash of a relayed transaction according to ERC 1077.\n    * @param _from The starting address for the relayed transaction (should be the module)\n    * @param _to The destination address for the relayed transaction (should be the wallet)\n    * @param _value The value for the relayed transaction\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function getSignHash(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _nonce,\n        uint256 _gasPrice,\n        uint256 _gasLimit\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(byte(0x19), byte(0), _from, _to, _value, _data, _nonce, _gasPrice, _gasLimit))\n        ));\n    }\n\n    /**\n    * @dev Checks if the relayed transaction is unique.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    * @param _signHash The signed hash of the transaction\n    */\n    function checkAndUpdateUniqueness(BaseWallet _wallet, uint256 _nonce, bytes32 _signHash) internal returns (bool) {\n        if (relayer[address(_wallet)].executedTx[_signHash] == true) {\n            return false;\n        }\n        relayer[address(_wallet)].executedTx[_signHash] = true;\n        return true;\n    }\n\n    /**\n    * @dev Checks that a nonce has the correct format and is valid.\n    * It must be constructed as nonce = {block number}{timestamp} where each component is 16 bytes.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    */\n    function checkAndUpdateNonce(BaseWallet _wallet, uint256 _nonce) internal returns (bool) {\n        if (_nonce <= relayer[address(_wallet)].nonce) {\n            return false;\n        }\n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n        if (nonceBlock > block.number + BLOCKBOUND) {\n            return false;\n        }\n        relayer[address(_wallet)].nonce = _nonce;\n        return true;\n    }\n\n    /**\n    * @dev Validates the signatures provided with a relayed transaction.\n    * The method MUST throw if one or more signatures are not valid.\n    * @param _wallet The target wallet.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _option An enum indicating whether the owner is required, optional or disallowed.\n    * @return A boolean indicating whether the signatures are valid.\n    */\n    function validateSignatures(\n        BaseWallet _wallet,\n        bytes32 _signHash,\n        bytes memory _signatures,\n        OwnerSignature _option\n    )\n        internal view returns (bool)\n    {\n        address lastSigner = address(0);\n        address[] memory guardians;\n        if (_option != OwnerSignature.Required || _signatures.length > 65) {\n            guardians = guardianStorage.getGuardians(_wallet); // guardians are only read if they may be needed\n        }\n        bool isGuardian;\n\n        for (uint8 i = 0; i < _signatures.length / 65; i++) {\n            address signer = recoverSigner(_signHash, _signatures, i);\n\n            if (i == 0) {\n                if (_option == OwnerSignature.Required) {\n                    // First signer must be owner\n                    if (isOwner(_wallet, signer)) {\n                        continue;\n                    }\n                    return false;\n                } else if (_option == OwnerSignature.Optional) {\n                    // First signer can be owner\n                    if (isOwner(_wallet, signer)) {\n                        continue;\n                    }\n                }\n            }\n            if (signer <= lastSigner) {\n                return false; // Signers must be different\n            }\n            lastSigner = signer;\n            (isGuardian, guardians) = GuardianUtils.isGuardian(guardians, signer);\n            if (!isGuardian) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n    * @dev Recovers the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28); // solium-disable-line error-reason\n        return ecrecover(_signedHash, v, r, s);\n    }\n\n    /**\n    * @dev Refunds the gas used to the Relayer.\n    * For security reasons the default behavior is to not refund calls with 0 or 1 signatures.\n    * @param _wallet The target wallet.\n    * @param _gasUsed The gas used.\n    * @param _gasPrice The gas price for the refund.\n    * @param _gasLimit The gas limit for the refund.\n    * @param _signatures The number of signatures used in the call.\n    * @param _relayer The address of the Relayer.\n    */\n    function refund(\n        BaseWallet _wallet,\n        uint _gasUsed,\n        uint _gasPrice,\n        uint _gasLimit,\n        uint _signatures,\n        address _relayer\n    )\n        internal\n    {\n        uint256 amount = 29292 + _gasUsed; // 21000 (transaction) + 7620 (execution of refund) + 672 to log the event + _gasUsed\n        // only refund if gas price not null, more than 1 signatures, gas less than gasLimit\n        if (_gasPrice > 0 && _signatures > 1 && amount <= _gasLimit) {\n            if (_gasPrice > tx.gasprice) {\n                amount = amount * tx.gasprice;\n            } else {\n                amount = amount * _gasPrice;\n            }\n            invokeWallet(address(_wallet), _relayer, amount, EMPTY_BYTES);\n        }\n    }\n\n    /**\n    * @dev Returns false if the refund is expected to fail.\n    * @param _wallet The target wallet.\n    * @param _gasUsed The expected gas used.\n    * @param _gasPrice The expected gas price for the refund.\n    */\n    function verifyRefund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _signatures) internal view returns (bool) {\n        if (_gasPrice > 0 &&\n            _signatures > 1 &&\n            (address(_wallet).balance < _gasUsed * _gasPrice || _wallet.authorised(address(this)) == false)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Parses the data to extract the method signature.\n    */\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n\n   /**\n    * @dev Checks that the wallet address provided as the first parameter of the relayed data is the same\n    * as the wallet passed as the input of the execute() method.\n    @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes memory _data) private pure returns (bool) {\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n        address dataWallet;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            //_data = {length:32}{sig:4}{_wallet:32}{...}\n            dataWallet := mload(add(_data, 0x24))\n        }\n        return dataWallet == _wallet;\n    }\n}\n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_RECOVERY_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_RECOVERY_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_RECOVERY_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n    bytes4 constant internal TRANSFER_OWNERSHIP_PREFIX = bytes4(keccak256(\"transferOwnership(address,address)\"));\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // Wallet specific storage\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n\n    // Recovery period\n    uint256 public recoveryPeriod;\n    // Lock period\n    uint256 public lockPeriod;\n    // Security period used for (non-recovery) ownership transfer\n    uint256 public securityPeriod;\n    // Security window used for (non-recovery) ownership transfer\n    uint256 public securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry,\n        GuardianStorage _guardianStorage,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow\n    )\n        BaseModule(_registry, _guardianStorage, NAME)\n        public\n    {\n        require(_lockPeriod >= _recoveryPeriod && _recoveryPeriod >= _securityPeriod + _securityWindow, \"RM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can\n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(address(_wallet), _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        _wallet.setOwner(config.recovery);\n        emit RecoveryFinalized(address(_wallet), config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete recoveryConfigs[address(_wallet)];\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        emit RecoveryCanceled(address(_wallet), config.recovery);\n        guardianStorage.setLock(_wallet, 0);\n        delete recoveryConfigs[address(_wallet)];\n    }\n\n    /**\n     * @dev Lets the owner start the execution of the ownership transfer procedure.\n     * Once triggered the ownership transfer is pending for the security period before it can\n     * be finalised.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(BaseWallet _wallet, address _newOwner) external onlyExecute onlyWhenUnlocked(_wallet) {\n        require(_newOwner != address(0), \"RM: new owner address cannot be null\");\n        _wallet.setOwner(_newOwner);\n\n        emit OwnershipTransfered(address(_wallet), _newOwner);\n    }\n\n    /**\n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == FINALIZE_RECOVERY_PREFIX) {\n            return (0, OwnerSignature.Required);\n        }\n        if (methodId == CANCEL_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(recoveryConfigs[address(_wallet)].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TRANSFER_OWNERSHIP_PREFIX) {\n            uint majorityGuardians = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            uint numberOfSignaturesRequired = SafeMath.add(majorityGuardians, 1);\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n\n        revert(\"RM: unknown method\");\n    }\n}\n", "commit_id": "c77a070e838fcf83937fb1c8a3385410e8c7a2c1"}, "fixed_version": {"raw_code": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\nimport \"./common/ArgentSafeMath.sol\";\nimport \"../wallet/BaseWallet.sol\";\nimport \"./common/BaseModule.sol\";\nimport \"./common/RelayerModule.sol\";\nimport \"./storage/GuardianStorage.sol\";\n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_RECOVERY_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_RECOVERY_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_RECOVERY_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n    bytes4 constant internal TRANSFER_OWNERSHIP_PREFIX = bytes4(keccak256(\"transferOwnership(address,address)\"));\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // Wallet specific storage\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n\n    // Recovery period\n    uint256 public recoveryPeriod;\n    // Lock period\n    uint256 public lockPeriod;\n    // Security period used for (non-recovery) ownership transfer\n    uint256 public securityPeriod;\n    // Security window used for (non-recovery) ownership transfer\n    uint256 public securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry,\n        GuardianStorage _guardianStorage,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow\n    )\n        BaseModule(_registry, _guardianStorage, NAME)\n        public\n    {\n        require(_lockPeriod >= _recoveryPeriod && _recoveryPeriod >= _securityPeriod + _securityWindow, \"RM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can\n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(address(_wallet), _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        address recoveryOwner = config.recovery;\n        delete recoveryConfigs[address(_wallet)];\n\n        _wallet.setOwner(recoveryOwner);\n        guardianStorage.setLock(_wallet, 0);\n\n        emit RecoveryFinalized(address(_wallet), config.recovery);\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        delete recoveryConfigs[address(_wallet)];\n        guardianStorage.setLock(_wallet, 0);\n\n        emit RecoveryCanceled(address(_wallet), config.recovery);\n    }\n\n    /**\n     * @dev Lets the owner start the execution of the ownership transfer procedure.\n     * Once triggered the ownership transfer is pending for the security period before it can\n     * be finalised.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(BaseWallet _wallet, address _newOwner) external onlyExecute onlyWhenUnlocked(_wallet) {\n        require(_newOwner != address(0), \"RM: new owner address cannot be null\");\n        _wallet.setOwner(_newOwner);\n\n        emit OwnershipTransfered(address(_wallet), _newOwner);\n    }\n\n    /**\n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == FINALIZE_RECOVERY_PREFIX) {\n            return (0, OwnerSignature.Required);\n        }\n        if (methodId == CANCEL_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(recoveryConfigs[address(_wallet)].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TRANSFER_OWNERSHIP_PREFIX) {\n            uint majorityGuardians = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            uint numberOfSignaturesRequired = SafeMath.add(majorityGuardians, 1);\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n\n        revert(\"RM: unknown method\");\n    }\n}", "flattened_code": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title ArgentSafeMath\n * @dev Math operations missing from the standard SafeMath libraries\n */\nlibrary ArgentSafeMath {\n    /**\n    * @dev Returns ceil(a / b).\n    */\n    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        if (a % b == 0) {\n            return c;\n        } else {\n            return c + 1;\n        }\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title Module\n * @dev Interface for a module.\n * A module MUST implement the addModule() method to ensure that a wallet with at least one module\n * can never end up in a \"frozen\" state.\n * @author Julien Niset - <julien@argent.xyz>\n */\ninterface Module {\n\n    /**\n     * @dev Inits a module for a wallet by e.g. setting some wallet specific parameters in storage.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) external;\n\n    /**\n     * @dev Adds a module to a wallet.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external;\n\n    /**\n    * @dev Utility method to recover any ERC20 token that was sent to the\n    * module by mistake.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external;\n}\n\n/**\n * @title BaseWallet\n * @dev Simple modular wallet that authorises modules to call its invoke() method.\n * @author Julien Niset - <julien@argent.xyz>\n */\ncontract BaseWallet {\n\n    // The implementation of the proxy\n    address public implementation;\n    // The owner\n    address public owner;\n    // The authorised modules\n    mapping (address => bool) public authorised;\n    // The enabled static calls\n    mapping (bytes4 => address) public enabled;\n    // The number of modules\n    uint public modules;\n\n    event AuthorisedModule(address indexed module, bool value);\n    event EnabledStaticCall(address indexed module, bytes4 indexed method);\n    event Invoked(address indexed module, address indexed target, uint indexed value, bytes data);\n    event Received(uint indexed value, address indexed sender, bytes data);\n    event OwnerChanged(address owner);\n\n    /**\n     * @dev Throws if the sender is not an authorised module.\n     */\n    modifier moduleOnly {\n        require(authorised[msg.sender], \"BW: msg.sender not an authorized module\");\n        _;\n    }\n\n    /**\n     * @dev Inits the wallet by setting the owner and authorising a list of modules.\n     * @param _owner The owner.\n     * @param _modules The modules to authorise.\n     */\n    function init(address _owner, address[] calldata _modules) external {\n        require(owner == address(0) && modules == 0, \"BW: wallet already initialised\");\n        require(_modules.length > 0, \"BW: construction requires at least 1 module\");\n        owner = _owner;\n        modules = _modules.length;\n        for (uint256 i = 0; i < _modules.length; i++) {\n            require(authorised[_modules[i]] == false, \"BW: module is already added\");\n            authorised[_modules[i]] = true;\n            Module(_modules[i]).init(this);\n            emit AuthorisedModule(_modules[i], true);\n        }\n        if (address(this).balance > 0) {\n            emit Received(address(this).balance, address(0), \"\");\n        }\n    }\n\n    /**\n     * @dev Enables/Disables a module.\n     * @param _module The target module.\n     * @param _value Set to true to authorise the module.\n     */\n    function authoriseModule(address _module, bool _value) external moduleOnly {\n        if (authorised[_module] != _value) {\n            emit AuthorisedModule(_module, _value);\n            if (_value == true) {\n                modules += 1;\n                authorised[_module] = true;\n                Module(_module).init(this);\n            } else {\n                modules -= 1;\n                require(modules > 0, \"BW: wallet must have at least one module\");\n                delete authorised[_module];\n            }\n        }\n    }\n\n    /**\n    * @dev Enables a static method by specifying the target module to which the call\n    * must be delegated.\n    * @param _module The target module.\n    * @param _method The static method signature.\n    */\n    function enableStaticCall(address _module, bytes4 _method) external moduleOnly {\n        require(authorised[_module], \"BW: must be an authorised module for static call\");\n        enabled[_method] = _module;\n        emit EnabledStaticCall(_module, _method);\n    }\n\n    /**\n     * @dev Sets a new owner for the wallet.\n     * @param _newOwner The new owner.\n     */\n    function setOwner(address _newOwner) external moduleOnly {\n        require(_newOwner != address(0), \"BW: address cannot be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n\n    /**\n     * @dev Performs a generic transaction.\n     * @param _target The address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invoke(address _target, uint _value, bytes calldata _data) external moduleOnly returns (bytes memory _result) {\n        bool success;\n        // solium-disable-next-line security/no-call-value\n        (success, _result) = _target.call.value(_value)(_data);\n        if (!success) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize)\n                revert(0, returndatasize)\n            }\n        }\n        emit Invoked(msg.sender, _target, _value, _data);\n    }\n\n    /**\n     * @dev This method makes it possible for the wallet to comply to interfaces expecting the wallet to\n     * implement specific static methods. It delegates the static call to a target contract if the data corresponds\n     * to an enabled method, or logs the call otherwise.\n     */\n    function() external payable {\n        if (msg.data.length > 0) {\n            address module = enabled[msg.sig];\n            if (module == address(0)) {\n                emit Received(msg.value, msg.sender, msg.data);\n            } else {\n                require(authorised[module], \"BW: must be an authorised module for static call\");\n                // solium-disable-next-line security/no-inline-assembly\n                assembly {\n                    calldatacopy(0, 0, calldatasize())\n                    let result := staticcall(gas, module, 0, calldatasize(), 0, 0)\n                    returndatacopy(0, 0, returndatasize())\n                    switch result\n                    case 0 {revert(0, returndatasize())}\n                    default {return (0, returndatasize())}\n                }\n            }\n        }\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title Owned\n * @dev Basic contract to define an owner.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract Owned {\n\n    // The owner\n    address public owner;\n\n    event OwnerChanged(address indexed _newOwner);\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Must be owner\");\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Lets the owner transfer ownership of the contract to a new owner.\n     * @param _newOwner The new owner.\n     */\n    function changeOwner(address _newOwner) external onlyOwner {\n        require(_newOwner != address(0), \"Address must not be null\");\n        owner = _newOwner;\n        emit OwnerChanged(_newOwner);\n    }\n}\npragma solidity ^0.5.4;\n\n/**\n * ERC20 contract interface.\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint);\n    function decimals() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n}\n\n/**\n * @title ModuleRegistry\n * @dev Registry of authorised modules.\n * Modules must be registered before they can be authorised on a wallet.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract ModuleRegistry is Owned {\n\n    mapping (address => Info) internal modules;\n    mapping (address => Info) internal upgraders;\n\n    event ModuleRegistered(address indexed module, bytes32 name);\n    event ModuleDeRegistered(address module);\n    event UpgraderRegistered(address indexed upgrader, bytes32 name);\n    event UpgraderDeRegistered(address upgrader);\n\n    struct Info {\n        bool exists;\n        bytes32 name;\n    }\n\n    /**\n     * @dev Registers a module.\n     * @param _module The module.\n     * @param _name The unique name of the module.\n     */\n    function registerModule(address _module, bytes32 _name) external onlyOwner {\n        require(!modules[_module].exists, \"MR: module already exists\");\n        modules[_module] = Info({exists: true, name: _name});\n        emit ModuleRegistered(_module, _name);\n    }\n\n    /**\n     * @dev Deregisters a module.\n     * @param _module The module.\n     */\n    function deregisterModule(address _module) external onlyOwner {\n        require(modules[_module].exists, \"MR: module does not exist\");\n        delete modules[_module];\n        emit ModuleDeRegistered(_module);\n    }\n\n        /**\n     * @dev Registers an upgrader.\n     * @param _upgrader The upgrader.\n     * @param _name The unique name of the upgrader.\n     */\n    function registerUpgrader(address _upgrader, bytes32 _name) external onlyOwner {\n        require(!upgraders[_upgrader].exists, \"MR: upgrader already exists\");\n        upgraders[_upgrader] = Info({exists: true, name: _name});\n        emit UpgraderRegistered(_upgrader, _name);\n    }\n\n    /**\n     * @dev Deregisters an upgrader.\n     * @param _upgrader The _upgrader.\n     */\n    function deregisterUpgrader(address _upgrader) external onlyOwner {\n        require(upgraders[_upgrader].exists, \"MR: upgrader does not exist\");\n        delete upgraders[_upgrader];\n        emit UpgraderDeRegistered(_upgrader);\n    }\n\n    /**\n    * @dev Utility method enbaling the owner of the registry to claim any ERC20 token that was sent to the\n    * registry.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external onlyOwner {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(msg.sender, total);\n    }\n\n    /**\n     * @dev Gets the name of a module from its address.\n     * @param _module The module address.\n     * @return the name.\n     */\n    function moduleInfo(address _module) external view returns (bytes32) {\n        return modules[_module].name;\n    }\n\n    /**\n     * @dev Gets the name of an upgrader from its address.\n     * @param _upgrader The upgrader address.\n     * @return the name.\n     */\n    function upgraderInfo(address _upgrader) external view returns (bytes32) {\n        return upgraders[_upgrader].name;\n    }\n\n    /**\n     * @dev Checks if a module is registered.\n     * @param _module The module address.\n     * @return true if the module is registered.\n     */\n    function isRegisteredModule(address _module) external view returns (bool) {\n        return modules[_module].exists;\n    }\n\n    /**\n     * @dev Checks if a list of modules are registered.\n     * @param _modules The list of modules address.\n     * @return true if all the modules are registered.\n     */\n    function isRegisteredModule(address[] calldata _modules) external view returns (bool) {\n        for (uint i = 0; i < _modules.length; i++) {\n            if (!modules[_modules[i]].exists) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Checks if an upgrader is registered.\n     * @param _upgrader The upgrader address.\n     * @return true if the upgrader is registered.\n     */\n    function isRegisteredUpgrader(address _upgrader) external view returns (bool) {\n        return upgraders[_upgrader].exists;\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\n/**\n * @title Storage\n * @dev Base contract for the storage of a wallet.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract Storage {\n\n    /**\n     * @dev Throws if the caller is not an authorised module.\n     */\n    modifier onlyModule(BaseWallet _wallet) {\n        require(_wallet.authorised(msg.sender), \"TS: must be an authorized module to call this method\");\n        _;\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\ninterface IGuardianStorage{\n\n    /**\n     * @dev Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(BaseWallet _wallet, address _guardian) external;\n\n    /**\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external;\n\n    /**\n     * @dev Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool);\n}\n\n/**\n * @title GuardianStorage\n * @dev Contract storing the state of wallets related to guardians and lock.\n * The contract only defines basic setters and getters with no logic. Only modules authorised\n * for a wallet can modify its state.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract GuardianStorage is IGuardianStorage, Storage {\n\n    struct GuardianStorageConfig {\n        // the list of guardians\n        address[] guardians;\n        // the info about guardians\n        mapping (address => GuardianInfo) info;\n        // the lock's release timestamp\n        uint256 lock;\n        // the module that set the last lock\n        address locker;\n    }\n\n    struct GuardianInfo {\n        bool exists;\n        uint128 index;\n    }\n\n    // wallet specific storage\n    mapping (address => GuardianStorageConfig) internal configs;\n\n    // *************** External Functions ********************* //\n\n    /**\n     * @dev Lets an authorised module add a guardian to a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to add.\n     */\n    function addGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[address(_wallet)];\n        config.info[_guardian].exists = true;\n        config.info[_guardian].index = uint128(config.guardians.push(_guardian) - 1);\n    }\n\n    /**\n     * @dev Lets an authorised module revoke a guardian from a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The guardian to revoke.\n     */\n    function revokeGuardian(BaseWallet _wallet, address _guardian) external onlyModule(_wallet) {\n        GuardianStorageConfig storage config = configs[address(_wallet)];\n        address lastGuardian = config.guardians[config.guardians.length - 1];\n        if (_guardian != lastGuardian) {\n            uint128 targetIndex = config.info[_guardian].index;\n            config.guardians[targetIndex] = lastGuardian;\n            config.info[lastGuardian].index = targetIndex;\n        }\n        config.guardians.length--;\n        delete config.info[_guardian];\n    }\n\n    /**\n     * @dev Returns the number of guardians for a wallet.\n     * @param _wallet The target wallet.\n     * @return the number of guardians.\n     */\n    function guardianCount(BaseWallet _wallet) external view returns (uint256) {\n        return configs[address(_wallet)].guardians.length;\n    }\n\n    /**\n     * @dev Gets the list of guaridans for a wallet.\n     * @param _wallet The target wallet.\n     * @return the list of guardians.\n     */\n    function getGuardians(BaseWallet _wallet) external view returns (address[] memory) {\n        GuardianStorageConfig storage config = configs[address(_wallet)];\n        address[] memory guardians = new address[](config.guardians.length);\n        for (uint256 i = 0; i < config.guardians.length; i++) {\n            guardians[i] = config.guardians[i];\n        }\n        return guardians;\n    }\n\n    /**\n     * @dev Checks if an account is a guardian for a wallet.\n     * @param _wallet The target wallet.\n     * @param _guardian The account.\n     * @return true if the account is a guardian for a wallet.\n     */\n    function isGuardian(BaseWallet _wallet, address _guardian) external view returns (bool) {\n        return configs[address(_wallet)].info[_guardian].exists;\n    }\n\n    /**\n     * @dev Lets an authorised module set the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @param _releaseAfter The epoch time at which the lock should automatically release.\n     */\n    function setLock(BaseWallet _wallet, uint256 _releaseAfter) external onlyModule(_wallet) {\n        configs[address(_wallet)].lock = _releaseAfter;\n        if (_releaseAfter != 0 && msg.sender != configs[address(_wallet)].locker) {\n            configs[address(_wallet)].locker = msg.sender;\n        }\n    }\n\n    /**\n     * @dev Checks if the lock is set for a wallet.\n     * @param _wallet The target wallet.\n     * @return true if the lock is set for the wallet.\n     */\n    function isLocked(BaseWallet _wallet) external view returns (bool) {\n        return configs[address(_wallet)].lock > now;\n    }\n\n    /**\n     * @dev Gets the time at which the lock of a wallet will release.\n     * @param _wallet The target wallet.\n     * @return the time at which the lock of a wallet will release, or zero if there is no lock set.\n     */\n    function getLock(BaseWallet _wallet) external view returns (uint256) {\n        return configs[address(_wallet)].lock;\n    }\n\n    /**\n     * @dev Gets the address of the last module that modified the lock for a wallet.\n     * @param _wallet The target wallet.\n     * @return the address of the last module that modified the lock for a wallet.\n     */\n    function getLocker(BaseWallet _wallet) external view returns (address) {\n        return configs[address(_wallet)].locker;\n    }\n}\n\n/**\n * @title BaseModule\n * @dev Basic module that contains some methods common to all modules.\n * @author Julien Niset - <julien@argent.im>\n */\ncontract BaseModule is Module {\n\n    // Empty calldata\n    bytes constant internal EMPTY_BYTES = \"\";\n\n    // The adddress of the module registry.\n    ModuleRegistry internal registry;\n    // The address of the Guardian storage\n    GuardianStorage internal guardianStorage;\n\n    /**\n     * @dev Throws if the wallet is locked.\n     */\n    modifier onlyWhenUnlocked(BaseWallet _wallet) {\n        verifyUnlocked(_wallet);\n        _;\n    }\n\n    event ModuleCreated(bytes32 name);\n    event ModuleInitialised(address wallet);\n\n    constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage, bytes32 _name) public {\n        registry = _registry;\n        guardianStorage = _guardianStorage;\n        emit ModuleCreated(_name);\n    }\n\n    /**\n     * @dev Throws if the sender is not the target wallet of the call.\n     */\n    modifier onlyWallet(BaseWallet _wallet) {\n        require(msg.sender == address(_wallet), \"BM: caller must be wallet\");\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet or the module itself.\n     */\n    modifier onlyWalletOwner(BaseWallet _wallet) {\n        // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code\n        verifyWalletOwner(_wallet);\n        _;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner of the target wallet.\n     */\n    modifier strictOnlyWalletOwner(BaseWallet _wallet) {\n        require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\");\n        _;\n    }\n\n    /**\n     * @dev Inits the module for a wallet by logging an event.\n     * The method can only be called by the wallet itself.\n     * @param _wallet The wallet.\n     */\n    function init(BaseWallet _wallet) public onlyWallet(_wallet) {\n        emit ModuleInitialised(address(_wallet));\n    }\n\n    /**\n     * @dev Adds a module to a wallet. First checks that the module is registered.\n     * @param _wallet The target wallet.\n     * @param _module The modules to authorise.\n     */\n    function addModule(BaseWallet _wallet, Module _module) external strictOnlyWalletOwner(_wallet) {\n        require(registry.isRegisteredModule(address(_module)), \"BM: module is not registered\");\n        _wallet.authoriseModule(address(_module), true);\n    }\n\n    /**\n    * @dev Utility method enbaling anyone to recover ERC20 token sent to the\n    * module by mistake and transfer them to the Module Registry.\n    * @param _token The token to recover.\n    */\n    function recoverToken(address _token) external {\n        uint total = ERC20(_token).balanceOf(address(this));\n        ERC20(_token).transfer(address(registry), total);\n    }\n\n    /**\n     * @dev Verify that the wallet is unlocked.\n     * @param _wallet The target wallet.\n     */\n    function verifyUnlocked(BaseWallet _wallet) internal view {\n        require(!guardianStorage.isLocked(_wallet), \"BM: wallet locked\");\n    }\n\n     /**\n     * @dev Verify that the caller is the module or the wallet owner.\n     * @param _wallet The target wallet.\n     */\n    function verifyWalletOwner(BaseWallet _wallet) internal view {\n        require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be wallet owner\");\n    }\n\n    /**\n     * @dev Helper method to check if an address is the owner of a target wallet.\n     * @param _wallet The target wallet.\n     * @param _addr The address.\n     */\n    function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) {\n        return _wallet.owner() == _addr;\n    }\n\n    /**\n     * @dev Helper method to invoke a wallet.\n     * @param _wallet The target wallet.\n     * @param _to The target address for the transaction.\n     * @param _value The value of the transaction.\n     * @param _data The data of the transaction.\n     */\n    function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) {\n        bool success;\n        // solium-disable-next-line security/no-call-value\n        (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data));\n        if (success && _res.length > 0) { //_res is empty if _wallet is an \"old\" BaseWallet that can't return output values\n            (_res) = abi.decode(_res, (bytes));\n        } else if (_res.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                returndatacopy(0, 0, returndatasize)\n                revert(0, returndatasize)\n            }\n        } else if (!success) {\n            revert(\"BM: wallet invoke reverted\");\n        }\n    }\n}\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz>\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.5.4;\n\nlibrary GuardianUtils {\n\n    /**\n    * @dev Checks if an address is an account guardian or an account authorised to sign on behalf of a smart-contract guardian\n    * given a list of guardians.\n    * @param _guardians the list of guardians\n    * @param _guardian the address to test\n    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n    */\n    function isGuardian(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\n        if (_guardians.length == 0 || _guardian == address(0)) {\n            return (false, _guardians);\n        }\n        bool isFound = false;\n        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n        uint256 index = 0;\n        for (uint256 i = 0; i < _guardians.length; i++) {\n            if (!isFound) {\n                // check if _guardian is an account guardian\n                if (_guardian == _guardians[i]) {\n                    isFound = true;\n                    continue;\n                }\n                // check if _guardian is the owner of a smart contract guardian\n                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n                    isFound = true;\n                    continue;\n                }\n            }\n            if (index < updatedGuardians.length) {\n                updatedGuardians[index] = _guardians[i];\n                index++;\n            }\n        }\n        return isFound ? (true, updatedGuardians) : (false, _guardians);\n    }\n\n   /**\n    * @dev Checks if an address is a contract.\n    * @param _addr The address.\n    */\n    function isContract(address _addr) internal view returns (bool) {\n        uint32 size;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            size := extcodesize(_addr)\n        }\n        return (size > 0);\n    }\n\n    /**\n    * @dev Checks if an address is the owner of a guardian contract.\n    * The method does not revert if the call to the owner() method consumes more then 5000 gas.\n    * @param _guardian The guardian contract\n    * @param _owner The owner to verify.\n    */\n    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n        address owner = address(0);\n        bytes4 sig = bytes4(keccak256(\"owner()\"));\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr,sig)\n            let result := staticcall(5000, _guardian, ptr, 0x20, ptr, 0x20)\n            if eq(result, 1) {\n                owner := mload(ptr)\n            }\n        }\n        return owner == _owner;\n    }\n}\n\n/**\n * @title RelayerModule\n * @dev Base module containing logic to execute transactions signed by eth-less accounts and sent by a relayer.\n * It is subclassed by all modules.\n * @author Julien Niset <julien@argent.xyz>, Olivier VDB <olivier@argent.xyz>\n */\ncontract RelayerModule is BaseModule {\n\n    uint256 constant internal BLOCKBOUND = 10000;\n\n    mapping (address => RelayerConfig) public relayer;\n\n    struct RelayerConfig {\n        uint256 nonce;\n        mapping (bytes32 => bool) executedTx;\n    }\n\n    enum OwnerSignature {\n        Required,\n        Optional,\n        Disallowed\n    }\n\n    event TransactionExecuted(address indexed wallet, bool indexed success, bytes returnData, bytes32 signedHash);\n\n    /**\n     * @dev Throws if the call did not go through the execute() method.\n     */\n    modifier onlyExecute {\n        require(msg.sender == address(this), \"RM: must be called via execute()\");\n        _;\n    }\n\n    /* ***************** Abstract methods ************************* */\n\n    /**\n    * @dev Gets the number of valid signatures that must be provided to execute a\n    * specific relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data of the relayed transaction.\n    * @return The number of required signatures and the wallet owner signature requirement.\n    */\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature);\n\n    /* ***************** External methods ************************* */\n\n    /**\n    * @dev Executes a relayed transaction.\n    * @param _wallet The target wallet.\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function execute(\n        BaseWallet _wallet,\n        bytes calldata _data,\n        uint256 _nonce,\n        bytes calldata _signatures,\n        uint256 _gasPrice,\n        uint256 _gasLimit\n    )\n        external\n        returns (bool success)\n    {\n        uint startGas = gasleft();\n        bytes32 signHash = getSignHash(address(this), address(_wallet), 0, _data, _nonce, _gasPrice, _gasLimit);\n        require(checkAndUpdateUniqueness(_wallet, _nonce, signHash), \"RM: Duplicate request\");\n        require(verifyData(address(_wallet), _data), \"RM: Target of _data != _wallet\");\n        (uint256 requiredSignatures, OwnerSignature ownerSignatureRequirement) = getRequiredSignatures(_wallet, _data);\n        require(requiredSignatures * 65 == _signatures.length, \"RM: Wrong number of signatures\");\n        require(requiredSignatures == 0 || validateSignatures(_wallet, signHash, _signatures, ownerSignatureRequirement),\n         \"RM: Invalid signatures\");\n        // The correctness of the refund is checked on the next line using an `if` instead of a `require`\n        // in order to prevent a failing refund from being replayable in the future.\n        bytes memory returnData;\n        if (verifyRefund(_wallet, _gasLimit, _gasPrice, requiredSignatures)) {\n            // solium-disable-next-line security/no-call-value\n            (success, returnData) = address(this).call(_data);\n            refund(_wallet, startGas - gasleft(), _gasPrice, _gasLimit, requiredSignatures, msg.sender);\n        } else {\n            returnData = bytes(\"RM: refund failed\");\n        }\n\n        emit TransactionExecuted(address(_wallet), success, returnData, signHash);\n    }\n\n    /**\n    * @dev Gets the current nonce for a wallet.\n    * @param _wallet The target wallet.\n    */\n    function getNonce(BaseWallet _wallet) external view returns (uint256 nonce) {\n        return relayer[address(_wallet)].nonce;\n    }\n\n    /* ***************** Internal & Private methods ************************* */\n\n    /**\n    * @dev Generates the signed hash of a relayed transaction according to ERC 1077.\n    * @param _from The starting address for the relayed transaction (should be the module)\n    * @param _to The destination address for the relayed transaction (should be the wallet)\n    * @param _value The value for the relayed transaction\n    * @param _data The data for the relayed transaction\n    * @param _nonce The nonce used to prevent replay attacks.\n    * @param _gasPrice The gas price to use for the gas refund.\n    * @param _gasLimit The gas limit to use for the gas refund.\n    */\n    function getSignHash(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _nonce,\n        uint256 _gasPrice,\n        uint256 _gasLimit\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(abi.encodePacked(byte(0x19), byte(0), _from, _to, _value, _data, _nonce, _gasPrice, _gasLimit))\n        ));\n    }\n\n    /**\n    * @dev Checks if the relayed transaction is unique.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    * @param _signHash The signed hash of the transaction\n    */\n    function checkAndUpdateUniqueness(BaseWallet _wallet, uint256 _nonce, bytes32 _signHash) internal returns (bool) {\n        if (relayer[address(_wallet)].executedTx[_signHash] == true) {\n            return false;\n        }\n        relayer[address(_wallet)].executedTx[_signHash] = true;\n        return true;\n    }\n\n    /**\n    * @dev Checks that a nonce has the correct format and is valid.\n    * It must be constructed as nonce = {block number}{timestamp} where each component is 16 bytes.\n    * @param _wallet The target wallet.\n    * @param _nonce The nonce\n    */\n    function checkAndUpdateNonce(BaseWallet _wallet, uint256 _nonce) internal returns (bool) {\n        if (_nonce <= relayer[address(_wallet)].nonce) {\n            return false;\n        }\n        uint256 nonceBlock = (_nonce & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128;\n        if (nonceBlock > block.number + BLOCKBOUND) {\n            return false;\n        }\n        relayer[address(_wallet)].nonce = _nonce;\n        return true;\n    }\n\n    /**\n    * @dev Validates the signatures provided with a relayed transaction.\n    * The method MUST throw if one or more signatures are not valid.\n    * @param _wallet The target wallet.\n    * @param _signHash The signed hash representing the relayed transaction.\n    * @param _signatures The signatures as a concatenated byte array.\n    * @param _option An enum indicating whether the owner is required, optional or disallowed.\n    * @return A boolean indicating whether the signatures are valid.\n    */\n    function validateSignatures(\n        BaseWallet _wallet,\n        bytes32 _signHash,\n        bytes memory _signatures,\n        OwnerSignature _option\n    )\n        internal view returns (bool)\n    {\n        address lastSigner = address(0);\n        address[] memory guardians;\n        if (_option != OwnerSignature.Required || _signatures.length > 65) {\n            guardians = guardianStorage.getGuardians(_wallet); // guardians are only read if they may be needed\n        }\n        bool isGuardian;\n\n        for (uint8 i = 0; i < _signatures.length / 65; i++) {\n            address signer = recoverSigner(_signHash, _signatures, i);\n\n            if (i == 0) {\n                if (_option == OwnerSignature.Required) {\n                    // First signer must be owner\n                    if (isOwner(_wallet, signer)) {\n                        continue;\n                    }\n                    return false;\n                } else if (_option == OwnerSignature.Optional) {\n                    // First signer can be owner\n                    if (isOwner(_wallet, signer)) {\n                        continue;\n                    }\n                }\n            }\n            if (signer <= lastSigner) {\n                return false; // Signers must be different\n            }\n            lastSigner = signer;\n            (isGuardian, guardians) = GuardianUtils.isGuardian(guardians, signer);\n            if (!isGuardian) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n    * @dev Recovers the signer at a given position from a list of concatenated signatures.\n    * @param _signedHash The signed hash\n    * @param _signatures The concatenated signatures.\n    * @param _index The index of the signature to recover.\n    */\n    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        // we jump 32 (0x20) as the first slot of bytes contains the length\n        // we jump 65 (0x41) per signature\n        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n        }\n        require(v == 27 || v == 28); // solium-disable-line error-reason\n        return ecrecover(_signedHash, v, r, s);\n    }\n\n    /**\n    * @dev Refunds the gas used to the Relayer.\n    * For security reasons the default behavior is to not refund calls with 0 or 1 signatures.\n    * @param _wallet The target wallet.\n    * @param _gasUsed The gas used.\n    * @param _gasPrice The gas price for the refund.\n    * @param _gasLimit The gas limit for the refund.\n    * @param _signatures The number of signatures used in the call.\n    * @param _relayer The address of the Relayer.\n    */\n    function refund(\n        BaseWallet _wallet,\n        uint _gasUsed,\n        uint _gasPrice,\n        uint _gasLimit,\n        uint _signatures,\n        address _relayer\n    )\n        internal\n    {\n        uint256 amount = 29292 + _gasUsed; // 21000 (transaction) + 7620 (execution of refund) + 672 to log the event + _gasUsed\n        // only refund if gas price not null, more than 1 signatures, gas less than gasLimit\n        if (_gasPrice > 0 && _signatures > 1 && amount <= _gasLimit) {\n            if (_gasPrice > tx.gasprice) {\n                amount = amount * tx.gasprice;\n            } else {\n                amount = amount * _gasPrice;\n            }\n            invokeWallet(address(_wallet), _relayer, amount, EMPTY_BYTES);\n        }\n    }\n\n    /**\n    * @dev Returns false if the refund is expected to fail.\n    * @param _wallet The target wallet.\n    * @param _gasUsed The expected gas used.\n    * @param _gasPrice The expected gas price for the refund.\n    */\n    function verifyRefund(BaseWallet _wallet, uint _gasUsed, uint _gasPrice, uint _signatures) internal view returns (bool) {\n        if (_gasPrice > 0 &&\n            _signatures > 1 &&\n            (address(_wallet).balance < _gasUsed * _gasPrice || _wallet.authorised(address(this)) == false)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    * @dev Parses the data to extract the method signature.\n    */\n    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n        require(_data.length >= 4, \"RM: Invalid functionPrefix\");\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            prefix := mload(add(_data, 0x20))\n        }\n    }\n\n   /**\n    * @dev Checks that the wallet address provided as the first parameter of the relayed data is the same\n    * as the wallet passed as the input of the execute() method.\n    @return false if the addresses are different.\n    */\n    function verifyData(address _wallet, bytes memory _data) private pure returns (bool) {\n        require(_data.length >= 36, \"RM: Invalid dataWallet\");\n        address dataWallet;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            //_data = {length:32}{sig:4}{_wallet:32}{...}\n            dataWallet := mload(add(_data, 0x24))\n        }\n        return dataWallet == _wallet;\n    }\n}\n\n/**\n * @title RecoveryManager\n * @dev Module to manage the recovery of a wallet owner.\n * Recovery is executed by a consensus of the wallet's guardians and takes\n * 24 hours before it can be finalized. Once finalised the ownership of the wallet\n * is transfered to a new address.\n * @author Julien Niset - <julien@argent.im>\n * @author Olivier Van Den Biggelaar - <olivier@argent.im>\n */\ncontract RecoveryManager is BaseModule, RelayerModule {\n\n    bytes32 constant NAME = \"RecoveryManager\";\n\n    bytes4 constant internal EXECUTE_RECOVERY_PREFIX = bytes4(keccak256(\"executeRecovery(address,address)\"));\n    bytes4 constant internal FINALIZE_RECOVERY_PREFIX = bytes4(keccak256(\"finalizeRecovery(address)\"));\n    bytes4 constant internal CANCEL_RECOVERY_PREFIX = bytes4(keccak256(\"cancelRecovery(address)\"));\n    bytes4 constant internal TRANSFER_OWNERSHIP_PREFIX = bytes4(keccak256(\"transferOwnership(address,address)\"));\n\n    struct RecoveryConfig {\n        address recovery;\n        uint64 executeAfter;\n        uint32 guardianCount;\n    }\n\n    // Wallet specific storage\n    mapping (address => RecoveryConfig) internal recoveryConfigs;\n\n    // Recovery period\n    uint256 public recoveryPeriod;\n    // Lock period\n    uint256 public lockPeriod;\n    // Security period used for (non-recovery) ownership transfer\n    uint256 public securityPeriod;\n    // Security window used for (non-recovery) ownership transfer\n    uint256 public securityWindow;\n\n    // *************** Events *************************** //\n\n    event RecoveryExecuted(address indexed wallet, address indexed _recovery, uint64 executeAfter);\n    event RecoveryFinalized(address indexed wallet, address indexed _recovery);\n    event RecoveryCanceled(address indexed wallet, address indexed _recovery);\n    event OwnershipTransfered(address indexed wallet, address indexed _newOwner);\n\n    // *************** Modifiers ************************ //\n\n    /**\n     * @dev Throws if there is no ongoing recovery procedure.\n     */\n    modifier onlyWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter > 0, \"RM: there must be an ongoing recovery\");\n        _;\n    }\n\n    /**\n     * @dev Throws if there is an ongoing recovery procedure.\n     */\n    modifier notWhenRecovery(BaseWallet _wallet) {\n        require(recoveryConfigs[address(_wallet)].executeAfter == 0, \"RM: there cannot be an ongoing recovery\");\n        _;\n    }\n\n    // *************** Constructor ************************ //\n\n    constructor(\n        ModuleRegistry _registry,\n        GuardianStorage _guardianStorage,\n        uint256 _recoveryPeriod,\n        uint256 _lockPeriod,\n        uint256 _securityPeriod,\n        uint256 _securityWindow\n    )\n        BaseModule(_registry, _guardianStorage, NAME)\n        public\n    {\n        require(_lockPeriod >= _recoveryPeriod && _recoveryPeriod >= _securityPeriod + _securityWindow, \"RM: insecure security periods\");\n        recoveryPeriod = _recoveryPeriod;\n        lockPeriod = _lockPeriod;\n        securityPeriod = _securityPeriod;\n        securityWindow = _securityWindow;\n    }\n\n    // *************** External functions ************************ //\n\n    /**\n     * @dev Lets the guardians start the execution of the recovery procedure.\n     * Once triggered the recovery is pending for the security period before it can\n     * be finalised.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2).\n     * @param _wallet The target wallet.\n     * @param _recovery The address to which ownership should be transferred.\n     */\n    function executeRecovery(BaseWallet _wallet, address _recovery) external onlyExecute notWhenRecovery(_wallet) {\n        require(_recovery != address(0), \"RM: recovery address cannot be null\");\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        config.recovery = _recovery;\n        config.executeAfter = uint64(now + recoveryPeriod);\n        config.guardianCount = uint32(guardianStorage.guardianCount(_wallet));\n        guardianStorage.setLock(_wallet, now + lockPeriod);\n        emit RecoveryExecuted(address(_wallet), _recovery, config.executeAfter);\n    }\n\n    /**\n     * @dev Finalizes an ongoing recovery procedure if the security period is over.\n     * The method is public and callable by anyone to enable orchestration.\n     * @param _wallet The target wallet.\n     */\n    function finalizeRecovery(BaseWallet _wallet) external onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        require(uint64(now) > config.executeAfter, \"RM: the recovery period is not over yet\");\n        address recoveryOwner = config.recovery;\n        delete recoveryConfigs[address(_wallet)];\n\n        _wallet.setOwner(recoveryOwner);\n        guardianStorage.setLock(_wallet, 0);\n\n        emit RecoveryFinalized(address(_wallet), config.recovery);\n    }\n\n    /**\n     * @dev Lets the owner cancel an ongoing recovery procedure.\n     * Must be confirmed by N guardians, where N = ((Nb Guardian + 1) / 2) - 1.\n     * @param _wallet The target wallet.\n     */\n    function cancelRecovery(BaseWallet _wallet) external onlyExecute onlyWhenRecovery(_wallet) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        delete recoveryConfigs[address(_wallet)];\n        guardianStorage.setLock(_wallet, 0);\n\n        emit RecoveryCanceled(address(_wallet), config.recovery);\n    }\n\n    /**\n     * @dev Lets the owner start the execution of the ownership transfer procedure.\n     * Once triggered the ownership transfer is pending for the security period before it can\n     * be finalised.\n     * @param _wallet The target wallet.\n     * @param _newOwner The address to which ownership should be transferred.\n     */\n    function transferOwnership(BaseWallet _wallet, address _newOwner) external onlyExecute onlyWhenUnlocked(_wallet) {\n        require(_newOwner != address(0), \"RM: new owner address cannot be null\");\n        _wallet.setOwner(_newOwner);\n\n        emit OwnershipTransfered(address(_wallet), _newOwner);\n    }\n\n    /**\n    * @dev Gets the details of the ongoing recovery procedure if any.\n    * @param _wallet The target wallet.\n    */\n    function getRecovery(BaseWallet _wallet) public view returns(address _address, uint64 _executeAfter, uint32 _guardianCount) {\n        RecoveryConfig storage config = recoveryConfigs[address(_wallet)];\n        return (config.recovery, config.executeAfter, config.guardianCount);\n    }\n\n    // *************** Implementation of RelayerModule methods ********************* //\n\n    function getRequiredSignatures(BaseWallet _wallet, bytes memory _data) public view returns (uint256, OwnerSignature) {\n        bytes4 methodId = functionPrefix(_data);\n        if (methodId == EXECUTE_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Disallowed);\n        }\n        if (methodId == FINALIZE_RECOVERY_PREFIX) {\n            return (0, OwnerSignature.Required);\n        }\n        if (methodId == CANCEL_RECOVERY_PREFIX) {\n            uint numberOfSignaturesRequired = ArgentSafeMath.ceil(recoveryConfigs[address(_wallet)].guardianCount + 1, 2);\n            return (numberOfSignaturesRequired, OwnerSignature.Optional);\n        }\n        if (methodId == TRANSFER_OWNERSHIP_PREFIX) {\n            uint majorityGuardians = ArgentSafeMath.ceil(guardianStorage.guardianCount(_wallet), 2);\n            uint numberOfSignaturesRequired = SafeMath.add(majorityGuardians, 1);\n            return (numberOfSignaturesRequired, OwnerSignature.Required);\n        }\n\n        revert(\"RM: unknown method\");\n    }\n}\n", "commit_id": "7f904ac5fe743711cfaf8461b8a867f001161434"}}