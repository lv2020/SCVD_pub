{"filename": "contracts/Auction.sol", "patch": "@@ -87,8 +87,9 @@ contract Auction {\n     bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n     for (uint i = 0; i < accountsList.length;  i++) {\n       if (bids[accountsList[i]] > 0) {\n-        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n-        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n+        uint refundValue = bids[accountsList[i]];\n+        bids[accountsList[i]] = 0;\n+        accountsList[i].transfer(refundValue); \n       }\n     }     \n   }", "project_link": "https://github.com/astralship/eos/commit/8bb9543d46bc1ae588bcf03522ee1545da1a507e", "bug_version": {"raw_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n\n    uint refundValue = bids[msg.sender];\n    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n    msg.sender.transfer(refundValue);\n    \n    emit Refund(msg.sender, refundValue, now);\n  }\n\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n\n    uint refundValue = bids[msg.sender];\n    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n    msg.sender.transfer(refundValue);\n    \n    emit Refund(msg.sender, refundValue, now);\n  }\n\n}\n", "commit_id": "ea415ec328778cbe5d2788b317b576986728d78b"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        uint refundValue = bids[accountsList[i]];\n        bids[accountsList[i]] = 0;\n        accountsList[i].transfer(refundValue); \n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n\n    uint refundValue = bids[msg.sender];\n    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n    msg.sender.transfer(refundValue);\n    \n    emit Refund(msg.sender, refundValue, now);\n  }\n\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        uint refundValue = bids[accountsList[i]];\n        bids[accountsList[i]] = 0;\n        accountsList[i].transfer(refundValue); \n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n\n    uint refundValue = bids[msg.sender];\n    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n    msg.sender.transfer(refundValue);\n    \n    emit Refund(msg.sender, refundValue, now);\n  }\n\n}\n", "commit_id": "8bb9543d46bc1ae588bcf03522ee1545da1a507e"}}