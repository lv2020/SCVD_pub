{"filename": "chain/contracts/ChequeBank.sol", "patch": "@@ -45,16 +45,16 @@ contract ChequeBank {\n     }\n \n     function withdraw(uint256 amount) external hasEnoughBalance(amount) {\n-        payable(msg.sender).transfer(amount);\n         _balances[msg.sender] -= amount;\n+        payable(msg.sender).transfer(amount);\n     }\n \n     function withdrawTo(uint256 amount, address payable recipient)\n         external\n         hasEnoughBalance(amount)\n     {\n-        recipient.transfer(amount);\n         _balances[msg.sender] -= amount;\n+        recipient.transfer(amount);\n     }\n \n     function balanceOf() external view returns (uint256) {", "project_link": "https://github.com/cryptocj/Dapp-Engineer-Training-Week2/commit/20046facc2141e6af4e1cd801f7b2c0dd4805602", "bug_version": {"raw_code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ncontract ChequeBank {\n    struct ChequeInfo {\n        uint256 amount;\n        bytes32 chequeId;\n        uint32 validFrom;\n        uint32 validThru;\n        address payee;\n        address payer;\n    }\n\n    struct SignOverInfo {\n        uint8 counter;\n        bytes32 chequeId;\n        address oldPayee;\n        address newPayee;\n    }\n\n    struct Cheque {\n        ChequeInfo chequeInfo;\n        bytes sig;\n    }\n\n    struct SignOver {\n        SignOverInfo signOverInfo;\n        bytes sig;\n    }\n\n    mapping(address => uint256) _balances;\n\n    modifier hasEnoughBalance(uint256 amount) {\n        require(\n            amount <= _balances[msg.sender],\n            \"not enough balance to withdraw\"\n        );\n        _;\n    }\n\n    function deposit() external payable {\n        if (msg.value > 0) {\n            _balances[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) external hasEnoughBalance(amount) {\n        payable(msg.sender).transfer(amount);\n        _balances[msg.sender] -= amount;\n    }\n\n    function withdrawTo(uint256 amount, address payable recipient)\n        external\n        hasEnoughBalance(amount)\n    {\n        recipient.transfer(amount);\n        _balances[msg.sender] -= amount;\n    }\n\n    function balanceOf() external view returns (uint256) {\n        return _balances[msg.sender];\n    }\n\n    function redeem(Cheque memory chequeData) external {}\n\n    function revoke(bytes32 chequeId) external {}\n\n    function notifySignOver(SignOver memory signOverData) external {}\n\n    function redeemSignOver(\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) external {}\n\n    function isChequeValid(\n        address payee,\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) public view returns (bool) {}\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ncontract ChequeBank {\n    struct ChequeInfo {\n        uint256 amount;\n        bytes32 chequeId;\n        uint32 validFrom;\n        uint32 validThru;\n        address payee;\n        address payer;\n    }\n\n    struct SignOverInfo {\n        uint8 counter;\n        bytes32 chequeId;\n        address oldPayee;\n        address newPayee;\n    }\n\n    struct Cheque {\n        ChequeInfo chequeInfo;\n        bytes sig;\n    }\n\n    struct SignOver {\n        SignOverInfo signOverInfo;\n        bytes sig;\n    }\n\n    mapping(address => uint256) _balances;\n\n    modifier hasEnoughBalance(uint256 amount) {\n        require(\n            amount <= _balances[msg.sender],\n            \"not enough balance to withdraw\"\n        );\n        _;\n    }\n\n    function deposit() external payable {\n        if (msg.value > 0) {\n            _balances[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) external hasEnoughBalance(amount) {\n        payable(msg.sender).transfer(amount);\n        _balances[msg.sender] -= amount;\n    }\n\n    function withdrawTo(uint256 amount, address payable recipient)\n        external\n        hasEnoughBalance(amount)\n    {\n        recipient.transfer(amount);\n        _balances[msg.sender] -= amount;\n    }\n\n    function balanceOf() external view returns (uint256) {\n        return _balances[msg.sender];\n    }\n\n    function redeem(Cheque memory chequeData) external {}\n\n    function revoke(bytes32 chequeId) external {}\n\n    function notifySignOver(SignOver memory signOverData) external {}\n\n    function redeemSignOver(\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) external {}\n\n    function isChequeValid(\n        address payee,\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) public view returns (bool) {}\n}\n", "commit_id": "8ecee207262705a09dc5219ef2b5c6c95196ad38"}, "fixed_version": {"raw_code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ncontract ChequeBank {\n    struct ChequeInfo {\n        uint256 amount;\n        bytes32 chequeId;\n        uint32 validFrom;\n        uint32 validThru;\n        address payee;\n        address payer;\n    }\n\n    struct SignOverInfo {\n        uint8 counter;\n        bytes32 chequeId;\n        address oldPayee;\n        address newPayee;\n    }\n\n    struct Cheque {\n        ChequeInfo chequeInfo;\n        bytes sig;\n    }\n\n    struct SignOver {\n        SignOverInfo signOverInfo;\n        bytes sig;\n    }\n\n    mapping(address => uint256) _balances;\n\n    modifier hasEnoughBalance(uint256 amount) {\n        require(\n            amount <= _balances[msg.sender],\n            \"not enough balance to withdraw\"\n        );\n        _;\n    }\n\n    function deposit() external payable {\n        if (msg.value > 0) {\n            _balances[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) external hasEnoughBalance(amount) {\n        _balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawTo(uint256 amount, address payable recipient)\n        external\n        hasEnoughBalance(amount)\n    {\n        _balances[msg.sender] -= amount;\n        recipient.transfer(amount);\n    }\n\n    function balanceOf() external view returns (uint256) {\n        return _balances[msg.sender];\n    }\n\n    function redeem(Cheque memory chequeData) external {}\n\n    function revoke(bytes32 chequeId) external {}\n\n    function notifySignOver(SignOver memory signOverData) external {}\n\n    function redeemSignOver(\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) external {}\n\n    function isChequeValid(\n        address payee,\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) public view returns (bool) {}\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: Unlicense\npragma solidity ^0.8.0;\n\ncontract ChequeBank {\n    struct ChequeInfo {\n        uint256 amount;\n        bytes32 chequeId;\n        uint32 validFrom;\n        uint32 validThru;\n        address payee;\n        address payer;\n    }\n\n    struct SignOverInfo {\n        uint8 counter;\n        bytes32 chequeId;\n        address oldPayee;\n        address newPayee;\n    }\n\n    struct Cheque {\n        ChequeInfo chequeInfo;\n        bytes sig;\n    }\n\n    struct SignOver {\n        SignOverInfo signOverInfo;\n        bytes sig;\n    }\n\n    mapping(address => uint256) _balances;\n\n    modifier hasEnoughBalance(uint256 amount) {\n        require(\n            amount <= _balances[msg.sender],\n            \"not enough balance to withdraw\"\n        );\n        _;\n    }\n\n    function deposit() external payable {\n        if (msg.value > 0) {\n            _balances[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) external hasEnoughBalance(amount) {\n        _balances[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n    }\n\n    function withdrawTo(uint256 amount, address payable recipient)\n        external\n        hasEnoughBalance(amount)\n    {\n        _balances[msg.sender] -= amount;\n        recipient.transfer(amount);\n    }\n\n    function balanceOf() external view returns (uint256) {\n        return _balances[msg.sender];\n    }\n\n    function redeem(Cheque memory chequeData) external {}\n\n    function revoke(bytes32 chequeId) external {}\n\n    function notifySignOver(SignOver memory signOverData) external {}\n\n    function redeemSignOver(\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) external {}\n\n    function isChequeValid(\n        address payee,\n        Cheque memory chequeData,\n        SignOver[] memory signOverData\n    ) public view returns (bool) {}\n}\n", "commit_id": "20046facc2141e6af4e1cd801f7b2c0dd4805602"}}