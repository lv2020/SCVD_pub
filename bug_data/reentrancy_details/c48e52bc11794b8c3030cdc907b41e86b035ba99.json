{"filename": "contracts/ContractSplitEther.sol", "patch": "@@ -5,6 +5,8 @@ contract ContractSplitEther {\n   address private recipient1;\n   address private recipient2;\n \n+  bool private reentryGuard = false;\n+\n   function ContractSplitEther(address _recipient1, address _recipient2)\n     validateAddress(_recipient1)\n     validateAddress(_recipient2) \n@@ -13,9 +15,14 @@ contract ContractSplitEther {\n     recipient2 = _recipient2;\n   }\n \n-  function () {\n-    sendTo(recipient1, this.balance / 2);\n-    sendTo(recipient2, this.balance);\n+  function () \n+    payable\n+  {\n+    uint amount1 = msg.value / 2;\n+    uint amount2 = msg.value - amount1;\n+\n+    sendTo(recipient1, amount1);\n+    sendTo(recipient2, amount2);\n   }\n \n   // Public\n@@ -32,7 +39,7 @@ contract ContractSplitEther {\n   modifier validateAddress (address recipient) {\n     if (recipient == 0) throw;\n     _;\n-  }    \n+  }\n \n }\n ", "project_link": "https://github.com/nickgeoca/split-contract/commit/a1f714d4622aa3b7ea7515a6059044bd142727f1", "bug_version": {"raw_code": "pragma solidity ^0.4.2;\n\ncontract ContractSplitEther {\n  // Addresses to split ether over\n  address private recipient1;\n  address private recipient2;\n\n  function ContractSplitEther(address _recipient1, address _recipient2)\n    validateAddress(_recipient1)\n    validateAddress(_recipient2) \n  {\n    recipient1 = _recipient1;\n    recipient2 = _recipient2;\n  }\n\n  function () {\n    sendTo(recipient1, this.balance / 2);\n    sendTo(recipient2, this.balance);\n  }\n\n  // Public\n  function getRecipients() returns (address[2]) {\n    return [recipient1, recipient2];\n  }\n\n  // Private\n  function sendTo(address recipient, uint bal) private {\n    if (!recipient.send(bal)) throw;\n  }\n\n  // Modifiers\n  modifier validateAddress (address recipient) {\n    if (recipient == 0) throw;\n    _;\n  }    \n\n}\n\n/*\nAlso try\n 1 using msg.value instead\n 2 making payments asynchronous.\n*/\n", "flattened_code": "pragma solidity ^0.4.2;\n\ncontract ContractSplitEther {\n  // Addresses to split ether over\n  address private recipient1;\n  address private recipient2;\n\n  function ContractSplitEther(address _recipient1, address _recipient2)\n    validateAddress(_recipient1)\n    validateAddress(_recipient2) \n  {\n    recipient1 = _recipient1;\n    recipient2 = _recipient2;\n  }\n\n  function () {\n    sendTo(recipient1, this.balance / 2);\n    sendTo(recipient2, this.balance);\n  }\n\n  // Public\n  function getRecipients() returns (address[2]) {\n    return [recipient1, recipient2];\n  }\n\n  // Private\n  function sendTo(address recipient, uint bal) private {\n    if (!recipient.send(bal)) throw;\n  }\n\n  // Modifiers\n  modifier validateAddress (address recipient) {\n    if (recipient == 0) throw;\n    _;\n  }    \n\n}\n\n/*\nAlso try\n 1 using msg.value instead\n 2 making payments asynchronous.\n*/\n", "commit_id": "c48e52bc11794b8c3030cdc907b41e86b035ba99"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.2;\n\ncontract ContractSplitEther {\n  // Addresses to split ether over\n  address private recipient1;\n  address private recipient2;\n\n  bool private reentryGuard = false;\n\n  function ContractSplitEther(address _recipient1, address _recipient2)\n    validateAddress(_recipient1)\n    validateAddress(_recipient2) \n  {\n    recipient1 = _recipient1;\n    recipient2 = _recipient2;\n  }\n\n  function () \n    payable\n  {\n    uint amount1 = msg.value / 2;\n    uint amount2 = msg.value - amount1;\n\n    sendTo(recipient1, amount1);\n    sendTo(recipient2, amount2);\n  }\n\n  // Public\n  function getRecipients() returns (address[2]) {\n    return [recipient1, recipient2];\n  }\n\n  // Private\n  function sendTo(address recipient, uint bal) private {\n    if (!recipient.send(bal)) throw;\n  }\n\n  // Modifiers\n  modifier validateAddress (address recipient) {\n    if (recipient == 0) throw;\n    _;\n  }\n\n}\n\n/*\nAlso try\n 1 using msg.value instead\n 2 making payments asynchronous.\n*/\n", "flattened_code": "pragma solidity ^0.4.2;\n\ncontract ContractSplitEther {\n  // Addresses to split ether over\n  address private recipient1;\n  address private recipient2;\n\n  bool private reentryGuard = false;\n\n  function ContractSplitEther(address _recipient1, address _recipient2)\n    validateAddress(_recipient1)\n    validateAddress(_recipient2) \n  {\n    recipient1 = _recipient1;\n    recipient2 = _recipient2;\n  }\n\n  function () \n    payable\n  {\n    uint amount1 = msg.value / 2;\n    uint amount2 = msg.value - amount1;\n\n    sendTo(recipient1, amount1);\n    sendTo(recipient2, amount2);\n  }\n\n  // Public\n  function getRecipients() returns (address[2]) {\n    return [recipient1, recipient2];\n  }\n\n  // Private\n  function sendTo(address recipient, uint bal) private {\n    if (!recipient.send(bal)) throw;\n  }\n\n  // Modifiers\n  modifier validateAddress (address recipient) {\n    if (recipient == 0) throw;\n    _;\n  }\n\n}\n\n/*\nAlso try\n 1 using msg.value instead\n 2 making payments asynchronous.\n*/\n", "commit_id": "a1f714d4622aa3b7ea7515a6059044bd142727f1"}}