{"filename": "contracts/sc.sol", "patch": "@@ -33,14 +33,14 @@ contract AgreementBetweenSubjects {\n     uint256 howLong;\n   }\n \n-  bool internal locked;\n+  uint16 internal locked = 1;\n \n   //doesn't allow reentrance attack\n   modifier noReentrant() {\n-        require(!locked, \"No re-entrancy\");\n-        locked = true;\n+        require(locked == 1, \"No re-entrancy\");\n+        locked = 2;\n         _;\n-        locked = false;\n+        locked = 1;\n     }\n \n    /// @dev Saving the money sent for the signee to withdraw it", "project_link": "https://github.com/farinavito/Lex/commit/193f3b272296c533b1708fc17296c36b920cacb4", "bug_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// @title Implementing a legal contract: Person A commits sending X amount of ether to person B every Y days for Z days\n/// @author Farina Vito\ncontract AgreementBetweenSubjects {\n\n  /// @notice Defining the agreement \n  /// @param id A unique identifier of the agreement\n  /// @param signee The person who commits sending the the money to the receiver \n  /// @param receiver The person receiving the money\n  /// @param amount The quantity of money that the signee commits sending to the receiver\n  /// @param transactionCreated Unix timestamp when transaction was sent\n  /// @param deposit The agreed amount of the deposit by both sides for the contract. Initial state will be zero\n  /// @param status Representation of different stages in the agreement: Created, Activated, Terminated\n  /// @param approved Confirmation of the agreedDeposit by the receiver. Stages: Not Confirmed, Confirmed\n  /// @param agreementStartDateThe unix timestamp of the agreement's creation. FRONTEND\n  /// @param everyTimeUnit The number of days till when the signee's transaction has to be created. First calculated by agreementStartDate+ everyTimeUnit. Later just adding everyTimeUnit\n  /// @param positionPeriod A pointer to the current everyTimeUnit parameter\n  /// @param howLong The number of days till the agreement expires\n  struct Agreement{\n    uint256 id; \n    address signee;\n    address payable receiver; \n    uint256 amount;\n    uint256 transactionCreated;\n    uint256 deposit;\n    string status;\n    string approved;\n    uint256 agreementStartDate;\n    uint256 everyTimeUnit;\n    uint256 positionPeriod;\n    uint256 howLong;\n  }\n\n  bool internal locked;\n\n  //doesn't allow reentrance attack\n  modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n   /// @dev Saving the money sent for the signee to withdraw it\n  mapping(address => uint256) private withdraw_signee;\n\n  /// @dev Saving the money sent for the receiver to withdraw it\n  mapping(address => uint256) private withdraw_receiver;\n\n  /// @dev A unique identifier of theagreement. The same as the id.\n  mapping(uint256 => Agreement) public exactAgreement;\n  /// @dev Used to increase the id of the agreements in the \"createAgreements\" function\n  uint numAgreement;\n\n  /// @dev Storing the id's of the agreements that the signee has created\n  mapping(address => uint[]) public mySenderAgreements;\n\n  /// @dev Storing the id's of the agreements of the same receiver address\n  mapping(address => uint[]) public myReceiverAgreements;\n\n  /// @notice Emitting agreement's info \n  event AgreementInfo(\n    uint256 agreementId,\n    address agreementSignee, \n    address agreementReceiver, \n    uint256 agreementAmount,\n    uint256 agreementTransactionCreated,\n    uint256 agreementDeposit,\n    string agreementStatus,\n    string agreementApproved,\n    uint256 agreementStartDate,\n    uint256 agreementTimePeriods,\n    uint256 agreementPositionPeriod,\n    uint256 agreementTimeDuration\n  );\n\n  /// @notice After the contract is terminated, emit an event with a message\n  event Terminated(string message);\n  /// @notice After other event than Terminated happens, emit it and send a message\n  event NotifyUser(string message);\n  \n\n  /// @notice Initializing the position from where the everyTimeUnit is added\n  function initializingPositionPeriod(uint256 _id) private {\n      exactAgreement[_id].positionPeriod = exactAgreement[_id].agreementStartDate+ (exactAgreement[_id].everyTimeUnit);\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline \n  function timeNotBreached(uint256 _id) private returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n        exactAgreement[_id].positionPeriod += exactAgreement[_id].everyTimeUnit;\n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline without incrementing positionPeriod\n  function timeWasntBreached(uint256 _id) private view returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Sending the payment based on the status of the agreement\n  function sendPayment(uint256 _id) external payable {\n    require(exactAgreement[_id].signee == msg.sender, \"Only the owner can pay the agreement's terms\");\n    //the agreement has to be confirmed from the receiver of the agreement\n    require(keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\")), \"The receiver has to confirm the contract\");\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //save the time of calling this function\n      exactAgreement[_id].transactionCreated = block.timestamp;\n      //if the transaction sent was on time and transaction was sent before the agreement's deadline\n      if (timeNotBreached(_id)){\n        if (exactAgreement[_id].amount <= msg.value){\n          //send the transaction to the receiver\n          withdraw_receiver[exactAgreement[_id].receiver] += msg.value;\n          emit NotifyUser(\"Transaction was sent to the receiver\");\n        //if the transaction was on time, but it wasn't enough\n        } else {\n            exactAgreement[_id].status = \"Terminated\"; \n            //sending the deposit to the receiver\n            withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n            //ensure that the deposit is reduced to 0\n            exactAgreement[_id].deposit = 0;\n            //return the transaction to the signee\n            withdraw_signee[exactAgreement[_id].signee] += msg.value;\n            emit Terminated(\"The agreement was terminated due to different amount sent than in the terms\");      \n        }\n      //if the transaction wasn't sent on time\n      } else {\n        exactAgreement[_id].status = \"Terminated\";\n        //sending the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        //return the transaction to the signee\n        withdraw_signee[exactAgreement[_id].signee] += msg.value;\n        emit Terminated(\"The agreement was terminated due to late payment\");\n      }\n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n        require(exactAgreement[_id].agreementStartDate<= block.timestamp, \"The agreement hasn't started yet\");\n        require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate> block.timestamp, \"The agreement's deadline has ended\");\n        require(exactAgreement[_id].amount <= msg.value, \"The deposit is not the same as agreed in the terms\");\n        exactAgreement[_id].status = \"Activated\";\n        //set the position period\n        initializingPositionPeriod(_id);\n        emit NotifyUser(\"The agreement has been activated\"); \n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n          //return the transaction to the signee\n          revert(\"The agreement is already terminated\");\n    } else {\n          //return the transaction to the signee\n          revert(\"There is no agreement with this id\");\n    }\n  }\n\n  function withdrawAsTheSignee(uint256 _id) external payable noReentrant{\n\t  require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    require(withdraw_signee[exactAgreement[_id].signee] > 0, \"There aren't any funds to withdraw\");\n\t  uint256 current_amount = withdraw_signee[exactAgreement[_id].signee];\n\t  withdraw_signee[exactAgreement[_id].signee] = 0;\n\t  (bool sent, ) = exactAgreement[_id].signee.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n\t  emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  function withdrawAsTheReceiver(uint256 _id) external payable noReentrant{\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    require(withdraw_receiver[exactAgreement[_id].receiver] > 0, \"There aren't any funds to withdraw\");\n    uint256 current_amount = withdraw_receiver[exactAgreement[_id].receiver];\n    withdraw_receiver[exactAgreement[_id].receiver] = 0;\n    (bool sent, ) = exactAgreement[_id].receiver.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n    emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  /// @notice Creating a new agreement\n  function createAgreement(\n    address payable _receiver, \n    uint256 _amount,\n    uint256 _everyTimeUnit,\n    uint256 _howLong,\n    uint256 _startOfTheAgreement\n    ) external payable {\n        require(_amount > 0 && _everyTimeUnit > 0 && _howLong > 0, \"All input data must be larger than 0\");\n        require(_howLong > _everyTimeUnit, \"The period of the payment is greater than the duration of the contract\");\n        require(msg.value >= _amount, \"Deposit has to be at least the size of the amount\");\n        require(_startOfTheAgreement >= block.timestamp, \"The agreement can't be created in the past\");\n        uint256 agreementId = numAgreement++;\n\n        //creating a new agreement\n        Agreement storage newAgreement = exactAgreement[agreementId];\n        newAgreement.id = agreementId;\n        newAgreement.signee = msg.sender;\n        newAgreement.receiver = _receiver;\n        newAgreement.amount = _amount;\n\n        //the amount that is actually deposited to the agreement. We initialize it with 0\n        newAgreement.deposit = msg.value;\n        //the status of the agreement when its created\n        newAgreement.status = \"Created\";\n        //initialize the approved term\n        newAgreement.approved = \"Not Confirmed\";\n        //when was the agreement created\n        newAgreement.agreementStartDate= _startOfTheAgreement;\n        //period of the payment\n        newAgreement.everyTimeUnit = _everyTimeUnit;\n        //position of the end of the period in which the signee has to send the money (for example: ...every 3 weeks... - this period needs to update itself)\n        newAgreement.positionPeriod = 0;\n        //how long will the agreement last\n        newAgreement.howLong = _howLong;\n        //storing the ids of the agreements and connecting them to msg.sender's address so we can display them to the frontend\n        mySenderAgreements[msg.sender].push(agreementId);\n        //storing the ids of the agreements and connecting them to _receiver's address so we can display them to the frontend\n        myReceiverAgreements[_receiver].push(agreementId);\n\n        emit AgreementInfo(\n          newAgreement.id, \n          newAgreement.signee, \n          newAgreement.receiver, \n          newAgreement.amount,\n          newAgreement.transactionCreated,\n          newAgreement.deposit, \n          newAgreement.status,\n          newAgreement.approved,\n          newAgreement.agreementStartDate, \n          newAgreement.everyTimeUnit, \n          newAgreement.positionPeriod, \n          newAgreement.howLong\n          ); \n  }\n\n  //function for the receiver - wether he agrees with the terms or not, approves the contract or not. If he does, we are able to activate it, otherwise we can't\n  function confirmAgreement(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\"))){\n\t\t  emit NotifyUser(\"The agreement is already confirmed\");\n\t  }else if(keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n      emit NotifyUser(\"The agreement is already terminated\");\n    }else{\n      require(exactAgreement[_id].receiver == msg.sender, \"Only the receiver can confirm the agreement\");\n      //cannot confirm an agreement that ends in the past\n      require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp, \"The agreement's deadline has ended\");\n      //confirm the agreement\n      exactAgreement[_id].approved = \"Confirmed\";\n      //emit that the agreement was confirmed\n      emit NotifyUser(\"The agreement was confirmed\");\n\t  }\n  }\n\n  /// @notice Terminating the agreement by the signee\n  function terminateContract(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n\t\t  emit NotifyUser(\"The agreement is already terminated\");\n\t  } else if (exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate< block.timestamp){\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the signee\n        withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n    } else {\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n\t  }\n  }\n\n  /// @notice Receiver checking if the contract has been breached\n  function wasContractBreached(uint256 _id) external {\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    //checking if the agreement was Activated\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //checking if the deadline was breached\n      if(timeWasntBreached(_id)){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      } \n    }else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n      if(exactAgreement[_id].agreementStartDate+ (6*60*60*24) > block.timestamp){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      }\n    } else {\n        emit NotifyUser(\"The agreement is already terminated\");\n    }\n  } \n\n  function getWithdrawalSignee(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    return withdraw_signee[exactAgreement[_id].signee];\n  }\n\n  function getWithdrawalReceiver(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    return withdraw_receiver[exactAgreement[_id].receiver];\n  }\n\n  fallback() external {}\n  receive() external payable {}\n\n}", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n/// @title Implementing a legal contract: Person A commits sending X amount of ether to person B every Y days for Z days\n/// @author Farina Vito\ncontract AgreementBetweenSubjects {\n\n  /// @notice Defining the agreement \n  /// @param id A unique identifier of the agreement\n  /// @param signee The person who commits sending the the money to the receiver \n  /// @param receiver The person receiving the money\n  /// @param amount The quantity of money that the signee commits sending to the receiver\n  /// @param transactionCreated Unix timestamp when transaction was sent\n  /// @param deposit The agreed amount of the deposit by both sides for the contract. Initial state will be zero\n  /// @param status Representation of different stages in the agreement: Created, Activated, Terminated\n  /// @param approved Confirmation of the agreedDeposit by the receiver. Stages: Not Confirmed, Confirmed\n  /// @param agreementStartDateThe unix timestamp of the agreement's creation. FRONTEND\n  /// @param everyTimeUnit The number of days till when the signee's transaction has to be created. First calculated by agreementStartDate+ everyTimeUnit. Later just adding everyTimeUnit\n  /// @param positionPeriod A pointer to the current everyTimeUnit parameter\n  /// @param howLong The number of days till the agreement expires\n  struct Agreement{\n    uint256 id; \n    address signee;\n    address payable receiver; \n    uint256 amount;\n    uint256 transactionCreated;\n    uint256 deposit;\n    string status;\n    string approved;\n    uint256 agreementStartDate;\n    uint256 everyTimeUnit;\n    uint256 positionPeriod;\n    uint256 howLong;\n  }\n\n  bool internal locked;\n\n  //doesn't allow reentrance attack\n  modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n   /// @dev Saving the money sent for the signee to withdraw it\n  mapping(address => uint256) private withdraw_signee;\n\n  /// @dev Saving the money sent for the receiver to withdraw it\n  mapping(address => uint256) private withdraw_receiver;\n\n  /// @dev A unique identifier of theagreement. The same as the id.\n  mapping(uint256 => Agreement) public exactAgreement;\n  /// @dev Used to increase the id of the agreements in the \"createAgreements\" function\n  uint numAgreement;\n\n  /// @dev Storing the id's of the agreements that the signee has created\n  mapping(address => uint[]) public mySenderAgreements;\n\n  /// @dev Storing the id's of the agreements of the same receiver address\n  mapping(address => uint[]) public myReceiverAgreements;\n\n  /// @notice Emitting agreement's info \n  event AgreementInfo(\n    uint256 agreementId,\n    address agreementSignee, \n    address agreementReceiver, \n    uint256 agreementAmount,\n    uint256 agreementTransactionCreated,\n    uint256 agreementDeposit,\n    string agreementStatus,\n    string agreementApproved,\n    uint256 agreementStartDate,\n    uint256 agreementTimePeriods,\n    uint256 agreementPositionPeriod,\n    uint256 agreementTimeDuration\n  );\n\n  /// @notice After the contract is terminated, emit an event with a message\n  event Terminated(string message);\n  /// @notice After other event than Terminated happens, emit it and send a message\n  event NotifyUser(string message);\n  \n\n  /// @notice Initializing the position from where the everyTimeUnit is added\n  function initializingPositionPeriod(uint256 _id) private {\n      exactAgreement[_id].positionPeriod = exactAgreement[_id].agreementStartDate+ (exactAgreement[_id].everyTimeUnit);\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline \n  function timeNotBreached(uint256 _id) private returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n        exactAgreement[_id].positionPeriod += exactAgreement[_id].everyTimeUnit;\n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline without incrementing positionPeriod\n  function timeWasntBreached(uint256 _id) private view returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Sending the payment based on the status of the agreement\n  function sendPayment(uint256 _id) external payable {\n    require(exactAgreement[_id].signee == msg.sender, \"Only the owner can pay the agreement's terms\");\n    //the agreement has to be confirmed from the receiver of the agreement\n    require(keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\")), \"The receiver has to confirm the contract\");\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //save the time of calling this function\n      exactAgreement[_id].transactionCreated = block.timestamp;\n      //if the transaction sent was on time and transaction was sent before the agreement's deadline\n      if (timeNotBreached(_id)){\n        if (exactAgreement[_id].amount <= msg.value){\n          //send the transaction to the receiver\n          withdraw_receiver[exactAgreement[_id].receiver] += msg.value;\n          emit NotifyUser(\"Transaction was sent to the receiver\");\n        //if the transaction was on time, but it wasn't enough\n        } else {\n            exactAgreement[_id].status = \"Terminated\"; \n            //sending the deposit to the receiver\n            withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n            //ensure that the deposit is reduced to 0\n            exactAgreement[_id].deposit = 0;\n            //return the transaction to the signee\n            withdraw_signee[exactAgreement[_id].signee] += msg.value;\n            emit Terminated(\"The agreement was terminated due to different amount sent than in the terms\");      \n        }\n      //if the transaction wasn't sent on time\n      } else {\n        exactAgreement[_id].status = \"Terminated\";\n        //sending the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        //return the transaction to the signee\n        withdraw_signee[exactAgreement[_id].signee] += msg.value;\n        emit Terminated(\"The agreement was terminated due to late payment\");\n      }\n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n        require(exactAgreement[_id].agreementStartDate<= block.timestamp, \"The agreement hasn't started yet\");\n        require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate> block.timestamp, \"The agreement's deadline has ended\");\n        require(exactAgreement[_id].amount <= msg.value, \"The deposit is not the same as agreed in the terms\");\n        exactAgreement[_id].status = \"Activated\";\n        //set the position period\n        initializingPositionPeriod(_id);\n        emit NotifyUser(\"The agreement has been activated\"); \n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n          //return the transaction to the signee\n          revert(\"The agreement is already terminated\");\n    } else {\n          //return the transaction to the signee\n          revert(\"There is no agreement with this id\");\n    }\n  }\n\n  function withdrawAsTheSignee(uint256 _id) external payable noReentrant{\n\t  require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    require(withdraw_signee[exactAgreement[_id].signee] > 0, \"There aren't any funds to withdraw\");\n\t  uint256 current_amount = withdraw_signee[exactAgreement[_id].signee];\n\t  withdraw_signee[exactAgreement[_id].signee] = 0;\n\t  (bool sent, ) = exactAgreement[_id].signee.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n\t  emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  function withdrawAsTheReceiver(uint256 _id) external payable noReentrant{\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    require(withdraw_receiver[exactAgreement[_id].receiver] > 0, \"There aren't any funds to withdraw\");\n    uint256 current_amount = withdraw_receiver[exactAgreement[_id].receiver];\n    withdraw_receiver[exactAgreement[_id].receiver] = 0;\n    (bool sent, ) = exactAgreement[_id].receiver.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n    emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  /// @notice Creating a new agreement\n  function createAgreement(\n    address payable _receiver, \n    uint256 _amount,\n    uint256 _everyTimeUnit,\n    uint256 _howLong,\n    uint256 _startOfTheAgreement\n    ) external payable {\n        require(_amount > 0 && _everyTimeUnit > 0 && _howLong > 0, \"All input data must be larger than 0\");\n        require(_howLong > _everyTimeUnit, \"The period of the payment is greater than the duration of the contract\");\n        require(msg.value >= _amount, \"Deposit has to be at least the size of the amount\");\n        require(_startOfTheAgreement >= block.timestamp, \"The agreement can't be created in the past\");\n        uint256 agreementId = numAgreement++;\n\n        //creating a new agreement\n        Agreement storage newAgreement = exactAgreement[agreementId];\n        newAgreement.id = agreementId;\n        newAgreement.signee = msg.sender;\n        newAgreement.receiver = _receiver;\n        newAgreement.amount = _amount;\n\n        //the amount that is actually deposited to the agreement. We initialize it with 0\n        newAgreement.deposit = msg.value;\n        //the status of the agreement when its created\n        newAgreement.status = \"Created\";\n        //initialize the approved term\n        newAgreement.approved = \"Not Confirmed\";\n        //when was the agreement created\n        newAgreement.agreementStartDate= _startOfTheAgreement;\n        //period of the payment\n        newAgreement.everyTimeUnit = _everyTimeUnit;\n        //position of the end of the period in which the signee has to send the money (for example: ...every 3 weeks... - this period needs to update itself)\n        newAgreement.positionPeriod = 0;\n        //how long will the agreement last\n        newAgreement.howLong = _howLong;\n        //storing the ids of the agreements and connecting them to msg.sender's address so we can display them to the frontend\n        mySenderAgreements[msg.sender].push(agreementId);\n        //storing the ids of the agreements and connecting them to _receiver's address so we can display them to the frontend\n        myReceiverAgreements[_receiver].push(agreementId);\n\n        emit AgreementInfo(\n          newAgreement.id, \n          newAgreement.signee, \n          newAgreement.receiver, \n          newAgreement.amount,\n          newAgreement.transactionCreated,\n          newAgreement.deposit, \n          newAgreement.status,\n          newAgreement.approved,\n          newAgreement.agreementStartDate, \n          newAgreement.everyTimeUnit, \n          newAgreement.positionPeriod, \n          newAgreement.howLong\n          ); \n  }\n\n  //function for the receiver - wether he agrees with the terms or not, approves the contract or not. If he does, we are able to activate it, otherwise we can't\n  function confirmAgreement(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\"))){\n\t\t  emit NotifyUser(\"The agreement is already confirmed\");\n\t  }else if(keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n      emit NotifyUser(\"The agreement is already terminated\");\n    }else{\n      require(exactAgreement[_id].receiver == msg.sender, \"Only the receiver can confirm the agreement\");\n      //cannot confirm an agreement that ends in the past\n      require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp, \"The agreement's deadline has ended\");\n      //confirm the agreement\n      exactAgreement[_id].approved = \"Confirmed\";\n      //emit that the agreement was confirmed\n      emit NotifyUser(\"The agreement was confirmed\");\n\t  }\n  }\n\n  /// @notice Terminating the agreement by the signee\n  function terminateContract(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n\t\t  emit NotifyUser(\"The agreement is already terminated\");\n\t  } else if (exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate< block.timestamp){\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the signee\n        withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n    } else {\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n\t  }\n  }\n\n  /// @notice Receiver checking if the contract has been breached\n  function wasContractBreached(uint256 _id) external {\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    //checking if the agreement was Activated\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //checking if the deadline was breached\n      if(timeWasntBreached(_id)){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      } \n    }else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n      if(exactAgreement[_id].agreementStartDate+ (6*60*60*24) > block.timestamp){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      }\n    } else {\n        emit NotifyUser(\"The agreement is already terminated\");\n    }\n  } \n\n  function getWithdrawalSignee(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    return withdraw_signee[exactAgreement[_id].signee];\n  }\n\n  function getWithdrawalReceiver(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    return withdraw_receiver[exactAgreement[_id].receiver];\n  }\n\n  fallback() external {}\n  receive() external payable {}\n\n}\n", "commit_id": "eeb2e3e8a760921f8c83cf127bfe94056473ed1e"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\n/// @title Implementing a legal contract: Person A commits sending X amount of ether to person B every Y days for Z days\n/// @author Farina Vito\ncontract AgreementBetweenSubjects {\n\n  /// @notice Defining the agreement \n  /// @param id A unique identifier of the agreement\n  /// @param signee The person who commits sending the the money to the receiver \n  /// @param receiver The person receiving the money\n  /// @param amount The quantity of money that the signee commits sending to the receiver\n  /// @param transactionCreated Unix timestamp when transaction was sent\n  /// @param deposit The agreed amount of the deposit by both sides for the contract. Initial state will be zero\n  /// @param status Representation of different stages in the agreement: Created, Activated, Terminated\n  /// @param approved Confirmation of the agreedDeposit by the receiver. Stages: Not Confirmed, Confirmed\n  /// @param agreementStartDateThe unix timestamp of the agreement's creation. FRONTEND\n  /// @param everyTimeUnit The number of days till when the signee's transaction has to be created. First calculated by agreementStartDate+ everyTimeUnit. Later just adding everyTimeUnit\n  /// @param positionPeriod A pointer to the current everyTimeUnit parameter\n  /// @param howLong The number of days till the agreement expires\n  struct Agreement{\n    uint256 id; \n    address signee;\n    address payable receiver; \n    uint256 amount;\n    uint256 transactionCreated;\n    uint256 deposit;\n    string status;\n    string approved;\n    uint256 agreementStartDate;\n    uint256 everyTimeUnit;\n    uint256 positionPeriod;\n    uint256 howLong;\n  }\n\n  uint16 internal locked = 1;\n\n  //doesn't allow reentrance attack\n  modifier noReentrant() {\n        require(locked == 1, \"No re-entrancy\");\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n   /// @dev Saving the money sent for the signee to withdraw it\n  mapping(address => uint256) private withdraw_signee;\n\n  /// @dev Saving the money sent for the receiver to withdraw it\n  mapping(address => uint256) private withdraw_receiver;\n\n  /// @dev A unique identifier of theagreement. The same as the id.\n  mapping(uint256 => Agreement) public exactAgreement;\n  /// @dev Used to increase the id of the agreements in the \"createAgreements\" function\n  uint numAgreement;\n\n  /// @dev Storing the id's of the agreements that the signee has created\n  mapping(address => uint[]) public mySenderAgreements;\n\n  /// @dev Storing the id's of the agreements of the same receiver address\n  mapping(address => uint[]) public myReceiverAgreements;\n\n  /// @notice Emitting agreement's info \n  event AgreementInfo(\n    uint256 agreementId,\n    address agreementSignee, \n    address agreementReceiver, \n    uint256 agreementAmount,\n    uint256 agreementTransactionCreated,\n    uint256 agreementDeposit,\n    string agreementStatus,\n    string agreementApproved,\n    uint256 agreementStartDate,\n    uint256 agreementTimePeriods,\n    uint256 agreementPositionPeriod,\n    uint256 agreementTimeDuration\n  );\n\n  /// @notice After the contract is terminated, emit an event with a message\n  event Terminated(string message);\n  /// @notice After other event than Terminated happens, emit it and send a message\n  event NotifyUser(string message);\n  \n\n  /// @notice Initializing the position from where the everyTimeUnit is added\n  function initializingPositionPeriod(uint256 _id) private {\n      exactAgreement[_id].positionPeriod = exactAgreement[_id].agreementStartDate+ (exactAgreement[_id].everyTimeUnit);\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline \n  function timeNotBreached(uint256 _id) private returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n        exactAgreement[_id].positionPeriod += exactAgreement[_id].everyTimeUnit;\n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline without incrementing positionPeriod\n  function timeWasntBreached(uint256 _id) private view returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Sending the payment based on the status of the agreement\n  function sendPayment(uint256 _id) external payable {\n    require(exactAgreement[_id].signee == msg.sender, \"Only the owner can pay the agreement's terms\");\n    //the agreement has to be confirmed from the receiver of the agreement\n    require(keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\")), \"The receiver has to confirm the contract\");\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //save the time of calling this function\n      exactAgreement[_id].transactionCreated = block.timestamp;\n      //if the transaction sent was on time and transaction was sent before the agreement's deadline\n      if (timeNotBreached(_id)){\n        if (exactAgreement[_id].amount <= msg.value){\n          //send the transaction to the receiver\n          withdraw_receiver[exactAgreement[_id].receiver] += msg.value;\n          emit NotifyUser(\"Transaction was sent to the receiver\");\n        //if the transaction was on time, but it wasn't enough\n        } else {\n            exactAgreement[_id].status = \"Terminated\"; \n            //sending the deposit to the receiver\n            withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n            //ensure that the deposit is reduced to 0\n            exactAgreement[_id].deposit = 0;\n            //return the transaction to the signee\n            withdraw_signee[exactAgreement[_id].signee] += msg.value;\n            emit Terminated(\"The agreement was terminated due to different amount sent than in the terms\");      \n        }\n      //if the transaction wasn't sent on time\n      } else {\n        exactAgreement[_id].status = \"Terminated\";\n        //sending the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        //return the transaction to the signee\n        withdraw_signee[exactAgreement[_id].signee] += msg.value;\n        emit Terminated(\"The agreement was terminated due to late payment\");\n      }\n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n        require(exactAgreement[_id].agreementStartDate<= block.timestamp, \"The agreement hasn't started yet\");\n        require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate> block.timestamp, \"The agreement's deadline has ended\");\n        require(exactAgreement[_id].amount <= msg.value, \"The deposit is not the same as agreed in the terms\");\n        exactAgreement[_id].status = \"Activated\";\n        //set the position period\n        initializingPositionPeriod(_id);\n        emit NotifyUser(\"The agreement has been activated\"); \n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n          //return the transaction to the signee\n          revert(\"The agreement is already terminated\");\n    } else {\n          //return the transaction to the signee\n          revert(\"There is no agreement with this id\");\n    }\n  }\n\n  function withdrawAsTheSignee(uint256 _id) external payable noReentrant{\n\t  require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    require(withdraw_signee[exactAgreement[_id].signee] > 0, \"There aren't any funds to withdraw\");\n\t  uint256 current_amount = withdraw_signee[exactAgreement[_id].signee];\n\t  withdraw_signee[exactAgreement[_id].signee] = 0;\n\t  (bool sent, ) = exactAgreement[_id].signee.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n\t  emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  function withdrawAsTheReceiver(uint256 _id) external payable noReentrant{\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    require(withdraw_receiver[exactAgreement[_id].receiver] > 0, \"There aren't any funds to withdraw\");\n    uint256 current_amount = withdraw_receiver[exactAgreement[_id].receiver];\n    withdraw_receiver[exactAgreement[_id].receiver] = 0;\n    (bool sent, ) = exactAgreement[_id].receiver.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n    emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  /// @notice Creating a new agreement\n  function createAgreement(\n    address payable _receiver, \n    uint256 _amount,\n    uint256 _everyTimeUnit,\n    uint256 _howLong,\n    uint256 _startOfTheAgreement\n    ) external payable {\n        require(_amount > 0 && _everyTimeUnit > 0 && _howLong > 0, \"All input data must be larger than 0\");\n        require(_howLong > _everyTimeUnit, \"The period of the payment is greater than the duration of the contract\");\n        require(msg.value >= _amount, \"Deposit has to be at least the size of the amount\");\n        require(_startOfTheAgreement >= block.timestamp, \"The agreement can't be created in the past\");\n        uint256 agreementId = numAgreement++;\n\n        //creating a new agreement\n        Agreement storage newAgreement = exactAgreement[agreementId];\n        newAgreement.id = agreementId;\n        newAgreement.signee = msg.sender;\n        newAgreement.receiver = _receiver;\n        newAgreement.amount = _amount;\n\n        //the amount that is actually deposited to the agreement. We initialize it with 0\n        newAgreement.deposit = msg.value;\n        //the status of the agreement when its created\n        newAgreement.status = \"Created\";\n        //initialize the approved term\n        newAgreement.approved = \"Not Confirmed\";\n        //when was the agreement created\n        newAgreement.agreementStartDate= _startOfTheAgreement;\n        //period of the payment\n        newAgreement.everyTimeUnit = _everyTimeUnit;\n        //position of the end of the period in which the signee has to send the money (for example: ...every 3 weeks... - this period needs to update itself)\n        newAgreement.positionPeriod = 0;\n        //how long will the agreement last\n        newAgreement.howLong = _howLong;\n        //storing the ids of the agreements and connecting them to msg.sender's address so we can display them to the frontend\n        mySenderAgreements[msg.sender].push(agreementId);\n        //storing the ids of the agreements and connecting them to _receiver's address so we can display them to the frontend\n        myReceiverAgreements[_receiver].push(agreementId);\n\n        emit AgreementInfo(\n          newAgreement.id, \n          newAgreement.signee, \n          newAgreement.receiver, \n          newAgreement.amount,\n          newAgreement.transactionCreated,\n          newAgreement.deposit, \n          newAgreement.status,\n          newAgreement.approved,\n          newAgreement.agreementStartDate, \n          newAgreement.everyTimeUnit, \n          newAgreement.positionPeriod, \n          newAgreement.howLong\n          ); \n  }\n\n  //function for the receiver - wether he agrees with the terms or not, approves the contract or not. If he does, we are able to activate it, otherwise we can't\n  function confirmAgreement(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\"))){\n\t\t  emit NotifyUser(\"The agreement is already confirmed\");\n\t  }else if(keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n      emit NotifyUser(\"The agreement is already terminated\");\n    }else{\n      require(exactAgreement[_id].receiver == msg.sender, \"Only the receiver can confirm the agreement\");\n      //cannot confirm an agreement that ends in the past\n      require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp, \"The agreement's deadline has ended\");\n      //confirm the agreement\n      exactAgreement[_id].approved = \"Confirmed\";\n      //emit that the agreement was confirmed\n      emit NotifyUser(\"The agreement was confirmed\");\n\t  }\n  }\n\n  /// @notice Terminating the agreement by the signee\n  function terminateContract(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n\t\t  emit NotifyUser(\"The agreement is already terminated\");\n\t  } else if (exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate< block.timestamp){\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the signee\n        withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n    } else {\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n\t  }\n  }\n\n  /// @notice Receiver checking if the contract has been breached\n  function wasContractBreached(uint256 _id) external {\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    //checking if the agreement was Activated\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //checking if the deadline was breached\n      if(timeWasntBreached(_id)){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      } \n    }else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n      if(exactAgreement[_id].agreementStartDate+ (6*60*60*24) > block.timestamp){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      }\n    } else {\n        emit NotifyUser(\"The agreement is already terminated\");\n    }\n  } \n\n  function getWithdrawalSignee(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    return withdraw_signee[exactAgreement[_id].signee];\n  }\n\n  function getWithdrawalReceiver(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    return withdraw_receiver[exactAgreement[_id].receiver];\n  }\n\n  fallback() external {}\n  receive() external payable {}\n\n}", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n/// @title Implementing a legal contract: Person A commits sending X amount of ether to person B every Y days for Z days\n/// @author Farina Vito\ncontract AgreementBetweenSubjects {\n\n  /// @notice Defining the agreement \n  /// @param id A unique identifier of the agreement\n  /// @param signee The person who commits sending the the money to the receiver \n  /// @param receiver The person receiving the money\n  /// @param amount The quantity of money that the signee commits sending to the receiver\n  /// @param transactionCreated Unix timestamp when transaction was sent\n  /// @param deposit The agreed amount of the deposit by both sides for the contract. Initial state will be zero\n  /// @param status Representation of different stages in the agreement: Created, Activated, Terminated\n  /// @param approved Confirmation of the agreedDeposit by the receiver. Stages: Not Confirmed, Confirmed\n  /// @param agreementStartDateThe unix timestamp of the agreement's creation. FRONTEND\n  /// @param everyTimeUnit The number of days till when the signee's transaction has to be created. First calculated by agreementStartDate+ everyTimeUnit. Later just adding everyTimeUnit\n  /// @param positionPeriod A pointer to the current everyTimeUnit parameter\n  /// @param howLong The number of days till the agreement expires\n  struct Agreement{\n    uint256 id; \n    address signee;\n    address payable receiver; \n    uint256 amount;\n    uint256 transactionCreated;\n    uint256 deposit;\n    string status;\n    string approved;\n    uint256 agreementStartDate;\n    uint256 everyTimeUnit;\n    uint256 positionPeriod;\n    uint256 howLong;\n  }\n\n  uint16 internal locked = 1;\n\n  //doesn't allow reentrance attack\n  modifier noReentrant() {\n        require(locked == 1, \"No re-entrancy\");\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n   /// @dev Saving the money sent for the signee to withdraw it\n  mapping(address => uint256) private withdraw_signee;\n\n  /// @dev Saving the money sent for the receiver to withdraw it\n  mapping(address => uint256) private withdraw_receiver;\n\n  /// @dev A unique identifier of theagreement. The same as the id.\n  mapping(uint256 => Agreement) public exactAgreement;\n  /// @dev Used to increase the id of the agreements in the \"createAgreements\" function\n  uint numAgreement;\n\n  /// @dev Storing the id's of the agreements that the signee has created\n  mapping(address => uint[]) public mySenderAgreements;\n\n  /// @dev Storing the id's of the agreements of the same receiver address\n  mapping(address => uint[]) public myReceiverAgreements;\n\n  /// @notice Emitting agreement's info \n  event AgreementInfo(\n    uint256 agreementId,\n    address agreementSignee, \n    address agreementReceiver, \n    uint256 agreementAmount,\n    uint256 agreementTransactionCreated,\n    uint256 agreementDeposit,\n    string agreementStatus,\n    string agreementApproved,\n    uint256 agreementStartDate,\n    uint256 agreementTimePeriods,\n    uint256 agreementPositionPeriod,\n    uint256 agreementTimeDuration\n  );\n\n  /// @notice After the contract is terminated, emit an event with a message\n  event Terminated(string message);\n  /// @notice After other event than Terminated happens, emit it and send a message\n  event NotifyUser(string message);\n  \n\n  /// @notice Initializing the position from where the everyTimeUnit is added\n  function initializingPositionPeriod(uint256 _id) private {\n      exactAgreement[_id].positionPeriod = exactAgreement[_id].agreementStartDate+ (exactAgreement[_id].everyTimeUnit);\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline \n  function timeNotBreached(uint256 _id) private returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n        exactAgreement[_id].positionPeriod += exactAgreement[_id].everyTimeUnit;\n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Verifying that the transaction created was sooner than its deadline without incrementing positionPeriod\n  function timeWasntBreached(uint256 _id) private view returns(bool){\n      //period till when we have to receive the transaction\n      uint256 extendedPeriod = exactAgreement[_id].positionPeriod + (6*60*60*24);\n      //if the transaction sent was on time, transaction was received on time and transaction was sent before the agreement's deadline\n\t    if (exactAgreement[_id].positionPeriod  >= exactAgreement[_id].transactionCreated && extendedPeriod >= block.timestamp && exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp){ \n\t\t    return true;\n\t    } else{\n\t\t    return false;\n\t    }\n    }\n\n  /// @notice Sending the payment based on the status of the agreement\n  function sendPayment(uint256 _id) external payable {\n    require(exactAgreement[_id].signee == msg.sender, \"Only the owner can pay the agreement's terms\");\n    //the agreement has to be confirmed from the receiver of the agreement\n    require(keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\")), \"The receiver has to confirm the contract\");\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //save the time of calling this function\n      exactAgreement[_id].transactionCreated = block.timestamp;\n      //if the transaction sent was on time and transaction was sent before the agreement's deadline\n      if (timeNotBreached(_id)){\n        if (exactAgreement[_id].amount <= msg.value){\n          //send the transaction to the receiver\n          withdraw_receiver[exactAgreement[_id].receiver] += msg.value;\n          emit NotifyUser(\"Transaction was sent to the receiver\");\n        //if the transaction was on time, but it wasn't enough\n        } else {\n            exactAgreement[_id].status = \"Terminated\"; \n            //sending the deposit to the receiver\n            withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n            //ensure that the deposit is reduced to 0\n            exactAgreement[_id].deposit = 0;\n            //return the transaction to the signee\n            withdraw_signee[exactAgreement[_id].signee] += msg.value;\n            emit Terminated(\"The agreement was terminated due to different amount sent than in the terms\");      \n        }\n      //if the transaction wasn't sent on time\n      } else {\n        exactAgreement[_id].status = \"Terminated\";\n        //sending the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        //return the transaction to the signee\n        withdraw_signee[exactAgreement[_id].signee] += msg.value;\n        emit Terminated(\"The agreement was terminated due to late payment\");\n      }\n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n        require(exactAgreement[_id].agreementStartDate<= block.timestamp, \"The agreement hasn't started yet\");\n        require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate> block.timestamp, \"The agreement's deadline has ended\");\n        require(exactAgreement[_id].amount <= msg.value, \"The deposit is not the same as agreed in the terms\");\n        exactAgreement[_id].status = \"Activated\";\n        //set the position period\n        initializingPositionPeriod(_id);\n        emit NotifyUser(\"The agreement has been activated\"); \n    } else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n          //return the transaction to the signee\n          revert(\"The agreement is already terminated\");\n    } else {\n          //return the transaction to the signee\n          revert(\"There is no agreement with this id\");\n    }\n  }\n\n  function withdrawAsTheSignee(uint256 _id) external payable noReentrant{\n\t  require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    require(withdraw_signee[exactAgreement[_id].signee] > 0, \"There aren't any funds to withdraw\");\n\t  uint256 current_amount = withdraw_signee[exactAgreement[_id].signee];\n\t  withdraw_signee[exactAgreement[_id].signee] = 0;\n\t  (bool sent, ) = exactAgreement[_id].signee.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n\t  emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  function withdrawAsTheReceiver(uint256 _id) external payable noReentrant{\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    require(withdraw_receiver[exactAgreement[_id].receiver] > 0, \"There aren't any funds to withdraw\");\n    uint256 current_amount = withdraw_receiver[exactAgreement[_id].receiver];\n    withdraw_receiver[exactAgreement[_id].receiver] = 0;\n    (bool sent, ) = exactAgreement[_id].receiver.call{value: current_amount}(\"\");\n    require(sent, \"Failed to send Ether\");\n    emit NotifyUser(\"Withdrawal has been transfered\");\n  }\n\n  /// @notice Creating a new agreement\n  function createAgreement(\n    address payable _receiver, \n    uint256 _amount,\n    uint256 _everyTimeUnit,\n    uint256 _howLong,\n    uint256 _startOfTheAgreement\n    ) external payable {\n        require(_amount > 0 && _everyTimeUnit > 0 && _howLong > 0, \"All input data must be larger than 0\");\n        require(_howLong > _everyTimeUnit, \"The period of the payment is greater than the duration of the contract\");\n        require(msg.value >= _amount, \"Deposit has to be at least the size of the amount\");\n        require(_startOfTheAgreement >= block.timestamp, \"The agreement can't be created in the past\");\n        uint256 agreementId = numAgreement++;\n\n        //creating a new agreement\n        Agreement storage newAgreement = exactAgreement[agreementId];\n        newAgreement.id = agreementId;\n        newAgreement.signee = msg.sender;\n        newAgreement.receiver = _receiver;\n        newAgreement.amount = _amount;\n\n        //the amount that is actually deposited to the agreement. We initialize it with 0\n        newAgreement.deposit = msg.value;\n        //the status of the agreement when its created\n        newAgreement.status = \"Created\";\n        //initialize the approved term\n        newAgreement.approved = \"Not Confirmed\";\n        //when was the agreement created\n        newAgreement.agreementStartDate= _startOfTheAgreement;\n        //period of the payment\n        newAgreement.everyTimeUnit = _everyTimeUnit;\n        //position of the end of the period in which the signee has to send the money (for example: ...every 3 weeks... - this period needs to update itself)\n        newAgreement.positionPeriod = 0;\n        //how long will the agreement last\n        newAgreement.howLong = _howLong;\n        //storing the ids of the agreements and connecting them to msg.sender's address so we can display them to the frontend\n        mySenderAgreements[msg.sender].push(agreementId);\n        //storing the ids of the agreements and connecting them to _receiver's address so we can display them to the frontend\n        myReceiverAgreements[_receiver].push(agreementId);\n\n        emit AgreementInfo(\n          newAgreement.id, \n          newAgreement.signee, \n          newAgreement.receiver, \n          newAgreement.amount,\n          newAgreement.transactionCreated,\n          newAgreement.deposit, \n          newAgreement.status,\n          newAgreement.approved,\n          newAgreement.agreementStartDate, \n          newAgreement.everyTimeUnit, \n          newAgreement.positionPeriod, \n          newAgreement.howLong\n          ); \n  }\n\n  //function for the receiver - wether he agrees with the terms or not, approves the contract or not. If he does, we are able to activate it, otherwise we can't\n  function confirmAgreement(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].approved)) == keccak256(bytes(\"Confirmed\"))){\n\t\t  emit NotifyUser(\"The agreement is already confirmed\");\n\t  }else if(keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n      emit NotifyUser(\"The agreement is already terminated\");\n    }else{\n      require(exactAgreement[_id].receiver == msg.sender, \"Only the receiver can confirm the agreement\");\n      //cannot confirm an agreement that ends in the past\n      require(exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate>= block.timestamp, \"The agreement's deadline has ended\");\n      //confirm the agreement\n      exactAgreement[_id].approved = \"Confirmed\";\n      //emit that the agreement was confirmed\n      emit NotifyUser(\"The agreement was confirmed\");\n\t  }\n  }\n\n  /// @notice Terminating the agreement by the signee\n  function terminateContract(uint256 _id) external {\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Terminated\"))){\n\t\t  emit NotifyUser(\"The agreement is already terminated\");\n\t  } else if (exactAgreement[_id].howLong + exactAgreement[_id].agreementStartDate< block.timestamp){\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the signee\n        withdraw_signee[exactAgreement[_id].signee] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n    } else {\n        require(exactAgreement[_id].signee == msg.sender, \"Only the owner can terminate the agreement\");\n        exactAgreement[_id].status = \"Terminated\";\n        //return the deposit to the receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n\t  }\n  }\n\n  /// @notice Receiver checking if the contract has been breached\n  function wasContractBreached(uint256 _id) external {\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    //checking if the agreement was Activated\n    if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Activated\"))){\n      //checking if the deadline was breached\n      if(timeWasntBreached(_id)){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      } \n    }else if (keccak256(bytes(exactAgreement[_id].status)) == keccak256(bytes(\"Created\"))){\n      if(exactAgreement[_id].agreementStartDate+ (6*60*60*24) > block.timestamp){\n        emit NotifyUser(\"The agreement wasn't breached\");\n      } else {\n        //receiver has to wait 7 days after the breached date to withdraw the deposit\n        require(exactAgreement[_id].positionPeriod + (60*60*24*7) < block.timestamp, \"You can't withdraw the deposit before 7 days after breached deadline\");\n        //terminate the agreement\n        exactAgreement[_id].status = \"Terminated\";\n        //return deposit to receiver\n        withdraw_receiver[exactAgreement[_id].receiver] += exactAgreement[_id].deposit;\n        //ensure that the deposit is reduced to 0\n        exactAgreement[_id].deposit = 0;\n        emit Terminated(\"The agreement has been terminated\");\n      }\n    } else {\n        emit NotifyUser(\"The agreement is already terminated\");\n    }\n  } \n\n  function getWithdrawalSignee(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].signee == msg.sender, \"Your logged in address isn't the same as the agreement's signee\");\n    return withdraw_signee[exactAgreement[_id].signee];\n  }\n\n  function getWithdrawalReceiver(uint256 _id) external view returns(uint256){\n    require(exactAgreement[_id].receiver == msg.sender, \"Your logged in address isn't the same as the agreement's receiver\");\n    return withdraw_receiver[exactAgreement[_id].receiver];\n  }\n\n  fallback() external {}\n  receive() external payable {}\n\n}\n", "commit_id": "193f3b272296c533b1708fc17296c36b920cacb4"}}