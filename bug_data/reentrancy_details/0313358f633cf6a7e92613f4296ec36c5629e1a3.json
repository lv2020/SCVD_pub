{"filename": "contracts/core/DaoRegistry.sol", "patch": "@@ -110,6 +110,7 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n     struct ExtensionEntry {\n         bytes32 id;\n         mapping(address => uint256) acl;\n+        bool deleted;\n     }\n \n     /*\n@@ -147,8 +148,7 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n     uint256 public lockedAt;\n \n     /// @notice Clonable contract must have an empty constructor\n-    // constructor() {\n-    // }\n+    constructor() {}\n \n     /**\n      * @notice Initialises the DAO\n@@ -157,13 +157,13 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n      * @param creator The DAO's creator, who will be an initial member\n      * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n      */\n+    //slither-disable-next-line reentrancy-no-eth\n     function initialize(address creator, address payer) external {\n         require(!initialized, \"dao already initialized\");\n+        initialized = true;\n         potentialNewMember(msg.sender);\n         potentialNewMember(payer);\n         potentialNewMember(creator);\n-\n-        initialized = true;\n     }\n \n     /**\n@@ -182,12 +182,18 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         state = DaoState.READY;\n     }\n \n+    /**\n+     * @notice Contract lock strategy to lock only the caller is an adapter or extension.\n+     */\n     function lockSession() external {\n         if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n             lockedAt = block.number;\n         }\n     }\n \n+    /**\n+     * @notice Contract lock strategy to release the lock only the caller is an adapter or extension.\n+     */\n     function unlockSession() external {\n         if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n             lockedAt = 0;\n@@ -209,6 +215,10 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         emit ConfigurationUpdated(key, value);\n     }\n \n+    /**\n+     * @notice Registers a member address in the DAO if it is not registered or invalid.\n+     * @notice A potential new member is a member that holds no shares, and its registration still needs to be voted on.\n+     */\n     function potentialNewMember(address memberAddress)\n         public\n         hasAccess(this, AclFlag.NEW_MEMBER)\n@@ -275,27 +285,8 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n     }\n \n     /**\n-     * @notice Adds a new extension to the registry\n-     * @param extensionId The unique identifier of the new extension\n-     * @param extension The address of the extension\n-     * @param creator The DAO's creator, who will be an initial member\n+     * @notice It sets the ACL flags to an Adapter to make it possible to access specific functions of an Extension.\n      */\n-    function addExtension(\n-        bytes32 extensionId,\n-        IExtension extension,\n-        address creator\n-    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n-        require(extensionId != bytes32(0), \"extension id must not be empty\");\n-        require(\n-            extensions[extensionId] == address(0x0),\n-            \"extension Id already in use\"\n-        );\n-        extensions[extensionId] = address(extension);\n-        inverseExtensions[address(extension)].id = extensionId;\n-        extension.initialize(this, creator);\n-        emit ExtensionAdded(extensionId, address(extension));\n-    }\n-\n     function setAclToExtensionForAdapter(\n         address extensionAddress,\n         address adapterAddress,\n@@ -352,6 +343,32 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         }\n     }\n \n+    /**\n+     * @notice Adds a new extension to the registry\n+     * @param extensionId The unique identifier of the new extension\n+     * @param extension The address of the extension\n+     * @param creator The DAO's creator, who will be an initial member\n+     */\n+    function addExtension(\n+        bytes32 extensionId,\n+        IExtension extension,\n+        address creator\n+    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n+        require(extensionId != bytes32(0), \"extension id must not be empty\");\n+        require(\n+            extensions[extensionId] == address(0x0),\n+            \"extension Id already in use\"\n+        );\n+        require(\n+            !inverseExtensions[address(extension)].deleted,\n+            \"extension can not be re-added\"\n+        );\n+        extensions[extensionId] = address(extension);\n+        inverseExtensions[address(extension)].id = extensionId;\n+        extension.initialize(this, creator);\n+        emit ExtensionAdded(extensionId, address(extension));\n+    }\n+\n     /**\n      * @notice Removes an adapter from the registry\n      * @param extensionId The unique identifier of the extension\n@@ -361,11 +378,12 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         hasAccess(this, AclFlag.REMOVE_EXTENSION)\n     {\n         require(extensionId != bytes32(0), \"extensionId must not be empty\");\n-        require(\n-            extensions[extensionId] != address(0x0),\n-            \"extensionId not registered\"\n-        );\n-        delete inverseExtensions[extensions[extensionId]];\n+        address extensionAddress = extensions[extensionId];\n+        require(extensionAddress != address(0x0), \"extensionId not registered\");\n+        ExtensionEntry storage extEntry = inverseExtensions[extensionAddress];\n+        extEntry.deleted = true;\n+        //slither-disable-next-line mapping-deletion\n+        delete inverseExtensions[extensionAddress];\n         delete extensions[extensionId];\n         emit ExtensionRemoved(extensionId);\n     }", "project_link": "https://github.com/openlawteam/tribute-contracts/commit/38e0cb233175605eaddd4f948ed21cf533d99792", "solc_version": "0.5.0", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "0313358f633cf6a7e92613f4296ec36c5629e1a3"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "38e0cb233175605eaddd4f948ed21cf533d99792"}}