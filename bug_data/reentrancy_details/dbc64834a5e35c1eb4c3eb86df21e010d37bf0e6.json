{"filename": "contracts/2key/singleton-contracts/TwoKeyUpgradableExchange.sol", "patch": "@@ -330,8 +330,6 @@ contract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n \n         uint stableCoinsAfter = stableCoinsOnContractBefore - stableCoinUnits;\n \n-        dai.transfer(_beneficiary, stableCoinUnits);\n-\n         emitEventWithdrawExecuted(\n             _beneficiary,\n             stableCoinsOnContractBefore,\n@@ -340,6 +338,8 @@ contract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n             stableCoinUnits,\n             _twoKeyUnits\n         );\n+\n+        dai.transfer(_beneficiary, stableCoinUnits);\n     }\n \n     /**", "project_link": "https://github.com/2key/contracts/commit/54ca1a4aa89acd54d958ebf650b55b0c1cdca02a", "bug_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport \"../../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/ITwoKeyExchangeRateContract.sol\";\nimport \"../interfaces/ITwoKeyCampaignValidator.sol\";\nimport \"../interfaces/IKyberNetworkProxy.sol\";\nimport \"../interfaces/storage-contracts/ITwoKeyUpgradableExchangeStorage.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/GetCode.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"../upgradability/Upgradeable.sol\";\nimport \"./ITwoKeySingletonUtils.sol\";\n\n\ncontract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    bool initialized;\n\n    ITwoKeyUpgradableExchangeStorage public PROXY_STORAGE_CONTRACT;\n\n\n    /**\n     * @notice Event will be fired every time someone buys tokens\n     */\n    event TokenSell(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param receiver is who got the tokens\n     * @param weiReceived is how weis paid for purchase\n     * @param tokensBought is the amount of tokens purchased\n     * @param rate is the global variable rate on the contract\n     */\n    event TokenPurchase(\n        address indexed purchaser,\n        address indexed receiver,\n        uint256 weiReceived,\n        uint256 tokensBought,\n        uint256 rate\n    );\n\n\n    /**\n     * @notice This event will be fired every time a withdraw is executed\n     */\n    event WithdrawExecuted(\n        address caller,\n        address beneficiary,\n        uint stableCoinsReserveBefore,\n        uint stableCoinsReserveAfter,\n        uint etherBalanceBefore,\n        uint etherBalanceAfter,\n        uint stableCoinsToWithdraw,\n        uint twoKeyAmount\n    );\n\n\n    /**\n     * @notice Constructor of the contract, can be called only once\n     * @param _token is ERC20 2key token\n     * @param _daiAddress is the address of DAI on ropsten\n     * @param _kyberNetworkProxy is the address of Kyber network contract\n     * @param _twoKeySingletonesRegistry is the address of TWO_KEY_SINGLETON_REGISTRY\n     * @param _proxyStorageContract is the address of proxy of storage contract\n     */\n    function setInitialParams(\n        ERC20 _token,\n        address _daiAddress,\n        address _kyberNetworkProxy,\n        address _twoKeySingletonesRegistry,\n        address _proxyStorageContract\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyUpgradableExchangeStorage(_proxyStorageContract);\n\n        setUint((\"buyRate2key\"),95);// When anyone send 2key to contract, 2key in exchange will be calculated on it's buy rate\n        setUint((\"sellRate2key\"),100);// When anyone send Ether to contract, 2key in exchange will be calculated on it's sell rate\n        setUint((\"weiRaised\"),0);\n        setUint(\"transactionCounter\",0);\n\n        setAddress((\"TWO_KEY_TOKEN\"),address(_token));\n        setAddress((\"DAI\"), _daiAddress);\n        setAddress((\"ETH_TOKEN_ADDRESS\"), 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n        setAddress((\"KYBER_NETWORK_PROXY\"), _kyberNetworkProxy);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice Modifier which will validate if contract is allowed to buy tokens\n     */\n    modifier onlyValidatedContracts {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(\"TwoKeyCampaignValidator\");\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * @param _beneficiary Address performing the token purchase\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(\n        address _beneficiary,\n        uint256 _weiAmount\n    )\n    private\n    {\n        require(_beneficiary != address(0),'beneficiary address can not be 0' );\n        require(_weiAmount != 0, 'wei amount can not be 0');\n    }\n\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        //Take the address of token from storage\n        address tokenAddress = getAddress(\"TWO_KEY_TOKEN\");\n\n        ERC20(tokenAddress).safeTransfer(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n     * @param _beneficiary Address receiving the tokens\n     * @param _tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getTokenAmountToBeSold(\n        uint256 _weiAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD\");\n        return (_weiAmount*rate).mul(1000).div(getUint(\"sellRate2key\")).div(10**18);\n    }\n\n\n    /**\n     * @notice Function to calculate how many stable coins we can get for specific amount of 2keys\n     * @dev This is happening in case we're receiving (buying) 2key\n     * @param _2keyAmount is the amount of 2keys sent to the contract\n     */\n    function _getUSDStableCoinAmountFrom2keyUnits(\n        uint256 _2keyAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        // Take the address of TwoKeyExchangeRateContract\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        // This is the case when we buy 2keys in exchange for stable coins\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD-DAI\"); // 1.01\n        uint lowestAcceptedRate = 96;\n        require(rate >= lowestAcceptedRate.mul(10**18).div(100)); // Require that lowest accepted rate is greater than 0.95\n\n        uint buyRate2key = getUint(\"buyRate2key\");\n\n        uint dollarWeiWorthTokens = _2keyAmount.mul(buyRate2key).div(1000);  // 100*95/1000 = 9.5\n        uint amountOfDAIs = dollarWeiWorthTokens.mul(rate).div(10**18);      // 9.5 * 1.01 =vOK\n\n        return amountOfDAIs;\n    }\n\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds(\n        address _twoKeyAdmin\n    )\n    internal\n    {\n        _twoKeyAdmin.transfer(msg.value);\n    }\n\n\n    /**\n     * @notice Function to buyTokens\n     * @param _beneficiary to get\n     * @return amount of tokens bought\n     */\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    onlyValidatedContracts\n    returns (uint)\n    {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(_beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmountToBeSold(weiAmount);\n\n        // update state\n        uint weiRaised = getUint(\"weiRaised\").add(weiAmount);\n        setUint(\"weiRaised\",weiRaised);\n        setUint(\"transactionCounter\",getUint(\"transactionCounter\")+1);\n\n        _processPurchase(_beneficiary, tokens);\n\n\n        emit TokenPurchase(\n            msg.sender,\n            _beneficiary,\n            weiAmount,\n            tokens,\n            getUint(\"sellRate2key\")\n        );\n\n        return tokens;\n    }\n\n\n    /**\n     * @notice Function to get expected rate from Kyber contract\n     * @param amountEthWei is the amount we'd like to exchange\n     * @return if the value is 0 that means we can't\n     */\n    function getKyberExpectedRate(\n        uint amountEthWei\n    )\n    public\n    view\n    returns (uint)\n    {\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        ERC20 eth = ERC20(getAddress(\"ETH_TOKEN_ADDRESS\"));\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        uint minConversionRate;\n        (minConversionRate,) = proxyContract.getExpectedRate(eth, dai, amountEthWei);\n\n        return minConversionRate;\n    }\n\n\n    /**\n     * @notice Function to start hedging some ether amount\n     * @param amountToBeHedged is the amount we'd like to hedge\n     * @dev only maintainer can call this function\n     */\n    function startHedging(\n        uint amountToBeHedged,\n        uint approvedMinConversionRate\n    )\n    public\n    onlyMaintainer\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        uint minConversionRate = getKyberExpectedRate(amountToBeHedged);\n        require(minConversionRate >= approvedMinConversionRate.mul(95).div(100)); //Means our rate can be at most same as their rate, because they're giving the best rate\n        uint stableCoinUnits = proxyContract.swapEtherToToken.value(amountToBeHedged)(dai,minConversionRate);\n    }\n\n    /**\n     * @notice Function which will be called by 2key campaigns if user wants to withdraw his earnings in stableCoins\n     * @param _twoKeyUnits is the amount of 2key tokens which will be taken from campaign\n     * @param _beneficiary is the user who will receive the tokens\n     */\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    external\n    onlyValidatedContracts\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n        ERC20 token = ERC20(getAddress(\"TWO_KEY_TOKEN\"));\n\n        uint stableCoinUnits = _getUSDStableCoinAmountFrom2keyUnits(_twoKeyUnits);\n        uint etherBalanceOnContractBefore = this.balance;\n        uint stableCoinsOnContractBefore = dai.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), _twoKeyUnits);\n\n        uint stableCoinsAfter = stableCoinsOnContractBefore - stableCoinUnits;\n\n        dai.transfer(_beneficiary, stableCoinUnits);\n\n        emitEventWithdrawExecuted(\n            _beneficiary,\n            stableCoinsOnContractBefore,\n            stableCoinsAfter,\n            etherBalanceOnContractBefore,\n            stableCoinUnits,\n            _twoKeyUnits\n        );\n    }\n\n    /**\n     * @notice Function to emit an event, created separately because of stack depth\n     */\n    function emitEventWithdrawExecuted(\n        address _beneficiary,\n        uint _stableCoinsOnContractBefore,\n        uint _stableCoinsAfter,\n        uint _etherBalanceOnContractBefore,\n        uint _stableCoinUnits,\n        uint twoKeyUnits\n    )\n    internal\n    {\n        emit WithdrawExecuted(\n            msg.sender,\n            _beneficiary,\n            _stableCoinsOnContractBefore,\n            _stableCoinsAfter,\n            _etherBalanceOnContractBefore,\n            this.balance,\n            _stableCoinUnits,\n            twoKeyUnits\n        );\n    }\n\n    /**\n     * @notice Getter for 2key buy rate\n     */\n    function buyRate2key() public view returns (uint) {\n        return getUint(\"buyRate2key\");\n    }\n\n    /**\n     * @notice Getter for 2key sell rate\n     */\n    function sellRate2key() public view returns (uint) {\n        return getUint(\"sellRate2key\");\n    }\n\n    /**\n     * @notice Getter for transactionCounter\n     */\n    function transactionCounter() public view returns (uint) {\n        return getUint(\"transactionCounter\");\n    }\n\n    /**\n     * @notice Getter for weiRaised\n     */\n    function weiRaised() public view returns (uint) {\n        return getUint(\"weiRaised\");\n    }\n\n    // Internal wrapper methods\n    function getUint(string key) internal view returns (uint) {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setUint(string key, uint value) internal {\n        PROXY_STORAGE_CONTRACT.setUint(keccak256(key), value);\n    }\n\n\n    // Internal wrapper methods\n    function getAddress(string key) internal view returns (address) {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setAddress(string key, address value) internal {\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(key), value);\n    }\n\n    /**\n     * @notice Function where maintainer can update any unassigned integer value\n     */\n    function updateUint(\n        string key,\n        uint value\n    )\n    public\n    onlyMaintainer\n    {\n        setUint(key, value);\n    }\n\n    /**\n     * @notice Withdraw all ether from contract\n     */\n    function withdrawEther()\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        _forwardFunds(twoKeyAdmin);\n    }\n\n\n    /**\n     * @notice Function to withdraw any ERC20 tokens to TwoKeyAdmin\n     */\n    function withdrawERC20(\n        address _erc20TokenAddress,\n        uint _tokenAmount\n    )\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        ERC20(_erc20TokenAddress).safeTransfer(twoKeyAdmin, _tokenAmount);\n\n    }\n\n    /**\n     * @notice Fallback function to handle incoming ether\n     */\n    function ()\n    public\n    payable\n    {\n\n    }\n\n}\n", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  function allowance(address _ocwner, address _spender) public view returns (uint256);\n  function approve(address spender, uint tokens) public returns (bool success);\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\n}\n\npragma solidity ^0.4.24;\n\n/**\n * @author Nikola Madjarevic\n */\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n}\npragma solidity ^0.4.24;\n/**y\n * @author Nikola Madjarevic\n * Created at 2/12/19\n */\ncontract ITwoKeyCampaignValidator {\n    function isCampaignValidated(address campaign) public view returns (bool);\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(\n    ERC20Basic _token,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transfer(_to, _value));\n  }\n\n  function safeTransferFrom(\n    ERC20 _token,\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transferFrom(_from, _to, _value));\n  }\n\n  function safeApprove(\n    ERC20 _token,\n    address _spender,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.approve(_spender, _value));\n  }\n}\n\ncontract IKyberNetworkProxy {\n    function swapEtherToToken(\n        ERC20 token,\n        uint minConversionRate\n    )\n    public\n    payable\n    returns(uint);\n\n    function getExpectedRate(\n        ERC20 src,\n        ERC20 dest,\n        uint srcQty\n    )\n    public\n    view\n    returns (uint expectedRate, uint slippageRate);\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyUpgradableExchangeStorage is IStructuredStorage{\n\n}\npragma solidity ^0.4.24;\n\n/// Interface of ERC20 contract we need in order to invoke balanceOf method from another contracts\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\npragma solidity ^0.4.24;\n\n/// The following example provides library code to access the code of another contract and load it into a bytes variable.\n/// This is not possible at all with \u201cplain Solidity\" and the idea is that assembly libraries will be used to enhance the\n/// language in such ways.\n\n/// Took from Solidity official documentation\n/// https://solidity.readthedocs.io/en/latest/assembly.html?highlight=getCode\nlibrary GetCode {\n    function at(address _addr) internal view returns (bytes o_code) {\n        assembly {\n        // retrieve the size of the code, this needs assembly\n            let size := extcodesize(_addr)\n        // allocate output byte array - this could also be done without assembly\n        // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n        // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n        // store length in memory\n            mstore(o_code, size)\n        // actually retrieve the code, this needs assembly\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n        }\n    }\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n/**\n * @title IRegistry\n * @dev This contract represents the interface of a registry contract\n */\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    */\n    event VersionAdded(string version, address implementation);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\n/**\n * @author Nikola Madjarevic\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\n */\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n/**\n * @author Nikola Madjarevic\n * Created at 2/7/19\n */\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestContractVersion(string contractName) public view returns (string);\n}\npragma solidity ^0.4.24;\n\ncontract ITwoKeyMaintainersRegistry {\n    function onlyMaintainer(address _sender) public view returns (bool);\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n        .getContractProxyAddress(contractName);\n    }\n}\n\n\ncontract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    bool initialized;\n\n    ITwoKeyUpgradableExchangeStorage public PROXY_STORAGE_CONTRACT;\n\n\n    /**\n     * @notice Event will be fired every time someone buys tokens\n     */\n    event TokenSell(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param receiver is who got the tokens\n     * @param weiReceived is how weis paid for purchase\n     * @param tokensBought is the amount of tokens purchased\n     * @param rate is the global variable rate on the contract\n     */\n    event TokenPurchase(\n        address indexed purchaser,\n        address indexed receiver,\n        uint256 weiReceived,\n        uint256 tokensBought,\n        uint256 rate\n    );\n\n\n    /**\n     * @notice This event will be fired every time a withdraw is executed\n     */\n    event WithdrawExecuted(\n        address caller,\n        address beneficiary,\n        uint stableCoinsReserveBefore,\n        uint stableCoinsReserveAfter,\n        uint etherBalanceBefore,\n        uint etherBalanceAfter,\n        uint stableCoinsToWithdraw,\n        uint twoKeyAmount\n    );\n\n\n    /**\n     * @notice Constructor of the contract, can be called only once\n     * @param _token is ERC20 2key token\n     * @param _daiAddress is the address of DAI on ropsten\n     * @param _kyberNetworkProxy is the address of Kyber network contract\n     * @param _twoKeySingletonesRegistry is the address of TWO_KEY_SINGLETON_REGISTRY\n     * @param _proxyStorageContract is the address of proxy of storage contract\n     */\n    function setInitialParams(\n        ERC20 _token,\n        address _daiAddress,\n        address _kyberNetworkProxy,\n        address _twoKeySingletonesRegistry,\n        address _proxyStorageContract\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyUpgradableExchangeStorage(_proxyStorageContract);\n\n        setUint((\"buyRate2key\"),95);// When anyone send 2key to contract, 2key in exchange will be calculated on it's buy rate\n        setUint((\"sellRate2key\"),100);// When anyone send Ether to contract, 2key in exchange will be calculated on it's sell rate\n        setUint((\"weiRaised\"),0);\n        setUint(\"transactionCounter\",0);\n\n        setAddress((\"TWO_KEY_TOKEN\"),address(_token));\n        setAddress((\"DAI\"), _daiAddress);\n        setAddress((\"ETH_TOKEN_ADDRESS\"), 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n        setAddress((\"KYBER_NETWORK_PROXY\"), _kyberNetworkProxy);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice Modifier which will validate if contract is allowed to buy tokens\n     */\n    modifier onlyValidatedContracts {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(\"TwoKeyCampaignValidator\");\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * @param _beneficiary Address performing the token purchase\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(\n        address _beneficiary,\n        uint256 _weiAmount\n    )\n    private\n    {\n        require(_beneficiary != address(0),'beneficiary address can not be 0' );\n        require(_weiAmount != 0, 'wei amount can not be 0');\n    }\n\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        //Take the address of token from storage\n        address tokenAddress = getAddress(\"TWO_KEY_TOKEN\");\n\n        ERC20(tokenAddress).safeTransfer(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n     * @param _beneficiary Address receiving the tokens\n     * @param _tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getTokenAmountToBeSold(\n        uint256 _weiAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD\");\n        return (_weiAmount*rate).mul(1000).div(getUint(\"sellRate2key\")).div(10**18);\n    }\n\n\n    /**\n     * @notice Function to calculate how many stable coins we can get for specific amount of 2keys\n     * @dev This is happening in case we're receiving (buying) 2key\n     * @param _2keyAmount is the amount of 2keys sent to the contract\n     */\n    function _getUSDStableCoinAmountFrom2keyUnits(\n        uint256 _2keyAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        // Take the address of TwoKeyExchangeRateContract\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        // This is the case when we buy 2keys in exchange for stable coins\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD-DAI\"); // 1.01\n        uint lowestAcceptedRate = 96;\n        require(rate >= lowestAcceptedRate.mul(10**18).div(100)); // Require that lowest accepted rate is greater than 0.95\n\n        uint buyRate2key = getUint(\"buyRate2key\");\n\n        uint dollarWeiWorthTokens = _2keyAmount.mul(buyRate2key).div(1000);  // 100*95/1000 = 9.5\n        uint amountOfDAIs = dollarWeiWorthTokens.mul(rate).div(10**18);      // 9.5 * 1.01 =vOK\n\n        return amountOfDAIs;\n    }\n\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds(\n        address _twoKeyAdmin\n    )\n    internal\n    {\n        _twoKeyAdmin.transfer(msg.value);\n    }\n\n\n    /**\n     * @notice Function to buyTokens\n     * @param _beneficiary to get\n     * @return amount of tokens bought\n     */\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    onlyValidatedContracts\n    returns (uint)\n    {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(_beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmountToBeSold(weiAmount);\n\n        // update state\n        uint weiRaised = getUint(\"weiRaised\").add(weiAmount);\n        setUint(\"weiRaised\",weiRaised);\n        setUint(\"transactionCounter\",getUint(\"transactionCounter\")+1);\n\n        _processPurchase(_beneficiary, tokens);\n\n\n        emit TokenPurchase(\n            msg.sender,\n            _beneficiary,\n            weiAmount,\n            tokens,\n            getUint(\"sellRate2key\")\n        );\n\n        return tokens;\n    }\n\n\n    /**\n     * @notice Function to get expected rate from Kyber contract\n     * @param amountEthWei is the amount we'd like to exchange\n     * @return if the value is 0 that means we can't\n     */\n    function getKyberExpectedRate(\n        uint amountEthWei\n    )\n    public\n    view\n    returns (uint)\n    {\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        ERC20 eth = ERC20(getAddress(\"ETH_TOKEN_ADDRESS\"));\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        uint minConversionRate;\n        (minConversionRate,) = proxyContract.getExpectedRate(eth, dai, amountEthWei);\n\n        return minConversionRate;\n    }\n\n\n    /**\n     * @notice Function to start hedging some ether amount\n     * @param amountToBeHedged is the amount we'd like to hedge\n     * @dev only maintainer can call this function\n     */\n    function startHedging(\n        uint amountToBeHedged,\n        uint approvedMinConversionRate\n    )\n    public\n    onlyMaintainer\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        uint minConversionRate = getKyberExpectedRate(amountToBeHedged);\n        require(minConversionRate >= approvedMinConversionRate.mul(95).div(100)); //Means our rate can be at most same as their rate, because they're giving the best rate\n        uint stableCoinUnits = proxyContract.swapEtherToToken.value(amountToBeHedged)(dai,minConversionRate);\n    }\n\n    /**\n     * @notice Function which will be called by 2key campaigns if user wants to withdraw his earnings in stableCoins\n     * @param _twoKeyUnits is the amount of 2key tokens which will be taken from campaign\n     * @param _beneficiary is the user who will receive the tokens\n     */\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    external\n    onlyValidatedContracts\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n        ERC20 token = ERC20(getAddress(\"TWO_KEY_TOKEN\"));\n\n        uint stableCoinUnits = _getUSDStableCoinAmountFrom2keyUnits(_twoKeyUnits);\n        uint etherBalanceOnContractBefore = this.balance;\n        uint stableCoinsOnContractBefore = dai.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), _twoKeyUnits);\n\n        uint stableCoinsAfter = stableCoinsOnContractBefore - stableCoinUnits;\n\n        dai.transfer(_beneficiary, stableCoinUnits);\n\n        emitEventWithdrawExecuted(\n            _beneficiary,\n            stableCoinsOnContractBefore,\n            stableCoinsAfter,\n            etherBalanceOnContractBefore,\n            stableCoinUnits,\n            _twoKeyUnits\n        );\n    }\n\n    /**\n     * @notice Function to emit an event, created separately because of stack depth\n     */\n    function emitEventWithdrawExecuted(\n        address _beneficiary,\n        uint _stableCoinsOnContractBefore,\n        uint _stableCoinsAfter,\n        uint _etherBalanceOnContractBefore,\n        uint _stableCoinUnits,\n        uint twoKeyUnits\n    )\n    internal\n    {\n        emit WithdrawExecuted(\n            msg.sender,\n            _beneficiary,\n            _stableCoinsOnContractBefore,\n            _stableCoinsAfter,\n            _etherBalanceOnContractBefore,\n            this.balance,\n            _stableCoinUnits,\n            twoKeyUnits\n        );\n    }\n\n    /**\n     * @notice Getter for 2key buy rate\n     */\n    function buyRate2key() public view returns (uint) {\n        return getUint(\"buyRate2key\");\n    }\n\n    /**\n     * @notice Getter for 2key sell rate\n     */\n    function sellRate2key() public view returns (uint) {\n        return getUint(\"sellRate2key\");\n    }\n\n    /**\n     * @notice Getter for transactionCounter\n     */\n    function transactionCounter() public view returns (uint) {\n        return getUint(\"transactionCounter\");\n    }\n\n    /**\n     * @notice Getter for weiRaised\n     */\n    function weiRaised() public view returns (uint) {\n        return getUint(\"weiRaised\");\n    }\n\n    // Internal wrapper methods\n    function getUint(string key) internal view returns (uint) {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setUint(string key, uint value) internal {\n        PROXY_STORAGE_CONTRACT.setUint(keccak256(key), value);\n    }\n\n\n    // Internal wrapper methods\n    function getAddress(string key) internal view returns (address) {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setAddress(string key, address value) internal {\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(key), value);\n    }\n\n    /**\n     * @notice Function where maintainer can update any unassigned integer value\n     */\n    function updateUint(\n        string key,\n        uint value\n    )\n    public\n    onlyMaintainer\n    {\n        setUint(key, value);\n    }\n\n    /**\n     * @notice Withdraw all ether from contract\n     */\n    function withdrawEther()\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        _forwardFunds(twoKeyAdmin);\n    }\n\n\n    /**\n     * @notice Function to withdraw any ERC20 tokens to TwoKeyAdmin\n     */\n    function withdrawERC20(\n        address _erc20TokenAddress,\n        uint _tokenAmount\n    )\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        ERC20(_erc20TokenAddress).safeTransfer(twoKeyAdmin, _tokenAmount);\n\n    }\n\n    /**\n     * @notice Fallback function to handle incoming ether\n     */\n    function ()\n    public\n    payable\n    {\n\n    }\n\n}\n", "commit_id": "dbc64834a5e35c1eb4c3eb86df21e010d37bf0e6"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport \"../../openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/ITwoKeyExchangeRateContract.sol\";\nimport \"../interfaces/ITwoKeyCampaignValidator.sol\";\nimport \"../interfaces/IKyberNetworkProxy.sol\";\nimport \"../interfaces/storage-contracts/ITwoKeyUpgradableExchangeStorage.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../libraries/GetCode.sol\";\nimport \"../libraries/SafeERC20.sol\";\nimport \"../upgradability/Upgradeable.sol\";\nimport \"./ITwoKeySingletonUtils.sol\";\n\n\ncontract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    bool initialized;\n\n    ITwoKeyUpgradableExchangeStorage public PROXY_STORAGE_CONTRACT;\n\n\n    /**\n     * @notice Event will be fired every time someone buys tokens\n     */\n    event TokenSell(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param receiver is who got the tokens\n     * @param weiReceived is how weis paid for purchase\n     * @param tokensBought is the amount of tokens purchased\n     * @param rate is the global variable rate on the contract\n     */\n    event TokenPurchase(\n        address indexed purchaser,\n        address indexed receiver,\n        uint256 weiReceived,\n        uint256 tokensBought,\n        uint256 rate\n    );\n\n\n    /**\n     * @notice This event will be fired every time a withdraw is executed\n     */\n    event WithdrawExecuted(\n        address caller,\n        address beneficiary,\n        uint stableCoinsReserveBefore,\n        uint stableCoinsReserveAfter,\n        uint etherBalanceBefore,\n        uint etherBalanceAfter,\n        uint stableCoinsToWithdraw,\n        uint twoKeyAmount\n    );\n\n\n    /**\n     * @notice Constructor of the contract, can be called only once\n     * @param _token is ERC20 2key token\n     * @param _daiAddress is the address of DAI on ropsten\n     * @param _kyberNetworkProxy is the address of Kyber network contract\n     * @param _twoKeySingletonesRegistry is the address of TWO_KEY_SINGLETON_REGISTRY\n     * @param _proxyStorageContract is the address of proxy of storage contract\n     */\n    function setInitialParams(\n        ERC20 _token,\n        address _daiAddress,\n        address _kyberNetworkProxy,\n        address _twoKeySingletonesRegistry,\n        address _proxyStorageContract\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyUpgradableExchangeStorage(_proxyStorageContract);\n\n        setUint((\"buyRate2key\"),95);// When anyone send 2key to contract, 2key in exchange will be calculated on it's buy rate\n        setUint((\"sellRate2key\"),100);// When anyone send Ether to contract, 2key in exchange will be calculated on it's sell rate\n        setUint((\"weiRaised\"),0);\n        setUint(\"transactionCounter\",0);\n\n        setAddress((\"TWO_KEY_TOKEN\"),address(_token));\n        setAddress((\"DAI\"), _daiAddress);\n        setAddress((\"ETH_TOKEN_ADDRESS\"), 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n        setAddress((\"KYBER_NETWORK_PROXY\"), _kyberNetworkProxy);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice Modifier which will validate if contract is allowed to buy tokens\n     */\n    modifier onlyValidatedContracts {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(\"TwoKeyCampaignValidator\");\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * @param _beneficiary Address performing the token purchase\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(\n        address _beneficiary,\n        uint256 _weiAmount\n    )\n    private\n    {\n        require(_beneficiary != address(0),'beneficiary address can not be 0' );\n        require(_weiAmount != 0, 'wei amount can not be 0');\n    }\n\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        //Take the address of token from storage\n        address tokenAddress = getAddress(\"TWO_KEY_TOKEN\");\n\n        ERC20(tokenAddress).safeTransfer(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n     * @param _beneficiary Address receiving the tokens\n     * @param _tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getTokenAmountToBeSold(\n        uint256 _weiAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD\");\n        return (_weiAmount*rate).mul(1000).div(getUint(\"sellRate2key\")).div(10**18);\n    }\n\n\n    /**\n     * @notice Function to calculate how many stable coins we can get for specific amount of 2keys\n     * @dev This is happening in case we're receiving (buying) 2key\n     * @param _2keyAmount is the amount of 2keys sent to the contract\n     */\n    function _getUSDStableCoinAmountFrom2keyUnits(\n        uint256 _2keyAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        // Take the address of TwoKeyExchangeRateContract\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        // This is the case when we buy 2keys in exchange for stable coins\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD-DAI\"); // 1.01\n        uint lowestAcceptedRate = 96;\n        require(rate >= lowestAcceptedRate.mul(10**18).div(100)); // Require that lowest accepted rate is greater than 0.95\n\n        uint buyRate2key = getUint(\"buyRate2key\");\n\n        uint dollarWeiWorthTokens = _2keyAmount.mul(buyRate2key).div(1000);  // 100*95/1000 = 9.5\n        uint amountOfDAIs = dollarWeiWorthTokens.mul(rate).div(10**18);      // 9.5 * 1.01 =vOK\n\n        return amountOfDAIs;\n    }\n\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds(\n        address _twoKeyAdmin\n    )\n    internal\n    {\n        _twoKeyAdmin.transfer(msg.value);\n    }\n\n\n    /**\n     * @notice Function to buyTokens\n     * @param _beneficiary to get\n     * @return amount of tokens bought\n     */\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    onlyValidatedContracts\n    returns (uint)\n    {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(_beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmountToBeSold(weiAmount);\n\n        // update state\n        uint weiRaised = getUint(\"weiRaised\").add(weiAmount);\n        setUint(\"weiRaised\",weiRaised);\n        setUint(\"transactionCounter\",getUint(\"transactionCounter\")+1);\n\n        _processPurchase(_beneficiary, tokens);\n\n\n        emit TokenPurchase(\n            msg.sender,\n            _beneficiary,\n            weiAmount,\n            tokens,\n            getUint(\"sellRate2key\")\n        );\n\n        return tokens;\n    }\n\n\n    /**\n     * @notice Function to get expected rate from Kyber contract\n     * @param amountEthWei is the amount we'd like to exchange\n     * @return if the value is 0 that means we can't\n     */\n    function getKyberExpectedRate(\n        uint amountEthWei\n    )\n    public\n    view\n    returns (uint)\n    {\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        ERC20 eth = ERC20(getAddress(\"ETH_TOKEN_ADDRESS\"));\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        uint minConversionRate;\n        (minConversionRate,) = proxyContract.getExpectedRate(eth, dai, amountEthWei);\n\n        return minConversionRate;\n    }\n\n\n    /**\n     * @notice Function to start hedging some ether amount\n     * @param amountToBeHedged is the amount we'd like to hedge\n     * @dev only maintainer can call this function\n     */\n    function startHedging(\n        uint amountToBeHedged,\n        uint approvedMinConversionRate\n    )\n    public\n    onlyMaintainer\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        uint minConversionRate = getKyberExpectedRate(amountToBeHedged);\n        require(minConversionRate >= approvedMinConversionRate.mul(95).div(100)); //Means our rate can be at most same as their rate, because they're giving the best rate\n        uint stableCoinUnits = proxyContract.swapEtherToToken.value(amountToBeHedged)(dai,minConversionRate);\n    }\n\n    /**\n     * @notice Function which will be called by 2key campaigns if user wants to withdraw his earnings in stableCoins\n     * @param _twoKeyUnits is the amount of 2key tokens which will be taken from campaign\n     * @param _beneficiary is the user who will receive the tokens\n     */\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    external\n    onlyValidatedContracts\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n        ERC20 token = ERC20(getAddress(\"TWO_KEY_TOKEN\"));\n\n        uint stableCoinUnits = _getUSDStableCoinAmountFrom2keyUnits(_twoKeyUnits);\n        uint etherBalanceOnContractBefore = this.balance;\n        uint stableCoinsOnContractBefore = dai.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), _twoKeyUnits);\n\n        uint stableCoinsAfter = stableCoinsOnContractBefore - stableCoinUnits;\n\n        emitEventWithdrawExecuted(\n            _beneficiary,\n            stableCoinsOnContractBefore,\n            stableCoinsAfter,\n            etherBalanceOnContractBefore,\n            stableCoinUnits,\n            _twoKeyUnits\n        );\n\n        dai.transfer(_beneficiary, stableCoinUnits);\n    }\n\n    /**\n     * @notice Function to emit an event, created separately because of stack depth\n     */\n    function emitEventWithdrawExecuted(\n        address _beneficiary,\n        uint _stableCoinsOnContractBefore,\n        uint _stableCoinsAfter,\n        uint _etherBalanceOnContractBefore,\n        uint _stableCoinUnits,\n        uint twoKeyUnits\n    )\n    internal\n    {\n        emit WithdrawExecuted(\n            msg.sender,\n            _beneficiary,\n            _stableCoinsOnContractBefore,\n            _stableCoinsAfter,\n            _etherBalanceOnContractBefore,\n            this.balance,\n            _stableCoinUnits,\n            twoKeyUnits\n        );\n    }\n\n    /**\n     * @notice Getter for 2key buy rate\n     */\n    function buyRate2key() public view returns (uint) {\n        return getUint(\"buyRate2key\");\n    }\n\n    /**\n     * @notice Getter for 2key sell rate\n     */\n    function sellRate2key() public view returns (uint) {\n        return getUint(\"sellRate2key\");\n    }\n\n    /**\n     * @notice Getter for transactionCounter\n     */\n    function transactionCounter() public view returns (uint) {\n        return getUint(\"transactionCounter\");\n    }\n\n    /**\n     * @notice Getter for weiRaised\n     */\n    function weiRaised() public view returns (uint) {\n        return getUint(\"weiRaised\");\n    }\n\n    // Internal wrapper methods\n    function getUint(string key) internal view returns (uint) {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setUint(string key, uint value) internal {\n        PROXY_STORAGE_CONTRACT.setUint(keccak256(key), value);\n    }\n\n\n    // Internal wrapper methods\n    function getAddress(string key) internal view returns (address) {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setAddress(string key, address value) internal {\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(key), value);\n    }\n\n    /**\n     * @notice Function where maintainer can update any unassigned integer value\n     */\n    function updateUint(\n        string key,\n        uint value\n    )\n    public\n    onlyMaintainer\n    {\n        setUint(key, value);\n    }\n\n    /**\n     * @notice Withdraw all ether from contract\n     */\n    function withdrawEther()\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        _forwardFunds(twoKeyAdmin);\n    }\n\n\n    /**\n     * @notice Function to withdraw any ERC20 tokens to TwoKeyAdmin\n     */\n    function withdrawERC20(\n        address _erc20TokenAddress,\n        uint _tokenAmount\n    )\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        ERC20(_erc20TokenAddress).safeTransfer(twoKeyAdmin, _tokenAmount);\n\n    }\n\n    /**\n     * @notice Fallback function to handle incoming ether\n     */\n    function ()\n    public\n    payable\n    {\n\n    }\n\n}\n", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address _who) public view returns (uint256);\n  function transfer(address _to, uint256 _value) public returns (bool);\n  function allowance(address _ocwner, address _spender) public view returns (uint256);\n  function approve(address spender, uint tokens) public returns (bool success);\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\n}\n\npragma solidity ^0.4.24;\n\n/**\n * @author Nikola Madjarevic\n */\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n}\npragma solidity ^0.4.24;\n/**y\n * @author Nikola Madjarevic\n * Created at 2/12/19\n */\ncontract ITwoKeyCampaignValidator {\n    function isCampaignValidated(address campaign) public view returns (bool);\n    function validateAcquisitionCampaign(address campaign, string nonSingletonHash) public;\n    function validateDonationCampaign(address campaign, address donationConversionHandler, address donationLogicHandler, string nonSingletonHash) public;\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(\n    ERC20Basic _token,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transfer(_to, _value));\n  }\n\n  function safeTransferFrom(\n    ERC20 _token,\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.transferFrom(_from, _to, _value));\n  }\n\n  function safeApprove(\n    ERC20 _token,\n    address _spender,\n    uint256 _value\n  )\n    internal\n  {\n    require(_token.approve(_spender, _value));\n  }\n}\n\ncontract IKyberNetworkProxy {\n    function swapEtherToToken(\n        ERC20 token,\n        uint minConversionRate\n    )\n    public\n    payable\n    returns(uint);\n\n    function getExpectedRate(\n        ERC20 src,\n        ERC20 dest,\n        uint srcQty\n    )\n    public\n    view\n    returns (uint expectedRate, uint slippageRate);\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\ncontract IStructuredStorage {\n\n    function setProxyLogicContractAndDeployer(address _proxyLogicContract, address _deployer) external;\n    function setProxyLogicContract(address _proxyLogicContract) external;\n\n    // *** Getter Methods ***\n    function getUint(bytes32 _key) external view returns(uint);\n    function getString(bytes32 _key) external view returns(string);\n    function getAddress(bytes32 _key) external view returns(address);\n    function getBytes(bytes32 _key) external view returns(bytes);\n    function getBool(bytes32 _key) external view returns(bool);\n    function getInt(bytes32 _key) external view returns(int);\n    function getBytes32(bytes32 _key) external view returns(bytes32);\n\n    // *** Getter Methods For Arrays ***\n    function getBytes32Array(bytes32 _key) external view returns (bytes32[]);\n    function getAddressArray(bytes32 _key) external view returns (address[]);\n    function getUintArray(bytes32 _key) external view returns (uint[]);\n    function getIntArray(bytes32 _key) external view returns (int[]);\n    function getBoolArray(bytes32 _key) external view returns (bool[]);\n\n    // *** Setter Methods ***\n    function setUint(bytes32 _key, uint _value) external;\n    function setString(bytes32 _key, string _value) external;\n    function setAddress(bytes32 _key, address _value) external;\n    function setBytes(bytes32 _key, bytes _value) external;\n    function setBool(bytes32 _key, bool _value) external;\n    function setInt(bytes32 _key, int _value) external;\n    function setBytes32(bytes32 _key, bytes32 _value) external;\n\n    // *** Setter Methods For Arrays ***\n    function setBytes32Array(bytes32 _key, bytes32[] _value) external;\n    function setAddressArray(bytes32 _key, address[] _value) external;\n    function setUintArray(bytes32 _key, uint[] _value) external;\n    function setIntArray(bytes32 _key, int[] _value) external;\n    function setBoolArray(bytes32 _key, bool[] _value) external;\n\n    // *** Delete Methods ***\n    function deleteUint(bytes32 _key) external;\n    function deleteString(bytes32 _key) external;\n    function deleteAddress(bytes32 _key) external;\n    function deleteBytes(bytes32 _key) external;\n    function deleteBool(bytes32 _key) external;\n    function deleteInt(bytes32 _key) external;\n    function deleteBytes32(bytes32 _key) external;\n}\n\ncontract ITwoKeyUpgradableExchangeStorage is IStructuredStorage{\n\n}\npragma solidity ^0.4.24;\n\n/// Interface of ERC20 contract we need in order to invoke balanceOf method from another contracts\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\npragma solidity ^0.4.24;\n\n/// The following example provides library code to access the code of another contract and load it into a bytes variable.\n/// This is not possible at all with \u201cplain Solidity\" and the idea is that assembly libraries will be used to enhance the\n/// language in such ways.\n\n/// Took from Solidity official documentation\n/// https://solidity.readthedocs.io/en/latest/assembly.html?highlight=getCode\nlibrary GetCode {\n    function at(address _addr) internal view returns (bytes o_code) {\n        assembly {\n        // retrieve the size of the code, this needs assembly\n            let size := extcodesize(_addr)\n        // allocate output byte array - this could also be done without assembly\n        // by using o_code = new bytes(size)\n            o_code := mload(0x40)\n        // new \"memory end\" including padding\n            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n        // store length in memory\n            mstore(o_code, size)\n        // actually retrieve the code, this needs assembly\n            extcodecopy(_addr, add(o_code, 0x20), 0, size)\n        }\n    }\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n/**\n * @title IRegistry\n * @dev This contract represents the interface of a registry contract\n */\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    */\n    event VersionAdded(string version, address implementation);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\n/**\n * @author Nikola Madjarevic\n * @dev This contract holds all the necessary state variables to support the upgrade functionality\n */\ncontract UpgradeabilityStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract Upgradeable is UpgradeabilityStorage {\n    /**\n     * @dev Validates the caller is the versions registry.\n     * @param sender representing the address deploying the initial behavior of the contract\n     */\n    function initialize(address sender) public payable {\n        require(msg.sender == address(registry));\n    }\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n/**\n * @author Nikola Madjarevic\n * Created at 2/7/19\n */\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestContractVersion(string contractName) public view returns (string);\n}\npragma solidity ^0.4.24;\n\ncontract ITwoKeyMaintainersRegistry {\n    function onlyMaintainer(address _sender) public view returns (bool);\n}\n\ncontract ITwoKeySingletonUtils {\n\n    address public TWO_KEY_SINGLETON_REGISTRY;\n\n    // Modifier to restrict method calls only to maintainers\n    modifier onlyMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n        _;\n    }\n\n    /**\n     * @notice Function to get any singleton contract proxy address from TwoKeySingletonRegistry contract\n     * @param contractName is the name of the contract we're looking for\n     */\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(TWO_KEY_SINGLETON_REGISTRY)\n        .getContractProxyAddress(contractName);\n    }\n}\n\n\ncontract TwoKeyUpgradableExchange is Upgradeable, ITwoKeySingletonUtils {\n\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    bool initialized;\n\n    ITwoKeyUpgradableExchangeStorage public PROXY_STORAGE_CONTRACT;\n\n\n    /**\n     * @notice Event will be fired every time someone buys tokens\n     */\n    event TokenSell(\n        address indexed purchaser,\n        address indexed beneficiary,\n        uint256 value,\n        uint256 amount\n    );\n\n\n    /**\n     * Event for token purchase logging\n     * @param purchaser who paid for the tokens\n     * @param receiver is who got the tokens\n     * @param weiReceived is how weis paid for purchase\n     * @param tokensBought is the amount of tokens purchased\n     * @param rate is the global variable rate on the contract\n     */\n    event TokenPurchase(\n        address indexed purchaser,\n        address indexed receiver,\n        uint256 weiReceived,\n        uint256 tokensBought,\n        uint256 rate\n    );\n\n\n    /**\n     * @notice This event will be fired every time a withdraw is executed\n     */\n    event WithdrawExecuted(\n        address caller,\n        address beneficiary,\n        uint stableCoinsReserveBefore,\n        uint stableCoinsReserveAfter,\n        uint etherBalanceBefore,\n        uint etherBalanceAfter,\n        uint stableCoinsToWithdraw,\n        uint twoKeyAmount\n    );\n\n\n    /**\n     * @notice Constructor of the contract, can be called only once\n     * @param _token is ERC20 2key token\n     * @param _daiAddress is the address of DAI on ropsten\n     * @param _kyberNetworkProxy is the address of Kyber network contract\n     * @param _twoKeySingletonesRegistry is the address of TWO_KEY_SINGLETON_REGISTRY\n     * @param _proxyStorageContract is the address of proxy of storage contract\n     */\n    function setInitialParams(\n        ERC20 _token,\n        address _daiAddress,\n        address _kyberNetworkProxy,\n        address _twoKeySingletonesRegistry,\n        address _proxyStorageContract\n    )\n    external\n    {\n        require(initialized == false);\n\n        TWO_KEY_SINGLETON_REGISTRY = _twoKeySingletonesRegistry;\n        PROXY_STORAGE_CONTRACT = ITwoKeyUpgradableExchangeStorage(_proxyStorageContract);\n\n        setUint((\"buyRate2key\"),95);// When anyone send 2key to contract, 2key in exchange will be calculated on it's buy rate\n        setUint((\"sellRate2key\"),100);// When anyone send Ether to contract, 2key in exchange will be calculated on it's sell rate\n        setUint((\"weiRaised\"),0);\n        setUint(\"transactionCounter\",0);\n\n        setAddress((\"TWO_KEY_TOKEN\"),address(_token));\n        setAddress((\"DAI\"), _daiAddress);\n        setAddress((\"ETH_TOKEN_ADDRESS\"), 0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n        setAddress((\"KYBER_NETWORK_PROXY\"), _kyberNetworkProxy);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice Modifier which will validate if contract is allowed to buy tokens\n     */\n    modifier onlyValidatedContracts {\n        address twoKeyCampaignValidator = getAddressFromTwoKeySingletonRegistry(\"TwoKeyCampaignValidator\");\n        require(ITwoKeyCampaignValidator(twoKeyCampaignValidator).isCampaignValidated(msg.sender) == true);\n        _;\n    }\n\n\n    /**\n     * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\n     * @param _beneficiary Address performing the token purchase\n     * @param _weiAmount Value in wei involved in the purchase\n     */\n    function _preValidatePurchase(\n        address _beneficiary,\n        uint256 _weiAmount\n    )\n    private\n    {\n        require(_beneficiary != address(0),'beneficiary address can not be 0' );\n        require(_weiAmount != 0, 'wei amount can not be 0');\n    }\n\n\n    /**\n     * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\n     * @param _beneficiary Address performing the token purchase\n     * @param _tokenAmount Number of tokens to be emitted\n     */\n    function _deliverTokens(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        //Take the address of token from storage\n        address tokenAddress = getAddress(\"TWO_KEY_TOKEN\");\n\n        ERC20(tokenAddress).safeTransfer(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\n     * @param _beneficiary Address receiving the tokens\n     * @param _tokenAmount Number of tokens to be purchased\n     */\n    function _processPurchase(\n        address _beneficiary,\n        uint256 _tokenAmount\n    )\n    internal\n    {\n        _deliverTokens(_beneficiary, _tokenAmount);\n    }\n\n\n    /**\n     * @dev Override to extend the way in which ether is converted to tokens.\n     * @param _weiAmount Value in wei to be converted into tokens\n     * @return Number of tokens that can be purchased with the specified _weiAmount\n     */\n    function _getTokenAmountToBeSold(\n        uint256 _weiAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD\");\n        return (_weiAmount*rate).mul(1000).div(getUint(\"sellRate2key\")).div(10**18);\n    }\n\n\n    /**\n     * @notice Function to calculate how many stable coins we can get for specific amount of 2keys\n     * @dev This is happening in case we're receiving (buying) 2key\n     * @param _2keyAmount is the amount of 2keys sent to the contract\n     */\n    function _getUSDStableCoinAmountFrom2keyUnits(\n        uint256 _2keyAmount\n    )\n    public\n    view\n    returns (uint256)\n    {\n        // Take the address of TwoKeyExchangeRateContract\n        address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n\n        // This is the case when we buy 2keys in exchange for stable coins\n        uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(\"USD-DAI\"); // 1.01\n        uint lowestAcceptedRate = 96;\n        require(rate >= lowestAcceptedRate.mul(10**18).div(100)); // Require that lowest accepted rate is greater than 0.95\n\n        uint buyRate2key = getUint(\"buyRate2key\");\n\n        uint dollarWeiWorthTokens = _2keyAmount.mul(buyRate2key).div(1000);  // 100*95/1000 = 9.5\n        uint amountOfDAIs = dollarWeiWorthTokens.mul(rate).div(10**18);      // 9.5 * 1.01 =vOK\n\n        return amountOfDAIs;\n    }\n\n\n    /**\n     * @dev Determines how ETH is stored/forwarded on purchases.\n     */\n    function _forwardFunds(\n        address _twoKeyAdmin\n    )\n    internal\n    {\n        _twoKeyAdmin.transfer(msg.value);\n    }\n\n\n    /**\n     * @notice Function to buyTokens\n     * @param _beneficiary to get\n     * @return amount of tokens bought\n     */\n    function buyTokens(\n        address _beneficiary\n    )\n    public\n    payable\n    onlyValidatedContracts\n    returns (uint)\n    {\n        uint256 weiAmount = msg.value;\n        _preValidatePurchase(_beneficiary, weiAmount);\n\n        // calculate token amount to be created\n        uint256 tokens = _getTokenAmountToBeSold(weiAmount);\n\n        // update state\n        uint weiRaised = getUint(\"weiRaised\").add(weiAmount);\n        setUint(\"weiRaised\",weiRaised);\n        setUint(\"transactionCounter\",getUint(\"transactionCounter\")+1);\n\n        _processPurchase(_beneficiary, tokens);\n\n\n        emit TokenPurchase(\n            msg.sender,\n            _beneficiary,\n            weiAmount,\n            tokens,\n            getUint(\"sellRate2key\")\n        );\n\n        return tokens;\n    }\n\n\n    /**\n     * @notice Function to get expected rate from Kyber contract\n     * @param amountEthWei is the amount we'd like to exchange\n     * @return if the value is 0 that means we can't\n     */\n    function getKyberExpectedRate(\n        uint amountEthWei\n    )\n    public\n    view\n    returns (uint)\n    {\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        ERC20 eth = ERC20(getAddress(\"ETH_TOKEN_ADDRESS\"));\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        uint minConversionRate;\n        (minConversionRate,) = proxyContract.getExpectedRate(eth, dai, amountEthWei);\n\n        return minConversionRate;\n    }\n\n\n    /**\n     * @notice Function to start hedging some ether amount\n     * @param amountToBeHedged is the amount we'd like to hedge\n     * @dev only maintainer can call this function\n     */\n    function startHedging(\n        uint amountToBeHedged,\n        uint approvedMinConversionRate\n    )\n    public\n    onlyMaintainer\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n\n        address kyberProxyContract = getAddress(\"KYBER_NETWORK_PROXY\");\n        IKyberNetworkProxy proxyContract = IKyberNetworkProxy(kyberProxyContract);\n\n        uint minConversionRate = getKyberExpectedRate(amountToBeHedged);\n        require(minConversionRate >= approvedMinConversionRate.mul(95).div(100)); //Means our rate can be at most same as their rate, because they're giving the best rate\n        uint stableCoinUnits = proxyContract.swapEtherToToken.value(amountToBeHedged)(dai,minConversionRate);\n    }\n\n    /**\n     * @notice Function which will be called by 2key campaigns if user wants to withdraw his earnings in stableCoins\n     * @param _twoKeyUnits is the amount of 2key tokens which will be taken from campaign\n     * @param _beneficiary is the user who will receive the tokens\n     */\n    function buyStableCoinWith2key(\n        uint _twoKeyUnits,\n        address _beneficiary\n    )\n    external\n    onlyValidatedContracts\n    {\n        ERC20 dai = ERC20(getAddress(\"DAI\"));\n        ERC20 token = ERC20(getAddress(\"TWO_KEY_TOKEN\"));\n\n        uint stableCoinUnits = _getUSDStableCoinAmountFrom2keyUnits(_twoKeyUnits);\n        uint etherBalanceOnContractBefore = this.balance;\n        uint stableCoinsOnContractBefore = dai.balanceOf(address(this));\n        token.transferFrom(msg.sender, address(this), _twoKeyUnits);\n\n        uint stableCoinsAfter = stableCoinsOnContractBefore - stableCoinUnits;\n\n        emitEventWithdrawExecuted(\n            _beneficiary,\n            stableCoinsOnContractBefore,\n            stableCoinsAfter,\n            etherBalanceOnContractBefore,\n            stableCoinUnits,\n            _twoKeyUnits\n        );\n\n        dai.transfer(_beneficiary, stableCoinUnits);\n    }\n\n    /**\n     * @notice Function to emit an event, created separately because of stack depth\n     */\n    function emitEventWithdrawExecuted(\n        address _beneficiary,\n        uint _stableCoinsOnContractBefore,\n        uint _stableCoinsAfter,\n        uint _etherBalanceOnContractBefore,\n        uint _stableCoinUnits,\n        uint twoKeyUnits\n    )\n    internal\n    {\n        emit WithdrawExecuted(\n            msg.sender,\n            _beneficiary,\n            _stableCoinsOnContractBefore,\n            _stableCoinsAfter,\n            _etherBalanceOnContractBefore,\n            this.balance,\n            _stableCoinUnits,\n            twoKeyUnits\n        );\n    }\n\n    /**\n     * @notice Getter for 2key buy rate\n     */\n    function buyRate2key() public view returns (uint) {\n        return getUint(\"buyRate2key\");\n    }\n\n    /**\n     * @notice Getter for 2key sell rate\n     */\n    function sellRate2key() public view returns (uint) {\n        return getUint(\"sellRate2key\");\n    }\n\n    /**\n     * @notice Getter for transactionCounter\n     */\n    function transactionCounter() public view returns (uint) {\n        return getUint(\"transactionCounter\");\n    }\n\n    /**\n     * @notice Getter for weiRaised\n     */\n    function weiRaised() public view returns (uint) {\n        return getUint(\"weiRaised\");\n    }\n\n    // Internal wrapper methods\n    function getUint(string key) internal view returns (uint) {\n        return PROXY_STORAGE_CONTRACT.getUint(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setUint(string key, uint value) internal {\n        PROXY_STORAGE_CONTRACT.setUint(keccak256(key), value);\n    }\n\n\n    // Internal wrapper methods\n    function getAddress(string key) internal view returns (address) {\n        return PROXY_STORAGE_CONTRACT.getAddress(keccak256(key));\n    }\n\n    // Internal wrapper methods\n    function setAddress(string key, address value) internal {\n        PROXY_STORAGE_CONTRACT.setAddress(keccak256(key), value);\n    }\n\n    /**\n     * @notice Function where maintainer can update any unassigned integer value\n     */\n    function updateUint(\n        string key,\n        uint value\n    )\n    public\n    onlyMaintainer\n    {\n        setUint(key, value);\n    }\n\n    /**\n     * @notice Withdraw all ether from contract\n     */\n    function withdrawEther()\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        _forwardFunds(twoKeyAdmin);\n    }\n\n\n    /**\n     * @notice Function to withdraw any ERC20 tokens to TwoKeyAdmin\n     */\n    function withdrawERC20(\n        address _erc20TokenAddress,\n        uint _tokenAmount\n    )\n    public\n    {\n        address twoKeyAdmin = getAddressFromTwoKeySingletonRegistry(\"TwoKeyAdmin\");\n        require(msg.sender == twoKeyAdmin);\n        ERC20(_erc20TokenAddress).safeTransfer(twoKeyAdmin, _tokenAmount);\n\n    }\n\n    /**\n     * @notice Fallback function to handle incoming ether\n     */\n    function ()\n    public\n    payable\n    {\n\n    }\n\n}\n", "commit_id": "54ca1a4aa89acd54d958ebf650b55b0c1cdca02a"}}