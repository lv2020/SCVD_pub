{"filename": "contracts/bondable.sol", "patch": "@@ -5,8 +5,8 @@ pragma solidity >= 0.8.4;\n import \"./Utils/SafeTransferLib.sol\";\n import './Tokens/zcToken.sol';\n \n-/// A factory to issue un-backed debt at a provided price (discount) in the form of zero-coupon bonds.\n-/// Utilizes solmate ERC20 & SafeTransfer, and intended to be used in tandem with @yieldprotocol/yieldspace-v2\n+// A factory to issue un-backed debt at a provided price (discount) in the form of zero-coupon bonds.\n+// Utilizes solmate ERC20 & SafeTransfer, and intended to be used in tandem with @yieldprotocol/yieldspace-v2\n contract Bondable {\n \n     address public admin;\n@@ -56,13 +56,10 @@ contract Bondable {\n         \n         // check if the market already exists\n         require(markets[underlying][maturity].maximumDebt == 0, 'Market already exists');\n-\n         // create the bond token\n         address bondAddress = address(new zcToken(name, symbol, decimals, maturity, underlying));\n-        \n         // create the market\n         markets[underlying][maturity] = Market(maximumDebt, price, 0, 0, 0, bondAddress, name);\n-        \n         // emit the event\n         emit marketCreated(underlying, maturity, bondAddress, maximumDebt, name);\n         \n@@ -120,14 +117,14 @@ contract Bondable {\n         // burn the bond\n         zcToken(_market.bond).burn(msg.sender, amount);\n \n-        // transfer out underlying\n-        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n-\n         // update the market's redeemed debt\n         markets[underlying][maturity].redeemedDebt = newRedeemedDebt;\n \n         // emit the event\n         emit bondRedeemed(underlying, maturity, _market.bond, amount, newRedeemedDebt);\n+\n+        // transfer out underlying\n+        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n         \n         return (amount);\n     }\n@@ -144,15 +141,15 @@ contract Bondable {\n         // ensure market is not overpaying its debts\n         require(newRepaidDebt <= _market.mintedDebt,'can not repay more debt than is minted');\n \n-        // transfer in underlying \n-        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n-\n         // update the market's repaid debt\n         markets[underlying][maturity].repaidDebt = newRepaidDebt;\n \n         // emit the event\n         emit bondRepaid(underlying, maturity, _market.bond, amount, newRepaidDebt);\n \n+        // transfer in underlying \n+        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n+\n         return (amount);\n     }\n ", "project_link": "https://github.com/JTraversa/bondable/commit/9864c5aa2b6bf799258dcdded57f8974380987fb", "bug_version": {"raw_code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >= 0.8.4;\n\nimport \"./Utils/SafeTransferLib.sol\";\nimport './Tokens/zcToken.sol';\n\n/// A factory to issue un-backed debt at a provided price (discount) in the form of zero-coupon bonds.\n/// Utilizes solmate ERC20 & SafeTransfer, and intended to be used in tandem with @yieldprotocol/yieldspace-v2\ncontract Bondable {\n\n    address public admin;\n\n    /// @notice A market for a specific underlying token and maturity.\n    /// @param maximumDebt The maximum amount of debt that can be issued.\n    /// @param price The issuance price of the debt / bond.\n    /// @param mintedDebt The amount of debt that has been issued.\n    /// @param repaidDebt The amounf of debt that the has been repaid to the market (must repay before it can be redeemed).\n    /// @param redeemedDebt The amount of debt that has been redeemed back into underlying (after maturity).\n    /// @param bond The address of the issued zero-coupon bond contract.\n    /// @param name The name of the bond market (e.g. TRIBE-MAR, TRIBE-1648728318, or Tetranode-TRIBE-MAR for an indivudalized bond)\n    struct Market {\n        uint256 maximumDebt;\n        uint256 price;\n        uint256 mintedDebt;\n        uint256 repaidDebt;\n        uint256 redeemedDebt;\n        address bond;\n        string name;\n    }\n    \n    /// @notice A mapping of markets that have been created\n    /// address the address of the underlying token\n    /// uint256 the maturity (unix timestamp) of the market\n    mapping (address => mapping (uint256 => Market)) public markets;\n    \n    event marketCreated(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 maximumDebt, string name);\n\n    event bondMinted(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 mintedDebt);\n\n    event bondRepaid(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 repaidDebt);\n\n    event bondRedeemed(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 redeemedDebt);\n    \n    constructor () {\n        admin = msg.sender;\n    }\n\n    /// @notice Can be called to create a new debt market for a given underlying token\n    /// @param underlying the address of the underlying token \n    /// @param maturity the maturity of the market\n    /// @param decimals the number of decimals in the underlying token\n    /// @param price the issuance price on the bonds (a decimal stored as a base 1e18 uint256, issuance accurate to 8 digits precision)\n    /// @param maximumDebt the maximum amount of debt/bonds to allow to be minted\n    function createMarket(address underlying, uint256 maturity, uint256 maximumDebt, uint256 price, uint8 decimals, string memory name, string memory symbol) external onlyAdmin() returns (address) {\n        \n        // check if the market already exists\n        require(markets[underlying][maturity].maximumDebt == 0, 'Market already exists');\n\n        // create the bond token\n        address bondAddress = address(new zcToken(name, symbol, decimals, maturity, underlying));\n        \n        // create the market\n        markets[underlying][maturity] = Market(maximumDebt, price, 0, 0, 0, bondAddress, name);\n        \n        // emit the event\n        emit marketCreated(underlying, maturity, bondAddress, maximumDebt, name);\n        \n        return (bondAddress);\n    }\n    \n    /// @notice Can be called to mint/purchase a new bond\n    /// @param underlying the address of the underlying token being lent\n    /// @param maturity the maturity of the market\n    /// @param amount the amount of underlying tokens to lend\n    function mint(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp <= maturity,'bond has already matured');       \n\n        // transfer in underlying\n        SafeTransferLib.safeTransferFrom(ERC20(underlying), msg.sender, address(this), amount);\n\n        // calculate amount of debt to mint (modifier = 1/price)\n        uint256 mintAmount = amount * (1e26 / _market.price) / 1e8;\n\n        // mint the bond\n        zcToken(_market.bond).mint(msg.sender, mintAmount);\n\n        // require that maximum debt has not been exceeded\n        uint256 newDebt = _market.mintedDebt + mintAmount;\n        require(newDebt <= _market.maximumDebt,'maximum debt exceeded');\n\n        // update the market\n        markets[underlying][maturity].mintedDebt = newDebt;\n\n        // emit the event\n        emit bondMinted(underlying, maturity, _market.bond, amount, newDebt);\n\n        return (mintAmount);\n    }\n\n    /// @notice Can be called after maturity to redeem debt owed\n    /// @param underlying the address of the underlying token being redeemed\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying tokens to redeem and bond tokens to burn\n    function redeem(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n        \n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp >= maturity,'bond maturity has not been reached');\n\n        uint256 newRedeemedDebt = _market.redeemedDebt + amount;\n        // ensure market has enough repaid debt to redeem (first come first served)\n        require(newRedeemedDebt <= _market.repaidDebt,'total market claim exceeds debt repaid');\n        \n        // burn the bond\n        zcToken(_market.bond).burn(msg.sender, amount);\n\n        // transfer out underlying\n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n\n        // update the market's redeemed debt\n        markets[underlying][maturity].redeemedDebt = newRedeemedDebt;\n\n        // emit the event\n        emit bondRedeemed(underlying, maturity, _market.bond, amount, newRedeemedDebt);\n        \n        return (amount);\n    }\n\n    /// @notice Can be called to pay towards a certain market's debt (generally called by the debtor)\n    /// @param underlying the address of the underlying token being paid\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying token debt to pay\n    function repay(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        uint256 newRepaidDebt = _market.repaidDebt + amount;\n        // ensure market is not overpaying its debts\n        require(newRepaidDebt <= _market.mintedDebt,'can not repay more debt than is minted');\n\n        // transfer in underlying \n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n\n        // update the market's repaid debt\n        markets[underlying][maturity].repaidDebt = newRepaidDebt;\n\n        // emit the event\n        emit bondRepaid(underlying, maturity, _market.bond, amount, newRepaidDebt);\n\n        return (amount);\n    }\n\n    /// @notice Allows the admin to set a new admin\n    /// @param newAdmin Address of the new admin\n    function transferAdmin(address newAdmin) external onlyAdmin() returns (address) {\n\n        admin = newAdmin;\n\n        return (newAdmin);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'sender must be admin');\n        _;\n  }\n    \n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: UNLICENSED\n\npragma solidity >= 0.8.4;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n // IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\ncontract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n}\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\ncontract zcToken {\n\n   /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    uint256 public immutable maturity;\n\n    address public underlying;\n\n    address public admin;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _maturity,\n        address _underlying\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        maturity = _maturity;\n        underlying = _underlying;\n\n        admin = msg.sender;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       EXTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function mint(address to, uint256 amount) external virtual onlyAdmin() {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function burn(address from, uint256 amount) external virtual onlyAdmin() {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'sender must be admin');\n        _;\n    }\n}\n\n/// A factory to issue un-backed debt at a provided price (discount) in the form of zero-coupon bonds.\n/// Utilizes solmate ERC20 & SafeTransfer, and intended to be used in tandem with @yieldprotocol/yieldspace-v2\ncontract Bondable {\n\n    address public admin;\n\n    /// @notice A market for a specific underlying token and maturity.\n    /// @param maximumDebt The maximum amount of debt that can be issued.\n    /// @param price The issuance price of the debt / bond.\n    /// @param mintedDebt The amount of debt that has been issued.\n    /// @param repaidDebt The amounf of debt that the has been repaid to the market (must repay before it can be redeemed).\n    /// @param redeemedDebt The amount of debt that has been redeemed back into underlying (after maturity).\n    /// @param bond The address of the issued zero-coupon bond contract.\n    /// @param name The name of the bond market (e.g. TRIBE-MAR, TRIBE-1648728318, or Tetranode-TRIBE-MAR for an indivudalized bond)\n    struct Market {\n        uint256 maximumDebt;\n        uint256 price;\n        uint256 mintedDebt;\n        uint256 repaidDebt;\n        uint256 redeemedDebt;\n        address bond;\n        string name;\n    }\n    \n    /// @notice A mapping of markets that have been created\n    /// address the address of the underlying token\n    /// uint256 the maturity (unix timestamp) of the market\n    mapping (address => mapping (uint256 => Market)) public markets;\n    \n    event marketCreated(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 maximumDebt, string name);\n\n    event bondMinted(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 mintedDebt);\n\n    event bondRepaid(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 repaidDebt);\n\n    event bondRedeemed(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 redeemedDebt);\n    \n    constructor () {\n        admin = msg.sender;\n    }\n\n    /// @notice Can be called to create a new debt market for a given underlying token\n    /// @param underlying the address of the underlying token \n    /// @param maturity the maturity of the market\n    /// @param decimals the number of decimals in the underlying token\n    /// @param price the issuance price on the bonds (a decimal stored as a base 1e18 uint256, issuance accurate to 8 digits precision)\n    /// @param maximumDebt the maximum amount of debt/bonds to allow to be minted\n    function createMarket(address underlying, uint256 maturity, uint256 maximumDebt, uint256 price, uint8 decimals, string memory name, string memory symbol) external onlyAdmin() returns (address) {\n        \n        // check if the market already exists\n        require(markets[underlying][maturity].maximumDebt == 0, 'Market already exists');\n\n        // create the bond token\n        address bondAddress = address(new zcToken(name, symbol, decimals, maturity, underlying));\n        \n        // create the market\n        markets[underlying][maturity] = Market(maximumDebt, price, 0, 0, 0, bondAddress, name);\n        \n        // emit the event\n        emit marketCreated(underlying, maturity, bondAddress, maximumDebt, name);\n        \n        return (bondAddress);\n    }\n    \n    /// @notice Can be called to mint/purchase a new bond\n    /// @param underlying the address of the underlying token being lent\n    /// @param maturity the maturity of the market\n    /// @param amount the amount of underlying tokens to lend\n    function mint(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp <= maturity,'bond has already matured');       \n\n        // transfer in underlying\n        SafeTransferLib.safeTransferFrom(ERC20(underlying), msg.sender, address(this), amount);\n\n        // calculate amount of debt to mint (modifier = 1/price)\n        uint256 mintAmount = amount * (1e26 / _market.price) / 1e8;\n\n        // mint the bond\n        zcToken(_market.bond).mint(msg.sender, mintAmount);\n\n        // require that maximum debt has not been exceeded\n        uint256 newDebt = _market.mintedDebt + mintAmount;\n        require(newDebt <= _market.maximumDebt,'maximum debt exceeded');\n\n        // update the market\n        markets[underlying][maturity].mintedDebt = newDebt;\n\n        // emit the event\n        emit bondMinted(underlying, maturity, _market.bond, amount, newDebt);\n\n        return (mintAmount);\n    }\n\n    /// @notice Can be called after maturity to redeem debt owed\n    /// @param underlying the address of the underlying token being redeemed\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying tokens to redeem and bond tokens to burn\n    function redeem(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n        \n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp >= maturity,'bond maturity has not been reached');\n\n        uint256 newRedeemedDebt = _market.redeemedDebt + amount;\n        // ensure market has enough repaid debt to redeem (first come first served)\n        require(newRedeemedDebt <= _market.repaidDebt,'total market claim exceeds debt repaid');\n        \n        // burn the bond\n        zcToken(_market.bond).burn(msg.sender, amount);\n\n        // transfer out underlying\n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n\n        // update the market's redeemed debt\n        markets[underlying][maturity].redeemedDebt = newRedeemedDebt;\n\n        // emit the event\n        emit bondRedeemed(underlying, maturity, _market.bond, amount, newRedeemedDebt);\n        \n        return (amount);\n    }\n\n    /// @notice Can be called to pay towards a certain market's debt (generally called by the debtor)\n    /// @param underlying the address of the underlying token being paid\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying token debt to pay\n    function repay(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        uint256 newRepaidDebt = _market.repaidDebt + amount;\n        // ensure market is not overpaying its debts\n        require(newRepaidDebt <= _market.mintedDebt,'can not repay more debt than is minted');\n\n        // transfer in underlying \n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n\n        // update the market's repaid debt\n        markets[underlying][maturity].repaidDebt = newRepaidDebt;\n\n        // emit the event\n        emit bondRepaid(underlying, maturity, _market.bond, amount, newRepaidDebt);\n\n        return (amount);\n    }\n\n    /// @notice Allows the admin to set a new admin\n    /// @param newAdmin Address of the new admin\n    function transferAdmin(address newAdmin) external onlyAdmin() returns (address) {\n\n        admin = newAdmin;\n\n        return (newAdmin);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'sender must be admin');\n        _;\n  }\n    \n}\n", "commit_id": "a0b4eaa4af400431287da202a17adf6baff807f1"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity >= 0.8.4;\n\nimport \"./Utils/SafeTransferLib.sol\";\nimport './Tokens/zcToken.sol';\n\n// A factory to issue un-backed debt at a provided price (discount) in the form of zero-coupon bonds.\n// Utilizes solmate ERC20 & SafeTransfer, and intended to be used in tandem with @yieldprotocol/yieldspace-v2\ncontract Bondable {\n\n    address public admin;\n\n    /// @notice A market for a specific underlying token and maturity.\n    /// @param maximumDebt The maximum amount of debt that can be issued.\n    /// @param price The issuance price of the debt / bond.\n    /// @param mintedDebt The amount of debt that has been issued.\n    /// @param repaidDebt The amounf of debt that the has been repaid to the market (must repay before it can be redeemed).\n    /// @param redeemedDebt The amount of debt that has been redeemed back into underlying (after maturity).\n    /// @param bond The address of the issued zero-coupon bond contract.\n    /// @param name The name of the bond market (e.g. TRIBE-MAR, TRIBE-1648728318, or Tetranode-TRIBE-MAR for an indivudalized bond)\n    struct Market {\n        uint256 maximumDebt;\n        uint256 price;\n        uint256 mintedDebt;\n        uint256 repaidDebt;\n        uint256 redeemedDebt;\n        address bond;\n        string name;\n    }\n    \n    /// @notice A mapping of markets that have been created\n    /// address the address of the underlying token\n    /// uint256 the maturity (unix timestamp) of the market\n    mapping (address => mapping (uint256 => Market)) public markets;\n    \n    event marketCreated(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 maximumDebt, string name);\n\n    event bondMinted(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 mintedDebt);\n\n    event bondRepaid(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 repaidDebt);\n\n    event bondRedeemed(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 redeemedDebt);\n    \n    constructor () {\n        admin = msg.sender;\n    }\n\n    /// @notice Can be called to create a new debt market for a given underlying token\n    /// @param underlying the address of the underlying token \n    /// @param maturity the maturity of the market\n    /// @param decimals the number of decimals in the underlying token\n    /// @param price the issuance price on the bonds (a decimal stored as a base 1e18 uint256, issuance accurate to 8 digits precision)\n    /// @param maximumDebt the maximum amount of debt/bonds to allow to be minted\n    function createMarket(address underlying, uint256 maturity, uint256 maximumDebt, uint256 price, uint8 decimals, string memory name, string memory symbol) external onlyAdmin() returns (address) {\n        \n        // check if the market already exists\n        require(markets[underlying][maturity].maximumDebt == 0, 'Market already exists');\n        // create the bond token\n        address bondAddress = address(new zcToken(name, symbol, decimals, maturity, underlying));\n        // create the market\n        markets[underlying][maturity] = Market(maximumDebt, price, 0, 0, 0, bondAddress, name);\n        // emit the event\n        emit marketCreated(underlying, maturity, bondAddress, maximumDebt, name);\n        \n        return (bondAddress);\n    }\n    \n    /// @notice Can be called to mint/purchase a new bond\n    /// @param underlying the address of the underlying token being lent\n    /// @param maturity the maturity of the market\n    /// @param amount the amount of underlying tokens to lend\n    function mint(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp <= maturity,'bond has already matured');       \n\n        // transfer in underlying\n        SafeTransferLib.safeTransferFrom(ERC20(underlying), msg.sender, address(this), amount);\n\n        // calculate amount of debt to mint (modifier = 1/price)\n        uint256 mintAmount = amount * (1e26 / _market.price) / 1e8;\n\n        // mint the bond\n        zcToken(_market.bond).mint(msg.sender, mintAmount);\n\n        // require that maximum debt has not been exceeded\n        uint256 newDebt = _market.mintedDebt + mintAmount;\n        require(newDebt <= _market.maximumDebt,'maximum debt exceeded');\n\n        // update the market\n        markets[underlying][maturity].mintedDebt = newDebt;\n\n        // emit the event\n        emit bondMinted(underlying, maturity, _market.bond, amount, newDebt);\n\n        return (mintAmount);\n    }\n\n    /// @notice Can be called after maturity to redeem debt owed\n    /// @param underlying the address of the underlying token being redeemed\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying tokens to redeem and bond tokens to burn\n    function redeem(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n        \n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp >= maturity,'bond maturity has not been reached');\n\n        uint256 newRedeemedDebt = _market.redeemedDebt + amount;\n        // ensure market has enough repaid debt to redeem (first come first served)\n        require(newRedeemedDebt <= _market.repaidDebt,'total market claim exceeds debt repaid');\n        \n        // burn the bond\n        zcToken(_market.bond).burn(msg.sender, amount);\n\n        // update the market's redeemed debt\n        markets[underlying][maturity].redeemedDebt = newRedeemedDebt;\n\n        // emit the event\n        emit bondRedeemed(underlying, maturity, _market.bond, amount, newRedeemedDebt);\n\n        // transfer out underlying\n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n        \n        return (amount);\n    }\n\n    /// @notice Can be called to pay towards a certain market's debt (generally called by the debtor)\n    /// @param underlying the address of the underlying token being paid\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying token debt to pay\n    function repay(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        uint256 newRepaidDebt = _market.repaidDebt + amount;\n        // ensure market is not overpaying its debts\n        require(newRepaidDebt <= _market.mintedDebt,'can not repay more debt than is minted');\n\n        // update the market's repaid debt\n        markets[underlying][maturity].repaidDebt = newRepaidDebt;\n\n        // emit the event\n        emit bondRepaid(underlying, maturity, _market.bond, amount, newRepaidDebt);\n\n        // transfer in underlying \n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n\n        return (amount);\n    }\n\n    /// @notice Allows the admin to set a new admin\n    /// @param newAdmin Address of the new admin\n    function transferAdmin(address newAdmin) external onlyAdmin() returns (address) {\n\n        admin = newAdmin;\n\n        return (newAdmin);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'sender must be admin');\n        _;\n  }\n    \n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: UNLICENSED\n\npragma solidity >= 0.8.4;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n // IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\ncontract ERC20 {\n    /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n}\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\nlibrary SafeTransferLib {\n    /*///////////////////////////////////////////////////////////////\n                            ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool callStatus;\n\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 100 because the calldata length is 4 + 32 * 3.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool callStatus;\n\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata to memory piece by piece:\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\n\n            // Call the token and store if it succeeded or not.\n            // We use 68 because the calldata length is 4 + 32 * 2.\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\n        }\n\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                         INTERNAL HELPER LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\n        assembly {\n            // Get how many bytes the call returned.\n            let returnDataSize := returndatasize()\n\n            // If the call reverted:\n            if iszero(callStatus) {\n                // Copy the revert message into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Revert with the same message.\n                revert(0, returnDataSize)\n            }\n\n            switch returnDataSize\n            case 32 {\n                // Copy the return data into memory.\n                returndatacopy(0, 0, returnDataSize)\n\n                // Set success to whether it returned true.\n                success := iszero(iszero(mload(0)))\n            }\n            case 0 {\n                // There was no return data.\n                success := 1\n            }\n            default {\n                // It returned some malformed input.\n                success := 0\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\ncontract zcToken {\n\n   /*///////////////////////////////////////////////////////////////\n                                  EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    uint256 public immutable maturity;\n\n    address public underlying;\n\n    address public admin;\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*///////////////////////////////////////////////////////////////\n                           EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*///////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _maturity,\n        address _underlying\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        maturity = _maturity;\n        underlying = _underlying;\n\n        admin = msg.sender;\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        if (allowance[from][msg.sender] != type(uint256).max) {\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_PERMIT_SIGNATURE\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(bytes(\"1\")),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       EXTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function mint(address to, uint256 amount) external virtual onlyAdmin() {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function burn(address from, uint256 amount) external virtual onlyAdmin() {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'sender must be admin');\n        _;\n    }\n}\n\n// A factory to issue un-backed debt at a provided price (discount) in the form of zero-coupon bonds.\n// Utilizes solmate ERC20 & SafeTransfer, and intended to be used in tandem with @yieldprotocol/yieldspace-v2\ncontract Bondable {\n\n    address public admin;\n\n    /// @notice A market for a specific underlying token and maturity.\n    /// @param maximumDebt The maximum amount of debt that can be issued.\n    /// @param price The issuance price of the debt / bond.\n    /// @param mintedDebt The amount of debt that has been issued.\n    /// @param repaidDebt The amounf of debt that the has been repaid to the market (must repay before it can be redeemed).\n    /// @param redeemedDebt The amount of debt that has been redeemed back into underlying (after maturity).\n    /// @param bond The address of the issued zero-coupon bond contract.\n    /// @param name The name of the bond market (e.g. TRIBE-MAR, TRIBE-1648728318, or Tetranode-TRIBE-MAR for an indivudalized bond)\n    struct Market {\n        uint256 maximumDebt;\n        uint256 price;\n        uint256 mintedDebt;\n        uint256 repaidDebt;\n        uint256 redeemedDebt;\n        address bond;\n        string name;\n    }\n    \n    /// @notice A mapping of markets that have been created\n    /// address the address of the underlying token\n    /// uint256 the maturity (unix timestamp) of the market\n    mapping (address => mapping (uint256 => Market)) public markets;\n    \n    event marketCreated(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 maximumDebt, string name);\n\n    event bondMinted(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 mintedDebt);\n\n    event bondRepaid(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 repaidDebt);\n\n    event bondRedeemed(address indexed underlying, uint256 indexed maturity, address indexed bond, uint256 amount, uint256 redeemedDebt);\n    \n    constructor () {\n        admin = msg.sender;\n    }\n\n    /// @notice Can be called to create a new debt market for a given underlying token\n    /// @param underlying the address of the underlying token \n    /// @param maturity the maturity of the market\n    /// @param decimals the number of decimals in the underlying token\n    /// @param price the issuance price on the bonds (a decimal stored as a base 1e18 uint256, issuance accurate to 8 digits precision)\n    /// @param maximumDebt the maximum amount of debt/bonds to allow to be minted\n    function createMarket(address underlying, uint256 maturity, uint256 maximumDebt, uint256 price, uint8 decimals, string memory name, string memory symbol) external onlyAdmin() returns (address) {\n        \n        // check if the market already exists\n        require(markets[underlying][maturity].maximumDebt == 0, 'Market already exists');\n        // create the bond token\n        address bondAddress = address(new zcToken(name, symbol, decimals, maturity, underlying));\n        // create the market\n        markets[underlying][maturity] = Market(maximumDebt, price, 0, 0, 0, bondAddress, name);\n        // emit the event\n        emit marketCreated(underlying, maturity, bondAddress, maximumDebt, name);\n        \n        return (bondAddress);\n    }\n    \n    /// @notice Can be called to mint/purchase a new bond\n    /// @param underlying the address of the underlying token being lent\n    /// @param maturity the maturity of the market\n    /// @param amount the amount of underlying tokens to lend\n    function mint(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp <= maturity,'bond has already matured');       \n\n        // transfer in underlying\n        SafeTransferLib.safeTransferFrom(ERC20(underlying), msg.sender, address(this), amount);\n\n        // calculate amount of debt to mint (modifier = 1/price)\n        uint256 mintAmount = amount * (1e26 / _market.price) / 1e8;\n\n        // mint the bond\n        zcToken(_market.bond).mint(msg.sender, mintAmount);\n\n        // require that maximum debt has not been exceeded\n        uint256 newDebt = _market.mintedDebt + mintAmount;\n        require(newDebt <= _market.maximumDebt,'maximum debt exceeded');\n\n        // update the market\n        markets[underlying][maturity].mintedDebt = newDebt;\n\n        // emit the event\n        emit bondMinted(underlying, maturity, _market.bond, amount, newDebt);\n\n        return (mintAmount);\n    }\n\n    /// @notice Can be called after maturity to redeem debt owed\n    /// @param underlying the address of the underlying token being redeemed\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying tokens to redeem and bond tokens to burn\n    function redeem(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n        \n        Market memory _market = markets[underlying][maturity];\n\n        // check market maturity\n        require(block.timestamp >= maturity,'bond maturity has not been reached');\n\n        uint256 newRedeemedDebt = _market.redeemedDebt + amount;\n        // ensure market has enough repaid debt to redeem (first come first served)\n        require(newRedeemedDebt <= _market.repaidDebt,'total market claim exceeds debt repaid');\n        \n        // burn the bond\n        zcToken(_market.bond).burn(msg.sender, amount);\n\n        // update the market's redeemed debt\n        markets[underlying][maturity].redeemedDebt = newRedeemedDebt;\n\n        // emit the event\n        emit bondRedeemed(underlying, maturity, _market.bond, amount, newRedeemedDebt);\n\n        // transfer out underlying\n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n        \n        return (amount);\n    }\n\n    /// @notice Can be called to pay towards a certain market's debt (generally called by the debtor)\n    /// @param underlying the address of the underlying token being paid\n    /// @param maturity the maturity of the market being redeemed\n    /// @param amount the amount of underlying token debt to pay\n    function repay(address underlying, uint256 maturity, uint256 amount) external returns (uint256) {\n\n        Market memory _market = markets[underlying][maturity];\n\n        uint256 newRepaidDebt = _market.repaidDebt + amount;\n        // ensure market is not overpaying its debts\n        require(newRepaidDebt <= _market.mintedDebt,'can not repay more debt than is minted');\n\n        // update the market's repaid debt\n        markets[underlying][maturity].repaidDebt = newRepaidDebt;\n\n        // emit the event\n        emit bondRepaid(underlying, maturity, _market.bond, amount, newRepaidDebt);\n\n        // transfer in underlying \n        SafeTransferLib.safeTransfer(ERC20(underlying), msg.sender, amount);\n\n        return (amount);\n    }\n\n    /// @notice Allows the admin to set a new admin\n    /// @param newAdmin Address of the new admin\n    function transferAdmin(address newAdmin) external onlyAdmin() returns (address) {\n\n        admin = newAdmin;\n\n        return (newAdmin);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'sender must be admin');\n        _;\n  }\n    \n}\n", "commit_id": "9864c5aa2b6bf799258dcdded57f8974380987fb"}}