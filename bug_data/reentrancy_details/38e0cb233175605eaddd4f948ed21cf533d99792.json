{"filename": "contracts/core/DaoRegistry.sol", "patch": "@@ -110,6 +110,7 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n     struct ExtensionEntry {\n         bytes32 id;\n         mapping(address => uint256) acl;\n+        bool deleted;\n     }\n \n     /*\n@@ -147,8 +148,7 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n     uint256 public lockedAt;\n \n     /// @notice Clonable contract must have an empty constructor\n-    // constructor() {\n-    // }\n+    constructor() {}\n \n     /**\n      * @notice Initialises the DAO\n@@ -157,13 +157,13 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n      * @param creator The DAO's creator, who will be an initial member\n      * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n      */\n+    //slither-disable-next-line reentrancy-no-eth\n     function initialize(address creator, address payer) external {\n         require(!initialized, \"dao already initialized\");\n+        initialized = true;\n         potentialNewMember(msg.sender);\n         potentialNewMember(payer);\n         potentialNewMember(creator);\n-\n-        initialized = true;\n     }\n \n     /**\n@@ -182,12 +182,18 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         state = DaoState.READY;\n     }\n \n+    /**\n+     * @notice Contract lock strategy to lock only the caller is an adapter or extension.\n+     */\n     function lockSession() external {\n         if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n             lockedAt = block.number;\n         }\n     }\n \n+    /**\n+     * @notice Contract lock strategy to release the lock only the caller is an adapter or extension.\n+     */\n     function unlockSession() external {\n         if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n             lockedAt = 0;\n@@ -209,6 +215,10 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         emit ConfigurationUpdated(key, value);\n     }\n \n+    /**\n+     * @notice Registers a member address in the DAO if it is not registered or invalid.\n+     * @notice A potential new member is a member that holds no shares, and its registration still needs to be voted on.\n+     */\n     function potentialNewMember(address memberAddress)\n         public\n         hasAccess(this, AclFlag.NEW_MEMBER)\n@@ -275,27 +285,8 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n     }\n \n     /**\n-     * @notice Adds a new extension to the registry\n-     * @param extensionId The unique identifier of the new extension\n-     * @param extension The address of the extension\n-     * @param creator The DAO's creator, who will be an initial member\n+     * @notice It sets the ACL flags to an Adapter to make it possible to access specific functions of an Extension.\n      */\n-    function addExtension(\n-        bytes32 extensionId,\n-        IExtension extension,\n-        address creator\n-    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n-        require(extensionId != bytes32(0), \"extension id must not be empty\");\n-        require(\n-            extensions[extensionId] == address(0x0),\n-            \"extension Id already in use\"\n-        );\n-        extensions[extensionId] = address(extension);\n-        inverseExtensions[address(extension)].id = extensionId;\n-        extension.initialize(this, creator);\n-        emit ExtensionAdded(extensionId, address(extension));\n-    }\n-\n     function setAclToExtensionForAdapter(\n         address extensionAddress,\n         address adapterAddress,\n@@ -352,6 +343,32 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         }\n     }\n \n+    /**\n+     * @notice Adds a new extension to the registry\n+     * @param extensionId The unique identifier of the new extension\n+     * @param extension The address of the extension\n+     * @param creator The DAO's creator, who will be an initial member\n+     */\n+    function addExtension(\n+        bytes32 extensionId,\n+        IExtension extension,\n+        address creator\n+    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n+        require(extensionId != bytes32(0), \"extension id must not be empty\");\n+        require(\n+            extensions[extensionId] == address(0x0),\n+            \"extension Id already in use\"\n+        );\n+        require(\n+            !inverseExtensions[address(extension)].deleted,\n+            \"extension can not be re-added\"\n+        );\n+        extensions[extensionId] = address(extension);\n+        inverseExtensions[address(extension)].id = extensionId;\n+        extension.initialize(this, creator);\n+        emit ExtensionAdded(extensionId, address(extension));\n+    }\n+\n     /**\n      * @notice Removes an adapter from the registry\n      * @param extensionId The unique identifier of the extension\n@@ -361,11 +378,12 @@ contract DaoRegistry is MemberGuard, AdapterGuard {\n         hasAccess(this, AclFlag.REMOVE_EXTENSION)\n     {\n         require(extensionId != bytes32(0), \"extensionId must not be empty\");\n-        require(\n-            extensions[extensionId] != address(0x0),\n-            \"extensionId not registered\"\n-        );\n-        delete inverseExtensions[extensions[extensionId]];\n+        address extensionAddress = extensions[extensionId];\n+        require(extensionAddress != address(0x0), \"extensionId not registered\");\n+        ExtensionEntry storage extEntry = inverseExtensions[extensionAddress];\n+        extEntry.deleted = true;\n+        //slither-disable-next-line mapping-deletion\n+        delete inverseExtensions[extensionAddress];\n         delete extensions[extensionId];\n         emit ExtensionRemoved(extensionId);\n     }", "project_link": "https://github.com/openlawteam/tribute-contracts/commit/38e0cb233175605eaddd4f948ed21cf533d99792", "bug_version": {"raw_code": "pragma solidity ^0.8.0;\n\n// SPDX-License-Identifier: MIT\n\nimport \"../guards/AdapterGuard.sol\";\nimport \"../guards/MemberGuard.sol\";\nimport \"../extensions/IExtension.sol\";\nimport \"../helpers/DaoHelper.sol\";\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract DaoRegistry is MemberGuard, AdapterGuard {\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n\n    enum DaoState {CREATION, READY}\n\n    /*\n     * EVENTS\n     */\n    /// @dev - Events for Proposals\n    event SubmittedProposal(bytes32 proposalId, uint256 flags);\n    event SponsoredProposal(\n        bytes32 proposalId,\n        uint256 flags,\n        address votingAdapter\n    );\n    event ProcessedProposal(bytes32 proposalId, uint256 flags);\n    event AdapterAdded(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint256 flags\n    );\n    event AdapterRemoved(bytes32 adapterId);\n\n    event ExtensionAdded(bytes32 extensionId, address extensionAddress);\n    event ExtensionRemoved(bytes32 extensionId);\n\n    /// @dev - Events for Members\n    event UpdateDelegateKey(address memberAddress, address newDelegateKey);\n    event ConfigurationUpdated(bytes32 key, uint256 value);\n    event AddressConfigurationUpdated(bytes32 key, address value);\n\n    enum MemberFlag {EXISTS}\n\n    enum ProposalFlag {EXISTS, SPONSORED, PROCESSED}\n\n    enum AclFlag {\n        REPLACE_ADAPTER,\n        SUBMIT_PROPOSAL,\n        UPDATE_DELEGATE_KEY,\n        SET_CONFIGURATION,\n        ADD_EXTENSION,\n        REMOVE_EXTENSION,\n        NEW_MEMBER\n    }\n\n    /*\n     * STRUCTURES\n     */\n    struct Proposal {\n        // the structure to track all the proposals in the DAO\n        address adapterAddress; // the adapter address that called the functions to change the DAO state\n        uint256 flags; // flags to track the state of the proposal: exist, sponsored, processed, canceled, etc.\n    }\n\n    struct Member {\n        // the structure to track all the members in the DAO\n        uint256 flags; // flags to track the state of the member: exists, etc\n    }\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    struct DelegateCheckpoint {\n        // A checkpoint for marking the delegate key for a member from a given block\n        uint96 fromBlock;\n        address delegateKey;\n    }\n\n    struct AdapterEntry {\n        bytes32 id;\n        uint256 acl;\n    }\n\n    struct ExtensionEntry {\n        bytes32 id;\n        mapping(address => uint256) acl;\n    }\n\n    /*\n     * PUBLIC VARIABLES\n     */\n    mapping(address => Member) public members; // the map to track all members of the DAO\n    address[] private _members;\n\n    // delegate key => member address mapping\n    mapping(address => address) public memberAddressesByDelegatedKey;\n\n    // memberAddress => checkpointNum => DelegateCheckpoint\n    mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints;\n    // memberAddress => numDelegateCheckpoints\n    mapping(address => uint32) numCheckpoints;\n\n    DaoState public state;\n\n    /// @notice The map that keeps track of all proposasls submitted to the DAO\n    mapping(bytes32 => Proposal) public proposals;\n    /// @notice The map that tracks the voting adapter address per proposalId\n    mapping(bytes32 => address) public votingAdapter;\n    /// @notice The map that keeps track of all adapters registered in the DAO\n    mapping(bytes32 => address) public adapters;\n    /// @notice The inverse map to get the adapter id based on its address\n    mapping(address => AdapterEntry) public inverseAdapters;\n    /// @notice The map that keeps track of all extensions registered in the DAO\n    mapping(bytes32 => address) public extensions;\n    /// @notice The inverse map to get the extension id based on its address\n    mapping(address => ExtensionEntry) public inverseExtensions;\n    /// @notice The map that keeps track of configuration parameters for the DAO and adapters\n    mapping(bytes32 => uint256) public mainConfiguration;\n    mapping(bytes32 => address) public addressConfiguration;\n\n    uint256 public lockedAt;\n\n    /// @notice Clonable contract must have an empty constructor\n    // constructor() {\n    // }\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n     */\n    function initialize(address creator, address payer) external {\n        require(!initialized, \"dao already initialized\");\n        potentialNewMember(msg.sender);\n        potentialNewMember(payer);\n        potentialNewMember(creator);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice default fallback function to prevent from sending ether to the contract\n     */\n    // The transaction is always reverted, so there are no risks of locking ether in the contract\n    //slither-disable-next-line locked-ether\n    receive() external payable {\n        revert(\"you cannot send money back directly\");\n    }\n\n    /**\n     * @dev Sets the state of the dao to READY\n     */\n    function finalizeDao() external {\n        state = DaoState.READY;\n    }\n\n    function lockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = block.number;\n        }\n    }\n\n    function unlockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = 0;\n        }\n    }\n\n    /**\n     * @notice Sets a configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setConfiguration(bytes32 key, uint256 value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        mainConfiguration[key] = value;\n\n        emit ConfigurationUpdated(key, value);\n    }\n\n    function potentialNewMember(address memberAddress)\n        public\n        hasAccess(this, AclFlag.NEW_MEMBER)\n    {\n        require(memberAddress != address(0x0), \"invalid member address\");\n\n        Member storage member = members[memberAddress];\n        if (!DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS))) {\n            require(\n                memberAddressesByDelegatedKey[memberAddress] == address(0x0),\n                \"member address already taken as delegated key\"\n            );\n            member.flags = DaoHelper.setFlag(\n                member.flags,\n                uint8(MemberFlag.EXISTS),\n                true\n            );\n            memberAddressesByDelegatedKey[memberAddress] = memberAddress;\n            _members.push(memberAddress);\n        }\n\n        address bankAddress = extensions[DaoHelper.BANK];\n        if (bankAddress != address(0x0)) {\n            BankExtension bank = BankExtension(bankAddress);\n            if (bank.balanceOf(memberAddress, DaoHelper.MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, DaoHelper.MEMBER_COUNT, 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets an configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setAddressConfiguration(bytes32 key, address value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        addressConfiguration[key] = value;\n\n        emit AddressConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getConfiguration(bytes32 key) external view returns (uint256) {\n        return mainConfiguration[key];\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getAddressConfiguration(bytes32 key)\n        external\n        view\n        returns (address)\n    {\n        return addressConfiguration[key];\n    }\n\n    /**\n     * @notice Adds a new extension to the registry\n     * @param extensionId The unique identifier of the new extension\n     * @param extension The address of the extension\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function addExtension(\n        bytes32 extensionId,\n        IExtension extension,\n        address creator\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(extensionId != bytes32(0), \"extension id must not be empty\");\n        require(\n            extensions[extensionId] == address(0x0),\n            \"extension Id already in use\"\n        );\n        extensions[extensionId] = address(extension);\n        inverseExtensions[address(extension)].id = extensionId;\n        extension.initialize(this, creator);\n        emit ExtensionAdded(extensionId, address(extension));\n    }\n\n    function setAclToExtensionForAdapter(\n        address extensionAddress,\n        address adapterAddress,\n        uint256 acl\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(isAdapter(adapterAddress), \"not an adapter\");\n        require(isExtension(extensionAddress), \"not an extension\");\n        inverseExtensions[extensionAddress].acl[adapterAddress] = acl;\n    }\n\n    /**\n     * @notice Replaces an adapter in the registry in a single step.\n     * @notice It handles addition and removal of adapters as special cases.\n     * @dev It removes the current adapter if the adapterId maps to an existing adapter address.\n     * @dev It adds an adapter if the adapterAddress parameter is not zeroed.\n     * @param adapterId The unique identifier of the adapter\n     * @param adapterAddress The address of the new adapter or zero if it is a removal operation\n     * @param acl The flags indicating the access control layer or permissions of the new adapter\n     * @param keys The keys indicating the adapter configuration names.\n     * @param values The values indicating the adapter configuration values.\n     */\n    function replaceAdapter(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint128 acl,\n        bytes32[] calldata keys,\n        uint256[] calldata values\n    ) external hasAccess(this, AclFlag.REPLACE_ADAPTER) {\n        require(adapterId != bytes32(0), \"adapterId must not be empty\");\n\n        address currentAdapterAddr = adapters[adapterId];\n        if (currentAdapterAddr != address(0x0)) {\n            delete inverseAdapters[currentAdapterAddr];\n            delete adapters[adapterId];\n            emit AdapterRemoved(adapterId);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            bytes32 key = keys[i];\n            uint256 value = values[i];\n            mainConfiguration[key] = value;\n            emit ConfigurationUpdated(key, value);\n        }\n\n        if (adapterAddress != address(0x0)) {\n            require(\n                inverseAdapters[adapterAddress].id == bytes32(0),\n                \"adapterAddress already in use\"\n            );\n            adapters[adapterId] = adapterAddress;\n            inverseAdapters[adapterAddress].id = adapterId;\n            inverseAdapters[adapterAddress].acl = acl;\n            emit AdapterAdded(adapterId, adapterAddress, acl);\n        }\n    }\n\n    /**\n     * @notice Removes an adapter from the registry\n     * @param extensionId The unique identifier of the extension\n     */\n    function removeExtension(bytes32 extensionId)\n        external\n        hasAccess(this, AclFlag.REMOVE_EXTENSION)\n    {\n        require(extensionId != bytes32(0), \"extensionId must not be empty\");\n        require(\n            extensions[extensionId] != address(0x0),\n            \"extensionId not registered\"\n        );\n        delete inverseExtensions[extensions[extensionId]];\n        delete extensions[extensionId];\n        emit ExtensionRemoved(extensionId);\n    }\n\n    /**\n     * @notice Looks up if there is an extension of a given address\n     * @return Whether or not the address is an extension\n     * @param extensionAddr The address to look up\n     */\n    function isExtension(address extensionAddr) public view returns (bool) {\n        return inverseExtensions[extensionAddr].id != bytes32(0);\n    }\n\n    /**\n     * @notice Looks up if there is an adapter of a given address\n     * @return Whether or not the address is an adapter\n     * @param adapterAddress The address to look up\n     */\n    function isAdapter(address adapterAddress) public view returns (bool) {\n        return inverseAdapters[adapterAddress].id != bytes32(0);\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccess(address adapterAddress, AclFlag flag)\n        external\n        view\n        returns (bool)\n    {\n        return\n            DaoHelper.getFlag(inverseAdapters[adapterAddress].acl, uint8(flag));\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccessToExtension(\n        address adapterAddress,\n        address extensionAddress,\n        uint8 flag\n    ) external view returns (bool) {\n        return\n            isAdapter(adapterAddress) &&\n            DaoHelper.getFlag(\n                inverseExtensions[extensionAddress].acl[adapterAddress],\n                uint8(flag)\n            );\n    }\n\n    /**\n     * @return The address of a given adapter ID\n     * @param adapterId The ID to look up\n     */\n    function getAdapterAddress(bytes32 adapterId)\n        external\n        view\n        returns (address)\n    {\n        require(adapters[adapterId] != address(0), \"adapter not found\");\n        return adapters[adapterId];\n    }\n\n    /**\n     * @return The address of a given extension Id\n     * @param extensionId The ID to look up\n     */\n    function getExtensionAddress(bytes32 extensionId)\n        external\n        view\n        returns (address)\n    {\n        require(extensions[extensionId] != address(0), \"extension not found\");\n        return extensions[extensionId];\n    }\n\n    /**\n     * PROPOSALS\n     */\n    /**\n     * @notice Submit proposals to the DAO registry\n     */\n    function submitProposal(bytes32 proposalId)\n        external\n        hasAccess(this, AclFlag.SUBMIT_PROPOSAL)\n    {\n        require(proposalId != bytes32(0), \"invalid proposalId\");\n        require(\n            !getProposalFlag(proposalId, ProposalFlag.EXISTS),\n            \"proposalId must be unique\"\n        );\n        proposals[proposalId] = Proposal(msg.sender, 1); // 1 means that only the first flag is being set i.e. EXISTS\n        emit SubmittedProposal(proposalId, 1);\n    }\n\n    /**\n     * @notice Sponsor proposals that were submitted to the DAO registry\n     * @dev adds SPONSORED to the proposal flag\n     * @param proposalId The ID of the proposal to sponsor\n     * @param sponsoringMember The member who is sponsoring the proposal\n     */\n    function sponsorProposal(\n        bytes32 proposalId,\n        address sponsoringMember,\n        address votingAdapterAddr\n    ) external onlyMember2(this, sponsoringMember) {\n        // also checks if the flag was already set\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.SPONSORED);\n\n        uint256 flags = proposal.flags;\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can process it\"\n        );\n\n        require(\n            !DaoHelper.getFlag(flags, uint8(ProposalFlag.PROCESSED)),\n            \"proposal already processed\"\n        );\n        votingAdapter[proposalId] = votingAdapterAddr;\n        emit SponsoredProposal(proposalId, flags, votingAdapterAddr);\n    }\n\n    /**\n     * @notice Mark a proposal as processed in the DAO registry\n     * @param proposalId The ID of the proposal that is being processed\n     */\n    function processProposal(bytes32 proposalId) external {\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.PROCESSED);\n\n        require(proposal.adapterAddress == msg.sender, \"err::adapter mismatch\");\n        uint256 flags = proposal.flags;\n\n        emit ProcessedProposal(proposalId, flags);\n    }\n\n    /**\n     * @notice Sets a flag of a proposal\n     * @dev Reverts if the proposal is already processed\n     * @param proposalId The ID of the proposal to be changed\n     * @param flag The flag that will be set on the proposal\n     */\n    function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        internal\n        returns (Proposal storage)\n    {\n        Proposal storage proposal = proposals[proposalId];\n\n        uint256 flags = proposal.flags;\n        require(\n            DaoHelper.getFlag(flags, uint8(ProposalFlag.EXISTS)),\n            \"proposal does not exist for this dao\"\n        );\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can set its flag\"\n        );\n\n        require(!DaoHelper.getFlag(flags, uint8(flag)), \"flag already set\");\n\n        flags = DaoHelper.setFlag(flags, uint8(flag), true);\n        proposals[proposalId].flags = flags;\n\n        return proposals[proposalId];\n    }\n\n    /*\n     * MEMBERS\n     */\n\n    /**\n     * @return Whether or not a given address is a member of the DAO.\n     * @dev it will resolve by delegate key, not member address.\n     * @param addr The address to look up\n     */\n    function isMember(address addr) external view returns (bool) {\n        address memberAddress = memberAddressesByDelegatedKey[addr];\n        return getMemberFlag(memberAddress, MemberFlag.EXISTS);\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given proposal\n     * @param proposalId The proposal to check against flag\n     * @param flag The flag to check in the proposal\n     */\n    function getProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(proposals[proposalId].flags, uint8(flag));\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given member\n     * @param memberAddress The member to check against flag\n     * @param flag The flag to check in the member\n     */\n    function getMemberFlag(address memberAddress, MemberFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(members[memberAddress].flags, uint8(flag));\n    }\n\n    function getNbMembers() external view returns (uint256) {\n        return _members.length;\n    }\n\n    function getMemberAddress(uint256 index) external view returns (address) {\n        return _members[index];\n    }\n\n    /**\n     * @notice Updates the delegate key of a member\n     * @param memberAddr The member doing the delegation\n     * @param newDelegateKey The member who is being delegated to\n     */\n    function updateDelegateKey(address memberAddr, address newDelegateKey)\n        external\n        hasAccess(this, AclFlag.UPDATE_DELEGATE_KEY)\n    {\n        require(newDelegateKey != address(0x0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != memberAddr) {\n            require(\n                // newDelegate must not be delegated to\n                memberAddressesByDelegatedKey[newDelegateKey] == address(0x0),\n                \"cannot overwrite existing delegated keys\"\n            );\n        } else {\n            require(\n                memberAddressesByDelegatedKey[memberAddr] == address(0x0),\n                \"address already taken as delegated key\"\n            );\n        }\n\n        Member storage member = members[memberAddr];\n        require(\n            DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS)),\n            \"member does not exist\"\n        );\n\n        // Reset the delegation of the previous delegate\n        memberAddressesByDelegatedKey[\n            getCurrentDelegateKey(memberAddr)\n        ] = address(0x0);\n\n        memberAddressesByDelegatedKey[newDelegateKey] = memberAddr;\n\n        _createNewDelegateCheckpoint(memberAddr, newDelegateKey);\n        emit UpdateDelegateKey(memberAddr, newDelegateKey);\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * @param checkAddr The address to check for a delegate\n     * @return the delegated address or the checked address if it is not a delegate\n     */\n    function getAddressIfDelegated(address checkAddr)\n        external\n        view\n        returns (address)\n    {\n        address delegatedKey = memberAddressesByDelegatedKey[checkAddr];\n        return delegatedKey == address(0x0) ? checkAddr : delegatedKey;\n    }\n\n    /**\n     * @param memberAddr The member whose delegate will be returned\n     * @return the delegate key at the current time for a member\n     */\n    function getCurrentDelegateKey(address memberAddr)\n        public\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 0\n                ? checkpoints[memberAddr][nCheckpoints - 1].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @param memberAddr The member address to look up\n     * @return The delegate key address for memberAddr at the second last checkpoint number\n     */\n    function getPreviousDelegateKey(address memberAddr)\n        external\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 1\n                ? checkpoints[memberAddr][nCheckpoints - 2].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param memberAddr The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorDelegateKey(address memberAddr, uint256 blockNumber)\n        external\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorDelegateKey: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        if (nCheckpoints == 0) {\n            return memberAddr;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[memberAddr][nCheckpoints - 1].fromBlock <= blockNumber\n        ) {\n            return checkpoints[memberAddr][nCheckpoints - 1].delegateKey;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[memberAddr][0].fromBlock > blockNumber) {\n            return memberAddr;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DelegateCheckpoint memory cp = checkpoints[memberAddr][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegateKey;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[memberAddr][lower].delegateKey;\n    }\n\n    /**\n     * @notice Creates a new delegate checkpoint of a certain member\n     * @param member The member whose delegate checkpoints will be added to\n     * @param newDelegateKey The delegate key that will be written into the new checkpoint\n     */\n    function _createNewDelegateCheckpoint(\n        address member,\n        address newDelegateKey\n    ) internal {\n        uint32 nCheckpoints = numCheckpoints[member];\n        // The only condition that we should allow the deletegaKey upgrade\n        // is when the block.number exactly matches the fromBlock value.\n        // Anything different from that should generate a new checkpoint.\n        if (\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[member][nCheckpoints - 1].fromBlock == block.number\n        ) {\n            checkpoints[member][nCheckpoints - 1].delegateKey = newDelegateKey;\n        } else {\n            checkpoints[member][nCheckpoints] = DelegateCheckpoint(\n                uint96(block.number),\n                newDelegateKey\n            );\n            numCheckpoints[member] = nCheckpoints + 1;\n        }\n    }\n}\n", "flattened_code": "pragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ninterface IExtension {\n    function initialize(DaoRegistry dao, address creator) external;\n}\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\n/**\nMIT License\n\nCopyright (c) 2021 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nlibrary DaoHelper {\n    // Adapters\n    bytes32 internal constant VOTING = keccak256(\"voting\");\n    bytes32 internal constant ONBOARDING = keccak256(\"onboarding\");\n    bytes32 internal constant NONVOTING_ONBOARDING =\n        keccak256(\"nonvoting-onboarding\");\n    bytes32 internal constant TRIBUTE = keccak256(\"tribute\");\n    bytes32 internal constant FINANCING = keccak256(\"financing\");\n    bytes32 internal constant MANAGING = keccak256(\"managing\");\n    bytes32 internal constant RAGEQUIT = keccak256(\"ragequit\");\n    bytes32 internal constant GUILDKICK = keccak256(\"guildkick\");\n    bytes32 internal constant CONFIGURATION = keccak256(\"configuration\");\n    bytes32 internal constant DISTRIBUTE = keccak256(\"distribute\");\n    bytes32 internal constant TRIBUTE_NFT = keccak256(\"tribute-nft\");\n    bytes32 internal constant TRANSFER_STRATEGY =\n        keccak256(\"erc20-transfer-strategy\");\n    bytes32 internal constant ERC1155_ADAPT = keccak256(\"erc1155-adpt\");\n\n    // Extensions\n    bytes32 internal constant BANK = keccak256(\"bank\");\n    bytes32 internal constant ERC1271 = keccak256(\"erc1271\");\n    bytes32 internal constant NFT = keccak256(\"nft\");\n    bytes32 internal constant EXECUTOR_EXT = keccak256(\"executor-ext\");\n    bytes32 internal constant INTERNAL_TOKEN_VESTING_EXT =\n        keccak256(\"internal-token-vesting-extension\");\n    bytes32 internal constant ERC1155_EXT = keccak256(\"erc1155-ext\");\n\n    // Reserved Addresses\n    address internal constant GUILD = address(0xdead);\n    address internal constant ESCROW = address(0x4bec);\n    address internal constant TOTAL = address(0xbabe);\n    address internal constant UNITS = address(0xFF1CE);\n    address internal constant LOCKED_UNITS = address(0xFFF1CE);\n    address internal constant LOOT = address(0xB105F00D);\n    address internal constant LOCKED_LOOT = address(0xBB105F00D);\n    address internal constant ETH_TOKEN = address(0x0);\n    address internal constant MEMBER_COUNT = address(0xDECAFBAD);\n\n    uint8 internal constant MAX_TOKENS_GUILD_BANK = 200;\n\n    function totalTokens(BankExtension bank) internal view returns (uint256) {\n        return memberTokens(bank, TOTAL) - memberTokens(bank, GUILD); //GUILD is accounted for twice otherwise\n    }\n\n    /**\n     * @notice calculates the total number of units.\n     */\n    function priorTotalTokens(BankExtension bank, uint256 at)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            priorMemberTokens(bank, TOTAL, at) -\n            priorMemberTokens(bank, GUILD, at);\n    }\n\n    function memberTokens(BankExtension bank, address member)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            bank.balanceOf(member, UNITS) +\n            bank.balanceOf(member, LOCKED_UNITS) +\n            bank.balanceOf(member, LOOT) +\n            bank.balanceOf(member, LOCKED_LOOT);\n    }\n\n    /**\n     * @notice calculates the total number of units.\n     */\n    function priorMemberTokens(\n        BankExtension bank,\n        address member,\n        uint256 at\n    ) internal view returns (uint256) {\n        return\n            bank.getPriorAmount(member, UNITS, at) +\n            bank.getPriorAmount(member, LOCKED_UNITS, at) +\n            bank.getPriorAmount(member, LOOT, at) +\n            bank.getPriorAmount(member, LOCKED_LOOT, at);\n    }\n\n    //helper\n    function getFlag(uint256 flags, uint256 flag) internal pure returns (bool) {\n        return (flags >> uint8(flag)) % 2 == 1;\n    }\n\n    function setFlag(\n        uint256 flags,\n        uint256 flag,\n        bool value\n    ) internal pure returns (uint256) {\n        if (getFlag(flags, flag) != value) {\n            if (value) {\n                return flags + 2**flag;\n            } else {\n                return flags - 2**flag;\n            }\n        } else {\n            return flags;\n        }\n    }\n\n    /**\n     * @notice Checks if a given address is reserved.\n     */\n    function isNotReservedAddress(address addr) internal pure returns (bool) {\n        return addr != GUILD && addr != TOTAL && addr != ESCROW;\n    }\n\n    /**\n     * @notice Checks if a given address is zeroed.\n     */\n    function isNotZeroAddress(address addr) internal pure returns (bool) {\n        return addr != address(0x0);\n    }\n\n    function potentialNewMember(\n        address memberAddress,\n        DaoRegistry dao,\n        BankExtension bank\n    ) internal {\n        dao.potentialNewMember(memberAddress);\n        require(memberAddress != address(0x0), \"invalid member address\");\n        if (address(bank) != address(0x0)) {\n            if (bank.balanceOf(memberAddress, MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, MEMBER_COUNT, 1);\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract BankExtension is AdapterGuard, IExtension {\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n\n    uint8 public maxExternalTokens; // the maximum number of external tokens that can be stored in the bank\n\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n    DaoRegistry public dao;\n\n    enum AclFlag {\n        ADD_TO_BALANCE,\n        SUB_FROM_BALANCE,\n        INTERNAL_TRANSFER,\n        WITHDRAW,\n        REGISTER_NEW_TOKEN,\n        REGISTER_NEW_INTERNAL_TOKEN,\n        UPDATE_TOKEN\n    }\n\n    modifier noProposal() {\n        require(dao.lockedAt() < block.number, \"proposal lock\");\n        _;\n    }\n\n    /// @dev - Events for Bank\n    event NewBalance(address member, address tokenAddr, uint160 amount);\n\n    event Withdraw(address account, address tokenAddr, uint160 amount);\n\n    /*\n     * STRUCTURES\n     */\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    address[] public tokens;\n    address[] public internalTokens;\n    // tokenAddress => availability\n    mapping(address => bool) public availableTokens;\n    mapping(address => bool) public availableInternalTokens;\n    // tokenAddress => memberAddress => checkpointNum => Checkpoint\n    mapping(address => mapping(address => mapping(uint32 => Checkpoint)))\n        public checkpoints;\n    // tokenAddress => memberAddress => numCheckpoints\n    mapping(address => mapping(address => uint32)) public numCheckpoints;\n\n    /// @notice Clonable contract must have an empty constructor\n    constructor() {}\n\n    modifier hasExtensionAccess(AclFlag flag) {\n        require(\n            address(this) == msg.sender ||\n                address(dao) == msg.sender ||\n                dao.state() == DaoRegistry.DaoState.CREATION ||\n                dao.hasAdapterAccessToExtension(\n                    msg.sender,\n                    address(this),\n                    uint8(flag)\n                ),\n            \"bank::accessDenied\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function initialize(DaoRegistry _dao, address creator) external override {\n        require(!initialized, \"bank already initialized\");\n        require(_dao.isMember(creator), \"bank::not member\");\n        dao = _dao;\n        initialized = true;\n\n        availableInternalTokens[DaoHelper.UNITS] = true;\n        internalTokens.push(DaoHelper.UNITS);\n\n        availableInternalTokens[DaoHelper.MEMBER_COUNT] = true;\n        internalTokens.push(DaoHelper.MEMBER_COUNT);\n        uint256 nbMembers = _dao.getNbMembers();\n        for (uint256 i = 0; i < nbMembers; i++) {\n            addToBalance(_dao.getMemberAddress(i), DaoHelper.MEMBER_COUNT, 1);\n        }\n\n        _createNewAmountCheckpoint(creator, DaoHelper.UNITS, 1);\n        _createNewAmountCheckpoint(DaoHelper.TOTAL, DaoHelper.UNITS, 1);\n    }\n\n    function withdraw(\n        address payable member,\n        address tokenAddr,\n        uint256 amount\n    ) external hasExtensionAccess(AclFlag.WITHDRAW) {\n        require(\n            balanceOf(member, tokenAddr) >= amount,\n            \"bank::withdraw::not enough funds\"\n        );\n        subtractFromBalance(member, tokenAddr, amount);\n        if (tokenAddr == DaoHelper.ETH_TOKEN) {\n            member.sendValue(amount);\n        } else {\n            IERC20 erc20 = IERC20(tokenAddr);\n            erc20.safeTransfer(member, amount);\n        }\n\n        emit Withdraw(member, tokenAddr, uint160(amount));\n    }\n\n    /**\n     * @return Whether or not the given token is an available internal token in the bank\n     * @param token The address of the token to look up\n     */\n    function isInternalToken(address token) external view returns (bool) {\n        return availableInternalTokens[token];\n    }\n\n    /**\n     * @return Whether or not the given token is an available token in the bank\n     * @param token The address of the token to look up\n     */\n    function isTokenAllowed(address token) public view returns (bool) {\n        return availableTokens[token];\n    }\n\n    /**\n     * @notice Sets the maximum amount of external tokens allowed in the bank\n     * @param maxTokens The maximum amount of token allowed\n     */\n    function setMaxExternalTokens(uint8 maxTokens) external {\n        require(!initialized, \"bank already initialized\");\n        require(\n            maxTokens > 0 && maxTokens <= DaoHelper.MAX_TOKENS_GUILD_BANK,\n            \"max number of external tokens should be (0,200)\"\n        );\n        maxExternalTokens = maxTokens;\n    }\n\n    /*\n     * BANK\n     */\n\n    /**\n     * @notice Registers a potential new token in the bank\n     * @dev Cannot be a reserved token or an available internal token\n     * @param token The address of the token\n     */\n    function registerPotentialNewToken(address token)\n        external\n        hasExtensionAccess(AclFlag.REGISTER_NEW_TOKEN)\n    {\n        require(DaoHelper.isNotReservedAddress(token), \"reservedToken\");\n        require(!availableInternalTokens[token], \"internalToken\");\n        require(\n            tokens.length <= maxExternalTokens,\n            \"exceeds the maximum tokens allowed\"\n        );\n\n        if (!availableTokens[token]) {\n            availableTokens[token] = true;\n            tokens.push(token);\n        }\n    }\n\n    /**\n     * @notice Registers a potential new internal token in the bank\n     * @dev Can not be a reserved token or an available token\n     * @param token The address of the token\n     */\n    function registerPotentialNewInternalToken(address token)\n        external\n        hasExtensionAccess(AclFlag.REGISTER_NEW_INTERNAL_TOKEN)\n    {\n        require(DaoHelper.isNotReservedAddress(token), \"reservedToken\");\n        require(!availableTokens[token], \"availableToken\");\n\n        if (!availableInternalTokens[token]) {\n            availableInternalTokens[token] = true;\n            internalTokens.push(token);\n        }\n    }\n\n    function updateToken(address tokenAddr)\n        external\n        hasExtensionAccess(AclFlag.UPDATE_TOKEN)\n    {\n        require(isTokenAllowed(tokenAddr), \"token not allowed\");\n        uint256 totalBalance = balanceOf(DaoHelper.TOTAL, tokenAddr);\n\n        uint256 realBalance;\n\n        if (tokenAddr == DaoHelper.ETH_TOKEN) {\n            realBalance = address(this).balance;\n        } else {\n            IERC20 erc20 = IERC20(tokenAddr);\n            realBalance = erc20.balanceOf(address(this));\n        }\n\n        if (totalBalance < realBalance) {\n            addToBalance(\n                DaoHelper.GUILD,\n                tokenAddr,\n                realBalance - totalBalance\n            );\n        } else if (totalBalance > realBalance) {\n            uint256 tokensToRemove = totalBalance - realBalance;\n            uint256 guildBalance = balanceOf(DaoHelper.GUILD, tokenAddr);\n            if (guildBalance > tokensToRemove) {\n                subtractFromBalance(DaoHelper.GUILD, tokenAddr, tokensToRemove);\n            } else {\n                subtractFromBalance(DaoHelper.GUILD, tokenAddr, guildBalance);\n            }\n        }\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * Internal bookkeeping\n     */\n\n    /**\n     * @return The token from the bank of a given index\n     * @param index The index to look up in the bank's tokens\n     */\n    function getToken(uint256 index) external view returns (address) {\n        return tokens[index];\n    }\n\n    /**\n     * @return The amount of token addresses in the bank\n     */\n    function nbTokens() external view returns (uint256) {\n        return tokens.length;\n    }\n\n    /**\n     * @return All the tokens registered in the bank.\n     */\n    function getTokens() external view returns (address[] memory) {\n        return tokens;\n    }\n\n    /**\n     * @return The internal token at a given index\n     * @param index The index to look up in the bank's array of internal tokens\n     */\n    function getInternalToken(uint256 index) external view returns (address) {\n        return internalTokens[index];\n    }\n\n    /**\n     * @return The amount of internal token addresses in the bank\n     */\n    function nbInternalTokens() external view returns (uint256) {\n        return internalTokens.length;\n    }\n\n    /**\n     * @notice Adds to a member's balance of a given token\n     * @param member The member whose balance will be updated\n     * @param token The token to update\n     * @param amount The new balance\n     */\n    function addToBalance(\n        address member,\n        address token,\n        uint256 amount\n    ) public payable hasExtensionAccess(AclFlag.ADD_TO_BALANCE) {\n        require(\n            availableTokens[token] || availableInternalTokens[token],\n            \"unknown token address\"\n        );\n        uint256 newAmount = balanceOf(member, token) + amount;\n        uint256 newTotalAmount = balanceOf(DaoHelper.TOTAL, token) + amount;\n\n        _createNewAmountCheckpoint(member, token, newAmount);\n        _createNewAmountCheckpoint(DaoHelper.TOTAL, token, newTotalAmount);\n    }\n\n    /**\n     * @notice Remove from a member's balance of a given token\n     * @param member The member whose balance will be updated\n     * @param token The token to update\n     * @param amount The new balance\n     */\n    function subtractFromBalance(\n        address member,\n        address token,\n        uint256 amount\n    ) public hasExtensionAccess(AclFlag.SUB_FROM_BALANCE) {\n        uint256 newAmount = balanceOf(member, token) - amount;\n        uint256 newTotalAmount = balanceOf(DaoHelper.TOTAL, token) - amount;\n\n        _createNewAmountCheckpoint(member, token, newAmount);\n        _createNewAmountCheckpoint(DaoHelper.TOTAL, token, newTotalAmount);\n    }\n\n    /**\n     * @notice Make an internal token transfer\n     * @param from The member who is sending tokens\n     * @param to The member who is receiving tokens\n     * @param amount The new amount to transfer\n     */\n    function internalTransfer(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) external hasExtensionAccess(AclFlag.INTERNAL_TRANSFER) {\n        uint256 newAmount = balanceOf(from, token) - amount;\n        uint256 newAmount2 = balanceOf(to, token) + amount;\n\n        _createNewAmountCheckpoint(from, token, newAmount);\n        _createNewAmountCheckpoint(to, token, newAmount2);\n    }\n\n    /**\n     * @notice Returns an member's balance of a given token\n     * @param member The address to look up\n     * @param tokenAddr The token where the member's balance of which will be returned\n     * @return The amount in account's tokenAddr balance\n     */\n    function balanceOf(address member, address tokenAddr)\n        public\n        view\n        returns (uint160)\n    {\n        uint32 nCheckpoints = numCheckpoints[tokenAddr][member];\n        return\n            nCheckpoints > 0\n                ? checkpoints[tokenAddr][member][nCheckpoints - 1].amount\n                : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorAmount(\n        address account,\n        address tokenAddr,\n        uint256 blockNumber\n    ) external view returns (uint256) {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorAmount: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[tokenAddr][account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[tokenAddr][account][nCheckpoints - 1].fromBlock <=\n            blockNumber\n        ) {\n            return checkpoints[tokenAddr][account][nCheckpoints - 1].amount;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[tokenAddr][account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[tokenAddr][account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.amount;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[tokenAddr][account][lower].amount;\n    }\n\n    /**\n     * @notice Creates a new amount checkpoint for a token of a certain member\n     * @dev Reverts if the amount is greater than 2**64-1\n     * @param member The member whose checkpoints will be added to\n     * @param token The token of which the balance will be changed\n     * @param amount The amount to be written into the new checkpoint\n     */\n    function _createNewAmountCheckpoint(\n        address member,\n        address token,\n        uint256 amount\n    ) internal {\n        bool isValidToken = false;\n        if (availableInternalTokens[token]) {\n            require(\n                amount < type(uint88).max,\n                \"token amount exceeds the maximum limit for internal tokens\"\n            );\n            isValidToken = true;\n        } else if (availableTokens[token]) {\n            require(\n                amount < type(uint160).max,\n                \"token amount exceeds the maximum limit for external tokens\"\n            );\n            isValidToken = true;\n        }\n        uint160 newAmount = uint160(amount);\n\n        require(isValidToken, \"token not registered\");\n\n        uint32 nCheckpoints = numCheckpoints[token][member];\n        if (\n            // The only condition that we should allow the amount update\n            // is when the block.number exactly matches the fromBlock value.\n            // Anything different from that should generate a new checkpoint.\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[token][member][nCheckpoints - 1].fromBlock ==\n            block.number\n        ) {\n            checkpoints[token][member][nCheckpoints - 1].amount = newAmount;\n        } else {\n            checkpoints[token][member][nCheckpoints] = Checkpoint(\n                uint96(block.number),\n                newAmount\n            );\n            numCheckpoints[token][member] = nCheckpoints + 1;\n        }\n        emit NewBalance(member, token, newAmount);\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nabstract contract MemberGuard {\n    /**\n     * @dev Only members of the DAO are allowed to execute the function call.\n     */\n    modifier onlyMember(DaoRegistry dao) {\n        _onlyMember(dao, msg.sender);\n        _;\n    }\n\n    modifier onlyMember2(DaoRegistry dao, address _addr) {\n        _onlyMember(dao, _addr);\n        _;\n    }\n\n    function _onlyMember(DaoRegistry dao, address _addr) internal view {\n        require(isActiveMember(dao, _addr), \"onlyMember\");\n    }\n\n    function isActiveMember(DaoRegistry dao, address _addr)\n        public\n        view\n        returns (bool)\n    {\n        address bankAddress = dao.extensions(DaoHelper.BANK);\n        if (bankAddress != address(0x0)) {\n            address memberAddr = dao.getAddressIfDelegated(_addr);\n            return\n                BankExtension(bankAddress).balanceOf(\n                    memberAddr,\n                    DaoHelper.UNITS\n                ) > 0;\n        }\n\n        return dao.isMember(_addr);\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract DaoRegistry is MemberGuard, AdapterGuard {\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n\n    enum DaoState {CREATION, READY}\n\n    /*\n     * EVENTS\n     */\n    /// @dev - Events for Proposals\n    event SubmittedProposal(bytes32 proposalId, uint256 flags);\n    event SponsoredProposal(\n        bytes32 proposalId,\n        uint256 flags,\n        address votingAdapter\n    );\n    event ProcessedProposal(bytes32 proposalId, uint256 flags);\n    event AdapterAdded(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint256 flags\n    );\n    event AdapterRemoved(bytes32 adapterId);\n\n    event ExtensionAdded(bytes32 extensionId, address extensionAddress);\n    event ExtensionRemoved(bytes32 extensionId);\n\n    /// @dev - Events for Members\n    event UpdateDelegateKey(address memberAddress, address newDelegateKey);\n    event ConfigurationUpdated(bytes32 key, uint256 value);\n    event AddressConfigurationUpdated(bytes32 key, address value);\n\n    enum MemberFlag {EXISTS}\n\n    enum ProposalFlag {EXISTS, SPONSORED, PROCESSED}\n\n    enum AclFlag {\n        REPLACE_ADAPTER,\n        SUBMIT_PROPOSAL,\n        UPDATE_DELEGATE_KEY,\n        SET_CONFIGURATION,\n        ADD_EXTENSION,\n        REMOVE_EXTENSION,\n        NEW_MEMBER\n    }\n\n    /*\n     * STRUCTURES\n     */\n    struct Proposal {\n        // the structure to track all the proposals in the DAO\n        address adapterAddress; // the adapter address that called the functions to change the DAO state\n        uint256 flags; // flags to track the state of the proposal: exist, sponsored, processed, canceled, etc.\n    }\n\n    struct Member {\n        // the structure to track all the members in the DAO\n        uint256 flags; // flags to track the state of the member: exists, etc\n    }\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    struct DelegateCheckpoint {\n        // A checkpoint for marking the delegate key for a member from a given block\n        uint96 fromBlock;\n        address delegateKey;\n    }\n\n    struct AdapterEntry {\n        bytes32 id;\n        uint256 acl;\n    }\n\n    struct ExtensionEntry {\n        bytes32 id;\n        mapping(address => uint256) acl;\n    }\n\n    /*\n     * PUBLIC VARIABLES\n     */\n    mapping(address => Member) public members; // the map to track all members of the DAO\n    address[] private _members;\n\n    // delegate key => member address mapping\n    mapping(address => address) public memberAddressesByDelegatedKey;\n\n    // memberAddress => checkpointNum => DelegateCheckpoint\n    mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints;\n    // memberAddress => numDelegateCheckpoints\n    mapping(address => uint32) numCheckpoints;\n\n    DaoState public state;\n\n    /// @notice The map that keeps track of all proposasls submitted to the DAO\n    mapping(bytes32 => Proposal) public proposals;\n    /// @notice The map that tracks the voting adapter address per proposalId\n    mapping(bytes32 => address) public votingAdapter;\n    /// @notice The map that keeps track of all adapters registered in the DAO\n    mapping(bytes32 => address) public adapters;\n    /// @notice The inverse map to get the adapter id based on its address\n    mapping(address => AdapterEntry) public inverseAdapters;\n    /// @notice The map that keeps track of all extensions registered in the DAO\n    mapping(bytes32 => address) public extensions;\n    /// @notice The inverse map to get the extension id based on its address\n    mapping(address => ExtensionEntry) public inverseExtensions;\n    /// @notice The map that keeps track of configuration parameters for the DAO and adapters\n    mapping(bytes32 => uint256) public mainConfiguration;\n    mapping(bytes32 => address) public addressConfiguration;\n\n    uint256 public lockedAt;\n\n    /// @notice Clonable contract must have an empty constructor\n    // constructor() {\n    // }\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n     */\n    function initialize(address creator, address payer) external {\n        require(!initialized, \"dao already initialized\");\n        potentialNewMember(msg.sender);\n        potentialNewMember(payer);\n        potentialNewMember(creator);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice default fallback function to prevent from sending ether to the contract\n     */\n    // The transaction is always reverted, so there are no risks of locking ether in the contract\n    //slither-disable-next-line locked-ether\n    receive() external payable {\n        revert(\"you cannot send money back directly\");\n    }\n\n    /**\n     * @dev Sets the state of the dao to READY\n     */\n    function finalizeDao() external {\n        state = DaoState.READY;\n    }\n\n    function lockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = block.number;\n        }\n    }\n\n    function unlockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = 0;\n        }\n    }\n\n    /**\n     * @notice Sets a configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setConfiguration(bytes32 key, uint256 value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        mainConfiguration[key] = value;\n\n        emit ConfigurationUpdated(key, value);\n    }\n\n    function potentialNewMember(address memberAddress)\n        public\n        hasAccess(this, AclFlag.NEW_MEMBER)\n    {\n        require(memberAddress != address(0x0), \"invalid member address\");\n\n        Member storage member = members[memberAddress];\n        if (!DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS))) {\n            require(\n                memberAddressesByDelegatedKey[memberAddress] == address(0x0),\n                \"member address already taken as delegated key\"\n            );\n            member.flags = DaoHelper.setFlag(\n                member.flags,\n                uint8(MemberFlag.EXISTS),\n                true\n            );\n            memberAddressesByDelegatedKey[memberAddress] = memberAddress;\n            _members.push(memberAddress);\n        }\n\n        address bankAddress = extensions[DaoHelper.BANK];\n        if (bankAddress != address(0x0)) {\n            BankExtension bank = BankExtension(bankAddress);\n            if (bank.balanceOf(memberAddress, DaoHelper.MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, DaoHelper.MEMBER_COUNT, 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets an configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setAddressConfiguration(bytes32 key, address value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        addressConfiguration[key] = value;\n\n        emit AddressConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getConfiguration(bytes32 key) external view returns (uint256) {\n        return mainConfiguration[key];\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getAddressConfiguration(bytes32 key)\n        external\n        view\n        returns (address)\n    {\n        return addressConfiguration[key];\n    }\n\n    /**\n     * @notice Adds a new extension to the registry\n     * @param extensionId The unique identifier of the new extension\n     * @param extension The address of the extension\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function addExtension(\n        bytes32 extensionId,\n        IExtension extension,\n        address creator\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(extensionId != bytes32(0), \"extension id must not be empty\");\n        require(\n            extensions[extensionId] == address(0x0),\n            \"extension Id already in use\"\n        );\n        extensions[extensionId] = address(extension);\n        inverseExtensions[address(extension)].id = extensionId;\n        extension.initialize(this, creator);\n        emit ExtensionAdded(extensionId, address(extension));\n    }\n\n    function setAclToExtensionForAdapter(\n        address extensionAddress,\n        address adapterAddress,\n        uint256 acl\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(isAdapter(adapterAddress), \"not an adapter\");\n        require(isExtension(extensionAddress), \"not an extension\");\n        inverseExtensions[extensionAddress].acl[adapterAddress] = acl;\n    }\n\n    /**\n     * @notice Replaces an adapter in the registry in a single step.\n     * @notice It handles addition and removal of adapters as special cases.\n     * @dev It removes the current adapter if the adapterId maps to an existing adapter address.\n     * @dev It adds an adapter if the adapterAddress parameter is not zeroed.\n     * @param adapterId The unique identifier of the adapter\n     * @param adapterAddress The address of the new adapter or zero if it is a removal operation\n     * @param acl The flags indicating the access control layer or permissions of the new adapter\n     * @param keys The keys indicating the adapter configuration names.\n     * @param values The values indicating the adapter configuration values.\n     */\n    function replaceAdapter(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint128 acl,\n        bytes32[] calldata keys,\n        uint256[] calldata values\n    ) external hasAccess(this, AclFlag.REPLACE_ADAPTER) {\n        require(adapterId != bytes32(0), \"adapterId must not be empty\");\n\n        address currentAdapterAddr = adapters[adapterId];\n        if (currentAdapterAddr != address(0x0)) {\n            delete inverseAdapters[currentAdapterAddr];\n            delete adapters[adapterId];\n            emit AdapterRemoved(adapterId);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            bytes32 key = keys[i];\n            uint256 value = values[i];\n            mainConfiguration[key] = value;\n            emit ConfigurationUpdated(key, value);\n        }\n\n        if (adapterAddress != address(0x0)) {\n            require(\n                inverseAdapters[adapterAddress].id == bytes32(0),\n                \"adapterAddress already in use\"\n            );\n            adapters[adapterId] = adapterAddress;\n            inverseAdapters[adapterAddress].id = adapterId;\n            inverseAdapters[adapterAddress].acl = acl;\n            emit AdapterAdded(adapterId, adapterAddress, acl);\n        }\n    }\n\n    /**\n     * @notice Removes an adapter from the registry\n     * @param extensionId The unique identifier of the extension\n     */\n    function removeExtension(bytes32 extensionId)\n        external\n        hasAccess(this, AclFlag.REMOVE_EXTENSION)\n    {\n        require(extensionId != bytes32(0), \"extensionId must not be empty\");\n        require(\n            extensions[extensionId] != address(0x0),\n            \"extensionId not registered\"\n        );\n        delete inverseExtensions[extensions[extensionId]];\n        delete extensions[extensionId];\n        emit ExtensionRemoved(extensionId);\n    }\n\n    /**\n     * @notice Looks up if there is an extension of a given address\n     * @return Whether or not the address is an extension\n     * @param extensionAddr The address to look up\n     */\n    function isExtension(address extensionAddr) public view returns (bool) {\n        return inverseExtensions[extensionAddr].id != bytes32(0);\n    }\n\n    /**\n     * @notice Looks up if there is an adapter of a given address\n     * @return Whether or not the address is an adapter\n     * @param adapterAddress The address to look up\n     */\n    function isAdapter(address adapterAddress) public view returns (bool) {\n        return inverseAdapters[adapterAddress].id != bytes32(0);\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccess(address adapterAddress, AclFlag flag)\n        external\n        view\n        returns (bool)\n    {\n        return\n            DaoHelper.getFlag(inverseAdapters[adapterAddress].acl, uint8(flag));\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccessToExtension(\n        address adapterAddress,\n        address extensionAddress,\n        uint8 flag\n    ) external view returns (bool) {\n        return\n            isAdapter(adapterAddress) &&\n            DaoHelper.getFlag(\n                inverseExtensions[extensionAddress].acl[adapterAddress],\n                uint8(flag)\n            );\n    }\n\n    /**\n     * @return The address of a given adapter ID\n     * @param adapterId The ID to look up\n     */\n    function getAdapterAddress(bytes32 adapterId)\n        external\n        view\n        returns (address)\n    {\n        require(adapters[adapterId] != address(0), \"adapter not found\");\n        return adapters[adapterId];\n    }\n\n    /**\n     * @return The address of a given extension Id\n     * @param extensionId The ID to look up\n     */\n    function getExtensionAddress(bytes32 extensionId)\n        external\n        view\n        returns (address)\n    {\n        require(extensions[extensionId] != address(0), \"extension not found\");\n        return extensions[extensionId];\n    }\n\n    /**\n     * PROPOSALS\n     */\n    /**\n     * @notice Submit proposals to the DAO registry\n     */\n    function submitProposal(bytes32 proposalId)\n        external\n        hasAccess(this, AclFlag.SUBMIT_PROPOSAL)\n    {\n        require(proposalId != bytes32(0), \"invalid proposalId\");\n        require(\n            !getProposalFlag(proposalId, ProposalFlag.EXISTS),\n            \"proposalId must be unique\"\n        );\n        proposals[proposalId] = Proposal(msg.sender, 1); // 1 means that only the first flag is being set i.e. EXISTS\n        emit SubmittedProposal(proposalId, 1);\n    }\n\n    /**\n     * @notice Sponsor proposals that were submitted to the DAO registry\n     * @dev adds SPONSORED to the proposal flag\n     * @param proposalId The ID of the proposal to sponsor\n     * @param sponsoringMember The member who is sponsoring the proposal\n     */\n    function sponsorProposal(\n        bytes32 proposalId,\n        address sponsoringMember,\n        address votingAdapterAddr\n    ) external onlyMember2(this, sponsoringMember) {\n        // also checks if the flag was already set\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.SPONSORED);\n\n        uint256 flags = proposal.flags;\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can process it\"\n        );\n\n        require(\n            !DaoHelper.getFlag(flags, uint8(ProposalFlag.PROCESSED)),\n            \"proposal already processed\"\n        );\n        votingAdapter[proposalId] = votingAdapterAddr;\n        emit SponsoredProposal(proposalId, flags, votingAdapterAddr);\n    }\n\n    /**\n     * @notice Mark a proposal as processed in the DAO registry\n     * @param proposalId The ID of the proposal that is being processed\n     */\n    function processProposal(bytes32 proposalId) external {\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.PROCESSED);\n\n        require(proposal.adapterAddress == msg.sender, \"err::adapter mismatch\");\n        uint256 flags = proposal.flags;\n\n        emit ProcessedProposal(proposalId, flags);\n    }\n\n    /**\n     * @notice Sets a flag of a proposal\n     * @dev Reverts if the proposal is already processed\n     * @param proposalId The ID of the proposal to be changed\n     * @param flag The flag that will be set on the proposal\n     */\n    function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        internal\n        returns (Proposal storage)\n    {\n        Proposal storage proposal = proposals[proposalId];\n\n        uint256 flags = proposal.flags;\n        require(\n            DaoHelper.getFlag(flags, uint8(ProposalFlag.EXISTS)),\n            \"proposal does not exist for this dao\"\n        );\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can set its flag\"\n        );\n\n        require(!DaoHelper.getFlag(flags, uint8(flag)), \"flag already set\");\n\n        flags = DaoHelper.setFlag(flags, uint8(flag), true);\n        proposals[proposalId].flags = flags;\n\n        return proposals[proposalId];\n    }\n\n    /*\n     * MEMBERS\n     */\n\n    /**\n     * @return Whether or not a given address is a member of the DAO.\n     * @dev it will resolve by delegate key, not member address.\n     * @param addr The address to look up\n     */\n    function isMember(address addr) external view returns (bool) {\n        address memberAddress = memberAddressesByDelegatedKey[addr];\n        return getMemberFlag(memberAddress, MemberFlag.EXISTS);\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given proposal\n     * @param proposalId The proposal to check against flag\n     * @param flag The flag to check in the proposal\n     */\n    function getProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(proposals[proposalId].flags, uint8(flag));\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given member\n     * @param memberAddress The member to check against flag\n     * @param flag The flag to check in the member\n     */\n    function getMemberFlag(address memberAddress, MemberFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(members[memberAddress].flags, uint8(flag));\n    }\n\n    function getNbMembers() external view returns (uint256) {\n        return _members.length;\n    }\n\n    function getMemberAddress(uint256 index) external view returns (address) {\n        return _members[index];\n    }\n\n    /**\n     * @notice Updates the delegate key of a member\n     * @param memberAddr The member doing the delegation\n     * @param newDelegateKey The member who is being delegated to\n     */\n    function updateDelegateKey(address memberAddr, address newDelegateKey)\n        external\n        hasAccess(this, AclFlag.UPDATE_DELEGATE_KEY)\n    {\n        require(newDelegateKey != address(0x0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != memberAddr) {\n            require(\n                // newDelegate must not be delegated to\n                memberAddressesByDelegatedKey[newDelegateKey] == address(0x0),\n                \"cannot overwrite existing delegated keys\"\n            );\n        } else {\n            require(\n                memberAddressesByDelegatedKey[memberAddr] == address(0x0),\n                \"address already taken as delegated key\"\n            );\n        }\n\n        Member storage member = members[memberAddr];\n        require(\n            DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS)),\n            \"member does not exist\"\n        );\n\n        // Reset the delegation of the previous delegate\n        memberAddressesByDelegatedKey[\n            getCurrentDelegateKey(memberAddr)\n        ] = address(0x0);\n\n        memberAddressesByDelegatedKey[newDelegateKey] = memberAddr;\n\n        _createNewDelegateCheckpoint(memberAddr, newDelegateKey);\n        emit UpdateDelegateKey(memberAddr, newDelegateKey);\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * @param checkAddr The address to check for a delegate\n     * @return the delegated address or the checked address if it is not a delegate\n     */\n    function getAddressIfDelegated(address checkAddr)\n        external\n        view\n        returns (address)\n    {\n        address delegatedKey = memberAddressesByDelegatedKey[checkAddr];\n        return delegatedKey == address(0x0) ? checkAddr : delegatedKey;\n    }\n\n    /**\n     * @param memberAddr The member whose delegate will be returned\n     * @return the delegate key at the current time for a member\n     */\n    function getCurrentDelegateKey(address memberAddr)\n        public\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 0\n                ? checkpoints[memberAddr][nCheckpoints - 1].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @param memberAddr The member address to look up\n     * @return The delegate key address for memberAddr at the second last checkpoint number\n     */\n    function getPreviousDelegateKey(address memberAddr)\n        external\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 1\n                ? checkpoints[memberAddr][nCheckpoints - 2].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param memberAddr The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorDelegateKey(address memberAddr, uint256 blockNumber)\n        external\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorDelegateKey: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        if (nCheckpoints == 0) {\n            return memberAddr;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[memberAddr][nCheckpoints - 1].fromBlock <= blockNumber\n        ) {\n            return checkpoints[memberAddr][nCheckpoints - 1].delegateKey;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[memberAddr][0].fromBlock > blockNumber) {\n            return memberAddr;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DelegateCheckpoint memory cp = checkpoints[memberAddr][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegateKey;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[memberAddr][lower].delegateKey;\n    }\n\n    /**\n     * @notice Creates a new delegate checkpoint of a certain member\n     * @param member The member whose delegate checkpoints will be added to\n     * @param newDelegateKey The delegate key that will be written into the new checkpoint\n     */\n    function _createNewDelegateCheckpoint(\n        address member,\n        address newDelegateKey\n    ) internal {\n        uint32 nCheckpoints = numCheckpoints[member];\n        // The only condition that we should allow the deletegaKey upgrade\n        // is when the block.number exactly matches the fromBlock value.\n        // Anything different from that should generate a new checkpoint.\n        if (\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[member][nCheckpoints - 1].fromBlock == block.number\n        ) {\n            checkpoints[member][nCheckpoints - 1].delegateKey = newDelegateKey;\n        } else {\n            checkpoints[member][nCheckpoints] = DelegateCheckpoint(\n                uint96(block.number),\n                newDelegateKey\n            );\n            numCheckpoints[member] = nCheckpoints + 1;\n        }\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nabstract contract AdapterGuard {\n    /**\n     * @dev Only registered adapters are allowed to execute the function call.\n     */\n    modifier onlyAdapter(DaoRegistry dao) {\n        require(\n            (dao.state() == DaoRegistry.DaoState.CREATION &&\n                creationModeCheck(dao)) || dao.isAdapter(msg.sender),\n            \"onlyAdapter\"\n        );\n        _;\n    }\n\n    modifier reentrancyGuard(DaoRegistry dao) {\n        require(dao.lockedAt() != block.number, \"reentrancy guard\");\n        dao.lockSession();\n        _;\n        dao.unlockSession();\n    }\n\n    modifier executorFunc(DaoRegistry dao) {\n        address executorAddr =\n            dao.getExtensionAddress(keccak256(\"executor-ext\"));\n        require(address(this) == executorAddr, \"only callable by the executor\");\n        _;\n    }\n\n    modifier hasAccess(DaoRegistry dao, DaoRegistry.AclFlag flag) {\n        require(\n            (dao.state() == DaoRegistry.DaoState.CREATION &&\n                creationModeCheck(dao)) ||\n                dao.hasAdapterAccess(msg.sender, flag),\n            \"accessDenied\"\n        );\n        _;\n    }\n\n    function creationModeCheck(DaoRegistry dao) internal view returns (bool) {\n        return\n            dao.getNbMembers() == 0 ||\n            dao.isMember(msg.sender) ||\n            dao.isAdapter(msg.sender);\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract DaoRegistry is MemberGuard, AdapterGuard {\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n\n    enum DaoState {CREATION, READY}\n\n    /*\n     * EVENTS\n     */\n    /// @dev - Events for Proposals\n    event SubmittedProposal(bytes32 proposalId, uint256 flags);\n    event SponsoredProposal(\n        bytes32 proposalId,\n        uint256 flags,\n        address votingAdapter\n    );\n    event ProcessedProposal(bytes32 proposalId, uint256 flags);\n    event AdapterAdded(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint256 flags\n    );\n    event AdapterRemoved(bytes32 adapterId);\n\n    event ExtensionAdded(bytes32 extensionId, address extensionAddress);\n    event ExtensionRemoved(bytes32 extensionId);\n\n    /// @dev - Events for Members\n    event UpdateDelegateKey(address memberAddress, address newDelegateKey);\n    event ConfigurationUpdated(bytes32 key, uint256 value);\n    event AddressConfigurationUpdated(bytes32 key, address value);\n\n    enum MemberFlag {EXISTS}\n\n    enum ProposalFlag {EXISTS, SPONSORED, PROCESSED}\n\n    enum AclFlag {\n        REPLACE_ADAPTER,\n        SUBMIT_PROPOSAL,\n        UPDATE_DELEGATE_KEY,\n        SET_CONFIGURATION,\n        ADD_EXTENSION,\n        REMOVE_EXTENSION,\n        NEW_MEMBER\n    }\n\n    /*\n     * STRUCTURES\n     */\n    struct Proposal {\n        // the structure to track all the proposals in the DAO\n        address adapterAddress; // the adapter address that called the functions to change the DAO state\n        uint256 flags; // flags to track the state of the proposal: exist, sponsored, processed, canceled, etc.\n    }\n\n    struct Member {\n        // the structure to track all the members in the DAO\n        uint256 flags; // flags to track the state of the member: exists, etc\n    }\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    struct DelegateCheckpoint {\n        // A checkpoint for marking the delegate key for a member from a given block\n        uint96 fromBlock;\n        address delegateKey;\n    }\n\n    struct AdapterEntry {\n        bytes32 id;\n        uint256 acl;\n    }\n\n    struct ExtensionEntry {\n        bytes32 id;\n        mapping(address => uint256) acl;\n    }\n\n    /*\n     * PUBLIC VARIABLES\n     */\n    mapping(address => Member) public members; // the map to track all members of the DAO\n    address[] private _members;\n\n    // delegate key => member address mapping\n    mapping(address => address) public memberAddressesByDelegatedKey;\n\n    // memberAddress => checkpointNum => DelegateCheckpoint\n    mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints;\n    // memberAddress => numDelegateCheckpoints\n    mapping(address => uint32) numCheckpoints;\n\n    DaoState public state;\n\n    /// @notice The map that keeps track of all proposasls submitted to the DAO\n    mapping(bytes32 => Proposal) public proposals;\n    /// @notice The map that tracks the voting adapter address per proposalId\n    mapping(bytes32 => address) public votingAdapter;\n    /// @notice The map that keeps track of all adapters registered in the DAO\n    mapping(bytes32 => address) public adapters;\n    /// @notice The inverse map to get the adapter id based on its address\n    mapping(address => AdapterEntry) public inverseAdapters;\n    /// @notice The map that keeps track of all extensions registered in the DAO\n    mapping(bytes32 => address) public extensions;\n    /// @notice The inverse map to get the extension id based on its address\n    mapping(address => ExtensionEntry) public inverseExtensions;\n    /// @notice The map that keeps track of configuration parameters for the DAO and adapters\n    mapping(bytes32 => uint256) public mainConfiguration;\n    mapping(bytes32 => address) public addressConfiguration;\n\n    uint256 public lockedAt;\n\n    /// @notice Clonable contract must have an empty constructor\n    // constructor() {\n    // }\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n     */\n    function initialize(address creator, address payer) external {\n        require(!initialized, \"dao already initialized\");\n        potentialNewMember(msg.sender);\n        potentialNewMember(payer);\n        potentialNewMember(creator);\n\n        initialized = true;\n    }\n\n    /**\n     * @notice default fallback function to prevent from sending ether to the contract\n     */\n    // The transaction is always reverted, so there are no risks of locking ether in the contract\n    //slither-disable-next-line locked-ether\n    receive() external payable {\n        revert(\"you cannot send money back directly\");\n    }\n\n    /**\n     * @dev Sets the state of the dao to READY\n     */\n    function finalizeDao() external {\n        state = DaoState.READY;\n    }\n\n    function lockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = block.number;\n        }\n    }\n\n    function unlockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = 0;\n        }\n    }\n\n    /**\n     * @notice Sets a configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setConfiguration(bytes32 key, uint256 value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        mainConfiguration[key] = value;\n\n        emit ConfigurationUpdated(key, value);\n    }\n\n    function potentialNewMember(address memberAddress)\n        public\n        hasAccess(this, AclFlag.NEW_MEMBER)\n    {\n        require(memberAddress != address(0x0), \"invalid member address\");\n\n        Member storage member = members[memberAddress];\n        if (!DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS))) {\n            require(\n                memberAddressesByDelegatedKey[memberAddress] == address(0x0),\n                \"member address already taken as delegated key\"\n            );\n            member.flags = DaoHelper.setFlag(\n                member.flags,\n                uint8(MemberFlag.EXISTS),\n                true\n            );\n            memberAddressesByDelegatedKey[memberAddress] = memberAddress;\n            _members.push(memberAddress);\n        }\n\n        address bankAddress = extensions[DaoHelper.BANK];\n        if (bankAddress != address(0x0)) {\n            BankExtension bank = BankExtension(bankAddress);\n            if (bank.balanceOf(memberAddress, DaoHelper.MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, DaoHelper.MEMBER_COUNT, 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets an configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setAddressConfiguration(bytes32 key, address value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        addressConfiguration[key] = value;\n\n        emit AddressConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getConfiguration(bytes32 key) external view returns (uint256) {\n        return mainConfiguration[key];\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getAddressConfiguration(bytes32 key)\n        external\n        view\n        returns (address)\n    {\n        return addressConfiguration[key];\n    }\n\n    /**\n     * @notice Adds a new extension to the registry\n     * @param extensionId The unique identifier of the new extension\n     * @param extension The address of the extension\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function addExtension(\n        bytes32 extensionId,\n        IExtension extension,\n        address creator\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(extensionId != bytes32(0), \"extension id must not be empty\");\n        require(\n            extensions[extensionId] == address(0x0),\n            \"extension Id already in use\"\n        );\n        extensions[extensionId] = address(extension);\n        inverseExtensions[address(extension)].id = extensionId;\n        extension.initialize(this, creator);\n        emit ExtensionAdded(extensionId, address(extension));\n    }\n\n    function setAclToExtensionForAdapter(\n        address extensionAddress,\n        address adapterAddress,\n        uint256 acl\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(isAdapter(adapterAddress), \"not an adapter\");\n        require(isExtension(extensionAddress), \"not an extension\");\n        inverseExtensions[extensionAddress].acl[adapterAddress] = acl;\n    }\n\n    /**\n     * @notice Replaces an adapter in the registry in a single step.\n     * @notice It handles addition and removal of adapters as special cases.\n     * @dev It removes the current adapter if the adapterId maps to an existing adapter address.\n     * @dev It adds an adapter if the adapterAddress parameter is not zeroed.\n     * @param adapterId The unique identifier of the adapter\n     * @param adapterAddress The address of the new adapter or zero if it is a removal operation\n     * @param acl The flags indicating the access control layer or permissions of the new adapter\n     * @param keys The keys indicating the adapter configuration names.\n     * @param values The values indicating the adapter configuration values.\n     */\n    function replaceAdapter(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint128 acl,\n        bytes32[] calldata keys,\n        uint256[] calldata values\n    ) external hasAccess(this, AclFlag.REPLACE_ADAPTER) {\n        require(adapterId != bytes32(0), \"adapterId must not be empty\");\n\n        address currentAdapterAddr = adapters[adapterId];\n        if (currentAdapterAddr != address(0x0)) {\n            delete inverseAdapters[currentAdapterAddr];\n            delete adapters[adapterId];\n            emit AdapterRemoved(adapterId);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            bytes32 key = keys[i];\n            uint256 value = values[i];\n            mainConfiguration[key] = value;\n            emit ConfigurationUpdated(key, value);\n        }\n\n        if (adapterAddress != address(0x0)) {\n            require(\n                inverseAdapters[adapterAddress].id == bytes32(0),\n                \"adapterAddress already in use\"\n            );\n            adapters[adapterId] = adapterAddress;\n            inverseAdapters[adapterAddress].id = adapterId;\n            inverseAdapters[adapterAddress].acl = acl;\n            emit AdapterAdded(adapterId, adapterAddress, acl);\n        }\n    }\n\n    /**\n     * @notice Removes an adapter from the registry\n     * @param extensionId The unique identifier of the extension\n     */\n    function removeExtension(bytes32 extensionId)\n        external\n        hasAccess(this, AclFlag.REMOVE_EXTENSION)\n    {\n        require(extensionId != bytes32(0), \"extensionId must not be empty\");\n        require(\n            extensions[extensionId] != address(0x0),\n            \"extensionId not registered\"\n        );\n        delete inverseExtensions[extensions[extensionId]];\n        delete extensions[extensionId];\n        emit ExtensionRemoved(extensionId);\n    }\n\n    /**\n     * @notice Looks up if there is an extension of a given address\n     * @return Whether or not the address is an extension\n     * @param extensionAddr The address to look up\n     */\n    function isExtension(address extensionAddr) public view returns (bool) {\n        return inverseExtensions[extensionAddr].id != bytes32(0);\n    }\n\n    /**\n     * @notice Looks up if there is an adapter of a given address\n     * @return Whether or not the address is an adapter\n     * @param adapterAddress The address to look up\n     */\n    function isAdapter(address adapterAddress) public view returns (bool) {\n        return inverseAdapters[adapterAddress].id != bytes32(0);\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccess(address adapterAddress, AclFlag flag)\n        external\n        view\n        returns (bool)\n    {\n        return\n            DaoHelper.getFlag(inverseAdapters[adapterAddress].acl, uint8(flag));\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccessToExtension(\n        address adapterAddress,\n        address extensionAddress,\n        uint8 flag\n    ) external view returns (bool) {\n        return\n            isAdapter(adapterAddress) &&\n            DaoHelper.getFlag(\n                inverseExtensions[extensionAddress].acl[adapterAddress],\n                uint8(flag)\n            );\n    }\n\n    /**\n     * @return The address of a given adapter ID\n     * @param adapterId The ID to look up\n     */\n    function getAdapterAddress(bytes32 adapterId)\n        external\n        view\n        returns (address)\n    {\n        require(adapters[adapterId] != address(0), \"adapter not found\");\n        return adapters[adapterId];\n    }\n\n    /**\n     * @return The address of a given extension Id\n     * @param extensionId The ID to look up\n     */\n    function getExtensionAddress(bytes32 extensionId)\n        external\n        view\n        returns (address)\n    {\n        require(extensions[extensionId] != address(0), \"extension not found\");\n        return extensions[extensionId];\n    }\n\n    /**\n     * PROPOSALS\n     */\n    /**\n     * @notice Submit proposals to the DAO registry\n     */\n    function submitProposal(bytes32 proposalId)\n        external\n        hasAccess(this, AclFlag.SUBMIT_PROPOSAL)\n    {\n        require(proposalId != bytes32(0), \"invalid proposalId\");\n        require(\n            !getProposalFlag(proposalId, ProposalFlag.EXISTS),\n            \"proposalId must be unique\"\n        );\n        proposals[proposalId] = Proposal(msg.sender, 1); // 1 means that only the first flag is being set i.e. EXISTS\n        emit SubmittedProposal(proposalId, 1);\n    }\n\n    /**\n     * @notice Sponsor proposals that were submitted to the DAO registry\n     * @dev adds SPONSORED to the proposal flag\n     * @param proposalId The ID of the proposal to sponsor\n     * @param sponsoringMember The member who is sponsoring the proposal\n     */\n    function sponsorProposal(\n        bytes32 proposalId,\n        address sponsoringMember,\n        address votingAdapterAddr\n    ) external onlyMember2(this, sponsoringMember) {\n        // also checks if the flag was already set\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.SPONSORED);\n\n        uint256 flags = proposal.flags;\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can process it\"\n        );\n\n        require(\n            !DaoHelper.getFlag(flags, uint8(ProposalFlag.PROCESSED)),\n            \"proposal already processed\"\n        );\n        votingAdapter[proposalId] = votingAdapterAddr;\n        emit SponsoredProposal(proposalId, flags, votingAdapterAddr);\n    }\n\n    /**\n     * @notice Mark a proposal as processed in the DAO registry\n     * @param proposalId The ID of the proposal that is being processed\n     */\n    function processProposal(bytes32 proposalId) external {\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.PROCESSED);\n\n        require(proposal.adapterAddress == msg.sender, \"err::adapter mismatch\");\n        uint256 flags = proposal.flags;\n\n        emit ProcessedProposal(proposalId, flags);\n    }\n\n    /**\n     * @notice Sets a flag of a proposal\n     * @dev Reverts if the proposal is already processed\n     * @param proposalId The ID of the proposal to be changed\n     * @param flag The flag that will be set on the proposal\n     */\n    function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        internal\n        returns (Proposal storage)\n    {\n        Proposal storage proposal = proposals[proposalId];\n\n        uint256 flags = proposal.flags;\n        require(\n            DaoHelper.getFlag(flags, uint8(ProposalFlag.EXISTS)),\n            \"proposal does not exist for this dao\"\n        );\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can set its flag\"\n        );\n\n        require(!DaoHelper.getFlag(flags, uint8(flag)), \"flag already set\");\n\n        flags = DaoHelper.setFlag(flags, uint8(flag), true);\n        proposals[proposalId].flags = flags;\n\n        return proposals[proposalId];\n    }\n\n    /*\n     * MEMBERS\n     */\n\n    /**\n     * @return Whether or not a given address is a member of the DAO.\n     * @dev it will resolve by delegate key, not member address.\n     * @param addr The address to look up\n     */\n    function isMember(address addr) external view returns (bool) {\n        address memberAddress = memberAddressesByDelegatedKey[addr];\n        return getMemberFlag(memberAddress, MemberFlag.EXISTS);\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given proposal\n     * @param proposalId The proposal to check against flag\n     * @param flag The flag to check in the proposal\n     */\n    function getProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(proposals[proposalId].flags, uint8(flag));\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given member\n     * @param memberAddress The member to check against flag\n     * @param flag The flag to check in the member\n     */\n    function getMemberFlag(address memberAddress, MemberFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(members[memberAddress].flags, uint8(flag));\n    }\n\n    function getNbMembers() external view returns (uint256) {\n        return _members.length;\n    }\n\n    function getMemberAddress(uint256 index) external view returns (address) {\n        return _members[index];\n    }\n\n    /**\n     * @notice Updates the delegate key of a member\n     * @param memberAddr The member doing the delegation\n     * @param newDelegateKey The member who is being delegated to\n     */\n    function updateDelegateKey(address memberAddr, address newDelegateKey)\n        external\n        hasAccess(this, AclFlag.UPDATE_DELEGATE_KEY)\n    {\n        require(newDelegateKey != address(0x0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != memberAddr) {\n            require(\n                // newDelegate must not be delegated to\n                memberAddressesByDelegatedKey[newDelegateKey] == address(0x0),\n                \"cannot overwrite existing delegated keys\"\n            );\n        } else {\n            require(\n                memberAddressesByDelegatedKey[memberAddr] == address(0x0),\n                \"address already taken as delegated key\"\n            );\n        }\n\n        Member storage member = members[memberAddr];\n        require(\n            DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS)),\n            \"member does not exist\"\n        );\n\n        // Reset the delegation of the previous delegate\n        memberAddressesByDelegatedKey[\n            getCurrentDelegateKey(memberAddr)\n        ] = address(0x0);\n\n        memberAddressesByDelegatedKey[newDelegateKey] = memberAddr;\n\n        _createNewDelegateCheckpoint(memberAddr, newDelegateKey);\n        emit UpdateDelegateKey(memberAddr, newDelegateKey);\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * @param checkAddr The address to check for a delegate\n     * @return the delegated address or the checked address if it is not a delegate\n     */\n    function getAddressIfDelegated(address checkAddr)\n        external\n        view\n        returns (address)\n    {\n        address delegatedKey = memberAddressesByDelegatedKey[checkAddr];\n        return delegatedKey == address(0x0) ? checkAddr : delegatedKey;\n    }\n\n    /**\n     * @param memberAddr The member whose delegate will be returned\n     * @return the delegate key at the current time for a member\n     */\n    function getCurrentDelegateKey(address memberAddr)\n        public\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 0\n                ? checkpoints[memberAddr][nCheckpoints - 1].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @param memberAddr The member address to look up\n     * @return The delegate key address for memberAddr at the second last checkpoint number\n     */\n    function getPreviousDelegateKey(address memberAddr)\n        external\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 1\n                ? checkpoints[memberAddr][nCheckpoints - 2].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param memberAddr The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorDelegateKey(address memberAddr, uint256 blockNumber)\n        external\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorDelegateKey: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        if (nCheckpoints == 0) {\n            return memberAddr;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[memberAddr][nCheckpoints - 1].fromBlock <= blockNumber\n        ) {\n            return checkpoints[memberAddr][nCheckpoints - 1].delegateKey;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[memberAddr][0].fromBlock > blockNumber) {\n            return memberAddr;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DelegateCheckpoint memory cp = checkpoints[memberAddr][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegateKey;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[memberAddr][lower].delegateKey;\n    }\n\n    /**\n     * @notice Creates a new delegate checkpoint of a certain member\n     * @param member The member whose delegate checkpoints will be added to\n     * @param newDelegateKey The delegate key that will be written into the new checkpoint\n     */\n    function _createNewDelegateCheckpoint(\n        address member,\n        address newDelegateKey\n    ) internal {\n        uint32 nCheckpoints = numCheckpoints[member];\n        // The only condition that we should allow the deletegaKey upgrade\n        // is when the block.number exactly matches the fromBlock value.\n        // Anything different from that should generate a new checkpoint.\n        if (\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[member][nCheckpoints - 1].fromBlock == block.number\n        ) {\n            checkpoints[member][nCheckpoints - 1].delegateKey = newDelegateKey;\n        } else {\n            checkpoints[member][nCheckpoints] = DelegateCheckpoint(\n                uint96(block.number),\n                newDelegateKey\n            );\n            numCheckpoints[member] = nCheckpoints + 1;\n        }\n    }\n}\n", "commit_id": "0313358f633cf6a7e92613f4296ec36c5629e1a3"}, "fixed_version": {"raw_code": "pragma solidity ^0.8.0;\n\n// SPDX-License-Identifier: MIT\n\nimport \"../guards/AdapterGuard.sol\";\nimport \"../guards/MemberGuard.sol\";\nimport \"../extensions/IExtension.sol\";\nimport \"../helpers/DaoHelper.sol\";\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract DaoRegistry is MemberGuard, AdapterGuard {\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n\n    enum DaoState {CREATION, READY}\n\n    /*\n     * EVENTS\n     */\n    /// @dev - Events for Proposals\n    event SubmittedProposal(bytes32 proposalId, uint256 flags);\n    event SponsoredProposal(\n        bytes32 proposalId,\n        uint256 flags,\n        address votingAdapter\n    );\n    event ProcessedProposal(bytes32 proposalId, uint256 flags);\n    event AdapterAdded(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint256 flags\n    );\n    event AdapterRemoved(bytes32 adapterId);\n\n    event ExtensionAdded(bytes32 extensionId, address extensionAddress);\n    event ExtensionRemoved(bytes32 extensionId);\n\n    /// @dev - Events for Members\n    event UpdateDelegateKey(address memberAddress, address newDelegateKey);\n    event ConfigurationUpdated(bytes32 key, uint256 value);\n    event AddressConfigurationUpdated(bytes32 key, address value);\n\n    enum MemberFlag {EXISTS}\n\n    enum ProposalFlag {EXISTS, SPONSORED, PROCESSED}\n\n    enum AclFlag {\n        REPLACE_ADAPTER,\n        SUBMIT_PROPOSAL,\n        UPDATE_DELEGATE_KEY,\n        SET_CONFIGURATION,\n        ADD_EXTENSION,\n        REMOVE_EXTENSION,\n        NEW_MEMBER\n    }\n\n    /*\n     * STRUCTURES\n     */\n    struct Proposal {\n        // the structure to track all the proposals in the DAO\n        address adapterAddress; // the adapter address that called the functions to change the DAO state\n        uint256 flags; // flags to track the state of the proposal: exist, sponsored, processed, canceled, etc.\n    }\n\n    struct Member {\n        // the structure to track all the members in the DAO\n        uint256 flags; // flags to track the state of the member: exists, etc\n    }\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    struct DelegateCheckpoint {\n        // A checkpoint for marking the delegate key for a member from a given block\n        uint96 fromBlock;\n        address delegateKey;\n    }\n\n    struct AdapterEntry {\n        bytes32 id;\n        uint256 acl;\n    }\n\n    struct ExtensionEntry {\n        bytes32 id;\n        mapping(address => uint256) acl;\n        bool deleted;\n    }\n\n    /*\n     * PUBLIC VARIABLES\n     */\n    mapping(address => Member) public members; // the map to track all members of the DAO\n    address[] private _members;\n\n    // delegate key => member address mapping\n    mapping(address => address) public memberAddressesByDelegatedKey;\n\n    // memberAddress => checkpointNum => DelegateCheckpoint\n    mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints;\n    // memberAddress => numDelegateCheckpoints\n    mapping(address => uint32) numCheckpoints;\n\n    DaoState public state;\n\n    /// @notice The map that keeps track of all proposasls submitted to the DAO\n    mapping(bytes32 => Proposal) public proposals;\n    /// @notice The map that tracks the voting adapter address per proposalId\n    mapping(bytes32 => address) public votingAdapter;\n    /// @notice The map that keeps track of all adapters registered in the DAO\n    mapping(bytes32 => address) public adapters;\n    /// @notice The inverse map to get the adapter id based on its address\n    mapping(address => AdapterEntry) public inverseAdapters;\n    /// @notice The map that keeps track of all extensions registered in the DAO\n    mapping(bytes32 => address) public extensions;\n    /// @notice The inverse map to get the extension id based on its address\n    mapping(address => ExtensionEntry) public inverseExtensions;\n    /// @notice The map that keeps track of configuration parameters for the DAO and adapters\n    mapping(bytes32 => uint256) public mainConfiguration;\n    mapping(bytes32 => address) public addressConfiguration;\n\n    uint256 public lockedAt;\n\n    /// @notice Clonable contract must have an empty constructor\n    constructor() {}\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n     */\n    //slither-disable-next-line reentrancy-no-eth\n    function initialize(address creator, address payer) external {\n        require(!initialized, \"dao already initialized\");\n        initialized = true;\n        potentialNewMember(msg.sender);\n        potentialNewMember(payer);\n        potentialNewMember(creator);\n    }\n\n    /**\n     * @notice default fallback function to prevent from sending ether to the contract\n     */\n    // The transaction is always reverted, so there are no risks of locking ether in the contract\n    //slither-disable-next-line locked-ether\n    receive() external payable {\n        revert(\"you cannot send money back directly\");\n    }\n\n    /**\n     * @dev Sets the state of the dao to READY\n     */\n    function finalizeDao() external {\n        state = DaoState.READY;\n    }\n\n    /**\n     * @notice Contract lock strategy to lock only the caller is an adapter or extension.\n     */\n    function lockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = block.number;\n        }\n    }\n\n    /**\n     * @notice Contract lock strategy to release the lock only the caller is an adapter or extension.\n     */\n    function unlockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = 0;\n        }\n    }\n\n    /**\n     * @notice Sets a configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setConfiguration(bytes32 key, uint256 value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        mainConfiguration[key] = value;\n\n        emit ConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @notice Registers a member address in the DAO if it is not registered or invalid.\n     * @notice A potential new member is a member that holds no shares, and its registration still needs to be voted on.\n     */\n    function potentialNewMember(address memberAddress)\n        public\n        hasAccess(this, AclFlag.NEW_MEMBER)\n    {\n        require(memberAddress != address(0x0), \"invalid member address\");\n\n        Member storage member = members[memberAddress];\n        if (!DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS))) {\n            require(\n                memberAddressesByDelegatedKey[memberAddress] == address(0x0),\n                \"member address already taken as delegated key\"\n            );\n            member.flags = DaoHelper.setFlag(\n                member.flags,\n                uint8(MemberFlag.EXISTS),\n                true\n            );\n            memberAddressesByDelegatedKey[memberAddress] = memberAddress;\n            _members.push(memberAddress);\n        }\n\n        address bankAddress = extensions[DaoHelper.BANK];\n        if (bankAddress != address(0x0)) {\n            BankExtension bank = BankExtension(bankAddress);\n            if (bank.balanceOf(memberAddress, DaoHelper.MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, DaoHelper.MEMBER_COUNT, 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets an configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setAddressConfiguration(bytes32 key, address value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        addressConfiguration[key] = value;\n\n        emit AddressConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getConfiguration(bytes32 key) external view returns (uint256) {\n        return mainConfiguration[key];\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getAddressConfiguration(bytes32 key)\n        external\n        view\n        returns (address)\n    {\n        return addressConfiguration[key];\n    }\n\n    /**\n     * @notice It sets the ACL flags to an Adapter to make it possible to access specific functions of an Extension.\n     */\n    function setAclToExtensionForAdapter(\n        address extensionAddress,\n        address adapterAddress,\n        uint256 acl\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(isAdapter(adapterAddress), \"not an adapter\");\n        require(isExtension(extensionAddress), \"not an extension\");\n        inverseExtensions[extensionAddress].acl[adapterAddress] = acl;\n    }\n\n    /**\n     * @notice Replaces an adapter in the registry in a single step.\n     * @notice It handles addition and removal of adapters as special cases.\n     * @dev It removes the current adapter if the adapterId maps to an existing adapter address.\n     * @dev It adds an adapter if the adapterAddress parameter is not zeroed.\n     * @param adapterId The unique identifier of the adapter\n     * @param adapterAddress The address of the new adapter or zero if it is a removal operation\n     * @param acl The flags indicating the access control layer or permissions of the new adapter\n     * @param keys The keys indicating the adapter configuration names.\n     * @param values The values indicating the adapter configuration values.\n     */\n    function replaceAdapter(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint128 acl,\n        bytes32[] calldata keys,\n        uint256[] calldata values\n    ) external hasAccess(this, AclFlag.REPLACE_ADAPTER) {\n        require(adapterId != bytes32(0), \"adapterId must not be empty\");\n\n        address currentAdapterAddr = adapters[adapterId];\n        if (currentAdapterAddr != address(0x0)) {\n            delete inverseAdapters[currentAdapterAddr];\n            delete adapters[adapterId];\n            emit AdapterRemoved(adapterId);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            bytes32 key = keys[i];\n            uint256 value = values[i];\n            mainConfiguration[key] = value;\n            emit ConfigurationUpdated(key, value);\n        }\n\n        if (adapterAddress != address(0x0)) {\n            require(\n                inverseAdapters[adapterAddress].id == bytes32(0),\n                \"adapterAddress already in use\"\n            );\n            adapters[adapterId] = adapterAddress;\n            inverseAdapters[adapterAddress].id = adapterId;\n            inverseAdapters[adapterAddress].acl = acl;\n            emit AdapterAdded(adapterId, adapterAddress, acl);\n        }\n    }\n\n    /**\n     * @notice Adds a new extension to the registry\n     * @param extensionId The unique identifier of the new extension\n     * @param extension The address of the extension\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function addExtension(\n        bytes32 extensionId,\n        IExtension extension,\n        address creator\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(extensionId != bytes32(0), \"extension id must not be empty\");\n        require(\n            extensions[extensionId] == address(0x0),\n            \"extension Id already in use\"\n        );\n        require(\n            !inverseExtensions[address(extension)].deleted,\n            \"extension can not be re-added\"\n        );\n        extensions[extensionId] = address(extension);\n        inverseExtensions[address(extension)].id = extensionId;\n        extension.initialize(this, creator);\n        emit ExtensionAdded(extensionId, address(extension));\n    }\n\n    /**\n     * @notice Removes an adapter from the registry\n     * @param extensionId The unique identifier of the extension\n     */\n    function removeExtension(bytes32 extensionId)\n        external\n        hasAccess(this, AclFlag.REMOVE_EXTENSION)\n    {\n        require(extensionId != bytes32(0), \"extensionId must not be empty\");\n        address extensionAddress = extensions[extensionId];\n        require(extensionAddress != address(0x0), \"extensionId not registered\");\n        ExtensionEntry storage extEntry = inverseExtensions[extensionAddress];\n        extEntry.deleted = true;\n        //slither-disable-next-line mapping-deletion\n        delete inverseExtensions[extensionAddress];\n        delete extensions[extensionId];\n        emit ExtensionRemoved(extensionId);\n    }\n\n    /**\n     * @notice Looks up if there is an extension of a given address\n     * @return Whether or not the address is an extension\n     * @param extensionAddr The address to look up\n     */\n    function isExtension(address extensionAddr) public view returns (bool) {\n        return inverseExtensions[extensionAddr].id != bytes32(0);\n    }\n\n    /**\n     * @notice Looks up if there is an adapter of a given address\n     * @return Whether or not the address is an adapter\n     * @param adapterAddress The address to look up\n     */\n    function isAdapter(address adapterAddress) public view returns (bool) {\n        return inverseAdapters[adapterAddress].id != bytes32(0);\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccess(address adapterAddress, AclFlag flag)\n        external\n        view\n        returns (bool)\n    {\n        return\n            DaoHelper.getFlag(inverseAdapters[adapterAddress].acl, uint8(flag));\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccessToExtension(\n        address adapterAddress,\n        address extensionAddress,\n        uint8 flag\n    ) external view returns (bool) {\n        return\n            isAdapter(adapterAddress) &&\n            DaoHelper.getFlag(\n                inverseExtensions[extensionAddress].acl[adapterAddress],\n                uint8(flag)\n            );\n    }\n\n    /**\n     * @return The address of a given adapter ID\n     * @param adapterId The ID to look up\n     */\n    function getAdapterAddress(bytes32 adapterId)\n        external\n        view\n        returns (address)\n    {\n        require(adapters[adapterId] != address(0), \"adapter not found\");\n        return adapters[adapterId];\n    }\n\n    /**\n     * @return The address of a given extension Id\n     * @param extensionId The ID to look up\n     */\n    function getExtensionAddress(bytes32 extensionId)\n        external\n        view\n        returns (address)\n    {\n        require(extensions[extensionId] != address(0), \"extension not found\");\n        return extensions[extensionId];\n    }\n\n    /**\n     * PROPOSALS\n     */\n    /**\n     * @notice Submit proposals to the DAO registry\n     */\n    function submitProposal(bytes32 proposalId)\n        external\n        hasAccess(this, AclFlag.SUBMIT_PROPOSAL)\n    {\n        require(proposalId != bytes32(0), \"invalid proposalId\");\n        require(\n            !getProposalFlag(proposalId, ProposalFlag.EXISTS),\n            \"proposalId must be unique\"\n        );\n        proposals[proposalId] = Proposal(msg.sender, 1); // 1 means that only the first flag is being set i.e. EXISTS\n        emit SubmittedProposal(proposalId, 1);\n    }\n\n    /**\n     * @notice Sponsor proposals that were submitted to the DAO registry\n     * @dev adds SPONSORED to the proposal flag\n     * @param proposalId The ID of the proposal to sponsor\n     * @param sponsoringMember The member who is sponsoring the proposal\n     */\n    function sponsorProposal(\n        bytes32 proposalId,\n        address sponsoringMember,\n        address votingAdapterAddr\n    ) external onlyMember2(this, sponsoringMember) {\n        // also checks if the flag was already set\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.SPONSORED);\n\n        uint256 flags = proposal.flags;\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can process it\"\n        );\n\n        require(\n            !DaoHelper.getFlag(flags, uint8(ProposalFlag.PROCESSED)),\n            \"proposal already processed\"\n        );\n        votingAdapter[proposalId] = votingAdapterAddr;\n        emit SponsoredProposal(proposalId, flags, votingAdapterAddr);\n    }\n\n    /**\n     * @notice Mark a proposal as processed in the DAO registry\n     * @param proposalId The ID of the proposal that is being processed\n     */\n    function processProposal(bytes32 proposalId) external {\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.PROCESSED);\n\n        require(proposal.adapterAddress == msg.sender, \"err::adapter mismatch\");\n        uint256 flags = proposal.flags;\n\n        emit ProcessedProposal(proposalId, flags);\n    }\n\n    /**\n     * @notice Sets a flag of a proposal\n     * @dev Reverts if the proposal is already processed\n     * @param proposalId The ID of the proposal to be changed\n     * @param flag The flag that will be set on the proposal\n     */\n    function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        internal\n        returns (Proposal storage)\n    {\n        Proposal storage proposal = proposals[proposalId];\n\n        uint256 flags = proposal.flags;\n        require(\n            DaoHelper.getFlag(flags, uint8(ProposalFlag.EXISTS)),\n            \"proposal does not exist for this dao\"\n        );\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can set its flag\"\n        );\n\n        require(!DaoHelper.getFlag(flags, uint8(flag)), \"flag already set\");\n\n        flags = DaoHelper.setFlag(flags, uint8(flag), true);\n        proposals[proposalId].flags = flags;\n\n        return proposals[proposalId];\n    }\n\n    /*\n     * MEMBERS\n     */\n\n    /**\n     * @return Whether or not a given address is a member of the DAO.\n     * @dev it will resolve by delegate key, not member address.\n     * @param addr The address to look up\n     */\n    function isMember(address addr) external view returns (bool) {\n        address memberAddress = memberAddressesByDelegatedKey[addr];\n        return getMemberFlag(memberAddress, MemberFlag.EXISTS);\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given proposal\n     * @param proposalId The proposal to check against flag\n     * @param flag The flag to check in the proposal\n     */\n    function getProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(proposals[proposalId].flags, uint8(flag));\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given member\n     * @param memberAddress The member to check against flag\n     * @param flag The flag to check in the member\n     */\n    function getMemberFlag(address memberAddress, MemberFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(members[memberAddress].flags, uint8(flag));\n    }\n\n    function getNbMembers() external view returns (uint256) {\n        return _members.length;\n    }\n\n    function getMemberAddress(uint256 index) external view returns (address) {\n        return _members[index];\n    }\n\n    /**\n     * @notice Updates the delegate key of a member\n     * @param memberAddr The member doing the delegation\n     * @param newDelegateKey The member who is being delegated to\n     */\n    function updateDelegateKey(address memberAddr, address newDelegateKey)\n        external\n        hasAccess(this, AclFlag.UPDATE_DELEGATE_KEY)\n    {\n        require(newDelegateKey != address(0x0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != memberAddr) {\n            require(\n                // newDelegate must not be delegated to\n                memberAddressesByDelegatedKey[newDelegateKey] == address(0x0),\n                \"cannot overwrite existing delegated keys\"\n            );\n        } else {\n            require(\n                memberAddressesByDelegatedKey[memberAddr] == address(0x0),\n                \"address already taken as delegated key\"\n            );\n        }\n\n        Member storage member = members[memberAddr];\n        require(\n            DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS)),\n            \"member does not exist\"\n        );\n\n        // Reset the delegation of the previous delegate\n        memberAddressesByDelegatedKey[\n            getCurrentDelegateKey(memberAddr)\n        ] = address(0x0);\n\n        memberAddressesByDelegatedKey[newDelegateKey] = memberAddr;\n\n        _createNewDelegateCheckpoint(memberAddr, newDelegateKey);\n        emit UpdateDelegateKey(memberAddr, newDelegateKey);\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * @param checkAddr The address to check for a delegate\n     * @return the delegated address or the checked address if it is not a delegate\n     */\n    function getAddressIfDelegated(address checkAddr)\n        external\n        view\n        returns (address)\n    {\n        address delegatedKey = memberAddressesByDelegatedKey[checkAddr];\n        return delegatedKey == address(0x0) ? checkAddr : delegatedKey;\n    }\n\n    /**\n     * @param memberAddr The member whose delegate will be returned\n     * @return the delegate key at the current time for a member\n     */\n    function getCurrentDelegateKey(address memberAddr)\n        public\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 0\n                ? checkpoints[memberAddr][nCheckpoints - 1].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @param memberAddr The member address to look up\n     * @return The delegate key address for memberAddr at the second last checkpoint number\n     */\n    function getPreviousDelegateKey(address memberAddr)\n        external\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 1\n                ? checkpoints[memberAddr][nCheckpoints - 2].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param memberAddr The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorDelegateKey(address memberAddr, uint256 blockNumber)\n        external\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorDelegateKey: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        if (nCheckpoints == 0) {\n            return memberAddr;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[memberAddr][nCheckpoints - 1].fromBlock <= blockNumber\n        ) {\n            return checkpoints[memberAddr][nCheckpoints - 1].delegateKey;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[memberAddr][0].fromBlock > blockNumber) {\n            return memberAddr;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DelegateCheckpoint memory cp = checkpoints[memberAddr][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegateKey;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[memberAddr][lower].delegateKey;\n    }\n\n    /**\n     * @notice Creates a new delegate checkpoint of a certain member\n     * @param member The member whose delegate checkpoints will be added to\n     * @param newDelegateKey The delegate key that will be written into the new checkpoint\n     */\n    function _createNewDelegateCheckpoint(\n        address member,\n        address newDelegateKey\n    ) internal {\n        uint32 nCheckpoints = numCheckpoints[member];\n        // The only condition that we should allow the deletegaKey upgrade\n        // is when the block.number exactly matches the fromBlock value.\n        // Anything different from that should generate a new checkpoint.\n        if (\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[member][nCheckpoints - 1].fromBlock == block.number\n        ) {\n            checkpoints[member][nCheckpoints - 1].delegateKey = newDelegateKey;\n        } else {\n            checkpoints[member][nCheckpoints] = DelegateCheckpoint(\n                uint96(block.number),\n                newDelegateKey\n            );\n            numCheckpoints[member] = nCheckpoints + 1;\n        }\n    }\n}\n", "flattened_code": "pragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ninterface IExtension {\n    function initialize(DaoRegistry dao, address creator) external;\n}\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\n/**\nMIT License\n\nCopyright (c) 2021 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nlibrary DaoHelper {\n    // Adapters\n    bytes32 internal constant VOTING = keccak256(\"voting\");\n    bytes32 internal constant ONBOARDING = keccak256(\"onboarding\");\n    bytes32 internal constant NONVOTING_ONBOARDING =\n        keccak256(\"nonvoting-onboarding\");\n    bytes32 internal constant TRIBUTE = keccak256(\"tribute\");\n    bytes32 internal constant FINANCING = keccak256(\"financing\");\n    bytes32 internal constant MANAGING = keccak256(\"managing\");\n    bytes32 internal constant RAGEQUIT = keccak256(\"ragequit\");\n    bytes32 internal constant GUILDKICK = keccak256(\"guildkick\");\n    bytes32 internal constant CONFIGURATION = keccak256(\"configuration\");\n    bytes32 internal constant DISTRIBUTE = keccak256(\"distribute\");\n    bytes32 internal constant TRIBUTE_NFT = keccak256(\"tribute-nft\");\n    bytes32 internal constant TRANSFER_STRATEGY =\n        keccak256(\"erc20-transfer-strategy\");\n    bytes32 internal constant ERC1155_ADAPT = keccak256(\"erc1155-adpt\");\n\n    // Extensions\n    bytes32 internal constant BANK = keccak256(\"bank\");\n    bytes32 internal constant ERC1271 = keccak256(\"erc1271\");\n    bytes32 internal constant NFT = keccak256(\"nft\");\n    bytes32 internal constant EXECUTOR_EXT = keccak256(\"executor-ext\");\n    bytes32 internal constant INTERNAL_TOKEN_VESTING_EXT =\n        keccak256(\"internal-token-vesting-extension\");\n    bytes32 internal constant ERC1155_EXT = keccak256(\"erc1155-ext\");\n\n    // Reserved Addresses\n    address internal constant GUILD = address(0xdead);\n    address internal constant ESCROW = address(0x4bec);\n    address internal constant TOTAL = address(0xbabe);\n    address internal constant UNITS = address(0xFF1CE);\n    address internal constant LOCKED_UNITS = address(0xFFF1CE);\n    address internal constant LOOT = address(0xB105F00D);\n    address internal constant LOCKED_LOOT = address(0xBB105F00D);\n    address internal constant ETH_TOKEN = address(0x0);\n    address internal constant MEMBER_COUNT = address(0xDECAFBAD);\n\n    uint8 internal constant MAX_TOKENS_GUILD_BANK = 200;\n\n    function totalTokens(BankExtension bank) internal view returns (uint256) {\n        return memberTokens(bank, TOTAL) - memberTokens(bank, GUILD); //GUILD is accounted for twice otherwise\n    }\n\n    /**\n     * @notice calculates the total number of units.\n     */\n    function priorTotalTokens(BankExtension bank, uint256 at)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            priorMemberTokens(bank, TOTAL, at) -\n            priorMemberTokens(bank, GUILD, at);\n    }\n\n    function memberTokens(BankExtension bank, address member)\n        internal\n        view\n        returns (uint256)\n    {\n        return\n            bank.balanceOf(member, UNITS) +\n            bank.balanceOf(member, LOCKED_UNITS) +\n            bank.balanceOf(member, LOOT) +\n            bank.balanceOf(member, LOCKED_LOOT);\n    }\n\n    /**\n     * @notice calculates the total number of units.\n     */\n    function priorMemberTokens(\n        BankExtension bank,\n        address member,\n        uint256 at\n    ) internal view returns (uint256) {\n        return\n            bank.getPriorAmount(member, UNITS, at) +\n            bank.getPriorAmount(member, LOCKED_UNITS, at) +\n            bank.getPriorAmount(member, LOOT, at) +\n            bank.getPriorAmount(member, LOCKED_LOOT, at);\n    }\n\n    //helper\n    function getFlag(uint256 flags, uint256 flag) internal pure returns (bool) {\n        return (flags >> uint8(flag)) % 2 == 1;\n    }\n\n    function setFlag(\n        uint256 flags,\n        uint256 flag,\n        bool value\n    ) internal pure returns (uint256) {\n        if (getFlag(flags, flag) != value) {\n            if (value) {\n                return flags + 2**flag;\n            } else {\n                return flags - 2**flag;\n            }\n        } else {\n            return flags;\n        }\n    }\n\n    /**\n     * @notice Checks if a given address is reserved.\n     */\n    function isNotReservedAddress(address addr) internal pure returns (bool) {\n        return addr != GUILD && addr != TOTAL && addr != ESCROW;\n    }\n\n    /**\n     * @notice Checks if a given address is zeroed.\n     */\n    function isNotZeroAddress(address addr) internal pure returns (bool) {\n        return addr != address(0x0);\n    }\n\n    function potentialNewMember(\n        address memberAddress,\n        DaoRegistry dao,\n        BankExtension bank\n    ) internal {\n        dao.potentialNewMember(memberAddress);\n        require(memberAddress != address(0x0), \"invalid member address\");\n        if (address(bank) != address(0x0)) {\n            if (bank.balanceOf(memberAddress, MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, MEMBER_COUNT, 1);\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract BankExtension is AdapterGuard, IExtension {\n    using Address for address payable;\n    using SafeERC20 for IERC20;\n\n    uint8 public maxExternalTokens; // the maximum number of external tokens that can be stored in the bank\n\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n    DaoRegistry public dao;\n\n    enum AclFlag {\n        ADD_TO_BALANCE,\n        SUB_FROM_BALANCE,\n        INTERNAL_TRANSFER,\n        WITHDRAW,\n        REGISTER_NEW_TOKEN,\n        REGISTER_NEW_INTERNAL_TOKEN,\n        UPDATE_TOKEN\n    }\n\n    modifier noProposal() {\n        require(dao.lockedAt() < block.number, \"proposal lock\");\n        _;\n    }\n\n    /// @dev - Events for Bank\n    event NewBalance(address member, address tokenAddr, uint160 amount);\n\n    event Withdraw(address account, address tokenAddr, uint160 amount);\n\n    /*\n     * STRUCTURES\n     */\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    address[] public tokens;\n    address[] public internalTokens;\n    // tokenAddress => availability\n    mapping(address => bool) public availableTokens;\n    mapping(address => bool) public availableInternalTokens;\n    // tokenAddress => memberAddress => checkpointNum => Checkpoint\n    mapping(address => mapping(address => mapping(uint32 => Checkpoint)))\n        public checkpoints;\n    // tokenAddress => memberAddress => numCheckpoints\n    mapping(address => mapping(address => uint32)) public numCheckpoints;\n\n    /// @notice Clonable contract must have an empty constructor\n    constructor() {}\n\n    modifier hasExtensionAccess(AclFlag flag) {\n        require(\n            address(this) == msg.sender ||\n                address(dao) == msg.sender ||\n                dao.state() == DaoRegistry.DaoState.CREATION ||\n                dao.hasAdapterAccessToExtension(\n                    msg.sender,\n                    address(this),\n                    uint8(flag)\n                ),\n            \"bank::accessDenied\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function initialize(DaoRegistry _dao, address creator) external override {\n        require(!initialized, \"bank already initialized\");\n        require(_dao.isMember(creator), \"bank::not member\");\n        dao = _dao;\n        initialized = true;\n\n        availableInternalTokens[DaoHelper.UNITS] = true;\n        internalTokens.push(DaoHelper.UNITS);\n\n        availableInternalTokens[DaoHelper.MEMBER_COUNT] = true;\n        internalTokens.push(DaoHelper.MEMBER_COUNT);\n        uint256 nbMembers = _dao.getNbMembers();\n        for (uint256 i = 0; i < nbMembers; i++) {\n            addToBalance(_dao.getMemberAddress(i), DaoHelper.MEMBER_COUNT, 1);\n        }\n\n        _createNewAmountCheckpoint(creator, DaoHelper.UNITS, 1);\n        _createNewAmountCheckpoint(DaoHelper.TOTAL, DaoHelper.UNITS, 1);\n    }\n\n    function withdraw(\n        address payable member,\n        address tokenAddr,\n        uint256 amount\n    ) external hasExtensionAccess(AclFlag.WITHDRAW) {\n        require(\n            balanceOf(member, tokenAddr) >= amount,\n            \"bank::withdraw::not enough funds\"\n        );\n        subtractFromBalance(member, tokenAddr, amount);\n        if (tokenAddr == DaoHelper.ETH_TOKEN) {\n            member.sendValue(amount);\n        } else {\n            IERC20 erc20 = IERC20(tokenAddr);\n            erc20.safeTransfer(member, amount);\n        }\n\n        emit Withdraw(member, tokenAddr, uint160(amount));\n    }\n\n    /**\n     * @return Whether or not the given token is an available internal token in the bank\n     * @param token The address of the token to look up\n     */\n    function isInternalToken(address token) external view returns (bool) {\n        return availableInternalTokens[token];\n    }\n\n    /**\n     * @return Whether or not the given token is an available token in the bank\n     * @param token The address of the token to look up\n     */\n    function isTokenAllowed(address token) public view returns (bool) {\n        return availableTokens[token];\n    }\n\n    /**\n     * @notice Sets the maximum amount of external tokens allowed in the bank\n     * @param maxTokens The maximum amount of token allowed\n     */\n    function setMaxExternalTokens(uint8 maxTokens) external {\n        require(!initialized, \"bank already initialized\");\n        require(\n            maxTokens > 0 && maxTokens <= DaoHelper.MAX_TOKENS_GUILD_BANK,\n            \"max number of external tokens should be (0,200)\"\n        );\n        maxExternalTokens = maxTokens;\n    }\n\n    /*\n     * BANK\n     */\n\n    /**\n     * @notice Registers a potential new token in the bank\n     * @dev Cannot be a reserved token or an available internal token\n     * @param token The address of the token\n     */\n    function registerPotentialNewToken(address token)\n        external\n        hasExtensionAccess(AclFlag.REGISTER_NEW_TOKEN)\n    {\n        require(DaoHelper.isNotReservedAddress(token), \"reservedToken\");\n        require(!availableInternalTokens[token], \"internalToken\");\n        require(\n            tokens.length <= maxExternalTokens,\n            \"exceeds the maximum tokens allowed\"\n        );\n\n        if (!availableTokens[token]) {\n            availableTokens[token] = true;\n            tokens.push(token);\n        }\n    }\n\n    /**\n     * @notice Registers a potential new internal token in the bank\n     * @dev Can not be a reserved token or an available token\n     * @param token The address of the token\n     */\n    function registerPotentialNewInternalToken(address token)\n        external\n        hasExtensionAccess(AclFlag.REGISTER_NEW_INTERNAL_TOKEN)\n    {\n        require(DaoHelper.isNotReservedAddress(token), \"reservedToken\");\n        require(!availableTokens[token], \"availableToken\");\n\n        if (!availableInternalTokens[token]) {\n            availableInternalTokens[token] = true;\n            internalTokens.push(token);\n        }\n    }\n\n    function updateToken(address tokenAddr)\n        external\n        hasExtensionAccess(AclFlag.UPDATE_TOKEN)\n    {\n        require(isTokenAllowed(tokenAddr), \"token not allowed\");\n        uint256 totalBalance = balanceOf(DaoHelper.TOTAL, tokenAddr);\n\n        uint256 realBalance;\n\n        if (tokenAddr == DaoHelper.ETH_TOKEN) {\n            realBalance = address(this).balance;\n        } else {\n            IERC20 erc20 = IERC20(tokenAddr);\n            realBalance = erc20.balanceOf(address(this));\n        }\n\n        if (totalBalance < realBalance) {\n            addToBalance(\n                DaoHelper.GUILD,\n                tokenAddr,\n                realBalance - totalBalance\n            );\n        } else if (totalBalance > realBalance) {\n            uint256 tokensToRemove = totalBalance - realBalance;\n            uint256 guildBalance = balanceOf(DaoHelper.GUILD, tokenAddr);\n            if (guildBalance > tokensToRemove) {\n                subtractFromBalance(DaoHelper.GUILD, tokenAddr, tokensToRemove);\n            } else {\n                subtractFromBalance(DaoHelper.GUILD, tokenAddr, guildBalance);\n            }\n        }\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * Internal bookkeeping\n     */\n\n    /**\n     * @return The token from the bank of a given index\n     * @param index The index to look up in the bank's tokens\n     */\n    function getToken(uint256 index) external view returns (address) {\n        return tokens[index];\n    }\n\n    /**\n     * @return The amount of token addresses in the bank\n     */\n    function nbTokens() external view returns (uint256) {\n        return tokens.length;\n    }\n\n    /**\n     * @return All the tokens registered in the bank.\n     */\n    function getTokens() external view returns (address[] memory) {\n        return tokens;\n    }\n\n    /**\n     * @return The internal token at a given index\n     * @param index The index to look up in the bank's array of internal tokens\n     */\n    function getInternalToken(uint256 index) external view returns (address) {\n        return internalTokens[index];\n    }\n\n    /**\n     * @return The amount of internal token addresses in the bank\n     */\n    function nbInternalTokens() external view returns (uint256) {\n        return internalTokens.length;\n    }\n\n    /**\n     * @notice Adds to a member's balance of a given token\n     * @param member The member whose balance will be updated\n     * @param token The token to update\n     * @param amount The new balance\n     */\n    function addToBalance(\n        address member,\n        address token,\n        uint256 amount\n    ) public payable hasExtensionAccess(AclFlag.ADD_TO_BALANCE) {\n        require(\n            availableTokens[token] || availableInternalTokens[token],\n            \"unknown token address\"\n        );\n        uint256 newAmount = balanceOf(member, token) + amount;\n        uint256 newTotalAmount = balanceOf(DaoHelper.TOTAL, token) + amount;\n\n        _createNewAmountCheckpoint(member, token, newAmount);\n        _createNewAmountCheckpoint(DaoHelper.TOTAL, token, newTotalAmount);\n    }\n\n    /**\n     * @notice Remove from a member's balance of a given token\n     * @param member The member whose balance will be updated\n     * @param token The token to update\n     * @param amount The new balance\n     */\n    function subtractFromBalance(\n        address member,\n        address token,\n        uint256 amount\n    ) public hasExtensionAccess(AclFlag.SUB_FROM_BALANCE) {\n        uint256 newAmount = balanceOf(member, token) - amount;\n        uint256 newTotalAmount = balanceOf(DaoHelper.TOTAL, token) - amount;\n\n        _createNewAmountCheckpoint(member, token, newAmount);\n        _createNewAmountCheckpoint(DaoHelper.TOTAL, token, newTotalAmount);\n    }\n\n    /**\n     * @notice Make an internal token transfer\n     * @param from The member who is sending tokens\n     * @param to The member who is receiving tokens\n     * @param amount The new amount to transfer\n     */\n    function internalTransfer(\n        address from,\n        address to,\n        address token,\n        uint256 amount\n    ) external hasExtensionAccess(AclFlag.INTERNAL_TRANSFER) {\n        uint256 newAmount = balanceOf(from, token) - amount;\n        uint256 newAmount2 = balanceOf(to, token) + amount;\n\n        _createNewAmountCheckpoint(from, token, newAmount);\n        _createNewAmountCheckpoint(to, token, newAmount2);\n    }\n\n    /**\n     * @notice Returns an member's balance of a given token\n     * @param member The address to look up\n     * @param tokenAddr The token where the member's balance of which will be returned\n     * @return The amount in account's tokenAddr balance\n     */\n    function balanceOf(address member, address tokenAddr)\n        public\n        view\n        returns (uint160)\n    {\n        uint32 nCheckpoints = numCheckpoints[tokenAddr][member];\n        return\n            nCheckpoints > 0\n                ? checkpoints[tokenAddr][member][nCheckpoints - 1].amount\n                : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorAmount(\n        address account,\n        address tokenAddr,\n        uint256 blockNumber\n    ) external view returns (uint256) {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorAmount: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[tokenAddr][account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[tokenAddr][account][nCheckpoints - 1].fromBlock <=\n            blockNumber\n        ) {\n            return checkpoints[tokenAddr][account][nCheckpoints - 1].amount;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[tokenAddr][account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[tokenAddr][account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.amount;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[tokenAddr][account][lower].amount;\n    }\n\n    /**\n     * @notice Creates a new amount checkpoint for a token of a certain member\n     * @dev Reverts if the amount is greater than 2**64-1\n     * @param member The member whose checkpoints will be added to\n     * @param token The token of which the balance will be changed\n     * @param amount The amount to be written into the new checkpoint\n     */\n    function _createNewAmountCheckpoint(\n        address member,\n        address token,\n        uint256 amount\n    ) internal {\n        bool isValidToken = false;\n        if (availableInternalTokens[token]) {\n            require(\n                amount < type(uint88).max,\n                \"token amount exceeds the maximum limit for internal tokens\"\n            );\n            isValidToken = true;\n        } else if (availableTokens[token]) {\n            require(\n                amount < type(uint160).max,\n                \"token amount exceeds the maximum limit for external tokens\"\n            );\n            isValidToken = true;\n        }\n        uint160 newAmount = uint160(amount);\n\n        require(isValidToken, \"token not registered\");\n\n        uint32 nCheckpoints = numCheckpoints[token][member];\n        if (\n            // The only condition that we should allow the amount update\n            // is when the block.number exactly matches the fromBlock value.\n            // Anything different from that should generate a new checkpoint.\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[token][member][nCheckpoints - 1].fromBlock ==\n            block.number\n        ) {\n            checkpoints[token][member][nCheckpoints - 1].amount = newAmount;\n        } else {\n            checkpoints[token][member][nCheckpoints] = Checkpoint(\n                uint96(block.number),\n                newAmount\n            );\n            numCheckpoints[token][member] = nCheckpoints + 1;\n        }\n        emit NewBalance(member, token, newAmount);\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nabstract contract MemberGuard {\n    /**\n     * @dev Only members of the DAO are allowed to execute the function call.\n     */\n    modifier onlyMember(DaoRegistry dao) {\n        _onlyMember(dao, msg.sender);\n        _;\n    }\n\n    modifier onlyMember2(DaoRegistry dao, address _addr) {\n        _onlyMember(dao, _addr);\n        _;\n    }\n\n    function _onlyMember(DaoRegistry dao, address _addr) internal view {\n        require(isActiveMember(dao, _addr), \"onlyMember\");\n    }\n\n    function isActiveMember(DaoRegistry dao, address _addr)\n        public\n        view\n        returns (bool)\n    {\n        address bankAddress = dao.extensions(DaoHelper.BANK);\n        if (bankAddress != address(0x0)) {\n            address memberAddr = dao.getAddressIfDelegated(_addr);\n            return\n                BankExtension(bankAddress).balanceOf(\n                    memberAddr,\n                    DaoHelper.UNITS\n                ) > 0;\n        }\n\n        return dao.isMember(_addr);\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract DaoRegistry is MemberGuard, AdapterGuard {\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n\n    enum DaoState {CREATION, READY}\n\n    /*\n     * EVENTS\n     */\n    /// @dev - Events for Proposals\n    event SubmittedProposal(bytes32 proposalId, uint256 flags);\n    event SponsoredProposal(\n        bytes32 proposalId,\n        uint256 flags,\n        address votingAdapter\n    );\n    event ProcessedProposal(bytes32 proposalId, uint256 flags);\n    event AdapterAdded(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint256 flags\n    );\n    event AdapterRemoved(bytes32 adapterId);\n\n    event ExtensionAdded(bytes32 extensionId, address extensionAddress);\n    event ExtensionRemoved(bytes32 extensionId);\n\n    /// @dev - Events for Members\n    event UpdateDelegateKey(address memberAddress, address newDelegateKey);\n    event ConfigurationUpdated(bytes32 key, uint256 value);\n    event AddressConfigurationUpdated(bytes32 key, address value);\n\n    enum MemberFlag {EXISTS}\n\n    enum ProposalFlag {EXISTS, SPONSORED, PROCESSED}\n\n    enum AclFlag {\n        REPLACE_ADAPTER,\n        SUBMIT_PROPOSAL,\n        UPDATE_DELEGATE_KEY,\n        SET_CONFIGURATION,\n        ADD_EXTENSION,\n        REMOVE_EXTENSION,\n        NEW_MEMBER\n    }\n\n    /*\n     * STRUCTURES\n     */\n    struct Proposal {\n        // the structure to track all the proposals in the DAO\n        address adapterAddress; // the adapter address that called the functions to change the DAO state\n        uint256 flags; // flags to track the state of the proposal: exist, sponsored, processed, canceled, etc.\n    }\n\n    struct Member {\n        // the structure to track all the members in the DAO\n        uint256 flags; // flags to track the state of the member: exists, etc\n    }\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    struct DelegateCheckpoint {\n        // A checkpoint for marking the delegate key for a member from a given block\n        uint96 fromBlock;\n        address delegateKey;\n    }\n\n    struct AdapterEntry {\n        bytes32 id;\n        uint256 acl;\n    }\n\n    struct ExtensionEntry {\n        bytes32 id;\n        mapping(address => uint256) acl;\n        bool deleted;\n    }\n\n    /*\n     * PUBLIC VARIABLES\n     */\n    mapping(address => Member) public members; // the map to track all members of the DAO\n    address[] private _members;\n\n    // delegate key => member address mapping\n    mapping(address => address) public memberAddressesByDelegatedKey;\n\n    // memberAddress => checkpointNum => DelegateCheckpoint\n    mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints;\n    // memberAddress => numDelegateCheckpoints\n    mapping(address => uint32) numCheckpoints;\n\n    DaoState public state;\n\n    /// @notice The map that keeps track of all proposasls submitted to the DAO\n    mapping(bytes32 => Proposal) public proposals;\n    /// @notice The map that tracks the voting adapter address per proposalId\n    mapping(bytes32 => address) public votingAdapter;\n    /// @notice The map that keeps track of all adapters registered in the DAO\n    mapping(bytes32 => address) public adapters;\n    /// @notice The inverse map to get the adapter id based on its address\n    mapping(address => AdapterEntry) public inverseAdapters;\n    /// @notice The map that keeps track of all extensions registered in the DAO\n    mapping(bytes32 => address) public extensions;\n    /// @notice The inverse map to get the extension id based on its address\n    mapping(address => ExtensionEntry) public inverseExtensions;\n    /// @notice The map that keeps track of configuration parameters for the DAO and adapters\n    mapping(bytes32 => uint256) public mainConfiguration;\n    mapping(bytes32 => address) public addressConfiguration;\n\n    uint256 public lockedAt;\n\n    /// @notice Clonable contract must have an empty constructor\n    constructor() {}\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n     */\n    //slither-disable-next-line reentrancy-no-eth\n    function initialize(address creator, address payer) external {\n        require(!initialized, \"dao already initialized\");\n        initialized = true;\n        potentialNewMember(msg.sender);\n        potentialNewMember(payer);\n        potentialNewMember(creator);\n    }\n\n    /**\n     * @notice default fallback function to prevent from sending ether to the contract\n     */\n    // The transaction is always reverted, so there are no risks of locking ether in the contract\n    //slither-disable-next-line locked-ether\n    receive() external payable {\n        revert(\"you cannot send money back directly\");\n    }\n\n    /**\n     * @dev Sets the state of the dao to READY\n     */\n    function finalizeDao() external {\n        state = DaoState.READY;\n    }\n\n    /**\n     * @notice Contract lock strategy to lock only the caller is an adapter or extension.\n     */\n    function lockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = block.number;\n        }\n    }\n\n    /**\n     * @notice Contract lock strategy to release the lock only the caller is an adapter or extension.\n     */\n    function unlockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = 0;\n        }\n    }\n\n    /**\n     * @notice Sets a configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setConfiguration(bytes32 key, uint256 value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        mainConfiguration[key] = value;\n\n        emit ConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @notice Registers a member address in the DAO if it is not registered or invalid.\n     * @notice A potential new member is a member that holds no shares, and its registration still needs to be voted on.\n     */\n    function potentialNewMember(address memberAddress)\n        public\n        hasAccess(this, AclFlag.NEW_MEMBER)\n    {\n        require(memberAddress != address(0x0), \"invalid member address\");\n\n        Member storage member = members[memberAddress];\n        if (!DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS))) {\n            require(\n                memberAddressesByDelegatedKey[memberAddress] == address(0x0),\n                \"member address already taken as delegated key\"\n            );\n            member.flags = DaoHelper.setFlag(\n                member.flags,\n                uint8(MemberFlag.EXISTS),\n                true\n            );\n            memberAddressesByDelegatedKey[memberAddress] = memberAddress;\n            _members.push(memberAddress);\n        }\n\n        address bankAddress = extensions[DaoHelper.BANK];\n        if (bankAddress != address(0x0)) {\n            BankExtension bank = BankExtension(bankAddress);\n            if (bank.balanceOf(memberAddress, DaoHelper.MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, DaoHelper.MEMBER_COUNT, 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets an configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setAddressConfiguration(bytes32 key, address value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        addressConfiguration[key] = value;\n\n        emit AddressConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getConfiguration(bytes32 key) external view returns (uint256) {\n        return mainConfiguration[key];\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getAddressConfiguration(bytes32 key)\n        external\n        view\n        returns (address)\n    {\n        return addressConfiguration[key];\n    }\n\n    /**\n     * @notice It sets the ACL flags to an Adapter to make it possible to access specific functions of an Extension.\n     */\n    function setAclToExtensionForAdapter(\n        address extensionAddress,\n        address adapterAddress,\n        uint256 acl\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(isAdapter(adapterAddress), \"not an adapter\");\n        require(isExtension(extensionAddress), \"not an extension\");\n        inverseExtensions[extensionAddress].acl[adapterAddress] = acl;\n    }\n\n    /**\n     * @notice Replaces an adapter in the registry in a single step.\n     * @notice It handles addition and removal of adapters as special cases.\n     * @dev It removes the current adapter if the adapterId maps to an existing adapter address.\n     * @dev It adds an adapter if the adapterAddress parameter is not zeroed.\n     * @param adapterId The unique identifier of the adapter\n     * @param adapterAddress The address of the new adapter or zero if it is a removal operation\n     * @param acl The flags indicating the access control layer or permissions of the new adapter\n     * @param keys The keys indicating the adapter configuration names.\n     * @param values The values indicating the adapter configuration values.\n     */\n    function replaceAdapter(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint128 acl,\n        bytes32[] calldata keys,\n        uint256[] calldata values\n    ) external hasAccess(this, AclFlag.REPLACE_ADAPTER) {\n        require(adapterId != bytes32(0), \"adapterId must not be empty\");\n\n        address currentAdapterAddr = adapters[adapterId];\n        if (currentAdapterAddr != address(0x0)) {\n            delete inverseAdapters[currentAdapterAddr];\n            delete adapters[adapterId];\n            emit AdapterRemoved(adapterId);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            bytes32 key = keys[i];\n            uint256 value = values[i];\n            mainConfiguration[key] = value;\n            emit ConfigurationUpdated(key, value);\n        }\n\n        if (adapterAddress != address(0x0)) {\n            require(\n                inverseAdapters[adapterAddress].id == bytes32(0),\n                \"adapterAddress already in use\"\n            );\n            adapters[adapterId] = adapterAddress;\n            inverseAdapters[adapterAddress].id = adapterId;\n            inverseAdapters[adapterAddress].acl = acl;\n            emit AdapterAdded(adapterId, adapterAddress, acl);\n        }\n    }\n\n    /**\n     * @notice Adds a new extension to the registry\n     * @param extensionId The unique identifier of the new extension\n     * @param extension The address of the extension\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function addExtension(\n        bytes32 extensionId,\n        IExtension extension,\n        address creator\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(extensionId != bytes32(0), \"extension id must not be empty\");\n        require(\n            extensions[extensionId] == address(0x0),\n            \"extension Id already in use\"\n        );\n        require(\n            !inverseExtensions[address(extension)].deleted,\n            \"extension can not be re-added\"\n        );\n        extensions[extensionId] = address(extension);\n        inverseExtensions[address(extension)].id = extensionId;\n        extension.initialize(this, creator);\n        emit ExtensionAdded(extensionId, address(extension));\n    }\n\n    /**\n     * @notice Removes an adapter from the registry\n     * @param extensionId The unique identifier of the extension\n     */\n    function removeExtension(bytes32 extensionId)\n        external\n        hasAccess(this, AclFlag.REMOVE_EXTENSION)\n    {\n        require(extensionId != bytes32(0), \"extensionId must not be empty\");\n        address extensionAddress = extensions[extensionId];\n        require(extensionAddress != address(0x0), \"extensionId not registered\");\n        ExtensionEntry storage extEntry = inverseExtensions[extensionAddress];\n        extEntry.deleted = true;\n        //slither-disable-next-line mapping-deletion\n        delete inverseExtensions[extensionAddress];\n        delete extensions[extensionId];\n        emit ExtensionRemoved(extensionId);\n    }\n\n    /**\n     * @notice Looks up if there is an extension of a given address\n     * @return Whether or not the address is an extension\n     * @param extensionAddr The address to look up\n     */\n    function isExtension(address extensionAddr) public view returns (bool) {\n        return inverseExtensions[extensionAddr].id != bytes32(0);\n    }\n\n    /**\n     * @notice Looks up if there is an adapter of a given address\n     * @return Whether or not the address is an adapter\n     * @param adapterAddress The address to look up\n     */\n    function isAdapter(address adapterAddress) public view returns (bool) {\n        return inverseAdapters[adapterAddress].id != bytes32(0);\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccess(address adapterAddress, AclFlag flag)\n        external\n        view\n        returns (bool)\n    {\n        return\n            DaoHelper.getFlag(inverseAdapters[adapterAddress].acl, uint8(flag));\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccessToExtension(\n        address adapterAddress,\n        address extensionAddress,\n        uint8 flag\n    ) external view returns (bool) {\n        return\n            isAdapter(adapterAddress) &&\n            DaoHelper.getFlag(\n                inverseExtensions[extensionAddress].acl[adapterAddress],\n                uint8(flag)\n            );\n    }\n\n    /**\n     * @return The address of a given adapter ID\n     * @param adapterId The ID to look up\n     */\n    function getAdapterAddress(bytes32 adapterId)\n        external\n        view\n        returns (address)\n    {\n        require(adapters[adapterId] != address(0), \"adapter not found\");\n        return adapters[adapterId];\n    }\n\n    /**\n     * @return The address of a given extension Id\n     * @param extensionId The ID to look up\n     */\n    function getExtensionAddress(bytes32 extensionId)\n        external\n        view\n        returns (address)\n    {\n        require(extensions[extensionId] != address(0), \"extension not found\");\n        return extensions[extensionId];\n    }\n\n    /**\n     * PROPOSALS\n     */\n    /**\n     * @notice Submit proposals to the DAO registry\n     */\n    function submitProposal(bytes32 proposalId)\n        external\n        hasAccess(this, AclFlag.SUBMIT_PROPOSAL)\n    {\n        require(proposalId != bytes32(0), \"invalid proposalId\");\n        require(\n            !getProposalFlag(proposalId, ProposalFlag.EXISTS),\n            \"proposalId must be unique\"\n        );\n        proposals[proposalId] = Proposal(msg.sender, 1); // 1 means that only the first flag is being set i.e. EXISTS\n        emit SubmittedProposal(proposalId, 1);\n    }\n\n    /**\n     * @notice Sponsor proposals that were submitted to the DAO registry\n     * @dev adds SPONSORED to the proposal flag\n     * @param proposalId The ID of the proposal to sponsor\n     * @param sponsoringMember The member who is sponsoring the proposal\n     */\n    function sponsorProposal(\n        bytes32 proposalId,\n        address sponsoringMember,\n        address votingAdapterAddr\n    ) external onlyMember2(this, sponsoringMember) {\n        // also checks if the flag was already set\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.SPONSORED);\n\n        uint256 flags = proposal.flags;\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can process it\"\n        );\n\n        require(\n            !DaoHelper.getFlag(flags, uint8(ProposalFlag.PROCESSED)),\n            \"proposal already processed\"\n        );\n        votingAdapter[proposalId] = votingAdapterAddr;\n        emit SponsoredProposal(proposalId, flags, votingAdapterAddr);\n    }\n\n    /**\n     * @notice Mark a proposal as processed in the DAO registry\n     * @param proposalId The ID of the proposal that is being processed\n     */\n    function processProposal(bytes32 proposalId) external {\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.PROCESSED);\n\n        require(proposal.adapterAddress == msg.sender, \"err::adapter mismatch\");\n        uint256 flags = proposal.flags;\n\n        emit ProcessedProposal(proposalId, flags);\n    }\n\n    /**\n     * @notice Sets a flag of a proposal\n     * @dev Reverts if the proposal is already processed\n     * @param proposalId The ID of the proposal to be changed\n     * @param flag The flag that will be set on the proposal\n     */\n    function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        internal\n        returns (Proposal storage)\n    {\n        Proposal storage proposal = proposals[proposalId];\n\n        uint256 flags = proposal.flags;\n        require(\n            DaoHelper.getFlag(flags, uint8(ProposalFlag.EXISTS)),\n            \"proposal does not exist for this dao\"\n        );\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can set its flag\"\n        );\n\n        require(!DaoHelper.getFlag(flags, uint8(flag)), \"flag already set\");\n\n        flags = DaoHelper.setFlag(flags, uint8(flag), true);\n        proposals[proposalId].flags = flags;\n\n        return proposals[proposalId];\n    }\n\n    /*\n     * MEMBERS\n     */\n\n    /**\n     * @return Whether or not a given address is a member of the DAO.\n     * @dev it will resolve by delegate key, not member address.\n     * @param addr The address to look up\n     */\n    function isMember(address addr) external view returns (bool) {\n        address memberAddress = memberAddressesByDelegatedKey[addr];\n        return getMemberFlag(memberAddress, MemberFlag.EXISTS);\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given proposal\n     * @param proposalId The proposal to check against flag\n     * @param flag The flag to check in the proposal\n     */\n    function getProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(proposals[proposalId].flags, uint8(flag));\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given member\n     * @param memberAddress The member to check against flag\n     * @param flag The flag to check in the member\n     */\n    function getMemberFlag(address memberAddress, MemberFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(members[memberAddress].flags, uint8(flag));\n    }\n\n    function getNbMembers() external view returns (uint256) {\n        return _members.length;\n    }\n\n    function getMemberAddress(uint256 index) external view returns (address) {\n        return _members[index];\n    }\n\n    /**\n     * @notice Updates the delegate key of a member\n     * @param memberAddr The member doing the delegation\n     * @param newDelegateKey The member who is being delegated to\n     */\n    function updateDelegateKey(address memberAddr, address newDelegateKey)\n        external\n        hasAccess(this, AclFlag.UPDATE_DELEGATE_KEY)\n    {\n        require(newDelegateKey != address(0x0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != memberAddr) {\n            require(\n                // newDelegate must not be delegated to\n                memberAddressesByDelegatedKey[newDelegateKey] == address(0x0),\n                \"cannot overwrite existing delegated keys\"\n            );\n        } else {\n            require(\n                memberAddressesByDelegatedKey[memberAddr] == address(0x0),\n                \"address already taken as delegated key\"\n            );\n        }\n\n        Member storage member = members[memberAddr];\n        require(\n            DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS)),\n            \"member does not exist\"\n        );\n\n        // Reset the delegation of the previous delegate\n        memberAddressesByDelegatedKey[\n            getCurrentDelegateKey(memberAddr)\n        ] = address(0x0);\n\n        memberAddressesByDelegatedKey[newDelegateKey] = memberAddr;\n\n        _createNewDelegateCheckpoint(memberAddr, newDelegateKey);\n        emit UpdateDelegateKey(memberAddr, newDelegateKey);\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * @param checkAddr The address to check for a delegate\n     * @return the delegated address or the checked address if it is not a delegate\n     */\n    function getAddressIfDelegated(address checkAddr)\n        external\n        view\n        returns (address)\n    {\n        address delegatedKey = memberAddressesByDelegatedKey[checkAddr];\n        return delegatedKey == address(0x0) ? checkAddr : delegatedKey;\n    }\n\n    /**\n     * @param memberAddr The member whose delegate will be returned\n     * @return the delegate key at the current time for a member\n     */\n    function getCurrentDelegateKey(address memberAddr)\n        public\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 0\n                ? checkpoints[memberAddr][nCheckpoints - 1].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @param memberAddr The member address to look up\n     * @return The delegate key address for memberAddr at the second last checkpoint number\n     */\n    function getPreviousDelegateKey(address memberAddr)\n        external\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 1\n                ? checkpoints[memberAddr][nCheckpoints - 2].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param memberAddr The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorDelegateKey(address memberAddr, uint256 blockNumber)\n        external\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorDelegateKey: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        if (nCheckpoints == 0) {\n            return memberAddr;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[memberAddr][nCheckpoints - 1].fromBlock <= blockNumber\n        ) {\n            return checkpoints[memberAddr][nCheckpoints - 1].delegateKey;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[memberAddr][0].fromBlock > blockNumber) {\n            return memberAddr;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DelegateCheckpoint memory cp = checkpoints[memberAddr][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegateKey;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[memberAddr][lower].delegateKey;\n    }\n\n    /**\n     * @notice Creates a new delegate checkpoint of a certain member\n     * @param member The member whose delegate checkpoints will be added to\n     * @param newDelegateKey The delegate key that will be written into the new checkpoint\n     */\n    function _createNewDelegateCheckpoint(\n        address member,\n        address newDelegateKey\n    ) internal {\n        uint32 nCheckpoints = numCheckpoints[member];\n        // The only condition that we should allow the deletegaKey upgrade\n        // is when the block.number exactly matches the fromBlock value.\n        // Anything different from that should generate a new checkpoint.\n        if (\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[member][nCheckpoints - 1].fromBlock == block.number\n        ) {\n            checkpoints[member][nCheckpoints - 1].delegateKey = newDelegateKey;\n        } else {\n            checkpoints[member][nCheckpoints] = DelegateCheckpoint(\n                uint96(block.number),\n                newDelegateKey\n            );\n            numCheckpoints[member] = nCheckpoints + 1;\n        }\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\nabstract contract AdapterGuard {\n    /**\n     * @dev Only registered adapters are allowed to execute the function call.\n     */\n    modifier onlyAdapter(DaoRegistry dao) {\n        require(\n            (dao.state() == DaoRegistry.DaoState.CREATION &&\n                creationModeCheck(dao)) || dao.isAdapter(msg.sender),\n            \"onlyAdapter\"\n        );\n        _;\n    }\n\n    modifier reentrancyGuard(DaoRegistry dao) {\n        require(dao.lockedAt() != block.number, \"reentrancy guard\");\n        dao.lockSession();\n        _;\n        dao.unlockSession();\n    }\n\n    modifier executorFunc(DaoRegistry dao) {\n        address executorAddr =\n            dao.getExtensionAddress(keccak256(\"executor-ext\"));\n        require(address(this) == executorAddr, \"only callable by the executor\");\n        _;\n    }\n\n    modifier hasAccess(DaoRegistry dao, DaoRegistry.AclFlag flag) {\n        require(\n            (dao.state() == DaoRegistry.DaoState.CREATION &&\n                creationModeCheck(dao)) ||\n                dao.hasAdapterAccess(msg.sender, flag),\n            \"accessDenied\"\n        );\n        _;\n    }\n\n    function creationModeCheck(DaoRegistry dao) internal view returns (bool) {\n        return\n            dao.getNbMembers() == 0 ||\n            dao.isMember(msg.sender) ||\n            dao.isAdapter(msg.sender);\n    }\n}\n\n/**\nMIT License\n\nCopyright (c) 2020 Openlaw\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n */\n\ncontract DaoRegistry is MemberGuard, AdapterGuard {\n    bool public initialized = false; // internally tracks deployment under eip-1167 proxy pattern\n\n    enum DaoState {CREATION, READY}\n\n    /*\n     * EVENTS\n     */\n    /// @dev - Events for Proposals\n    event SubmittedProposal(bytes32 proposalId, uint256 flags);\n    event SponsoredProposal(\n        bytes32 proposalId,\n        uint256 flags,\n        address votingAdapter\n    );\n    event ProcessedProposal(bytes32 proposalId, uint256 flags);\n    event AdapterAdded(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint256 flags\n    );\n    event AdapterRemoved(bytes32 adapterId);\n\n    event ExtensionAdded(bytes32 extensionId, address extensionAddress);\n    event ExtensionRemoved(bytes32 extensionId);\n\n    /// @dev - Events for Members\n    event UpdateDelegateKey(address memberAddress, address newDelegateKey);\n    event ConfigurationUpdated(bytes32 key, uint256 value);\n    event AddressConfigurationUpdated(bytes32 key, address value);\n\n    enum MemberFlag {EXISTS}\n\n    enum ProposalFlag {EXISTS, SPONSORED, PROCESSED}\n\n    enum AclFlag {\n        REPLACE_ADAPTER,\n        SUBMIT_PROPOSAL,\n        UPDATE_DELEGATE_KEY,\n        SET_CONFIGURATION,\n        ADD_EXTENSION,\n        REMOVE_EXTENSION,\n        NEW_MEMBER\n    }\n\n    /*\n     * STRUCTURES\n     */\n    struct Proposal {\n        // the structure to track all the proposals in the DAO\n        address adapterAddress; // the adapter address that called the functions to change the DAO state\n        uint256 flags; // flags to track the state of the proposal: exist, sponsored, processed, canceled, etc.\n    }\n\n    struct Member {\n        // the structure to track all the members in the DAO\n        uint256 flags; // flags to track the state of the member: exists, etc\n    }\n\n    struct Checkpoint {\n        // A checkpoint for marking number of votes from a given block\n        uint96 fromBlock;\n        uint160 amount;\n    }\n\n    struct DelegateCheckpoint {\n        // A checkpoint for marking the delegate key for a member from a given block\n        uint96 fromBlock;\n        address delegateKey;\n    }\n\n    struct AdapterEntry {\n        bytes32 id;\n        uint256 acl;\n    }\n\n    struct ExtensionEntry {\n        bytes32 id;\n        mapping(address => uint256) acl;\n        bool deleted;\n    }\n\n    /*\n     * PUBLIC VARIABLES\n     */\n    mapping(address => Member) public members; // the map to track all members of the DAO\n    address[] private _members;\n\n    // delegate key => member address mapping\n    mapping(address => address) public memberAddressesByDelegatedKey;\n\n    // memberAddress => checkpointNum => DelegateCheckpoint\n    mapping(address => mapping(uint32 => DelegateCheckpoint)) checkpoints;\n    // memberAddress => numDelegateCheckpoints\n    mapping(address => uint32) numCheckpoints;\n\n    DaoState public state;\n\n    /// @notice The map that keeps track of all proposasls submitted to the DAO\n    mapping(bytes32 => Proposal) public proposals;\n    /// @notice The map that tracks the voting adapter address per proposalId\n    mapping(bytes32 => address) public votingAdapter;\n    /// @notice The map that keeps track of all adapters registered in the DAO\n    mapping(bytes32 => address) public adapters;\n    /// @notice The inverse map to get the adapter id based on its address\n    mapping(address => AdapterEntry) public inverseAdapters;\n    /// @notice The map that keeps track of all extensions registered in the DAO\n    mapping(bytes32 => address) public extensions;\n    /// @notice The inverse map to get the extension id based on its address\n    mapping(address => ExtensionEntry) public inverseExtensions;\n    /// @notice The map that keeps track of configuration parameters for the DAO and adapters\n    mapping(bytes32 => uint256) public mainConfiguration;\n    mapping(bytes32 => address) public addressConfiguration;\n\n    uint256 public lockedAt;\n\n    /// @notice Clonable contract must have an empty constructor\n    constructor() {}\n\n    /**\n     * @notice Initialises the DAO\n     * @dev Involves initialising available tokens, checkpoints, and membership of creator\n     * @dev Can only be called once\n     * @param creator The DAO's creator, who will be an initial member\n     * @param payer The account which paid for the transaction to create the DAO, who will be an initial member\n     */\n    //slither-disable-next-line reentrancy-no-eth\n    function initialize(address creator, address payer) external {\n        require(!initialized, \"dao already initialized\");\n        initialized = true;\n        potentialNewMember(msg.sender);\n        potentialNewMember(payer);\n        potentialNewMember(creator);\n    }\n\n    /**\n     * @notice default fallback function to prevent from sending ether to the contract\n     */\n    // The transaction is always reverted, so there are no risks of locking ether in the contract\n    //slither-disable-next-line locked-ether\n    receive() external payable {\n        revert(\"you cannot send money back directly\");\n    }\n\n    /**\n     * @dev Sets the state of the dao to READY\n     */\n    function finalizeDao() external {\n        state = DaoState.READY;\n    }\n\n    /**\n     * @notice Contract lock strategy to lock only the caller is an adapter or extension.\n     */\n    function lockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = block.number;\n        }\n    }\n\n    /**\n     * @notice Contract lock strategy to release the lock only the caller is an adapter or extension.\n     */\n    function unlockSession() external {\n        if (isAdapter(msg.sender) || isExtension(msg.sender)) {\n            lockedAt = 0;\n        }\n    }\n\n    /**\n     * @notice Sets a configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setConfiguration(bytes32 key, uint256 value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        mainConfiguration[key] = value;\n\n        emit ConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @notice Registers a member address in the DAO if it is not registered or invalid.\n     * @notice A potential new member is a member that holds no shares, and its registration still needs to be voted on.\n     */\n    function potentialNewMember(address memberAddress)\n        public\n        hasAccess(this, AclFlag.NEW_MEMBER)\n    {\n        require(memberAddress != address(0x0), \"invalid member address\");\n\n        Member storage member = members[memberAddress];\n        if (!DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS))) {\n            require(\n                memberAddressesByDelegatedKey[memberAddress] == address(0x0),\n                \"member address already taken as delegated key\"\n            );\n            member.flags = DaoHelper.setFlag(\n                member.flags,\n                uint8(MemberFlag.EXISTS),\n                true\n            );\n            memberAddressesByDelegatedKey[memberAddress] = memberAddress;\n            _members.push(memberAddress);\n        }\n\n        address bankAddress = extensions[DaoHelper.BANK];\n        if (bankAddress != address(0x0)) {\n            BankExtension bank = BankExtension(bankAddress);\n            if (bank.balanceOf(memberAddress, DaoHelper.MEMBER_COUNT) == 0) {\n                bank.addToBalance(memberAddress, DaoHelper.MEMBER_COUNT, 1);\n            }\n        }\n    }\n\n    /**\n     * @notice Sets an configuration value\n     * @dev Changes the value of a key in the configuration mapping\n     * @param key The configuration key for which the value will be set\n     * @param value The value to set the key\n     */\n    function setAddressConfiguration(bytes32 key, address value)\n        external\n        hasAccess(this, AclFlag.SET_CONFIGURATION)\n    {\n        addressConfiguration[key] = value;\n\n        emit AddressConfigurationUpdated(key, value);\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getConfiguration(bytes32 key) external view returns (uint256) {\n        return mainConfiguration[key];\n    }\n\n    /**\n     * @return The configuration value of a particular key\n     * @param key The key to look up in the configuration mapping\n     */\n    function getAddressConfiguration(bytes32 key)\n        external\n        view\n        returns (address)\n    {\n        return addressConfiguration[key];\n    }\n\n    /**\n     * @notice It sets the ACL flags to an Adapter to make it possible to access specific functions of an Extension.\n     */\n    function setAclToExtensionForAdapter(\n        address extensionAddress,\n        address adapterAddress,\n        uint256 acl\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(isAdapter(adapterAddress), \"not an adapter\");\n        require(isExtension(extensionAddress), \"not an extension\");\n        inverseExtensions[extensionAddress].acl[adapterAddress] = acl;\n    }\n\n    /**\n     * @notice Replaces an adapter in the registry in a single step.\n     * @notice It handles addition and removal of adapters as special cases.\n     * @dev It removes the current adapter if the adapterId maps to an existing adapter address.\n     * @dev It adds an adapter if the adapterAddress parameter is not zeroed.\n     * @param adapterId The unique identifier of the adapter\n     * @param adapterAddress The address of the new adapter or zero if it is a removal operation\n     * @param acl The flags indicating the access control layer or permissions of the new adapter\n     * @param keys The keys indicating the adapter configuration names.\n     * @param values The values indicating the adapter configuration values.\n     */\n    function replaceAdapter(\n        bytes32 adapterId,\n        address adapterAddress,\n        uint128 acl,\n        bytes32[] calldata keys,\n        uint256[] calldata values\n    ) external hasAccess(this, AclFlag.REPLACE_ADAPTER) {\n        require(adapterId != bytes32(0), \"adapterId must not be empty\");\n\n        address currentAdapterAddr = adapters[adapterId];\n        if (currentAdapterAddr != address(0x0)) {\n            delete inverseAdapters[currentAdapterAddr];\n            delete adapters[adapterId];\n            emit AdapterRemoved(adapterId);\n        }\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            bytes32 key = keys[i];\n            uint256 value = values[i];\n            mainConfiguration[key] = value;\n            emit ConfigurationUpdated(key, value);\n        }\n\n        if (adapterAddress != address(0x0)) {\n            require(\n                inverseAdapters[adapterAddress].id == bytes32(0),\n                \"adapterAddress already in use\"\n            );\n            adapters[adapterId] = adapterAddress;\n            inverseAdapters[adapterAddress].id = adapterId;\n            inverseAdapters[adapterAddress].acl = acl;\n            emit AdapterAdded(adapterId, adapterAddress, acl);\n        }\n    }\n\n    /**\n     * @notice Adds a new extension to the registry\n     * @param extensionId The unique identifier of the new extension\n     * @param extension The address of the extension\n     * @param creator The DAO's creator, who will be an initial member\n     */\n    function addExtension(\n        bytes32 extensionId,\n        IExtension extension,\n        address creator\n    ) external hasAccess(this, AclFlag.ADD_EXTENSION) {\n        require(extensionId != bytes32(0), \"extension id must not be empty\");\n        require(\n            extensions[extensionId] == address(0x0),\n            \"extension Id already in use\"\n        );\n        require(\n            !inverseExtensions[address(extension)].deleted,\n            \"extension can not be re-added\"\n        );\n        extensions[extensionId] = address(extension);\n        inverseExtensions[address(extension)].id = extensionId;\n        extension.initialize(this, creator);\n        emit ExtensionAdded(extensionId, address(extension));\n    }\n\n    /**\n     * @notice Removes an adapter from the registry\n     * @param extensionId The unique identifier of the extension\n     */\n    function removeExtension(bytes32 extensionId)\n        external\n        hasAccess(this, AclFlag.REMOVE_EXTENSION)\n    {\n        require(extensionId != bytes32(0), \"extensionId must not be empty\");\n        address extensionAddress = extensions[extensionId];\n        require(extensionAddress != address(0x0), \"extensionId not registered\");\n        ExtensionEntry storage extEntry = inverseExtensions[extensionAddress];\n        extEntry.deleted = true;\n        //slither-disable-next-line mapping-deletion\n        delete inverseExtensions[extensionAddress];\n        delete extensions[extensionId];\n        emit ExtensionRemoved(extensionId);\n    }\n\n    /**\n     * @notice Looks up if there is an extension of a given address\n     * @return Whether or not the address is an extension\n     * @param extensionAddr The address to look up\n     */\n    function isExtension(address extensionAddr) public view returns (bool) {\n        return inverseExtensions[extensionAddr].id != bytes32(0);\n    }\n\n    /**\n     * @notice Looks up if there is an adapter of a given address\n     * @return Whether or not the address is an adapter\n     * @param adapterAddress The address to look up\n     */\n    function isAdapter(address adapterAddress) public view returns (bool) {\n        return inverseAdapters[adapterAddress].id != bytes32(0);\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccess(address adapterAddress, AclFlag flag)\n        external\n        view\n        returns (bool)\n    {\n        return\n            DaoHelper.getFlag(inverseAdapters[adapterAddress].acl, uint8(flag));\n    }\n\n    /**\n     * @notice Checks if an adapter has a given ACL flag\n     * @return Whether or not the given adapter has the given flag set\n     * @param adapterAddress The address to look up\n     * @param flag The ACL flag to check against the given address\n     */\n    function hasAdapterAccessToExtension(\n        address adapterAddress,\n        address extensionAddress,\n        uint8 flag\n    ) external view returns (bool) {\n        return\n            isAdapter(adapterAddress) &&\n            DaoHelper.getFlag(\n                inverseExtensions[extensionAddress].acl[adapterAddress],\n                uint8(flag)\n            );\n    }\n\n    /**\n     * @return The address of a given adapter ID\n     * @param adapterId The ID to look up\n     */\n    function getAdapterAddress(bytes32 adapterId)\n        external\n        view\n        returns (address)\n    {\n        require(adapters[adapterId] != address(0), \"adapter not found\");\n        return adapters[adapterId];\n    }\n\n    /**\n     * @return The address of a given extension Id\n     * @param extensionId The ID to look up\n     */\n    function getExtensionAddress(bytes32 extensionId)\n        external\n        view\n        returns (address)\n    {\n        require(extensions[extensionId] != address(0), \"extension not found\");\n        return extensions[extensionId];\n    }\n\n    /**\n     * PROPOSALS\n     */\n    /**\n     * @notice Submit proposals to the DAO registry\n     */\n    function submitProposal(bytes32 proposalId)\n        external\n        hasAccess(this, AclFlag.SUBMIT_PROPOSAL)\n    {\n        require(proposalId != bytes32(0), \"invalid proposalId\");\n        require(\n            !getProposalFlag(proposalId, ProposalFlag.EXISTS),\n            \"proposalId must be unique\"\n        );\n        proposals[proposalId] = Proposal(msg.sender, 1); // 1 means that only the first flag is being set i.e. EXISTS\n        emit SubmittedProposal(proposalId, 1);\n    }\n\n    /**\n     * @notice Sponsor proposals that were submitted to the DAO registry\n     * @dev adds SPONSORED to the proposal flag\n     * @param proposalId The ID of the proposal to sponsor\n     * @param sponsoringMember The member who is sponsoring the proposal\n     */\n    function sponsorProposal(\n        bytes32 proposalId,\n        address sponsoringMember,\n        address votingAdapterAddr\n    ) external onlyMember2(this, sponsoringMember) {\n        // also checks if the flag was already set\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.SPONSORED);\n\n        uint256 flags = proposal.flags;\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can process it\"\n        );\n\n        require(\n            !DaoHelper.getFlag(flags, uint8(ProposalFlag.PROCESSED)),\n            \"proposal already processed\"\n        );\n        votingAdapter[proposalId] = votingAdapterAddr;\n        emit SponsoredProposal(proposalId, flags, votingAdapterAddr);\n    }\n\n    /**\n     * @notice Mark a proposal as processed in the DAO registry\n     * @param proposalId The ID of the proposal that is being processed\n     */\n    function processProposal(bytes32 proposalId) external {\n        Proposal storage proposal =\n            _setProposalFlag(proposalId, ProposalFlag.PROCESSED);\n\n        require(proposal.adapterAddress == msg.sender, \"err::adapter mismatch\");\n        uint256 flags = proposal.flags;\n\n        emit ProcessedProposal(proposalId, flags);\n    }\n\n    /**\n     * @notice Sets a flag of a proposal\n     * @dev Reverts if the proposal is already processed\n     * @param proposalId The ID of the proposal to be changed\n     * @param flag The flag that will be set on the proposal\n     */\n    function _setProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        internal\n        returns (Proposal storage)\n    {\n        Proposal storage proposal = proposals[proposalId];\n\n        uint256 flags = proposal.flags;\n        require(\n            DaoHelper.getFlag(flags, uint8(ProposalFlag.EXISTS)),\n            \"proposal does not exist for this dao\"\n        );\n\n        require(\n            proposal.adapterAddress == msg.sender,\n            \"only the adapter that submitted the proposal can set its flag\"\n        );\n\n        require(!DaoHelper.getFlag(flags, uint8(flag)), \"flag already set\");\n\n        flags = DaoHelper.setFlag(flags, uint8(flag), true);\n        proposals[proposalId].flags = flags;\n\n        return proposals[proposalId];\n    }\n\n    /*\n     * MEMBERS\n     */\n\n    /**\n     * @return Whether or not a given address is a member of the DAO.\n     * @dev it will resolve by delegate key, not member address.\n     * @param addr The address to look up\n     */\n    function isMember(address addr) external view returns (bool) {\n        address memberAddress = memberAddressesByDelegatedKey[addr];\n        return getMemberFlag(memberAddress, MemberFlag.EXISTS);\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given proposal\n     * @param proposalId The proposal to check against flag\n     * @param flag The flag to check in the proposal\n     */\n    function getProposalFlag(bytes32 proposalId, ProposalFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(proposals[proposalId].flags, uint8(flag));\n    }\n\n    /**\n     * @return Whether or not a flag is set for a given member\n     * @param memberAddress The member to check against flag\n     * @param flag The flag to check in the member\n     */\n    function getMemberFlag(address memberAddress, MemberFlag flag)\n        public\n        view\n        returns (bool)\n    {\n        return DaoHelper.getFlag(members[memberAddress].flags, uint8(flag));\n    }\n\n    function getNbMembers() external view returns (uint256) {\n        return _members.length;\n    }\n\n    function getMemberAddress(uint256 index) external view returns (address) {\n        return _members[index];\n    }\n\n    /**\n     * @notice Updates the delegate key of a member\n     * @param memberAddr The member doing the delegation\n     * @param newDelegateKey The member who is being delegated to\n     */\n    function updateDelegateKey(address memberAddr, address newDelegateKey)\n        external\n        hasAccess(this, AclFlag.UPDATE_DELEGATE_KEY)\n    {\n        require(newDelegateKey != address(0x0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != memberAddr) {\n            require(\n                // newDelegate must not be delegated to\n                memberAddressesByDelegatedKey[newDelegateKey] == address(0x0),\n                \"cannot overwrite existing delegated keys\"\n            );\n        } else {\n            require(\n                memberAddressesByDelegatedKey[memberAddr] == address(0x0),\n                \"address already taken as delegated key\"\n            );\n        }\n\n        Member storage member = members[memberAddr];\n        require(\n            DaoHelper.getFlag(member.flags, uint8(MemberFlag.EXISTS)),\n            \"member does not exist\"\n        );\n\n        // Reset the delegation of the previous delegate\n        memberAddressesByDelegatedKey[\n            getCurrentDelegateKey(memberAddr)\n        ] = address(0x0);\n\n        memberAddressesByDelegatedKey[newDelegateKey] = memberAddr;\n\n        _createNewDelegateCheckpoint(memberAddr, newDelegateKey);\n        emit UpdateDelegateKey(memberAddr, newDelegateKey);\n    }\n\n    /**\n     * Public read-only functions\n     */\n\n    /**\n     * @param checkAddr The address to check for a delegate\n     * @return the delegated address or the checked address if it is not a delegate\n     */\n    function getAddressIfDelegated(address checkAddr)\n        external\n        view\n        returns (address)\n    {\n        address delegatedKey = memberAddressesByDelegatedKey[checkAddr];\n        return delegatedKey == address(0x0) ? checkAddr : delegatedKey;\n    }\n\n    /**\n     * @param memberAddr The member whose delegate will be returned\n     * @return the delegate key at the current time for a member\n     */\n    function getCurrentDelegateKey(address memberAddr)\n        public\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 0\n                ? checkpoints[memberAddr][nCheckpoints - 1].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @param memberAddr The member address to look up\n     * @return The delegate key address for memberAddr at the second last checkpoint number\n     */\n    function getPreviousDelegateKey(address memberAddr)\n        external\n        view\n        returns (address)\n    {\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        return\n            nCheckpoints > 1\n                ? checkpoints[memberAddr][nCheckpoints - 2].delegateKey\n                : memberAddr;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param memberAddr The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorDelegateKey(address memberAddr, uint256 blockNumber)\n        external\n        view\n        returns (address)\n    {\n        require(\n            blockNumber < block.number,\n            \"Uni::getPriorDelegateKey: not yet determined\"\n        );\n\n        uint32 nCheckpoints = numCheckpoints[memberAddr];\n        if (nCheckpoints == 0) {\n            return memberAddr;\n        }\n\n        // First check most recent balance\n        if (\n            checkpoints[memberAddr][nCheckpoints - 1].fromBlock <= blockNumber\n        ) {\n            return checkpoints[memberAddr][nCheckpoints - 1].delegateKey;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[memberAddr][0].fromBlock > blockNumber) {\n            return memberAddr;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            DelegateCheckpoint memory cp = checkpoints[memberAddr][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.delegateKey;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[memberAddr][lower].delegateKey;\n    }\n\n    /**\n     * @notice Creates a new delegate checkpoint of a certain member\n     * @param member The member whose delegate checkpoints will be added to\n     * @param newDelegateKey The delegate key that will be written into the new checkpoint\n     */\n    function _createNewDelegateCheckpoint(\n        address member,\n        address newDelegateKey\n    ) internal {\n        uint32 nCheckpoints = numCheckpoints[member];\n        // The only condition that we should allow the deletegaKey upgrade\n        // is when the block.number exactly matches the fromBlock value.\n        // Anything different from that should generate a new checkpoint.\n        if (\n            //slither-disable-next-line incorrect-equality\n            nCheckpoints > 0 &&\n            checkpoints[member][nCheckpoints - 1].fromBlock == block.number\n        ) {\n            checkpoints[member][nCheckpoints - 1].delegateKey = newDelegateKey;\n        } else {\n            checkpoints[member][nCheckpoints] = DelegateCheckpoint(\n                uint96(block.number),\n                newDelegateKey\n            );\n            numCheckpoints[member] = nCheckpoints + 1;\n        }\n    }\n}\n", "commit_id": "38e0cb233175605eaddd4f948ed21cf533d99792"}}