{"filename": "packages/hardhat/contracts/CityDaoParcel.sol", "patch": "@@ -3,6 +3,7 @@ pragma experimental ABIEncoderV2;\n //SPDX-License-Identifier: MIT\n \n import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n+import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n import \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n import \"@openzeppelin/contracts/utils/Counters.sol\";\n import \"@openzeppelin/contracts/access/Ownable.sol\";\n@@ -25,7 +26,7 @@ interface IEIP2981 is IERC165 {\n \n /// @title CityDAO Parcel 0\n /// @author @gregfromstl\n-contract CityDaoParcel is ERC165, ERC721URIStorage, Ownable, IEIP2981, VRFConsumerBase {\n+contract CityDaoParcel is ERC165, ERC721URIStorage, Ownable, IEIP2981, VRFConsumerBase, ReentrancyGuard {\n \n   // Counter to increment plot (token) IDs\n   using Counters for Counters.Counter;\n@@ -65,8 +66,8 @@ contract CityDaoParcel is ERC165, ERC721URIStorage, Ownable, IEIP2981, VRFConsum\n   // The owner of a plot NFT will also be granted one governance vote in proposals involving the communal land designated in the communalLandMetadata found at the communalLandMetadataUri.\n   uint256[] private _plotIds = new uint256[](0);\n \n-  // The plot metadata marks the bounding area of each plot. \n-  // The plot metadata's order matches the order of the plot ids array. \n+  // The plot metadata marks the bounding area of each plot.\n+  // The plot metadata's order matches the order of the plot ids array.\n   // For example, the first plot metadata is for the first plot id in the array.\n   string private plotsMetadataUri;\n \n@@ -103,8 +104,8 @@ contract CityDaoParcel is ERC165, ERC721URIStorage, Ownable, IEIP2981, VRFConsum\n   /**\n   * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n   */\n-  constructor() \n-  ERC721(\"CityDAO Parcel 0\", \"PRCL0\") \n+  constructor()\n+  ERC721(\"CityDAO Parcel 0\", \"PRCL0\")\n   VRFConsumerBase(\n       0xb3dCcb4Cf7a26f6cf6B120Cf5A73875B7BBc655B, // VRF Coordinator\n       0x01BE23585060835E02B77ef475b0Cc51aA1e0709  // LINK Token\n@@ -127,8 +128,8 @@ contract CityDaoParcel is ERC165, ERC721URIStorage, Ownable, IEIP2981, VRFConsum\n     fee = _fee;\n   }\n \n-  /** \n-  * Requests randomness \n+  /**\n+  * Requests randomness\n   */\n   function getRandomNumber() internal returns (bytes32 requestId) {\n       require(LINK.balanceOf(address(this)) >= fee, \"Not enough LINK - fill contract with at least 2 LINK (mainnet)\");\n@@ -269,20 +270,18 @@ contract CityDaoParcel is ERC165, ERC721URIStorage, Ownable, IEIP2981, VRFConsum\n   function buyPlot(uint256 plotId)\n       payable\n       external\n+      nonReentrant\n       returns (uint256)\n   {\n       require(_whitelistedAmounts[msg.sender] > 0, \"You have purchased all your whitelisted plots.\");\n       require(!isSold(plotId), \"This plot has already been sold!\");\n-      uint256 _price = _plotIdToPrice[plotId];\n-      require(msg.value == _price, \"You must pay the price of the plot!\");\n-\n-      _safeMint(msg.sender, plotId);\n-      _setTokenURI(plotId, _plotIdToMetadata[plotId]);\n-\n+      require(msg.value == _plotIdToPrice[plotId], \"You must pay the price of the plot!\");\n       _whitelistedAmounts[msg.sender] = _whitelistedAmounts[msg.sender] - 1;\n       delete _plotIdToPrice[plotId];\n       _plotIdToSoldStatus[plotId] = true;\n+      _setTokenURI(plotId, _plotIdToMetadata[plotId]);\n \n+      _safeMint(msg.sender, plotId);\n       emit PlotMinted(msg.sender, plotId);\n \n       return plotId;", "project_link": "https://github.com/citydaoproject/app/commit/5599d05567adc4abb31059fde761444f6117a4d0", "solc_version": "0.4.24", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "13d68d09b9995e8c2eba68800aa03be96f86405b"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "5599d05567adc4abb31059fde761444f6117a4d0"}}