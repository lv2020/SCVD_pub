{"filename": "contract/src/TIOracle.sol", "patch": "@@ -79,6 +79,7 @@ contract TIOracle {\n         }\n         for (uint i=0; i<peersPrice.length; i++) {\n             PeerPriceFeed memory peer = peersPrice[i];\n+            require(peer.timestamp > lastPrice.timestamp, \"invalid timestamp\");\n             require(nodesOffset[peer.peerAddress] > 0, \"peer not in valid list\");\n             require(peer.price >= prevPeerPrice , \"price list not soreted in increasing order\");\n             bytes32 digest = keccak256(abi.encodePacked(coinName, peer.price, peer.timestamp));\n@@ -97,6 +98,7 @@ contract TIOracle {\n         PriceInfo memory priceInfo;\n         priceInfo.price = peersPrice[peersPrice.length/2].price; //median\n         priceInfo.timestamp = block.timestamp;\n+        //console.log(\"timestamp\", block.timestamp);\n         lastPrice = priceInfo;\n         emit PriceFeed(lastRound, priceInfo);\n         ++feedCount;", "project_link": "https://github.com/tokenInsight/ti-oracle/commit/21267824e3846a6d83098d6f5511a5b736753356", "bug_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n//import \"forge-std/Test.sol\";\n// TIOracle is an oracle that provides reliable prices in multiple currencies\ncontract TIOracle {\n    // PriceInfo is a single piece of price information,\n    // which includes TI's quotation, and the timestamp of price feeding\n    struct PriceInfo {\n        uint256 price; //median of peers' price\n        uint256 timestamp;\n    }\n    // PeerPriceFeed represents price reported by each peer, with nodes' signature\n    struct PeerPriceFeed {\n        address peerAddress;\n        bytes sig;\n        uint256 price;\n        uint256 timestamp;\n    }\n    event NodeAdded(address newNode);\n    event NodeRemoved(address removedNode);\n    event NodeKicked(address removedNode);\n    event PriceFeed(uint256 round, PriceInfo info);\n    // Coin name\n    string coin;\n    // last updated price, with timestamp\n    PriceInfo public lastPrice;\n    // last round\n    uint256 public lastRound;\n    // count\n    uint256 public feedCount;\n    // owner of the contract\n    address admin;\n    // list of transmission nodes\n    address[] public nodes;\n    // map of nodes\n    mapping(address => uint) nodesOffset;\n    // count per round\n    uint256 public countPerRound;\n    // proposals of kicking nodes\n    mapping(address => address[]) public kickProposals;\n    // max seconds of delay for each time of feeding\n    uint256 maxDelay;\n\n    constructor(string memory coinName, uint256 feedCountPerRound, uint256 timeout) {\n        admin = msg.sender;\n        coin = coinName;\n        countPerRound = feedCountPerRound;\n        maxDelay = timeout;\n    }\n\n    // queryPrice returns the last updated price with timestamp\n    function queryPrice() public view returns (PriceInfo memory) {\n        require(lastPrice.timestamp > 0, \"not initialzied\");\n        return lastPrice;\n    }\n\n    //  decide next valid node to feed price, in a round-robbin way\n    function decideValidNode(uint256 roundNo) public view returns (address) {\n        require(nodes.length > 0, \"list of transmission nodes is empty\");\n        uint256 offset = roundNo % nodes.length;\n        return nodes[offset];\n    }\n\n    function isMyTurn() public view returns (bool)  {\n        bool timeout = lastPrice.timestamp >0 && ((block.timestamp - lastPrice.timestamp) > maxDelay);\n        //console.log(\"timeout\", timeout);\n        if (timeout) { //if timeout, any nodes in the list can feed price\n            return nodesOffset[msg.sender] > 0;\n        }\n        //in case of not timeout, scheduling should be in a way of round-robbin\n        return decideValidNode(lastRound) == msg.sender;\n    }\n\n    // check whether the feeding has enough signatures from > 2/3 nodes\n    function checkSignatures(string memory coinName, PeerPriceFeed[] memory peersPrice) view internal returns (bool) {\n        uint256 prevPeerPrice = 0;\n        if (nodes.length * 2 / 3 >= peersPrice.length) {\n            return false;\n        }\n        for (uint i=0; i<peersPrice.length; i++) {\n            PeerPriceFeed memory peer = peersPrice[i];\n            require(nodesOffset[peer.peerAddress] > 0, \"peer not in valid list\");\n            require(peer.price >= prevPeerPrice , \"price list not soreted in increasing order\");\n            bytes32 digest = keccak256(abi.encodePacked(coinName, peer.price, peer.timestamp));\n            address recovered = recoverSign(digest, peer.sig);\n            require(recovered == peer.peerAddress, \"invalid signature\");\n            prevPeerPrice = peer.price;\n        }\n        return true;\n    }\n\n    // feedPrice is called by leader node to feed price of cryptos, with a price list reported by all peers\n    function feedPrice(string memory coinName, PeerPriceFeed[] memory peersPrice) public {\n        require(keccak256(bytes(coinName)) == keccak256(bytes(coin)), \"coin mismatch\");\n        require(isMyTurn(), \"invalid transmission node\");\n        require(checkSignatures(coinName, peersPrice), \"no enough signatures of nodes\");\n        PriceInfo memory priceInfo;\n        priceInfo.price = peersPrice[peersPrice.length/2].price; //median\n        priceInfo.timestamp = block.timestamp;\n        lastPrice = priceInfo;\n        emit PriceFeed(lastRound, priceInfo);\n        ++feedCount;\n        if (feedCount % countPerRound == 0) {\n            ++lastRound; //next round\n        }\n    }\n\n    // addNode: add new trasmission node\n    function addNode(address newNode) public {\n        require(msg.sender == admin, \"invalid caller to add new node\");\n        nodes.push(newNode);\n        nodesOffset[newNode] = nodes.length;\n        emit NodeAdded(newNode);\n    }\n\n    // execute removing of a node\n    function swapAndPop(address rmNode) internal {\n        uint offset = nodesOffset[rmNode];\n        require(offset > 0, \"node not exsit\");\n        address tailNode = nodes[nodes.length - 1];\n        nodes[offset-1] = tailNode;\n        nodesOffset[tailNode] = offset;\n        nodes.pop();\n        delete nodesOffset[rmNode];\n    }\n\n    // removeNode remove trasmission node from whitelist\n    function removeNode(address rmNode) public {\n        require(msg.sender == admin, \"invalid caller to remove node\");\n        swapAndPop(rmNode);\n        emit NodeRemoved(rmNode);\n    }\n\n    // kickNode remove trasmission node from whitelist\n    function kickNode(address rmNode) public {\n        //check duplicated vote\n        for (uint256 i=0; i<kickProposals[rmNode].length; i++) {\n            require(kickProposals[rmNode][i] != msg.sender, \"duplciated vote\");\n        }\n        bool valid_sender = false;\n        for (uint256 i=0; i<nodes.length;i++) {\n            if (nodes[i] == msg.sender) {\n                valid_sender = true;\n                break;\n            }\n        }\n        require(valid_sender, \"invalid node to kick others\");\n        // vote to kick\n        kickProposals[rmNode].push(msg.sender);\n        // >2/3 agree\n        if (nodes.length * 2 / 3 < kickProposals[rmNode].length) {\n            swapAndPop(rmNode);\n            emit NodeKicked(rmNode);\n        }\n    }\n\n    // transferOwnership transfer the ownership of this contract\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == admin, \"invalid caller to transfer ownership\");\n        admin =  newOwner;\n    }\n\n    //recover address from sign\n    function recoverSign(bytes32 hash, bytes memory sig) public pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        //Check the signature length\n        if (sig.length != 65) {\n        return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n        v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n        return (address(0));\n        } else {\n        return ecrecover(hash, v, r, s);\n        }\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.13;\n//import \"forge-std/Test.sol\";\n// TIOracle is an oracle that provides reliable prices in multiple currencies\ncontract TIOracle {\n    // PriceInfo is a single piece of price information,\n    // which includes TI's quotation, and the timestamp of price feeding\n    struct PriceInfo {\n        uint256 price; //median of peers' price\n        uint256 timestamp;\n    }\n    // PeerPriceFeed represents price reported by each peer, with nodes' signature\n    struct PeerPriceFeed {\n        address peerAddress;\n        bytes sig;\n        uint256 price;\n        uint256 timestamp;\n    }\n    event NodeAdded(address newNode);\n    event NodeRemoved(address removedNode);\n    event NodeKicked(address removedNode);\n    event PriceFeed(uint256 round, PriceInfo info);\n    // Coin name\n    string coin;\n    // last updated price, with timestamp\n    PriceInfo public lastPrice;\n    // last round\n    uint256 public lastRound;\n    // count\n    uint256 public feedCount;\n    // owner of the contract\n    address admin;\n    // list of transmission nodes\n    address[] public nodes;\n    // map of nodes\n    mapping(address => uint) nodesOffset;\n    // count per round\n    uint256 public countPerRound;\n    // proposals of kicking nodes\n    mapping(address => address[]) public kickProposals;\n    // max seconds of delay for each time of feeding\n    uint256 maxDelay;\n\n    constructor(string memory coinName, uint256 feedCountPerRound, uint256 timeout) {\n        admin = msg.sender;\n        coin = coinName;\n        countPerRound = feedCountPerRound;\n        maxDelay = timeout;\n    }\n\n    // queryPrice returns the last updated price with timestamp\n    function queryPrice() public view returns (PriceInfo memory) {\n        require(lastPrice.timestamp > 0, \"not initialzied\");\n        return lastPrice;\n    }\n\n    //  decide next valid node to feed price, in a round-robbin way\n    function decideValidNode(uint256 roundNo) public view returns (address) {\n        require(nodes.length > 0, \"list of transmission nodes is empty\");\n        uint256 offset = roundNo % nodes.length;\n        return nodes[offset];\n    }\n\n    function isMyTurn() public view returns (bool)  {\n        bool timeout = lastPrice.timestamp >0 && ((block.timestamp - lastPrice.timestamp) > maxDelay);\n        //console.log(\"timeout\", timeout);\n        if (timeout) { //if timeout, any nodes in the list can feed price\n            return nodesOffset[msg.sender] > 0;\n        }\n        //in case of not timeout, scheduling should be in a way of round-robbin\n        return decideValidNode(lastRound) == msg.sender;\n    }\n\n    // check whether the feeding has enough signatures from > 2/3 nodes\n    function checkSignatures(string memory coinName, PeerPriceFeed[] memory peersPrice) view internal returns (bool) {\n        uint256 prevPeerPrice = 0;\n        if (nodes.length * 2 / 3 >= peersPrice.length) {\n            return false;\n        }\n        for (uint i=0; i<peersPrice.length; i++) {\n            PeerPriceFeed memory peer = peersPrice[i];\n            require(nodesOffset[peer.peerAddress] > 0, \"peer not in valid list\");\n            require(peer.price >= prevPeerPrice , \"price list not soreted in increasing order\");\n            bytes32 digest = keccak256(abi.encodePacked(coinName, peer.price, peer.timestamp));\n            address recovered = recoverSign(digest, peer.sig);\n            require(recovered == peer.peerAddress, \"invalid signature\");\n            prevPeerPrice = peer.price;\n        }\n        return true;\n    }\n\n    // feedPrice is called by leader node to feed price of cryptos, with a price list reported by all peers\n    function feedPrice(string memory coinName, PeerPriceFeed[] memory peersPrice) public {\n        require(keccak256(bytes(coinName)) == keccak256(bytes(coin)), \"coin mismatch\");\n        require(isMyTurn(), \"invalid transmission node\");\n        require(checkSignatures(coinName, peersPrice), \"no enough signatures of nodes\");\n        PriceInfo memory priceInfo;\n        priceInfo.price = peersPrice[peersPrice.length/2].price; //median\n        priceInfo.timestamp = block.timestamp;\n        lastPrice = priceInfo;\n        emit PriceFeed(lastRound, priceInfo);\n        ++feedCount;\n        if (feedCount % countPerRound == 0) {\n            ++lastRound; //next round\n        }\n    }\n\n    // addNode: add new trasmission node\n    function addNode(address newNode) public {\n        require(msg.sender == admin, \"invalid caller to add new node\");\n        nodes.push(newNode);\n        nodesOffset[newNode] = nodes.length;\n        emit NodeAdded(newNode);\n    }\n\n    // execute removing of a node\n    function swapAndPop(address rmNode) internal {\n        uint offset = nodesOffset[rmNode];\n        require(offset > 0, \"node not exsit\");\n        address tailNode = nodes[nodes.length - 1];\n        nodes[offset-1] = tailNode;\n        nodesOffset[tailNode] = offset;\n        nodes.pop();\n        delete nodesOffset[rmNode];\n    }\n\n    // removeNode remove trasmission node from whitelist\n    function removeNode(address rmNode) public {\n        require(msg.sender == admin, \"invalid caller to remove node\");\n        swapAndPop(rmNode);\n        emit NodeRemoved(rmNode);\n    }\n\n    // kickNode remove trasmission node from whitelist\n    function kickNode(address rmNode) public {\n        //check duplicated vote\n        for (uint256 i=0; i<kickProposals[rmNode].length; i++) {\n            require(kickProposals[rmNode][i] != msg.sender, \"duplciated vote\");\n        }\n        bool valid_sender = false;\n        for (uint256 i=0; i<nodes.length;i++) {\n            if (nodes[i] == msg.sender) {\n                valid_sender = true;\n                break;\n            }\n        }\n        require(valid_sender, \"invalid node to kick others\");\n        // vote to kick\n        kickProposals[rmNode].push(msg.sender);\n        // >2/3 agree\n        if (nodes.length * 2 / 3 < kickProposals[rmNode].length) {\n            swapAndPop(rmNode);\n            emit NodeKicked(rmNode);\n        }\n    }\n\n    // transferOwnership transfer the ownership of this contract\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == admin, \"invalid caller to transfer ownership\");\n        admin =  newOwner;\n    }\n\n    //recover address from sign\n    function recoverSign(bytes32 hash, bytes memory sig) public pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        //Check the signature length\n        if (sig.length != 65) {\n        return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n        v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n        return (address(0));\n        } else {\n        return ecrecover(hash, v, r, s);\n        }\n    }\n}\n", "commit_id": "e0acaee12a4298dc6c322af2ca2cdee4cf79892c"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n//import \"forge-std/Test.sol\";\n// TIOracle is an oracle that provides reliable prices in multiple currencies\ncontract TIOracle {\n    // PriceInfo is a single piece of price information,\n    // which includes TI's quotation, and the timestamp of price feeding\n    struct PriceInfo {\n        uint256 price; //median of peers' price\n        uint256 timestamp;\n    }\n    // PeerPriceFeed represents price reported by each peer, with nodes' signature\n    struct PeerPriceFeed {\n        address peerAddress;\n        bytes sig;\n        uint256 price;\n        uint256 timestamp;\n    }\n    event NodeAdded(address newNode);\n    event NodeRemoved(address removedNode);\n    event NodeKicked(address removedNode);\n    event PriceFeed(uint256 round, PriceInfo info);\n    // Coin name\n    string coin;\n    // last updated price, with timestamp\n    PriceInfo public lastPrice;\n    // last round\n    uint256 public lastRound;\n    // count\n    uint256 public feedCount;\n    // owner of the contract\n    address admin;\n    // list of transmission nodes\n    address[] public nodes;\n    // map of nodes\n    mapping(address => uint) nodesOffset;\n    // count per round\n    uint256 public countPerRound;\n    // proposals of kicking nodes\n    mapping(address => address[]) public kickProposals;\n    // max seconds of delay for each time of feeding\n    uint256 maxDelay;\n\n    constructor(string memory coinName, uint256 feedCountPerRound, uint256 timeout) {\n        admin = msg.sender;\n        coin = coinName;\n        countPerRound = feedCountPerRound;\n        maxDelay = timeout;\n    }\n\n    // queryPrice returns the last updated price with timestamp\n    function queryPrice() public view returns (PriceInfo memory) {\n        require(lastPrice.timestamp > 0, \"not initialzied\");\n        return lastPrice;\n    }\n\n    //  decide next valid node to feed price, in a round-robbin way\n    function decideValidNode(uint256 roundNo) public view returns (address) {\n        require(nodes.length > 0, \"list of transmission nodes is empty\");\n        uint256 offset = roundNo % nodes.length;\n        return nodes[offset];\n    }\n\n    function isMyTurn() public view returns (bool)  {\n        bool timeout = lastPrice.timestamp >0 && ((block.timestamp - lastPrice.timestamp) > maxDelay);\n        //console.log(\"timeout\", timeout);\n        if (timeout) { //if timeout, any nodes in the list can feed price\n            return nodesOffset[msg.sender] > 0;\n        }\n        //in case of not timeout, scheduling should be in a way of round-robbin\n        return decideValidNode(lastRound) == msg.sender;\n    }\n\n    // check whether the feeding has enough signatures from > 2/3 nodes\n    function checkSignatures(string memory coinName, PeerPriceFeed[] memory peersPrice) view internal returns (bool) {\n        uint256 prevPeerPrice = 0;\n        if (nodes.length * 2 / 3 >= peersPrice.length) {\n            return false;\n        }\n        for (uint i=0; i<peersPrice.length; i++) {\n            PeerPriceFeed memory peer = peersPrice[i];\n            require(peer.timestamp > lastPrice.timestamp, \"invalid timestamp\");\n            require(nodesOffset[peer.peerAddress] > 0, \"peer not in valid list\");\n            require(peer.price >= prevPeerPrice , \"price list not soreted in increasing order\");\n            bytes32 digest = keccak256(abi.encodePacked(coinName, peer.price, peer.timestamp));\n            address recovered = recoverSign(digest, peer.sig);\n            require(recovered == peer.peerAddress, \"invalid signature\");\n            prevPeerPrice = peer.price;\n        }\n        return true;\n    }\n\n    // feedPrice is called by leader node to feed price of cryptos, with a price list reported by all peers\n    function feedPrice(string memory coinName, PeerPriceFeed[] memory peersPrice) public {\n        require(keccak256(bytes(coinName)) == keccak256(bytes(coin)), \"coin mismatch\");\n        require(isMyTurn(), \"invalid transmission node\");\n        require(checkSignatures(coinName, peersPrice), \"no enough signatures of nodes\");\n        PriceInfo memory priceInfo;\n        priceInfo.price = peersPrice[peersPrice.length/2].price; //median\n        priceInfo.timestamp = block.timestamp;\n        //console.log(\"timestamp\", block.timestamp);\n        lastPrice = priceInfo;\n        emit PriceFeed(lastRound, priceInfo);\n        ++feedCount;\n        if (feedCount % countPerRound == 0) {\n            ++lastRound; //next round\n        }\n    }\n\n    // addNode: add new trasmission node\n    function addNode(address newNode) public {\n        require(msg.sender == admin, \"invalid caller to add new node\");\n        nodes.push(newNode);\n        nodesOffset[newNode] = nodes.length;\n        emit NodeAdded(newNode);\n    }\n\n    // execute removing of a node\n    function swapAndPop(address rmNode) internal {\n        uint offset = nodesOffset[rmNode];\n        require(offset > 0, \"node not exsit\");\n        address tailNode = nodes[nodes.length - 1];\n        nodes[offset-1] = tailNode;\n        nodesOffset[tailNode] = offset;\n        nodes.pop();\n        delete nodesOffset[rmNode];\n    }\n\n    // removeNode remove trasmission node from whitelist\n    function removeNode(address rmNode) public {\n        require(msg.sender == admin, \"invalid caller to remove node\");\n        swapAndPop(rmNode);\n        emit NodeRemoved(rmNode);\n    }\n\n    // kickNode remove trasmission node from whitelist\n    function kickNode(address rmNode) public {\n        //check duplicated vote\n        for (uint256 i=0; i<kickProposals[rmNode].length; i++) {\n            require(kickProposals[rmNode][i] != msg.sender, \"duplciated vote\");\n        }\n        bool valid_sender = false;\n        for (uint256 i=0; i<nodes.length;i++) {\n            if (nodes[i] == msg.sender) {\n                valid_sender = true;\n                break;\n            }\n        }\n        require(valid_sender, \"invalid node to kick others\");\n        // vote to kick\n        kickProposals[rmNode].push(msg.sender);\n        // >2/3 agree\n        if (nodes.length * 2 / 3 < kickProposals[rmNode].length) {\n            swapAndPop(rmNode);\n            emit NodeKicked(rmNode);\n        }\n    }\n\n    // transferOwnership transfer the ownership of this contract\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == admin, \"invalid caller to transfer ownership\");\n        admin =  newOwner;\n    }\n\n    //recover address from sign\n    function recoverSign(bytes32 hash, bytes memory sig) public pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        //Check the signature length\n        if (sig.length != 65) {\n        return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n        v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n        return (address(0));\n        } else {\n        return ecrecover(hash, v, r, s);\n        }\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.13;\n//import \"forge-std/Test.sol\";\n// TIOracle is an oracle that provides reliable prices in multiple currencies\ncontract TIOracle {\n    // PriceInfo is a single piece of price information,\n    // which includes TI's quotation, and the timestamp of price feeding\n    struct PriceInfo {\n        uint256 price; //median of peers' price\n        uint256 timestamp;\n    }\n    // PeerPriceFeed represents price reported by each peer, with nodes' signature\n    struct PeerPriceFeed {\n        address peerAddress;\n        bytes sig;\n        uint256 price;\n        uint256 timestamp;\n    }\n    event NodeAdded(address newNode);\n    event NodeRemoved(address removedNode);\n    event NodeKicked(address removedNode);\n    event PriceFeed(uint256 round, PriceInfo info);\n    // Coin name\n    string coin;\n    // last updated price, with timestamp\n    PriceInfo public lastPrice;\n    // last round\n    uint256 public lastRound;\n    // count\n    uint256 public feedCount;\n    // owner of the contract\n    address admin;\n    // list of transmission nodes\n    address[] public nodes;\n    // map of nodes\n    mapping(address => uint) nodesOffset;\n    // count per round\n    uint256 public countPerRound;\n    // proposals of kicking nodes\n    mapping(address => address[]) public kickProposals;\n    // max seconds of delay for each time of feeding\n    uint256 maxDelay;\n\n    constructor(string memory coinName, uint256 feedCountPerRound, uint256 timeout) {\n        admin = msg.sender;\n        coin = coinName;\n        countPerRound = feedCountPerRound;\n        maxDelay = timeout;\n    }\n\n    // queryPrice returns the last updated price with timestamp\n    function queryPrice() public view returns (PriceInfo memory) {\n        require(lastPrice.timestamp > 0, \"not initialzied\");\n        return lastPrice;\n    }\n\n    //  decide next valid node to feed price, in a round-robbin way\n    function decideValidNode(uint256 roundNo) public view returns (address) {\n        require(nodes.length > 0, \"list of transmission nodes is empty\");\n        uint256 offset = roundNo % nodes.length;\n        return nodes[offset];\n    }\n\n    function isMyTurn() public view returns (bool)  {\n        bool timeout = lastPrice.timestamp >0 && ((block.timestamp - lastPrice.timestamp) > maxDelay);\n        //console.log(\"timeout\", timeout);\n        if (timeout) { //if timeout, any nodes in the list can feed price\n            return nodesOffset[msg.sender] > 0;\n        }\n        //in case of not timeout, scheduling should be in a way of round-robbin\n        return decideValidNode(lastRound) == msg.sender;\n    }\n\n    // check whether the feeding has enough signatures from > 2/3 nodes\n    function checkSignatures(string memory coinName, PeerPriceFeed[] memory peersPrice) view internal returns (bool) {\n        uint256 prevPeerPrice = 0;\n        if (nodes.length * 2 / 3 >= peersPrice.length) {\n            return false;\n        }\n        for (uint i=0; i<peersPrice.length; i++) {\n            PeerPriceFeed memory peer = peersPrice[i];\n            require(peer.timestamp > lastPrice.timestamp, \"invalid timestamp\");\n            require(nodesOffset[peer.peerAddress] > 0, \"peer not in valid list\");\n            require(peer.price >= prevPeerPrice , \"price list not soreted in increasing order\");\n            bytes32 digest = keccak256(abi.encodePacked(coinName, peer.price, peer.timestamp));\n            address recovered = recoverSign(digest, peer.sig);\n            require(recovered == peer.peerAddress, \"invalid signature\");\n            prevPeerPrice = peer.price;\n        }\n        return true;\n    }\n\n    // feedPrice is called by leader node to feed price of cryptos, with a price list reported by all peers\n    function feedPrice(string memory coinName, PeerPriceFeed[] memory peersPrice) public {\n        require(keccak256(bytes(coinName)) == keccak256(bytes(coin)), \"coin mismatch\");\n        require(isMyTurn(), \"invalid transmission node\");\n        require(checkSignatures(coinName, peersPrice), \"no enough signatures of nodes\");\n        PriceInfo memory priceInfo;\n        priceInfo.price = peersPrice[peersPrice.length/2].price; //median\n        priceInfo.timestamp = block.timestamp;\n        //console.log(\"timestamp\", block.timestamp);\n        lastPrice = priceInfo;\n        emit PriceFeed(lastRound, priceInfo);\n        ++feedCount;\n        if (feedCount % countPerRound == 0) {\n            ++lastRound; //next round\n        }\n    }\n\n    // addNode: add new trasmission node\n    function addNode(address newNode) public {\n        require(msg.sender == admin, \"invalid caller to add new node\");\n        nodes.push(newNode);\n        nodesOffset[newNode] = nodes.length;\n        emit NodeAdded(newNode);\n    }\n\n    // execute removing of a node\n    function swapAndPop(address rmNode) internal {\n        uint offset = nodesOffset[rmNode];\n        require(offset > 0, \"node not exsit\");\n        address tailNode = nodes[nodes.length - 1];\n        nodes[offset-1] = tailNode;\n        nodesOffset[tailNode] = offset;\n        nodes.pop();\n        delete nodesOffset[rmNode];\n    }\n\n    // removeNode remove trasmission node from whitelist\n    function removeNode(address rmNode) public {\n        require(msg.sender == admin, \"invalid caller to remove node\");\n        swapAndPop(rmNode);\n        emit NodeRemoved(rmNode);\n    }\n\n    // kickNode remove trasmission node from whitelist\n    function kickNode(address rmNode) public {\n        //check duplicated vote\n        for (uint256 i=0; i<kickProposals[rmNode].length; i++) {\n            require(kickProposals[rmNode][i] != msg.sender, \"duplciated vote\");\n        }\n        bool valid_sender = false;\n        for (uint256 i=0; i<nodes.length;i++) {\n            if (nodes[i] == msg.sender) {\n                valid_sender = true;\n                break;\n            }\n        }\n        require(valid_sender, \"invalid node to kick others\");\n        // vote to kick\n        kickProposals[rmNode].push(msg.sender);\n        // >2/3 agree\n        if (nodes.length * 2 / 3 < kickProposals[rmNode].length) {\n            swapAndPop(rmNode);\n            emit NodeKicked(rmNode);\n        }\n    }\n\n    // transferOwnership transfer the ownership of this contract\n    function transferOwnership(address newOwner) public {\n        require(msg.sender == admin, \"invalid caller to transfer ownership\");\n        admin =  newOwner;\n    }\n\n    //recover address from sign\n    function recoverSign(bytes32 hash, bytes memory sig) public pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        //Check the signature length\n        if (sig.length != 65) {\n        return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        assembly {\n        r := mload(add(sig, 32))\n        s := mload(add(sig, 64))\n        v := byte(0, mload(add(sig, 96)))\n        }\n\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n        if (v < 27) {\n        v += 27;\n        }\n\n        // If the version is correct return the signer address\n        if (v != 27 && v != 28) {\n        return (address(0));\n        } else {\n        return ecrecover(hash, v, r, s);\n        }\n    }\n}\n", "commit_id": "21267824e3846a6d83098d6f5511a5b736753356"}}