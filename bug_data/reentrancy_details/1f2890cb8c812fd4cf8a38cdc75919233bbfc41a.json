{"filename": "smart-contracts/contracts/wallet/QuickWallet.sol", "patch": "@@ -44,6 +44,8 @@ contract QuickWallet {\n         )).toEthSignedMessageHash().recover(txSignature);\n         require(owner() == _signer, \"QuickWallet: Signer is not wallet owner\");\n \n+        txCount++;\n+        \n         _call(receiver, data, value);\n \n         if (feeValue > 0) {\n@@ -52,8 +54,6 @@ contract QuickWallet {\n           );\n           _call(feeToken, feePaymentData, 0);\n         }\n-\n-        txCount++;\n     }\n \n     /**", "project_link": "https://github.com/AugustoL/quick-wallet/commit/1f2890cb8c812fd4cf8a38cdc75919233bbfc41a", "bug_version": {"raw_code": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\ncontract QuickWallet {\n\n    using ECDSA for bytes32;\n\n    // Used to prevent execution of already executed txs\n    uint256 public txCount;\n\n    // QuickWallet owner address\n    address public _owner;\n\n    /**\n     * @dev Constructor\n     * @param owner The address of the wallet owner\n     */\n    constructor(address owner) public {\n        _owner = owner;\n    }\n\n    /**\n     * @dev Call a external contract and pay a fee for the call\n     * @param txData encoded data that contains:\n       * receiver The address of the contract to call\n       * data ABI-encoded contract call to call `_to` address\n       * value Amount of ETH in wei to be sent in the call\n       * feeToken The token used for the fee, use this wallet address for ETH\n       * feeValue The amount to be payed as fee\n       * beforeTime timetstamp of the time where this tx cant be executed\n       * once it passed\n     * @param txSignature The signature of the wallet owner\n     * @param feeReceiver The receiver of the fee payment\n     */\n    function call(bytes memory txData, bytes memory txSignature, address feeReceiver) public payable {\n        (address receiver, bytes memory data, uint256 value, address feeToken, uint256 feeValue, uint256 beforeTime) =\n          abi.decode(txData, (address, bytes, uint256, address, uint256, uint256));\n        require(beforeTime > block.timestamp, \"QuickWallet: Invalid beforeTime value\");\n        require(feeToken != address(0), \"QuickWallet: Invalid fee token\");\n\n        address _signer = keccak256(abi.encodePacked(\n            address(this), txData, txCount\n        )).toEthSignedMessageHash().recover(txSignature);\n        require(owner() == _signer, \"QuickWallet: Signer is not wallet owner\");\n\n        _call(receiver, data, value);\n\n        if (feeValue > 0) {\n          bytes memory feePaymentData = abi.encodeWithSelector(\n              bytes4(keccak256(\"transfer(address,uint256)\")), feeReceiver, feeValue\n          );\n          _call(feeToken, feePaymentData, 0);\n        }\n\n        txCount++;\n    }\n\n    /**\n     * @dev ERC20 transfer of ETH, can only be called from this contract\n     * @param receiver The address to transfer the eth\n     * @param value The amount of eth in wei to be transfered\n     */\n    function transfer(address payable receiver, uint256 value) public {\n        require(msg.sender == address(this), \"QuickWallet: Transfer cant be called outside contract\");\n        receiver.transfer(value);\n    }\n\n    /**\n     * @dev Get QuickWallet owner address\n     */\n    function owner() public view returns (address) {\n      return _owner;\n    }\n\n    /**\n     * @dev Call a external contract\n     * @param _to The address of the contract to call\n     * @param _data ABI-encoded contract call to call `_to` address.\n     * @param _value The amount of ETH in wei to be sent in the call\n     */\n    function _call(address _to, bytes memory _data, uint256 _value) internal {\n        // solhint-disable-next-line avoid-call-value\n        (bool success, bytes memory data) = _to.call.value(_value)(_data);\n        require(success, \"QuickWallet: Call to external contract failed\");\n    }\n\n}\n", "flattened_code": "pragma solidity ^0.5.0;\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\ncontract QuickWallet {\n\n    using ECDSA for bytes32;\n\n    // Used to prevent execution of already executed txs\n    uint256 public txCount;\n\n    // QuickWallet owner address\n    address public _owner;\n\n    /**\n     * @dev Constructor\n     * @param owner The address of the wallet owner\n     */\n    constructor(address owner) public {\n        _owner = owner;\n    }\n\n    /**\n     * @dev Call a external contract and pay a fee for the call\n     * @param txData encoded data that contains:\n       * receiver The address of the contract to call\n       * data ABI-encoded contract call to call `_to` address\n       * value Amount of ETH in wei to be sent in the call\n       * feeToken The token used for the fee, use this wallet address for ETH\n       * feeValue The amount to be payed as fee\n       * beforeTime timetstamp of the time where this tx cant be executed\n       * once it passed\n     * @param txSignature The signature of the wallet owner\n     * @param feeReceiver The receiver of the fee payment\n     */\n    function call(bytes memory txData, bytes memory txSignature, address feeReceiver) public payable {\n        (address receiver, bytes memory data, uint256 value, address feeToken, uint256 feeValue, uint256 beforeTime) =\n          abi.decode(txData, (address, bytes, uint256, address, uint256, uint256));\n        require(beforeTime > block.timestamp, \"QuickWallet: Invalid beforeTime value\");\n        require(feeToken != address(0), \"QuickWallet: Invalid fee token\");\n\n        address _signer = keccak256(abi.encodePacked(\n            address(this), txData, txCount\n        )).toEthSignedMessageHash().recover(txSignature);\n        require(owner() == _signer, \"QuickWallet: Signer is not wallet owner\");\n\n        _call(receiver, data, value);\n\n        if (feeValue > 0) {\n          bytes memory feePaymentData = abi.encodeWithSelector(\n              bytes4(keccak256(\"transfer(address,uint256)\")), feeReceiver, feeValue\n          );\n          _call(feeToken, feePaymentData, 0);\n        }\n\n        txCount++;\n    }\n\n    /**\n     * @dev ERC20 transfer of ETH, can only be called from this contract\n     * @param receiver The address to transfer the eth\n     * @param value The amount of eth in wei to be transfered\n     */\n    function transfer(address payable receiver, uint256 value) public {\n        require(msg.sender == address(this), \"QuickWallet: Transfer cant be called outside contract\");\n        receiver.transfer(value);\n    }\n\n    /**\n     * @dev Get QuickWallet owner address\n     */\n    function owner() public view returns (address) {\n      return _owner;\n    }\n\n    /**\n     * @dev Call a external contract\n     * @param _to The address of the contract to call\n     * @param _data ABI-encoded contract call to call `_to` address.\n     * @param _value The amount of ETH in wei to be sent in the call\n     */\n    function _call(address _to, bytes memory _data, uint256 _value) internal {\n        // solhint-disable-next-line avoid-call-value\n        (bool success, bytes memory data) = _to.call.value(_value)(_data);\n        require(success, \"QuickWallet: Call to external contract failed\");\n    }\n\n}\n", "commit_id": "e9083fb203f5796cbef0d96beed1308435d91652"}, "fixed_version": {"raw_code": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\ncontract QuickWallet {\n\n    using ECDSA for bytes32;\n\n    // Used to prevent execution of already executed txs\n    uint256 public txCount;\n\n    // QuickWallet owner address\n    address public _owner;\n\n    /**\n     * @dev Constructor\n     * @param owner The address of the wallet owner\n     */\n    constructor(address owner) public {\n        _owner = owner;\n    }\n\n    /**\n     * @dev Call a external contract and pay a fee for the call\n     * @param txData encoded data that contains:\n       * receiver The address of the contract to call\n       * data ABI-encoded contract call to call `_to` address\n       * value Amount of ETH in wei to be sent in the call\n       * feeToken The token used for the fee, use this wallet address for ETH\n       * feeValue The amount to be payed as fee\n       * beforeTime timetstamp of the time where this tx cant be executed\n       * once it passed\n     * @param txSignature The signature of the wallet owner\n     * @param feeReceiver The receiver of the fee payment\n     */\n    function call(bytes memory txData, bytes memory txSignature, address feeReceiver) public payable {\n        (address receiver, bytes memory data, uint256 value, address feeToken, uint256 feeValue, uint256 beforeTime) =\n          abi.decode(txData, (address, bytes, uint256, address, uint256, uint256));\n        require(beforeTime > block.timestamp, \"QuickWallet: Invalid beforeTime value\");\n        require(feeToken != address(0), \"QuickWallet: Invalid fee token\");\n\n        address _signer = keccak256(abi.encodePacked(\n            address(this), txData, txCount\n        )).toEthSignedMessageHash().recover(txSignature);\n        require(owner() == _signer, \"QuickWallet: Signer is not wallet owner\");\n\n        txCount++;\n        \n        _call(receiver, data, value);\n\n        if (feeValue > 0) {\n          bytes memory feePaymentData = abi.encodeWithSelector(\n              bytes4(keccak256(\"transfer(address,uint256)\")), feeReceiver, feeValue\n          );\n          _call(feeToken, feePaymentData, 0);\n        }\n    }\n\n    /**\n     * @dev ERC20 transfer of ETH, can only be called from this contract\n     * @param receiver The address to transfer the eth\n     * @param value The amount of eth in wei to be transfered\n     */\n    function transfer(address payable receiver, uint256 value) public {\n        require(msg.sender == address(this), \"QuickWallet: Transfer cant be called outside contract\");\n        receiver.transfer(value);\n    }\n\n    /**\n     * @dev Get QuickWallet owner address\n     */\n    function owner() public view returns (address) {\n      return _owner;\n    }\n\n    /**\n     * @dev Call a external contract\n     * @param _to The address of the contract to call\n     * @param _data ABI-encoded contract call to call `_to` address.\n     * @param _value The amount of ETH in wei to be sent in the call\n     */\n    function _call(address _to, bytes memory _data, uint256 _value) internal {\n        // solhint-disable-next-line avoid-call-value\n        (bool success, bytes memory data) = _to.call.value(_value)(_data);\n        require(success, \"QuickWallet: Call to external contract failed\");\n    }\n\n}\n", "flattened_code": "pragma solidity ^0.5.0;\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\ncontract QuickWallet {\n\n    using ECDSA for bytes32;\n\n    // Used to prevent execution of already executed txs\n    uint256 public txCount;\n\n    // QuickWallet owner address\n    address public _owner;\n\n    /**\n     * @dev Constructor\n     * @param owner The address of the wallet owner\n     */\n    constructor(address owner) public {\n        _owner = owner;\n    }\n\n    /**\n     * @dev Call a external contract and pay a fee for the call\n     * @param txData encoded data that contains:\n       * receiver The address of the contract to call\n       * data ABI-encoded contract call to call `_to` address\n       * value Amount of ETH in wei to be sent in the call\n       * feeToken The token used for the fee, use this wallet address for ETH\n       * feeValue The amount to be payed as fee\n       * beforeTime timetstamp of the time where this tx cant be executed\n       * once it passed\n     * @param txSignature The signature of the wallet owner\n     * @param feeReceiver The receiver of the fee payment\n     */\n    function call(bytes memory txData, bytes memory txSignature, address feeReceiver) public payable {\n        (address receiver, bytes memory data, uint256 value, address feeToken, uint256 feeValue, uint256 beforeTime) =\n          abi.decode(txData, (address, bytes, uint256, address, uint256, uint256));\n        require(beforeTime > block.timestamp, \"QuickWallet: Invalid beforeTime value\");\n        require(feeToken != address(0), \"QuickWallet: Invalid fee token\");\n\n        address _signer = keccak256(abi.encodePacked(\n            address(this), txData, txCount\n        )).toEthSignedMessageHash().recover(txSignature);\n        require(owner() == _signer, \"QuickWallet: Signer is not wallet owner\");\n\n        txCount++;\n        \n        _call(receiver, data, value);\n\n        if (feeValue > 0) {\n          bytes memory feePaymentData = abi.encodeWithSelector(\n              bytes4(keccak256(\"transfer(address,uint256)\")), feeReceiver, feeValue\n          );\n          _call(feeToken, feePaymentData, 0);\n        }\n    }\n\n    /**\n     * @dev ERC20 transfer of ETH, can only be called from this contract\n     * @param receiver The address to transfer the eth\n     * @param value The amount of eth in wei to be transfered\n     */\n    function transfer(address payable receiver, uint256 value) public {\n        require(msg.sender == address(this), \"QuickWallet: Transfer cant be called outside contract\");\n        receiver.transfer(value);\n    }\n\n    /**\n     * @dev Get QuickWallet owner address\n     */\n    function owner() public view returns (address) {\n      return _owner;\n    }\n\n    /**\n     * @dev Call a external contract\n     * @param _to The address of the contract to call\n     * @param _data ABI-encoded contract call to call `_to` address.\n     * @param _value The amount of ETH in wei to be sent in the call\n     */\n    function _call(address _to, bytes memory _data, uint256 _value) internal {\n        // solhint-disable-next-line avoid-call-value\n        (bool success, bytes memory data) = _to.call.value(_value)(_data);\n        require(success, \"QuickWallet: Call to external contract failed\");\n    }\n\n}\n", "commit_id": "1f2890cb8c812fd4cf8a38cdc75919233bbfc41a"}}