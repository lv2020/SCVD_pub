{"filename": "contracts/2key/singleton-contracts/TwoKeyCongress.sol", "patch": "@@ -498,11 +498,13 @@ contract TwoKeyCongress {\n \n         // ...then execute result\n         p.executed = true; // Avoid recursive calling\n-        require(p.recipient.call.value(p.amount)(transactionBytecode));\n         p.proposalPassed = true;\n \n         // Fire Events\n         emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n+\n+        // Call external function\n+        require(p.recipient.call.value(p.amount)(transactionBytecode));\n     }\n \n ", "project_link": "https://github.com/2key/contracts/commit/1aecf40bb4528fec8dc5122f39da9d108b0ca6a7", "bug_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract TwoKeyCongress {\n\n    event ReceivedEther(address sender, uint amount);\n    using SafeMath for uint;\n\n    bool initialized;\n\n    // The maximum voting power containing sum of voting powers of all active members\n    uint256 maxVotingPower;\n    //The minimum number of voting members that must be in attendance\n    uint256 public minimumQuorum;\n    //Period length for voting\n    uint256 public debatingPeriodInMinutes;\n    //Array of proposals\n    Proposal[] public proposals;\n    //Number of proposals\n    uint public numProposals;\n\n    mapping (address => bool) public isMemberInCongress;\n    // Mapping address to memberId\n    mapping(address => Member) public address2Member;\n    // Mapping to store all members addresses\n    address[] public allMembers;\n    // Array of allowed methods\n    bytes32[] allowedMethodSignatures;\n\n    mapping(bytes32 => string) methodHashToMethodName;\n\n    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n    event Voted(uint proposalID, bool position, address voter, string justification);\n    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n    event MembershipChanged(address member, bool isMember);\n    event ChangeOfRules(uint256 _newMinimumQuorum, uint256 _newDebatingPeriodInMinutes);\n\n    struct Proposal {\n        address recipient;\n        uint amount;\n        string description;\n        uint minExecutionDate;\n        bool executed;\n        bool proposalPassed;\n        uint numberOfVotes;\n        int currentResult;\n        bytes32 proposalHash;\n        bytes transactionBytecode;\n        Vote[] votes;\n        mapping (address => bool) voted;\n    }\n\n    struct Member {\n        address memberAddress;\n        bytes32 name;\n        uint votingPower;\n        uint memberSince;\n    }\n\n    struct Vote {\n        bool inSupport;\n        address voter;\n        string justification;\n    }\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyMembers {\n        require(isMemberInCongress[msg.sender] == true);\n        _;\n    }\n\n    /// @notice Function to check if the bytecode of passed method is in the whitelist\n    /// @param bytecode is the bytecode of transaction we'd like to execute\n    /// @return true if whitelisted otherwise false\n    function onlyAllowedMethods(\n        bytes bytecode\n    )\n    public\n    view\n    returns (bool)\n    {\n        for(uint i=0; i< allowedMethodSignatures.length; i++) {\n            if(compare(allowedMethodSignatures[i], bytecode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Function which will be called only once, immediately after contract deployment\n     * @param _minutesForDebate is the number of minutes debate length\n     * @param initialMembers is the array containing addresses of initial members\n     * @param votingPowers is the array of unassigned integers containing voting powers respectively\n     * @dev initialMembers.length must be equal votingPowers.length\n     */\n    constructor(\n        uint256 _minutesForDebate,\n        address[] initialMembers,\n        bytes32[] initialMemberNames,\n        uint[] votingPowers\n    )\n    payable\n    public\n    {\n        changeVotingRules(0, _minutesForDebate);\n        for(uint i=0; i<initialMembers.length; i++) {\n            addMember(initialMembers[i], initialMemberNames[i], votingPowers[i]);\n        }\n        initialized = true;\n        addInitialWhitelistedMethods();\n    }\n\n\n    /// @notice Function to add initial whitelisted methods during the deployment\n    /// @dev Function is internal, it can't be called outside of the contract\n    function addInitialWhitelistedMethods()\n    internal\n    {\n        hashAllowedMethods(\"transferByAdmins(address,uint256)\");\n        hashAllowedMethods(\"transferEtherByAdmins(address,uint256)\");\n        hashAllowedMethods(\"destroy\");\n        hashAllowedMethods(\"transfer2KeyTokens(address,uint256)\");\n        hashAllowedMethods(\"addMaintainerForRegistry(address)\");\n        hashAllowedMethods(\"twoKeyEventSourceAddMaintainer(address[])\");\n        hashAllowedMethods(\"twoKeyEventSourceWhitelistContract(address)\");\n        hashAllowedMethods(\"freezeTransfersInEconomy\");\n        hashAllowedMethods(\"unfreezeTransfersInEconomy\");\n        hashAllowedMethods(\"addMaintainersToSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"deleteMaintainersFromSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"updateRewardsRelease(uint256)\");\n        hashAllowedMethods(\"updateTwoKeyTokenRate(uint256)\");\n    }\n\n\n    /// @notice Since transaction's bytecode first 10 chars will contain method name and argument types\n    /// @notice This is the way to compare it efficiently\n    /// @dev on contract we will store allowed method name and argument types\n    /// @param x is the already validated method name\n    /// @param y is the bytecode of the transaction\n    /// @return true if same\n    function compare(\n        bytes32 x,\n        bytes y\n    )\n    public\n    pure\n    returns (bool)\n    {\n        for(uint i=0;i<3;i++) {\n            byte a = x[i];\n            byte b = y[i];\n            if(a != b) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    /// @notice Function to hash allowed method\n    /// @param nameAndParams is the name of the function and it's params to hash\n    /// @dev example: 'functionName(address,string)'\n    /// @return hash of allowed methods\n    function hashAllowedMethods(\n        string nameAndParams\n    )\n    internal\n    {\n        bytes32 allowed = keccak256(abi.encodePacked(nameAndParams));\n        allowedMethodSignatures.push(allowed);\n        methodHashToMethodName[allowed] = nameAndParams;\n    }\n\n\n    /// @notice Function where member can replace it's own address\n    /// @dev member can change only it's own address\n    /// @param _newMemberAddress is the new address we'd like to set for us\n    function replaceMemberAddress(\n        address _newMemberAddress\n    )\n    public\n    {\n        require(_newMemberAddress != address(0));\n        // Update is member in congress state\n        isMemberInCongress[_newMemberAddress] = true;\n        isMemberInCongress[msg.sender] = false;\n\n        //Update array containing all members addresses\n        for(uint i=0; i<allMembers.length; i++) {\n            if(allMembers[i] == msg.sender) {\n                allMembers[i] = _newMemberAddress;\n            }\n        }\n\n        //Update member object\n        Member memory m = address2Member[msg.sender];\n        address2Member[_newMemberAddress] = m;\n        address2Member[msg.sender] = Member(\n            {\n            memberAddress: address(0),\n            memberSince: block.timestamp,\n            votingPower: 0,\n            name: \"0x0\"\n            }\n        );\n    }\n\n    //TODO: Security backdoor, handle and close ASAP\n    /**\n     * Add member\n     *\n     * Make `targetMember` a member named `memberName`\n     *\n     * @param targetMember ethereum address to be added\n     * @param memberName public name for that member\n     */\n    function addMember(\n        address targetMember,\n        bytes32 memberName,\n        uint _votingPower\n    )\n    public\n    {\n        if(initialized == true) {\n            require(msg.sender == address(this));\n        }\n        minimumQuorum = allMembers.length;\n        maxVotingPower += _votingPower;\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: targetMember,\n                memberSince: block.timestamp,\n                votingPower: _votingPower,\n                name: memberName\n            }\n        );\n        allMembers.push(targetMember);\n        isMemberInCongress[targetMember] = true;\n        emit MembershipChanged(targetMember, true);\n    }\n\n    /**\n     * Remove member\n     *\n     * @notice Remove membership from `targetMember`\n     *\n     * @param targetMember ethereum address to be removed\n     */\n    function removeMember(\n        address targetMember\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        require(isMemberInCongress[targetMember] == true);\n\n        //Remove member voting power from max voting power\n        uint votingPower = getMemberVotingPower(targetMember);\n        maxVotingPower-= votingPower;\n\n        uint i=0;\n        //Find selected member\n        while(allMembers[i] != targetMember) {\n            if(i == allMembers.length) {\n                revert();\n            }\n            i++;\n        }\n        //After member is found, remove his address from all members\n        for (uint j = i; j< allMembers.length; j++){\n            allMembers[j] = allMembers[j+1];\n        }\n        //After reduce array size\n        delete allMembers[allMembers.length-1];\n        allMembers.length--;\n\n        //Remove him from state mapping\n        isMemberInCongress[targetMember] = false;\n\n        //Remove his state to empty member\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: address(0),\n                memberSince: block.timestamp,\n                votingPower: 0,\n                name: \"0x0\"\n            }\n        );\n        //Reduce 1 member from quorum\n        minimumQuorum -= 1;\n    }\n\n    /**\n     *  Method to add voting for new allowed bytecode\n     *  The point is that for anything to be executed has to be voted\n     *  @param functionSignature is the new transaction bytecode we'd like to whitelist\n     *  @dev method requires that it's called only by contract\n    */\n    function addNewAllowedBytecode(\n        bytes32 functionSignature\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        allowedMethodSignatures.push(bytes32(functionSignature));\n    }\n    /**\n     * Change voting rules\n     *\n     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\n     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\n     *\n     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n     */\n    function changeVotingRules(\n        uint256 minimumQuorumForProposals,\n        uint256 minutesForDebate\n    )\n    internal\n    {\n        minimumQuorum = minimumQuorumForProposals;\n        debatingPeriodInMinutes = minutesForDebate;\n\n        emit ChangeOfRules(minimumQuorumForProposals, minutesForDebate);\n    }\n\n    /**\n     * Add Proposal\n     *\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     *\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send, in wei\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposal(\n        address beneficiary,\n        uint weiAmount,\n        string jobDescription,\n        bytes transactionBytecode)\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        require(onlyAllowedMethods(transactionBytecode)); // security layer\n        proposalID = proposals.length++;\n        Proposal storage p = proposals[proposalID];\n        p.recipient = beneficiary;\n        p.amount = weiAmount;\n        p.description = jobDescription;\n        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n        p.transactionBytecode = transactionBytecode;\n        p.minExecutionDate = block.timestamp + debatingPeriodInMinutes * 1 minutes;\n        p.executed = false;\n        p.proposalPassed = false;\n        p.numberOfVotes = 0;\n        p.currentResult = 0;\n        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n        numProposals = proposalID+1;\n\n        return proposalID;\n    }\n\n    /**\n     * Add proposal in Ether\n     *\n     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     * This is a convenience function to use if the amount to be given is in round number of ether units.\n     *\n     * @param beneficiary who to send the ether to\n     * @param etherAmount amount of ether to send\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposalInEther(\n        address beneficiary,\n        uint etherAmount,\n        string jobDescription,\n        bytes transactionBytecode\n    )\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n    }\n\n    /**\n     * Check if a proposal code matches\n     *\n     * @param proposalNumber ID number of the proposal to query\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send\n     * @param transactionBytecode bytecode of transaction\n     */\n    function checkProposalCode(\n        uint proposalNumber,\n        address beneficiary,\n        uint weiAmount,\n        bytes transactionBytecode\n    )\n    public\n    view\n    returns (bool codeChecksOut)\n    {\n        Proposal storage p = proposals[proposalNumber];\n        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n    }\n\n    /**\n     * Log a vote for a proposal\n     *\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n     *\n     * @param proposalNumber number of proposal\n     * @param supportsProposal either in favor or against it\n     * @param justificationText optional justification text\n     */\n    function vote(\n        uint proposalNumber,\n        bool supportsProposal,\n        string justificationText)\n    public\n    onlyMembers\n    returns (uint256 voteID)\n    {\n        Proposal storage p = proposals[proposalNumber]; // Get the proposal\n        require(block.timestamp <= p.minExecutionDate);\n        require(!p.voted[msg.sender]);                  // If has already voted, cancel\n        p.voted[msg.sender] = true;                     // Set this voter as having voted\n        p.numberOfVotes++;\n        voteID = p.numberOfVotes;                     // Increase the number of votes\n        p.votes.push(Vote({ inSupport: supportsProposal, voter: msg.sender, justification: justificationText }));\n        uint votingPower = getMemberVotingPower(msg.sender);\n        if (supportsProposal) {                         // If they support the proposal\n            p.currentResult+= int(votingPower);                          // Increase score\n        } else {                                        // If they don't\n            p.currentResult-= int(votingPower);                          // Decrease the score\n        }\n        // Create a log of this event\n        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\n        return voteID;\n    }\n\n    function getVoteCount(\n        uint256 proposalNumber\n    )\n    onlyMembers\n    public\n    view\n    returns(uint256 numberOfVotes, int256 currentResult, string description)\n    {\n        require(proposals[proposalNumber].proposalHash != 0);\n        numberOfVotes = proposals[proposalNumber].numberOfVotes;\n        currentResult = proposals[proposalNumber].currentResult;\n        description = proposals[proposalNumber].description;\n    }\n\n    /// Basic getter function\n    function getMemberInfo()\n    public\n    view\n    returns (address, bytes32, uint, uint)\n    {\n        Member memory member = address2Member[msg.sender];\n        return (member.memberAddress, member.name, member.votingPower, member.memberSince);\n    }\n\n    /**\n     * Finish vote\n     *\n     * Count the votes proposal #`proposalNumber` and execute it if approved\n     *\n     * @param proposalNumber proposal number\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n     */\n    function executeProposal(\n        uint proposalNumber,\n        bytes transactionBytecode\n    )\n    public\n    {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(\n//            block.timestamp > p.minExecutionDate  &&                             // If it is past the voting deadline\n             !p.executed                                                         // and it has not already been executed\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\n            && p.numberOfVotes >= minimumQuorum.sub(1) // and a minimum quorum has been reached...\n        //TODO: Delete -1 from MINIMUM QUORUM, left because KIKI is OOO\n            && uint(p.currentResult) >= maxVotingPower.mul(51).div(100)\n            && p.currentResult > 0\n        );\n\n        // ...then execute result\n        p.executed = true; // Avoid recursive calling\n        require(p.recipient.call.value(p.amount)(transactionBytecode));\n        p.proposalPassed = true;\n\n        // Fire Events\n        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n    }\n\n\n    /// @notice Function getter for voting power for specific member\n    /// @param _memberAddress is the address of the member\n    /// @return integer representing voting power\n    function getMemberVotingPower(\n        address _memberAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        Member memory _member = address2Member[msg.sender];\n        return _member.votingPower;\n    }\n\n    /// @notice to check if an address is member\n    /// @param _member is the address we're checking for\n    function checkIsMember(\n        address _member\n    )\n    public\n    view\n    returns (bool)\n    {\n        return isMemberInCongress[_member];\n    }\n\n    /// @notice Fallback function\n    function () payable public {\n        emit ReceivedEther(msg.sender, msg.value);\n    }\n\n    /// @notice Getter for maximum voting power\n    /// @return maxVotingPower\n    function getMaxVotingPower()\n    public\n    view\n    returns (uint)\n    {\n        return maxVotingPower;\n    }\n\n    /// @notice Getter for length for how many members are currently\n    /// @return length of members\n    function getMembersLength()\n    public\n    view\n    returns (uint)\n    {\n        return allMembers.length;\n    }\n\n    /// @notice Function / Getter for hashes of allowed methods\n    /// @return array of bytes32 hashes\n    function getAllowedMethods()\n    public\n    view\n    returns (bytes32[])\n    {\n        return allowedMethodSignatures;\n    }\n\n    /// @notice Function to fetch method name from method hash\n    /// @return methodname string representation\n    function getMethodNameFromMethodHash(\n        bytes32 _methodHash\n    )\n    public\n    view\n    returns(string)\n    {\n        return methodHashToMethodName[_methodHash];\n    }\n\n    /// @notice Function to get major proposal data\n    /// @param proposalId is the id of proposal\n    /// @return tuple containing all the data for proposal\n    function getProposalData(\n        uint proposalId\n    )\n    public\n    view\n    returns (uint,string,uint,bool,uint,int,bytes)\n    {\n        Proposal memory p = proposals[proposalId];\n        return (p.amount, p.description, p.minExecutionDate, p.executed, p.numberOfVotes, p.currentResult, p.transactionBytecode);\n    }\n\n    /// @notice Function to get addresses of all members in congress\n    /// @return array of addresses\n    function getAllMemberAddresses()\n    public\n    view\n    returns (address[])\n    {\n        return allMembers;\n    }\n\n}\n\n", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract TwoKeyCongress {\n\n    event ReceivedEther(address sender, uint amount);\n    using SafeMath for uint;\n\n    bool initialized;\n\n    // The maximum voting power containing sum of voting powers of all active members\n    uint256 maxVotingPower;\n    //The minimum number of voting members that must be in attendance\n    uint256 public minimumQuorum;\n    //Period length for voting\n    uint256 public debatingPeriodInMinutes;\n    //Array of proposals\n    Proposal[] public proposals;\n    //Number of proposals\n    uint public numProposals;\n\n    mapping (address => bool) public isMemberInCongress;\n    // Mapping address to memberId\n    mapping(address => Member) public address2Member;\n    // Mapping to store all members addresses\n    address[] public allMembers;\n    // Array of allowed methods\n    bytes32[] allowedMethodSignatures;\n\n    mapping(bytes32 => string) methodHashToMethodName;\n\n    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n    event Voted(uint proposalID, bool position, address voter, string justification);\n    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n    event MembershipChanged(address member, bool isMember);\n    event ChangeOfRules(uint256 _newMinimumQuorum, uint256 _newDebatingPeriodInMinutes);\n\n    struct Proposal {\n        address recipient;\n        uint amount;\n        string description;\n        uint minExecutionDate;\n        bool executed;\n        bool proposalPassed;\n        uint numberOfVotes;\n        int currentResult;\n        bytes32 proposalHash;\n        bytes transactionBytecode;\n        Vote[] votes;\n        mapping (address => bool) voted;\n    }\n\n    struct Member {\n        address memberAddress;\n        bytes32 name;\n        uint votingPower;\n        uint memberSince;\n    }\n\n    struct Vote {\n        bool inSupport;\n        address voter;\n        string justification;\n    }\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyMembers {\n        require(isMemberInCongress[msg.sender] == true);\n        _;\n    }\n\n    /// @notice Function to check if the bytecode of passed method is in the whitelist\n    /// @param bytecode is the bytecode of transaction we'd like to execute\n    /// @return true if whitelisted otherwise false\n    function onlyAllowedMethods(\n        bytes bytecode\n    )\n    public\n    view\n    returns (bool)\n    {\n        for(uint i=0; i< allowedMethodSignatures.length; i++) {\n            if(compare(allowedMethodSignatures[i], bytecode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Function which will be called only once, immediately after contract deployment\n     * @param _minutesForDebate is the number of minutes debate length\n     * @param initialMembers is the array containing addresses of initial members\n     * @param votingPowers is the array of unassigned integers containing voting powers respectively\n     * @dev initialMembers.length must be equal votingPowers.length\n     */\n    constructor(\n        uint256 _minutesForDebate,\n        address[] initialMembers,\n        bytes32[] initialMemberNames,\n        uint[] votingPowers\n    )\n    payable\n    public\n    {\n        changeVotingRules(0, _minutesForDebate);\n        for(uint i=0; i<initialMembers.length; i++) {\n            addMember(initialMembers[i], initialMemberNames[i], votingPowers[i]);\n        }\n        initialized = true;\n        addInitialWhitelistedMethods();\n    }\n\n\n    /// @notice Function to add initial whitelisted methods during the deployment\n    /// @dev Function is internal, it can't be called outside of the contract\n    function addInitialWhitelistedMethods()\n    internal\n    {\n        hashAllowedMethods(\"transferByAdmins(address,uint256)\");\n        hashAllowedMethods(\"transferEtherByAdmins(address,uint256)\");\n        hashAllowedMethods(\"destroy\");\n        hashAllowedMethods(\"transfer2KeyTokens(address,uint256)\");\n        hashAllowedMethods(\"addMaintainerForRegistry(address)\");\n        hashAllowedMethods(\"twoKeyEventSourceAddMaintainer(address[])\");\n        hashAllowedMethods(\"twoKeyEventSourceWhitelistContract(address)\");\n        hashAllowedMethods(\"freezeTransfersInEconomy\");\n        hashAllowedMethods(\"unfreezeTransfersInEconomy\");\n        hashAllowedMethods(\"addMaintainersToSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"deleteMaintainersFromSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"updateRewardsRelease(uint256)\");\n        hashAllowedMethods(\"updateTwoKeyTokenRate(uint256)\");\n    }\n\n\n    /// @notice Since transaction's bytecode first 10 chars will contain method name and argument types\n    /// @notice This is the way to compare it efficiently\n    /// @dev on contract we will store allowed method name and argument types\n    /// @param x is the already validated method name\n    /// @param y is the bytecode of the transaction\n    /// @return true if same\n    function compare(\n        bytes32 x,\n        bytes y\n    )\n    public\n    pure\n    returns (bool)\n    {\n        for(uint i=0;i<3;i++) {\n            byte a = x[i];\n            byte b = y[i];\n            if(a != b) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    /// @notice Function to hash allowed method\n    /// @param nameAndParams is the name of the function and it's params to hash\n    /// @dev example: 'functionName(address,string)'\n    /// @return hash of allowed methods\n    function hashAllowedMethods(\n        string nameAndParams\n    )\n    internal\n    {\n        bytes32 allowed = keccak256(abi.encodePacked(nameAndParams));\n        allowedMethodSignatures.push(allowed);\n        methodHashToMethodName[allowed] = nameAndParams;\n    }\n\n\n    /// @notice Function where member can replace it's own address\n    /// @dev member can change only it's own address\n    /// @param _newMemberAddress is the new address we'd like to set for us\n    function replaceMemberAddress(\n        address _newMemberAddress\n    )\n    public\n    {\n        require(_newMemberAddress != address(0));\n        // Update is member in congress state\n        isMemberInCongress[_newMemberAddress] = true;\n        isMemberInCongress[msg.sender] = false;\n\n        //Update array containing all members addresses\n        for(uint i=0; i<allMembers.length; i++) {\n            if(allMembers[i] == msg.sender) {\n                allMembers[i] = _newMemberAddress;\n            }\n        }\n\n        //Update member object\n        Member memory m = address2Member[msg.sender];\n        address2Member[_newMemberAddress] = m;\n        address2Member[msg.sender] = Member(\n            {\n            memberAddress: address(0),\n            memberSince: block.timestamp,\n            votingPower: 0,\n            name: \"0x0\"\n            }\n        );\n    }\n\n    //TODO: Security backdoor, handle and close ASAP\n    /**\n     * Add member\n     *\n     * Make `targetMember` a member named `memberName`\n     *\n     * @param targetMember ethereum address to be added\n     * @param memberName public name for that member\n     */\n    function addMember(\n        address targetMember,\n        bytes32 memberName,\n        uint _votingPower\n    )\n    public\n    {\n        if(initialized == true) {\n            require(msg.sender == address(this));\n        }\n        minimumQuorum = allMembers.length;\n        maxVotingPower += _votingPower;\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: targetMember,\n                memberSince: block.timestamp,\n                votingPower: _votingPower,\n                name: memberName\n            }\n        );\n        allMembers.push(targetMember);\n        isMemberInCongress[targetMember] = true;\n        emit MembershipChanged(targetMember, true);\n    }\n\n    /**\n     * Remove member\n     *\n     * @notice Remove membership from `targetMember`\n     *\n     * @param targetMember ethereum address to be removed\n     */\n    function removeMember(\n        address targetMember\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        require(isMemberInCongress[targetMember] == true);\n\n        //Remove member voting power from max voting power\n        uint votingPower = getMemberVotingPower(targetMember);\n        maxVotingPower-= votingPower;\n\n        uint i=0;\n        //Find selected member\n        while(allMembers[i] != targetMember) {\n            if(i == allMembers.length) {\n                revert();\n            }\n            i++;\n        }\n        //After member is found, remove his address from all members\n        for (uint j = i; j< allMembers.length; j++){\n            allMembers[j] = allMembers[j+1];\n        }\n        //After reduce array size\n        delete allMembers[allMembers.length-1];\n        allMembers.length--;\n\n        //Remove him from state mapping\n        isMemberInCongress[targetMember] = false;\n\n        //Remove his state to empty member\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: address(0),\n                memberSince: block.timestamp,\n                votingPower: 0,\n                name: \"0x0\"\n            }\n        );\n        //Reduce 1 member from quorum\n        minimumQuorum -= 1;\n    }\n\n    /**\n     *  Method to add voting for new allowed bytecode\n     *  The point is that for anything to be executed has to be voted\n     *  @param functionSignature is the new transaction bytecode we'd like to whitelist\n     *  @dev method requires that it's called only by contract\n    */\n    function addNewAllowedBytecode(\n        bytes32 functionSignature\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        allowedMethodSignatures.push(bytes32(functionSignature));\n    }\n    /**\n     * Change voting rules\n     *\n     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\n     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\n     *\n     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n     */\n    function changeVotingRules(\n        uint256 minimumQuorumForProposals,\n        uint256 minutesForDebate\n    )\n    internal\n    {\n        minimumQuorum = minimumQuorumForProposals;\n        debatingPeriodInMinutes = minutesForDebate;\n\n        emit ChangeOfRules(minimumQuorumForProposals, minutesForDebate);\n    }\n\n    /**\n     * Add Proposal\n     *\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     *\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send, in wei\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposal(\n        address beneficiary,\n        uint weiAmount,\n        string jobDescription,\n        bytes transactionBytecode)\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        require(onlyAllowedMethods(transactionBytecode)); // security layer\n        proposalID = proposals.length++;\n        Proposal storage p = proposals[proposalID];\n        p.recipient = beneficiary;\n        p.amount = weiAmount;\n        p.description = jobDescription;\n        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n        p.transactionBytecode = transactionBytecode;\n        p.minExecutionDate = block.timestamp + debatingPeriodInMinutes * 1 minutes;\n        p.executed = false;\n        p.proposalPassed = false;\n        p.numberOfVotes = 0;\n        p.currentResult = 0;\n        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n        numProposals = proposalID+1;\n\n        return proposalID;\n    }\n\n    /**\n     * Add proposal in Ether\n     *\n     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     * This is a convenience function to use if the amount to be given is in round number of ether units.\n     *\n     * @param beneficiary who to send the ether to\n     * @param etherAmount amount of ether to send\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposalInEther(\n        address beneficiary,\n        uint etherAmount,\n        string jobDescription,\n        bytes transactionBytecode\n    )\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n    }\n\n    /**\n     * Check if a proposal code matches\n     *\n     * @param proposalNumber ID number of the proposal to query\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send\n     * @param transactionBytecode bytecode of transaction\n     */\n    function checkProposalCode(\n        uint proposalNumber,\n        address beneficiary,\n        uint weiAmount,\n        bytes transactionBytecode\n    )\n    public\n    view\n    returns (bool codeChecksOut)\n    {\n        Proposal storage p = proposals[proposalNumber];\n        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n    }\n\n    /**\n     * Log a vote for a proposal\n     *\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n     *\n     * @param proposalNumber number of proposal\n     * @param supportsProposal either in favor or against it\n     * @param justificationText optional justification text\n     */\n    function vote(\n        uint proposalNumber,\n        bool supportsProposal,\n        string justificationText)\n    public\n    onlyMembers\n    returns (uint256 voteID)\n    {\n        Proposal storage p = proposals[proposalNumber]; // Get the proposal\n        require(block.timestamp <= p.minExecutionDate);\n        require(!p.voted[msg.sender]);                  // If has already voted, cancel\n        p.voted[msg.sender] = true;                     // Set this voter as having voted\n        p.numberOfVotes++;\n        voteID = p.numberOfVotes;                     // Increase the number of votes\n        p.votes.push(Vote({ inSupport: supportsProposal, voter: msg.sender, justification: justificationText }));\n        uint votingPower = getMemberVotingPower(msg.sender);\n        if (supportsProposal) {                         // If they support the proposal\n            p.currentResult+= int(votingPower);                          // Increase score\n        } else {                                        // If they don't\n            p.currentResult-= int(votingPower);                          // Decrease the score\n        }\n        // Create a log of this event\n        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\n        return voteID;\n    }\n\n    function getVoteCount(\n        uint256 proposalNumber\n    )\n    onlyMembers\n    public\n    view\n    returns(uint256 numberOfVotes, int256 currentResult, string description)\n    {\n        require(proposals[proposalNumber].proposalHash != 0);\n        numberOfVotes = proposals[proposalNumber].numberOfVotes;\n        currentResult = proposals[proposalNumber].currentResult;\n        description = proposals[proposalNumber].description;\n    }\n\n    /// Basic getter function\n    function getMemberInfo()\n    public\n    view\n    returns (address, bytes32, uint, uint)\n    {\n        Member memory member = address2Member[msg.sender];\n        return (member.memberAddress, member.name, member.votingPower, member.memberSince);\n    }\n\n    /**\n     * Finish vote\n     *\n     * Count the votes proposal #`proposalNumber` and execute it if approved\n     *\n     * @param proposalNumber proposal number\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n     */\n    function executeProposal(\n        uint proposalNumber,\n        bytes transactionBytecode\n    )\n    public\n    {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(\n//            block.timestamp > p.minExecutionDate  &&                             // If it is past the voting deadline\n             !p.executed                                                         // and it has not already been executed\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\n            && p.numberOfVotes >= minimumQuorum.sub(1) // and a minimum quorum has been reached...\n        //TODO: Delete -1 from MINIMUM QUORUM, left because KIKI is OOO\n            && uint(p.currentResult) >= maxVotingPower.mul(51).div(100)\n            && p.currentResult > 0\n        );\n\n        // ...then execute result\n        p.executed = true; // Avoid recursive calling\n        require(p.recipient.call.value(p.amount)(transactionBytecode));\n        p.proposalPassed = true;\n\n        // Fire Events\n        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n    }\n\n\n    /// @notice Function getter for voting power for specific member\n    /// @param _memberAddress is the address of the member\n    /// @return integer representing voting power\n    function getMemberVotingPower(\n        address _memberAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        Member memory _member = address2Member[msg.sender];\n        return _member.votingPower;\n    }\n\n    /// @notice to check if an address is member\n    /// @param _member is the address we're checking for\n    function checkIsMember(\n        address _member\n    )\n    public\n    view\n    returns (bool)\n    {\n        return isMemberInCongress[_member];\n    }\n\n    /// @notice Fallback function\n    function () payable public {\n        emit ReceivedEther(msg.sender, msg.value);\n    }\n\n    /// @notice Getter for maximum voting power\n    /// @return maxVotingPower\n    function getMaxVotingPower()\n    public\n    view\n    returns (uint)\n    {\n        return maxVotingPower;\n    }\n\n    /// @notice Getter for length for how many members are currently\n    /// @return length of members\n    function getMembersLength()\n    public\n    view\n    returns (uint)\n    {\n        return allMembers.length;\n    }\n\n    /// @notice Function / Getter for hashes of allowed methods\n    /// @return array of bytes32 hashes\n    function getAllowedMethods()\n    public\n    view\n    returns (bytes32[])\n    {\n        return allowedMethodSignatures;\n    }\n\n    /// @notice Function to fetch method name from method hash\n    /// @return methodname string representation\n    function getMethodNameFromMethodHash(\n        bytes32 _methodHash\n    )\n    public\n    view\n    returns(string)\n    {\n        return methodHashToMethodName[_methodHash];\n    }\n\n    /// @notice Function to get major proposal data\n    /// @param proposalId is the id of proposal\n    /// @return tuple containing all the data for proposal\n    function getProposalData(\n        uint proposalId\n    )\n    public\n    view\n    returns (uint,string,uint,bool,uint,int,bytes)\n    {\n        Proposal memory p = proposals[proposalId];\n        return (p.amount, p.description, p.minExecutionDate, p.executed, p.numberOfVotes, p.currentResult, p.transactionBytecode);\n    }\n\n    /// @notice Function to get addresses of all members in congress\n    /// @return array of addresses\n    function getAllMemberAddresses()\n    public\n    view\n    returns (address[])\n    {\n        return allMembers;\n    }\n\n}\n\n", "commit_id": "54ca1a4aa89acd54d958ebf650b55b0c1cdca02a"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport \"../libraries/SafeMath.sol\";\n\ncontract TwoKeyCongress {\n\n    event ReceivedEther(address sender, uint amount);\n    using SafeMath for uint;\n\n    bool initialized;\n\n    // The maximum voting power containing sum of voting powers of all active members\n    uint256 maxVotingPower;\n    //The minimum number of voting members that must be in attendance\n    uint256 public minimumQuorum;\n    //Period length for voting\n    uint256 public debatingPeriodInMinutes;\n    //Array of proposals\n    Proposal[] public proposals;\n    //Number of proposals\n    uint public numProposals;\n\n    mapping (address => bool) public isMemberInCongress;\n    // Mapping address to memberId\n    mapping(address => Member) public address2Member;\n    // Mapping to store all members addresses\n    address[] public allMembers;\n    // Array of allowed methods\n    bytes32[] allowedMethodSignatures;\n\n    mapping(bytes32 => string) methodHashToMethodName;\n\n    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n    event Voted(uint proposalID, bool position, address voter, string justification);\n    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n    event MembershipChanged(address member, bool isMember);\n    event ChangeOfRules(uint256 _newMinimumQuorum, uint256 _newDebatingPeriodInMinutes);\n\n    struct Proposal {\n        address recipient;\n        uint amount;\n        string description;\n        uint minExecutionDate;\n        bool executed;\n        bool proposalPassed;\n        uint numberOfVotes;\n        int currentResult;\n        bytes32 proposalHash;\n        bytes transactionBytecode;\n        Vote[] votes;\n        mapping (address => bool) voted;\n    }\n\n    struct Member {\n        address memberAddress;\n        bytes32 name;\n        uint votingPower;\n        uint memberSince;\n    }\n\n    struct Vote {\n        bool inSupport;\n        address voter;\n        string justification;\n    }\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyMembers {\n        require(isMemberInCongress[msg.sender] == true);\n        _;\n    }\n\n    /// @notice Function to check if the bytecode of passed method is in the whitelist\n    /// @param bytecode is the bytecode of transaction we'd like to execute\n    /// @return true if whitelisted otherwise false\n    function onlyAllowedMethods(\n        bytes bytecode\n    )\n    public\n    view\n    returns (bool)\n    {\n        for(uint i=0; i< allowedMethodSignatures.length; i++) {\n            if(compare(allowedMethodSignatures[i], bytecode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Function which will be called only once, immediately after contract deployment\n     * @param _minutesForDebate is the number of minutes debate length\n     * @param initialMembers is the array containing addresses of initial members\n     * @param votingPowers is the array of unassigned integers containing voting powers respectively\n     * @dev initialMembers.length must be equal votingPowers.length\n     */\n    constructor(\n        uint256 _minutesForDebate,\n        address[] initialMembers,\n        bytes32[] initialMemberNames,\n        uint[] votingPowers\n    )\n    payable\n    public\n    {\n        changeVotingRules(0, _minutesForDebate);\n        for(uint i=0; i<initialMembers.length; i++) {\n            addMember(initialMembers[i], initialMemberNames[i], votingPowers[i]);\n        }\n        initialized = true;\n        addInitialWhitelistedMethods();\n    }\n\n\n    /// @notice Function to add initial whitelisted methods during the deployment\n    /// @dev Function is internal, it can't be called outside of the contract\n    function addInitialWhitelistedMethods()\n    internal\n    {\n        hashAllowedMethods(\"transferByAdmins(address,uint256)\");\n        hashAllowedMethods(\"transferEtherByAdmins(address,uint256)\");\n        hashAllowedMethods(\"destroy\");\n        hashAllowedMethods(\"transfer2KeyTokens(address,uint256)\");\n        hashAllowedMethods(\"addMaintainerForRegistry(address)\");\n        hashAllowedMethods(\"twoKeyEventSourceAddMaintainer(address[])\");\n        hashAllowedMethods(\"twoKeyEventSourceWhitelistContract(address)\");\n        hashAllowedMethods(\"freezeTransfersInEconomy\");\n        hashAllowedMethods(\"unfreezeTransfersInEconomy\");\n        hashAllowedMethods(\"addMaintainersToSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"deleteMaintainersFromSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"updateRewardsRelease(uint256)\");\n        hashAllowedMethods(\"updateTwoKeyTokenRate(uint256)\");\n    }\n\n\n    /// @notice Since transaction's bytecode first 10 chars will contain method name and argument types\n    /// @notice This is the way to compare it efficiently\n    /// @dev on contract we will store allowed method name and argument types\n    /// @param x is the already validated method name\n    /// @param y is the bytecode of the transaction\n    /// @return true if same\n    function compare(\n        bytes32 x,\n        bytes y\n    )\n    public\n    pure\n    returns (bool)\n    {\n        for(uint i=0;i<3;i++) {\n            byte a = x[i];\n            byte b = y[i];\n            if(a != b) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    /// @notice Function to hash allowed method\n    /// @param nameAndParams is the name of the function and it's params to hash\n    /// @dev example: 'functionName(address,string)'\n    /// @return hash of allowed methods\n    function hashAllowedMethods(\n        string nameAndParams\n    )\n    internal\n    {\n        bytes32 allowed = keccak256(abi.encodePacked(nameAndParams));\n        allowedMethodSignatures.push(allowed);\n        methodHashToMethodName[allowed] = nameAndParams;\n    }\n\n\n    /// @notice Function where member can replace it's own address\n    /// @dev member can change only it's own address\n    /// @param _newMemberAddress is the new address we'd like to set for us\n    function replaceMemberAddress(\n        address _newMemberAddress\n    )\n    public\n    {\n        require(_newMemberAddress != address(0));\n        // Update is member in congress state\n        isMemberInCongress[_newMemberAddress] = true;\n        isMemberInCongress[msg.sender] = false;\n\n        //Update array containing all members addresses\n        for(uint i=0; i<allMembers.length; i++) {\n            if(allMembers[i] == msg.sender) {\n                allMembers[i] = _newMemberAddress;\n            }\n        }\n\n        //Update member object\n        Member memory m = address2Member[msg.sender];\n        address2Member[_newMemberAddress] = m;\n        address2Member[msg.sender] = Member(\n            {\n            memberAddress: address(0),\n            memberSince: block.timestamp,\n            votingPower: 0,\n            name: \"0x0\"\n            }\n        );\n    }\n\n    //TODO: Security backdoor, handle and close ASAP\n    /**\n     * Add member\n     *\n     * Make `targetMember` a member named `memberName`\n     *\n     * @param targetMember ethereum address to be added\n     * @param memberName public name for that member\n     */\n    function addMember(\n        address targetMember,\n        bytes32 memberName,\n        uint _votingPower\n    )\n    public\n    {\n        if(initialized == true) {\n            require(msg.sender == address(this));\n        }\n        minimumQuorum = allMembers.length;\n        maxVotingPower += _votingPower;\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: targetMember,\n                memberSince: block.timestamp,\n                votingPower: _votingPower,\n                name: memberName\n            }\n        );\n        allMembers.push(targetMember);\n        isMemberInCongress[targetMember] = true;\n        emit MembershipChanged(targetMember, true);\n    }\n\n    /**\n     * Remove member\n     *\n     * @notice Remove membership from `targetMember`\n     *\n     * @param targetMember ethereum address to be removed\n     */\n    function removeMember(\n        address targetMember\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        require(isMemberInCongress[targetMember] == true);\n\n        //Remove member voting power from max voting power\n        uint votingPower = getMemberVotingPower(targetMember);\n        maxVotingPower-= votingPower;\n\n        uint i=0;\n        //Find selected member\n        while(allMembers[i] != targetMember) {\n            if(i == allMembers.length) {\n                revert();\n            }\n            i++;\n        }\n        //After member is found, remove his address from all members\n        for (uint j = i; j< allMembers.length; j++){\n            allMembers[j] = allMembers[j+1];\n        }\n        //After reduce array size\n        delete allMembers[allMembers.length-1];\n        allMembers.length--;\n\n        //Remove him from state mapping\n        isMemberInCongress[targetMember] = false;\n\n        //Remove his state to empty member\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: address(0),\n                memberSince: block.timestamp,\n                votingPower: 0,\n                name: \"0x0\"\n            }\n        );\n        //Reduce 1 member from quorum\n        minimumQuorum -= 1;\n    }\n\n    /**\n     *  Method to add voting for new allowed bytecode\n     *  The point is that for anything to be executed has to be voted\n     *  @param functionSignature is the new transaction bytecode we'd like to whitelist\n     *  @dev method requires that it's called only by contract\n    */\n    function addNewAllowedBytecode(\n        bytes32 functionSignature\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        allowedMethodSignatures.push(bytes32(functionSignature));\n    }\n    /**\n     * Change voting rules\n     *\n     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\n     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\n     *\n     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n     */\n    function changeVotingRules(\n        uint256 minimumQuorumForProposals,\n        uint256 minutesForDebate\n    )\n    internal\n    {\n        minimumQuorum = minimumQuorumForProposals;\n        debatingPeriodInMinutes = minutesForDebate;\n\n        emit ChangeOfRules(minimumQuorumForProposals, minutesForDebate);\n    }\n\n    /**\n     * Add Proposal\n     *\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     *\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send, in wei\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposal(\n        address beneficiary,\n        uint weiAmount,\n        string jobDescription,\n        bytes transactionBytecode)\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        require(onlyAllowedMethods(transactionBytecode)); // security layer\n        proposalID = proposals.length++;\n        Proposal storage p = proposals[proposalID];\n        p.recipient = beneficiary;\n        p.amount = weiAmount;\n        p.description = jobDescription;\n        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n        p.transactionBytecode = transactionBytecode;\n        p.minExecutionDate = block.timestamp + debatingPeriodInMinutes * 1 minutes;\n        p.executed = false;\n        p.proposalPassed = false;\n        p.numberOfVotes = 0;\n        p.currentResult = 0;\n        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n        numProposals = proposalID+1;\n\n        return proposalID;\n    }\n\n    /**\n     * Add proposal in Ether\n     *\n     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     * This is a convenience function to use if the amount to be given is in round number of ether units.\n     *\n     * @param beneficiary who to send the ether to\n     * @param etherAmount amount of ether to send\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposalInEther(\n        address beneficiary,\n        uint etherAmount,\n        string jobDescription,\n        bytes transactionBytecode\n    )\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n    }\n\n    /**\n     * Check if a proposal code matches\n     *\n     * @param proposalNumber ID number of the proposal to query\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send\n     * @param transactionBytecode bytecode of transaction\n     */\n    function checkProposalCode(\n        uint proposalNumber,\n        address beneficiary,\n        uint weiAmount,\n        bytes transactionBytecode\n    )\n    public\n    view\n    returns (bool codeChecksOut)\n    {\n        Proposal storage p = proposals[proposalNumber];\n        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n    }\n\n    /**\n     * Log a vote for a proposal\n     *\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n     *\n     * @param proposalNumber number of proposal\n     * @param supportsProposal either in favor or against it\n     * @param justificationText optional justification text\n     */\n    function vote(\n        uint proposalNumber,\n        bool supportsProposal,\n        string justificationText)\n    public\n    onlyMembers\n    returns (uint256 voteID)\n    {\n        Proposal storage p = proposals[proposalNumber]; // Get the proposal\n        require(block.timestamp <= p.minExecutionDate);\n        require(!p.voted[msg.sender]);                  // If has already voted, cancel\n        p.voted[msg.sender] = true;                     // Set this voter as having voted\n        p.numberOfVotes++;\n        voteID = p.numberOfVotes;                     // Increase the number of votes\n        p.votes.push(Vote({ inSupport: supportsProposal, voter: msg.sender, justification: justificationText }));\n        uint votingPower = getMemberVotingPower(msg.sender);\n        if (supportsProposal) {                         // If they support the proposal\n            p.currentResult+= int(votingPower);                          // Increase score\n        } else {                                        // If they don't\n            p.currentResult-= int(votingPower);                          // Decrease the score\n        }\n        // Create a log of this event\n        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\n        return voteID;\n    }\n\n    function getVoteCount(\n        uint256 proposalNumber\n    )\n    onlyMembers\n    public\n    view\n    returns(uint256 numberOfVotes, int256 currentResult, string description)\n    {\n        require(proposals[proposalNumber].proposalHash != 0);\n        numberOfVotes = proposals[proposalNumber].numberOfVotes;\n        currentResult = proposals[proposalNumber].currentResult;\n        description = proposals[proposalNumber].description;\n    }\n\n    /// Basic getter function\n    function getMemberInfo()\n    public\n    view\n    returns (address, bytes32, uint, uint)\n    {\n        Member memory member = address2Member[msg.sender];\n        return (member.memberAddress, member.name, member.votingPower, member.memberSince);\n    }\n\n    /**\n     * Finish vote\n     *\n     * Count the votes proposal #`proposalNumber` and execute it if approved\n     *\n     * @param proposalNumber proposal number\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n     */\n    function executeProposal(\n        uint proposalNumber,\n        bytes transactionBytecode\n    )\n    public\n    {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(\n//            block.timestamp > p.minExecutionDate  &&                             // If it is past the voting deadline\n             !p.executed                                                         // and it has not already been executed\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\n            && p.numberOfVotes >= minimumQuorum.sub(1) // and a minimum quorum has been reached...\n        //TODO: Delete -1 from MINIMUM QUORUM, left because KIKI is OOO\n            && uint(p.currentResult) >= maxVotingPower.mul(51).div(100)\n            && p.currentResult > 0\n        );\n\n        // ...then execute result\n        p.executed = true; // Avoid recursive calling\n        p.proposalPassed = true;\n\n        // Fire Events\n        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n\n        // Call external function\n        require(p.recipient.call.value(p.amount)(transactionBytecode));\n    }\n\n\n    /// @notice Function getter for voting power for specific member\n    /// @param _memberAddress is the address of the member\n    /// @return integer representing voting power\n    function getMemberVotingPower(\n        address _memberAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        Member memory _member = address2Member[msg.sender];\n        return _member.votingPower;\n    }\n\n    /// @notice to check if an address is member\n    /// @param _member is the address we're checking for\n    function checkIsMember(\n        address _member\n    )\n    public\n    view\n    returns (bool)\n    {\n        return isMemberInCongress[_member];\n    }\n\n    /// @notice Fallback function\n    function () payable public {\n        emit ReceivedEther(msg.sender, msg.value);\n    }\n\n    /// @notice Getter for maximum voting power\n    /// @return maxVotingPower\n    function getMaxVotingPower()\n    public\n    view\n    returns (uint)\n    {\n        return maxVotingPower;\n    }\n\n    /// @notice Getter for length for how many members are currently\n    /// @return length of members\n    function getMembersLength()\n    public\n    view\n    returns (uint)\n    {\n        return allMembers.length;\n    }\n\n    /// @notice Function / Getter for hashes of allowed methods\n    /// @return array of bytes32 hashes\n    function getAllowedMethods()\n    public\n    view\n    returns (bytes32[])\n    {\n        return allowedMethodSignatures;\n    }\n\n    /// @notice Function to fetch method name from method hash\n    /// @return methodname string representation\n    function getMethodNameFromMethodHash(\n        bytes32 _methodHash\n    )\n    public\n    view\n    returns(string)\n    {\n        return methodHashToMethodName[_methodHash];\n    }\n\n    /// @notice Function to get major proposal data\n    /// @param proposalId is the id of proposal\n    /// @return tuple containing all the data for proposal\n    function getProposalData(\n        uint proposalId\n    )\n    public\n    view\n    returns (uint,string,uint,bool,uint,int,bytes)\n    {\n        Proposal memory p = proposals[proposalId];\n        return (p.amount, p.description, p.minExecutionDate, p.executed, p.numberOfVotes, p.currentResult, p.transactionBytecode);\n    }\n\n    /// @notice Function to get addresses of all members in congress\n    /// @return array of addresses\n    function getAllMemberAddresses()\n    public\n    view\n    returns (address[])\n    {\n        return allMembers;\n    }\n\n}\n\n", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\ncontract TwoKeyCongress {\n\n    event ReceivedEther(address sender, uint amount);\n    using SafeMath for uint;\n\n    bool initialized;\n\n    // The maximum voting power containing sum of voting powers of all active members\n    uint256 maxVotingPower;\n    //The minimum number of voting members that must be in attendance\n    uint256 public minimumQuorum;\n    //Period length for voting\n    uint256 public debatingPeriodInMinutes;\n    //Array of proposals\n    Proposal[] public proposals;\n    //Number of proposals\n    uint public numProposals;\n\n    mapping (address => bool) public isMemberInCongress;\n    // Mapping address to memberId\n    mapping(address => Member) public address2Member;\n    // Mapping to store all members addresses\n    address[] public allMembers;\n    // Array of allowed methods\n    bytes32[] allowedMethodSignatures;\n\n    mapping(bytes32 => string) methodHashToMethodName;\n\n    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n    event Voted(uint proposalID, bool position, address voter, string justification);\n    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n    event MembershipChanged(address member, bool isMember);\n    event ChangeOfRules(uint256 _newMinimumQuorum, uint256 _newDebatingPeriodInMinutes);\n\n    struct Proposal {\n        address recipient;\n        uint amount;\n        string description;\n        uint minExecutionDate;\n        bool executed;\n        bool proposalPassed;\n        uint numberOfVotes;\n        int currentResult;\n        bytes32 proposalHash;\n        bytes transactionBytecode;\n        Vote[] votes;\n        mapping (address => bool) voted;\n    }\n\n    struct Member {\n        address memberAddress;\n        bytes32 name;\n        uint votingPower;\n        uint memberSince;\n    }\n\n    struct Vote {\n        bool inSupport;\n        address voter;\n        string justification;\n    }\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyMembers {\n        require(isMemberInCongress[msg.sender] == true);\n        _;\n    }\n\n    /// @notice Function to check if the bytecode of passed method is in the whitelist\n    /// @param bytecode is the bytecode of transaction we'd like to execute\n    /// @return true if whitelisted otherwise false\n    function onlyAllowedMethods(\n        bytes bytecode\n    )\n    public\n    view\n    returns (bool)\n    {\n        for(uint i=0; i< allowedMethodSignatures.length; i++) {\n            if(compare(allowedMethodSignatures[i], bytecode)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @notice Function which will be called only once, immediately after contract deployment\n     * @param _minutesForDebate is the number of minutes debate length\n     * @param initialMembers is the array containing addresses of initial members\n     * @param votingPowers is the array of unassigned integers containing voting powers respectively\n     * @dev initialMembers.length must be equal votingPowers.length\n     */\n    constructor(\n        uint256 _minutesForDebate,\n        address[] initialMembers,\n        bytes32[] initialMemberNames,\n        uint[] votingPowers\n    )\n    payable\n    public\n    {\n        changeVotingRules(0, _minutesForDebate);\n        for(uint i=0; i<initialMembers.length; i++) {\n            addMember(initialMembers[i], initialMemberNames[i], votingPowers[i]);\n        }\n        initialized = true;\n        addInitialWhitelistedMethods();\n    }\n\n\n    /// @notice Function to add initial whitelisted methods during the deployment\n    /// @dev Function is internal, it can't be called outside of the contract\n    function addInitialWhitelistedMethods()\n    internal\n    {\n        hashAllowedMethods(\"transferByAdmins(address,uint256)\");\n        hashAllowedMethods(\"transferEtherByAdmins(address,uint256)\");\n        hashAllowedMethods(\"destroy\");\n        hashAllowedMethods(\"transfer2KeyTokens(address,uint256)\");\n        hashAllowedMethods(\"addMaintainerForRegistry(address)\");\n        hashAllowedMethods(\"twoKeyEventSourceAddMaintainer(address[])\");\n        hashAllowedMethods(\"twoKeyEventSourceWhitelistContract(address)\");\n        hashAllowedMethods(\"freezeTransfersInEconomy\");\n        hashAllowedMethods(\"unfreezeTransfersInEconomy\");\n        hashAllowedMethods(\"addMaintainersToSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"deleteMaintainersFromSelectedSingletone(address,address[])\");\n        hashAllowedMethods(\"updateRewardsRelease(uint256)\");\n        hashAllowedMethods(\"updateTwoKeyTokenRate(uint256)\");\n    }\n\n\n    /// @notice Since transaction's bytecode first 10 chars will contain method name and argument types\n    /// @notice This is the way to compare it efficiently\n    /// @dev on contract we will store allowed method name and argument types\n    /// @param x is the already validated method name\n    /// @param y is the bytecode of the transaction\n    /// @return true if same\n    function compare(\n        bytes32 x,\n        bytes y\n    )\n    public\n    pure\n    returns (bool)\n    {\n        for(uint i=0;i<3;i++) {\n            byte a = x[i];\n            byte b = y[i];\n            if(a != b) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    /// @notice Function to hash allowed method\n    /// @param nameAndParams is the name of the function and it's params to hash\n    /// @dev example: 'functionName(address,string)'\n    /// @return hash of allowed methods\n    function hashAllowedMethods(\n        string nameAndParams\n    )\n    internal\n    {\n        bytes32 allowed = keccak256(abi.encodePacked(nameAndParams));\n        allowedMethodSignatures.push(allowed);\n        methodHashToMethodName[allowed] = nameAndParams;\n    }\n\n\n    /// @notice Function where member can replace it's own address\n    /// @dev member can change only it's own address\n    /// @param _newMemberAddress is the new address we'd like to set for us\n    function replaceMemberAddress(\n        address _newMemberAddress\n    )\n    public\n    {\n        require(_newMemberAddress != address(0));\n        // Update is member in congress state\n        isMemberInCongress[_newMemberAddress] = true;\n        isMemberInCongress[msg.sender] = false;\n\n        //Update array containing all members addresses\n        for(uint i=0; i<allMembers.length; i++) {\n            if(allMembers[i] == msg.sender) {\n                allMembers[i] = _newMemberAddress;\n            }\n        }\n\n        //Update member object\n        Member memory m = address2Member[msg.sender];\n        address2Member[_newMemberAddress] = m;\n        address2Member[msg.sender] = Member(\n            {\n            memberAddress: address(0),\n            memberSince: block.timestamp,\n            votingPower: 0,\n            name: \"0x0\"\n            }\n        );\n    }\n\n    //TODO: Security backdoor, handle and close ASAP\n    /**\n     * Add member\n     *\n     * Make `targetMember` a member named `memberName`\n     *\n     * @param targetMember ethereum address to be added\n     * @param memberName public name for that member\n     */\n    function addMember(\n        address targetMember,\n        bytes32 memberName,\n        uint _votingPower\n    )\n    public\n    {\n        if(initialized == true) {\n            require(msg.sender == address(this));\n        }\n        minimumQuorum = allMembers.length;\n        maxVotingPower += _votingPower;\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: targetMember,\n                memberSince: block.timestamp,\n                votingPower: _votingPower,\n                name: memberName\n            }\n        );\n        allMembers.push(targetMember);\n        isMemberInCongress[targetMember] = true;\n        emit MembershipChanged(targetMember, true);\n    }\n\n    /**\n     * Remove member\n     *\n     * @notice Remove membership from `targetMember`\n     *\n     * @param targetMember ethereum address to be removed\n     */\n    function removeMember(\n        address targetMember\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        require(isMemberInCongress[targetMember] == true);\n\n        //Remove member voting power from max voting power\n        uint votingPower = getMemberVotingPower(targetMember);\n        maxVotingPower-= votingPower;\n\n        uint i=0;\n        //Find selected member\n        while(allMembers[i] != targetMember) {\n            if(i == allMembers.length) {\n                revert();\n            }\n            i++;\n        }\n        //After member is found, remove his address from all members\n        for (uint j = i; j< allMembers.length; j++){\n            allMembers[j] = allMembers[j+1];\n        }\n        //After reduce array size\n        delete allMembers[allMembers.length-1];\n        allMembers.length--;\n\n        //Remove him from state mapping\n        isMemberInCongress[targetMember] = false;\n\n        //Remove his state to empty member\n        address2Member[targetMember] = Member(\n            {\n                memberAddress: address(0),\n                memberSince: block.timestamp,\n                votingPower: 0,\n                name: \"0x0\"\n            }\n        );\n        //Reduce 1 member from quorum\n        minimumQuorum -= 1;\n    }\n\n    /**\n     *  Method to add voting for new allowed bytecode\n     *  The point is that for anything to be executed has to be voted\n     *  @param functionSignature is the new transaction bytecode we'd like to whitelist\n     *  @dev method requires that it's called only by contract\n    */\n    function addNewAllowedBytecode(\n        bytes32 functionSignature\n    )\n    public\n    {\n        require(msg.sender == address(this));\n        allowedMethodSignatures.push(bytes32(functionSignature));\n    }\n    /**\n     * Change voting rules\n     *\n     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\n     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\n     *\n     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\n     */\n    function changeVotingRules(\n        uint256 minimumQuorumForProposals,\n        uint256 minutesForDebate\n    )\n    internal\n    {\n        minimumQuorum = minimumQuorumForProposals;\n        debatingPeriodInMinutes = minutesForDebate;\n\n        emit ChangeOfRules(minimumQuorumForProposals, minutesForDebate);\n    }\n\n    /**\n     * Add Proposal\n     *\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     *\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send, in wei\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposal(\n        address beneficiary,\n        uint weiAmount,\n        string jobDescription,\n        bytes transactionBytecode)\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        require(onlyAllowedMethods(transactionBytecode)); // security layer\n        proposalID = proposals.length++;\n        Proposal storage p = proposals[proposalID];\n        p.recipient = beneficiary;\n        p.amount = weiAmount;\n        p.description = jobDescription;\n        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n        p.transactionBytecode = transactionBytecode;\n        p.minExecutionDate = block.timestamp + debatingPeriodInMinutes * 1 minutes;\n        p.executed = false;\n        p.proposalPassed = false;\n        p.numberOfVotes = 0;\n        p.currentResult = 0;\n        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\n        numProposals = proposalID+1;\n\n        return proposalID;\n    }\n\n    /**\n     * Add proposal in Ether\n     *\n     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\n     * This is a convenience function to use if the amount to be given is in round number of ether units.\n     *\n     * @param beneficiary who to send the ether to\n     * @param etherAmount amount of ether to send\n     * @param jobDescription Description of job\n     * @param transactionBytecode bytecode of transaction\n     */\n    function newProposalInEther(\n        address beneficiary,\n        uint etherAmount,\n        string jobDescription,\n        bytes transactionBytecode\n    )\n    public\n    onlyMembers\n    returns (uint proposalID)\n    {\n        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\n    }\n\n    /**\n     * Check if a proposal code matches\n     *\n     * @param proposalNumber ID number of the proposal to query\n     * @param beneficiary who to send the ether to\n     * @param weiAmount amount of ether to send\n     * @param transactionBytecode bytecode of transaction\n     */\n    function checkProposalCode(\n        uint proposalNumber,\n        address beneficiary,\n        uint weiAmount,\n        bytes transactionBytecode\n    )\n    public\n    view\n    returns (bool codeChecksOut)\n    {\n        Proposal storage p = proposals[proposalNumber];\n        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\n    }\n\n    /**\n     * Log a vote for a proposal\n     *\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\n     *\n     * @param proposalNumber number of proposal\n     * @param supportsProposal either in favor or against it\n     * @param justificationText optional justification text\n     */\n    function vote(\n        uint proposalNumber,\n        bool supportsProposal,\n        string justificationText)\n    public\n    onlyMembers\n    returns (uint256 voteID)\n    {\n        Proposal storage p = proposals[proposalNumber]; // Get the proposal\n        require(block.timestamp <= p.minExecutionDate);\n        require(!p.voted[msg.sender]);                  // If has already voted, cancel\n        p.voted[msg.sender] = true;                     // Set this voter as having voted\n        p.numberOfVotes++;\n        voteID = p.numberOfVotes;                     // Increase the number of votes\n        p.votes.push(Vote({ inSupport: supportsProposal, voter: msg.sender, justification: justificationText }));\n        uint votingPower = getMemberVotingPower(msg.sender);\n        if (supportsProposal) {                         // If they support the proposal\n            p.currentResult+= int(votingPower);                          // Increase score\n        } else {                                        // If they don't\n            p.currentResult-= int(votingPower);                          // Decrease the score\n        }\n        // Create a log of this event\n        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\n        return voteID;\n    }\n\n    function getVoteCount(\n        uint256 proposalNumber\n    )\n    onlyMembers\n    public\n    view\n    returns(uint256 numberOfVotes, int256 currentResult, string description)\n    {\n        require(proposals[proposalNumber].proposalHash != 0);\n        numberOfVotes = proposals[proposalNumber].numberOfVotes;\n        currentResult = proposals[proposalNumber].currentResult;\n        description = proposals[proposalNumber].description;\n    }\n\n    /// Basic getter function\n    function getMemberInfo()\n    public\n    view\n    returns (address, bytes32, uint, uint)\n    {\n        Member memory member = address2Member[msg.sender];\n        return (member.memberAddress, member.name, member.votingPower, member.memberSince);\n    }\n\n    /**\n     * Finish vote\n     *\n     * Count the votes proposal #`proposalNumber` and execute it if approved\n     *\n     * @param proposalNumber proposal number\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\n     */\n    function executeProposal(\n        uint proposalNumber,\n        bytes transactionBytecode\n    )\n    public\n    {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(\n//            block.timestamp > p.minExecutionDate  &&                             // If it is past the voting deadline\n             !p.executed                                                         // and it has not already been executed\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\n            && p.numberOfVotes >= minimumQuorum.sub(1) // and a minimum quorum has been reached...\n        //TODO: Delete -1 from MINIMUM QUORUM, left because KIKI is OOO\n            && uint(p.currentResult) >= maxVotingPower.mul(51).div(100)\n            && p.currentResult > 0\n        );\n\n        // ...then execute result\n        p.executed = true; // Avoid recursive calling\n        p.proposalPassed = true;\n\n        // Fire Events\n        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n\n        // Call external function\n        require(p.recipient.call.value(p.amount)(transactionBytecode));\n    }\n\n\n    /// @notice Function getter for voting power for specific member\n    /// @param _memberAddress is the address of the member\n    /// @return integer representing voting power\n    function getMemberVotingPower(\n        address _memberAddress\n    )\n    public\n    view\n    returns (uint)\n    {\n        Member memory _member = address2Member[msg.sender];\n        return _member.votingPower;\n    }\n\n    /// @notice to check if an address is member\n    /// @param _member is the address we're checking for\n    function checkIsMember(\n        address _member\n    )\n    public\n    view\n    returns (bool)\n    {\n        return isMemberInCongress[_member];\n    }\n\n    /// @notice Fallback function\n    function () payable public {\n        emit ReceivedEther(msg.sender, msg.value);\n    }\n\n    /// @notice Getter for maximum voting power\n    /// @return maxVotingPower\n    function getMaxVotingPower()\n    public\n    view\n    returns (uint)\n    {\n        return maxVotingPower;\n    }\n\n    /// @notice Getter for length for how many members are currently\n    /// @return length of members\n    function getMembersLength()\n    public\n    view\n    returns (uint)\n    {\n        return allMembers.length;\n    }\n\n    /// @notice Function / Getter for hashes of allowed methods\n    /// @return array of bytes32 hashes\n    function getAllowedMethods()\n    public\n    view\n    returns (bytes32[])\n    {\n        return allowedMethodSignatures;\n    }\n\n    /// @notice Function to fetch method name from method hash\n    /// @return methodname string representation\n    function getMethodNameFromMethodHash(\n        bytes32 _methodHash\n    )\n    public\n    view\n    returns(string)\n    {\n        return methodHashToMethodName[_methodHash];\n    }\n\n    /// @notice Function to get major proposal data\n    /// @param proposalId is the id of proposal\n    /// @return tuple containing all the data for proposal\n    function getProposalData(\n        uint proposalId\n    )\n    public\n    view\n    returns (uint,string,uint,bool,uint,int,bytes)\n    {\n        Proposal memory p = proposals[proposalId];\n        return (p.amount, p.description, p.minExecutionDate, p.executed, p.numberOfVotes, p.currentResult, p.transactionBytecode);\n    }\n\n    /// @notice Function to get addresses of all members in congress\n    /// @return array of addresses\n    function getAllMemberAddresses()\n    public\n    view\n    returns (address[])\n    {\n        return allMembers;\n    }\n\n}\n\n", "commit_id": "1aecf40bb4528fec8dc5122f39da9d108b0ca6a7"}}