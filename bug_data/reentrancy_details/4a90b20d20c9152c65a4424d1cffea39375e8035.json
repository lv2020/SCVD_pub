{"filename": "packages/core/contracts/insured-bridge/BridgePool.sol", "patch": "@@ -209,22 +209,20 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * @dev Reentrancy guard not added to this function because this indirectly calls sync() which is guarded.\n      * @param l1TokenAmount Number of l1Token to add as liquidity.\n      */\n-    function addLiquidity(uint256 l1TokenAmount) public payable {\n+    function addLiquidity(uint256 l1TokenAmount) public payable nonReentrant() {\n         // If this is the weth pool and the caller sends msg.value then the msg.value must match the l1TokenAmount.\n         // Else, msg.value must be set to 0.\n         require((isWethPool && msg.value == l1TokenAmount) || msg.value == 0, \"Bad add liquidity Eth value\");\n \n         // Since `exchangeRateCurrent()` reads this contract's balance and updates contract state using it,\n         // we must call it first before transferring any tokens to this contract.\n-        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / exchangeRateCurrent();\n+        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent();\n+        _mint(msg.sender, lpTokensToMint);\n+        liquidReserves += l1TokenAmount;\n \n         if (msg.value > 0 && isWethPool) WETH9Like(address(l1Token)).deposit{ value: msg.value }();\n         else l1Token.safeTransferFrom(msg.sender, address(this), l1TokenAmount);\n \n-        _mint(msg.sender, lpTokensToMint);\n-\n-        liquidReserves += l1TokenAmount;\n-\n         emit LiquidityAdded(address(l1Token), l1TokenAmount, lpTokensToMint, msg.sender);\n     }\n \n@@ -236,16 +234,15 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * @param lpTokenAmount Number of lpTokens to redeem for underlying.\n      * @param sendEth Enable the liquidity provider to remove liquidity in ETH, if this is the WETH pool.\n      */\n-    function removeLiquidity(uint256 lpTokenAmount, bool sendEth) public {\n+    function removeLiquidity(uint256 lpTokenAmount, bool sendEth) public nonReentrant() {\n         // Can only send eth on withdrawing liquidity iff this is the WETH pool.\n         require(!sendEth || isWethPool, \"Cant send eth\");\n-        uint256 l1TokensToReturn = (lpTokenAmount * exchangeRateCurrent()) / 1e18;\n+        uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent()) / 1e18;\n \n         // Check that there is enough liquid reserves to withdraw the requested amount.\n         require(liquidReserves >= (pendingReserves + l1TokensToReturn), \"Utilization too high to remove\");\n \n         _burn(msg.sender, lpTokenAmount);\n-\n         liquidReserves -= l1TokensToReturn;\n \n         if (sendEth) _unwrapWETHTo(payable(msg.sender), l1TokensToReturn);\n@@ -332,13 +329,13 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n         // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n         uint256 recipientAmount = depositData.amount - feesTotal;\n \n-        l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);\n         bonds += totalBond;\n-\n         pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n \n         instantRelays[instantRelayHash] = msg.sender;\n \n+        l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);\n+\n         // If this is a weth pool then unwrap and send eth.\n         if (isWethPool) {\n             _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n@@ -441,11 +438,10 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n \n         // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n         uint256 totalBond = proposerBond + l1TokenFinalFee;\n-        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\n-\n         pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n         bonds += totalBond;\n \n+        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\n         emit DepositRelayed(depositHash, depositData, address(l1Token), relayData, relayHash);\n     }\n \n@@ -583,8 +579,8 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n         liquidReserves -= totalReservesSent;\n         utilizedReserves += int256(totalReservesSent);\n         bonds -= totalBond;\n-        updateAccumulatedLpFees();\n-        allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));\n+        _updateAccumulatedLpFees();\n+        _allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));\n \n         emit RelaySettled(depositHash, msg.sender, relayData);\n \n@@ -598,43 +594,24 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * at the conclusion of an L2 -> L1 token transfer via the canonical token bridge.\n      */\n     function sync() public nonReentrant() {\n-        // Check if the l1Token balance of the contract is greater than the liquidReserves. If it is then the bridging\n-        // action from L2 -> L1 has concluded and the local accounting can be updated.\n-        uint256 l1TokenBalance = l1Token.balanceOf(address(this)) - bonds;\n-        if (l1TokenBalance > liquidReserves) {\n-            // utilizedReserves can go to less than zero. This will happen if the accumulated fees exceeds the current\n-            // outstanding utilization. In other words, if outstanding bridging transfers are 0 then utilizedReserves\n-            // will equal the total LP fees accumulated over all time.\n-            utilizedReserves -= int256(l1TokenBalance - liquidReserves);\n-            liquidReserves = l1TokenBalance;\n-        }\n+        _sync();\n     }\n \n     /**\n      * @notice Computes the exchange rate between LP tokens and L1Tokens. Used when adding/removing liquidity.\n      * @return The updated exchange rate between LP tokens and L1 tokens.\n      */\n-    function exchangeRateCurrent() public returns (uint256) {\n-        if (totalSupply() == 0) return 1e18; // initial rate is 1 pre any mint action.\n-\n-        // First, update fee counters and local accounting of finalized transfers from L2 -> L1.\n-        updateAccumulatedLpFees(); // Accumulate all allocated fees from the last time this method was called.\n-        sync(); // Fetch any balance changes due to token bridging finalization and factor them in.\n-\n-        // ExchangeRate := (liquidReserves + utilizedReserves - undistributedLpFees) / lpTokenSupply\n-        uint256 numerator = liquidReserves - undistributedLpFees;\n-        if (utilizedReserves > 0) numerator += uint256(utilizedReserves);\n-        else numerator -= uint256(utilizedReserves * -1);\n-        return (numerator * 1e18) / totalSupply();\n+    function exchangeRateCurrent() public nonReentrant() returns (uint256) {\n+        return _exchangeRateCurrent();\n     }\n \n     /**\n      * @notice Computes the current liquidity utilization ratio.\n      * @dev Used in computing realizedLpFeePct off-chain.\n      * @return The current utilization ratio.\n      */\n-    function liquidityUtilizationCurrent() public returns (uint256) {\n-        return liquidityUtilizationPostRelay(0);\n+    function liquidityUtilizationCurrent() public nonReentrant() returns (uint256) {\n+        return _liquidityUtilizationPostRelay(0);\n     }\n \n     /**\n@@ -643,28 +620,8 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * @param relayedAmount Size of the relayed deposit to factor into the utilization calculation.\n      * @return The updated utilization ratio accounting for a new `relayedAmount`.\n      */\n-    function liquidityUtilizationPostRelay(uint256 relayedAmount) public returns (uint256) {\n-        sync(); // Fetch any balance changes due to token bridging finalization and factor them in.\n-\n-        // The liquidity utilization ratio is the ratio of utilized liquidity (pendingReserves + relayedAmount\n-        // +utilizedReserves) divided by the liquid reserves.\n-        int256 numerator = int256(pendingReserves + relayedAmount);\n-        numerator += utilizedReserves;\n-\n-        // The numerator could be less than zero iff pending reserves is zero, relayed amount is zero and utilizedReserves\n-        // is negative. This could happen if tokens are sent to the bridge after deployment without any relays yet\n-        // having happened.\n-        if (numerator < 0) return 0;\n-\n-        // There are two cases where liquid reserves could be zero. Handle accordingly to avoid division by zero:\n-        // a) the pool is new and there no funds in it nor any bridging actions have happened. In this case the\n-        // numerator is 0 and liquid reserves are 0. The utilization is therefore 0.\n-        if (numerator == 0 && liquidReserves == 0) return 0;\n-        // b) the numerator is more than 0 and the liquid reserves are 0. in this case, The pool is at 100% utilization.\n-        if (numerator > 0 && liquidReserves == 0) return 1e18;\n-\n-        // In all other cases, return the utilization ratio.\n-        return (uint256(numerator) * 1e18) / liquidReserves;\n+    function liquidityUtilizationPostRelay(uint256 relayedAmount) public nonReentrant() returns (uint256) {\n+        return _liquidityUtilizationPostRelay(relayedAmount);\n     }\n \n     /**\n@@ -673,7 +630,7 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * @dev There is no risk of leaving this function public for anyone to call as in all cases we want the addresses\n      * in this contract to map to the latest version in the Finder and store the latest final fee.\n      */\n-    function syncUmaEcosystemParams() public {\n+    function syncUmaEcosystemParams() public nonReentrant() {\n         FinderInterface finder = FinderInterface(bridgeAdmin.finder());\n         optimisticOracle = SkinnyOptimisticOracleInterface(\n             finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle)\n@@ -689,7 +646,7 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * @dev There is no risk of leaving this function public for anyone to call as in all cases we want these values\n      * in this contract to map to the latest version set in the BridgeAdmin.\n      */\n-    function syncWithBridgeAdminParams() public {\n+    function syncWithBridgeAdminParams() public nonReentrant() {\n         proposerBondPct = bridgeAdmin.proposerBondPct();\n         optimisticOracleLiveness = bridgeAdmin.optimisticOracleLiveness();\n         identifier = bridgeAdmin.identifier();\n@@ -717,12 +674,8 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      * @notice Computes the current amount of unallocated fees that have accumulated from the previous time this the\n      * contract was called.\n      */\n-    function getAccumulatedFees() public view returns (uint256) {\n-        // UnallocatedLpFees := min(undistributedLpFees*lpFeeRatePerSecond*timeFromLastInteraction,undistributedLpFees)\n-        // The min acts to pay out all fees in the case the equation returns more than the remaining a fees.\n-        uint256 possibleUnpaidFees =\n-            (undistributedLpFees * lpFeeRatePerSecond * (getCurrentTime() - lastLpFeeUpdate)) / (1e18);\n-        return possibleUnpaidFees < undistributedLpFees ? possibleUnpaidFees : undistributedLpFees;\n+    function getAccumulatedFees() public view nonReentrantView() returns (uint256) {\n+        return _getAccumulatedFees();\n     }\n \n     /**\n@@ -737,6 +690,7 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n     function getRelayAncillaryData(DepositData memory depositData, RelayData memory relayData)\n         public\n         view\n+        nonReentrantView()\n         returns (bytes memory)\n     {\n         return _getRelayAncillaryData(_getRelayHash(depositData, relayData));\n@@ -746,6 +700,57 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n      *    INTERNAL & PRIVATE FUNCTIONS    *\n      **************************************/\n \n+    function _sync() internal {\n+        // Check if the l1Token balance of the contract is greater than the liquidReserves. If it is then the bridging\n+        // action from L2 -> L1 has concluded and the local accounting can be updated.\n+        uint256 l1TokenBalance = l1Token.balanceOf(address(this)) - bonds;\n+        if (l1TokenBalance > liquidReserves) {\n+            // utilizedReserves can go to less than zero. This will happen if the accumulated fees exceeds the current\n+            // outstanding utilization. In other words, if outstanding bridging transfers are 0 then utilizedReserves\n+            // will equal the total LP fees accumulated over all time.\n+            utilizedReserves -= int256(l1TokenBalance - liquidReserves);\n+            liquidReserves = l1TokenBalance;\n+        }\n+    }\n+\n+    function _exchangeRateCurrent() internal returns (uint256) {\n+        if (totalSupply() == 0) return 1e18; // initial rate is 1 pre any mint action.\n+\n+        // First, update fee counters and local accounting of finalized transfers from L2 -> L1.\n+        _updateAccumulatedLpFees(); // Accumulate all allocated fees from the last time this method was called.\n+        _sync(); // Fetch any balance changes due to token bridging finalization and factor them in.\n+\n+        // ExchangeRate := (liquidReserves + utilizedReserves - undistributedLpFees) / lpTokenSupply\n+        uint256 numerator = liquidReserves - undistributedLpFees;\n+        if (utilizedReserves > 0) numerator += uint256(utilizedReserves);\n+        else numerator -= uint256(utilizedReserves * -1);\n+        return (numerator * 1e18) / totalSupply();\n+    }\n+\n+    function _liquidityUtilizationPostRelay(uint256 relayedAmount) internal returns (uint256) {\n+        _sync(); // Fetch any balance changes due to token bridging finalization and factor them in.\n+\n+        // The liquidity utilization ratio is the ratio of utilized liquidity (pendingReserves + relayedAmount\n+        // +utilizedReserves) divided by the liquid reserves.\n+        int256 numerator = int256(pendingReserves + relayedAmount);\n+        numerator += utilizedReserves;\n+\n+        // The numerator could be less than zero iff pending reserves is zero, relayed amount is zero and utilizedReserves\n+        // is negative. This could happen if tokens are sent to the bridge after deployment without any relays yet\n+        // having happened.\n+        if (numerator < 0) return 0;\n+\n+        // There are two cases where liquid reserves could be zero. Handle accordingly to avoid division by zero:\n+        // a) the pool is new and there no funds in it nor any bridging actions have happened. In this case the\n+        // numerator is 0 and liquid reserves are 0. The utilization is therefore 0.\n+        if (numerator == 0 && liquidReserves == 0) return 0;\n+        // b) the numerator is more than 0 and the liquid reserves are 0. in this case, The pool is at 100% utilization.\n+        if (numerator > 0 && liquidReserves == 0) return 1e18;\n+\n+        // In all other cases, return the utilization ratio.\n+        return (uint256(numerator) * 1e18) / liquidReserves;\n+    }\n+\n     // Return UTF8-decodable ancillary data for relay price request associated with relay hash.\n     function _getRelayAncillaryData(bytes32 relayHash) private pure returns (bytes memory) {\n         return AncillaryData.appendKeyValueBytes32(\"\", \"relayHash\", relayHash);\n@@ -777,10 +782,18 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n         return keccak256(abi.encode(depositHash, relayData.realizedLpFeePct));\n     }\n \n+    function _getAccumulatedFees() internal view returns (uint256) {\n+        // UnallocatedLpFees := min(undistributedLpFees*lpFeeRatePerSecond*timeFromLastInteraction,undistributedLpFees)\n+        // The min acts to pay out all fees in the case the equation returns more than the remaining a fees.\n+        uint256 possibleUnpaidFees =\n+            (undistributedLpFees * lpFeeRatePerSecond * (getCurrentTime() - lastLpFeeUpdate)) / (1e18);\n+        return possibleUnpaidFees < undistributedLpFees ? possibleUnpaidFees : undistributedLpFees;\n+    }\n+\n     // Update internal fee counters by adding in any accumulated fees from the last time this logic was called.\n-    function updateAccumulatedLpFees() internal {\n+    function _updateAccumulatedLpFees() internal {\n         // Calculate the unallocatedAccumulatedFees from the last time the contract was called.\n-        uint256 unallocatedAccumulatedFees = getAccumulatedFees();\n+        uint256 unallocatedAccumulatedFees = _getAccumulatedFees();\n \n         // Decrement the undistributedLpFees by the amount of accumulated fees.\n         undistributedLpFees = undistributedLpFees - unallocatedAccumulatedFees;\n@@ -789,7 +802,7 @@ contract BridgePool is Testable, BridgePoolInterface, ERC20, Lockable {\n     }\n \n     // Allocate fees to the LPs by incrementing counters.\n-    function allocateLpFees(uint256 allocatedLpFees) internal {\n+    function _allocateLpFees(uint256 allocatedLpFees) internal {\n         // Add to the total undistributed LP fees and the utilized reserves. Adding it to the utilized reserves acts to\n         // track the fees while they are in transit.\n         if (allocatedLpFees > 0) {", "project_link": "https://github.com/mrice32/protocol/commit/fe5f448ccf7cb91594921daae49cb1f7d9ecac67", "solc_version": "0.6.0", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "4a90b20d20c9152c65a4424d1cffea39375e8035"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "fe5f448ccf7cb91594921daae49cb1f7d9ecac67"}}