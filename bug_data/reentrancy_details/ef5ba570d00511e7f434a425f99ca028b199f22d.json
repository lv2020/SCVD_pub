{"filename": "modules/contracts/contracts/funding/state-deposit-holders/MinimumViableMultisig.sol", "patch": "@@ -63,6 +63,8 @@ contract MinimumViableMultisig {\n       \"Transacation has already been executed\"\n     );\n \n+    isExecuted[transactionHash] = true;\n+\n     address lastSigner = address(0);\n     for (uint256 i = 0; i < _owners.length; i++) {\n       require(\n@@ -74,8 +76,6 @@ contract MinimumViableMultisig {\n     }\n \n     execute(to, value, data, operation);\n-\n-    isExecuted[transactionHash] = true;\n   }\n \n   /// @notice Compute a unique transaction hash for a particular (to, value, data, op) tuple", "project_link": "https://github.com/balasan/indra/commit/ef5ba570d00511e7f434a425f99ca028b199f22d", "bug_version": {"raw_code": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\n\n/// @title MinimumViableMultisig - A multisig wallet supporting the minimum\n/// features required for state channels support\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice\n/// (a) Executes arbitrary transactions using `CALL` or `DELEGATECALL`\n/// (b) Requires n-of-n unanimous consent\n/// (c) Does not use on-chain address for signature verification\n/// (d) Uses hash-based instead of nonce-based replay protection\ncontract MinimumViableMultisig {\n\n  using ECDSA for bytes32;\n\n  address masterCopy;\n\n  mapping(bytes32 => bool) isExecuted;\n\n  address[] private _owners;\n\n  enum Operation {\n    Call,\n    DelegateCall\n  }\n\n  function ()\n    external\n    payable\n  {}\n\n  /// @notice Contract constructor\n  /// @param owners An array of unique addresses representing the multisig owners\n  function setup(address[] memory owners) public {\n    require(_owners.length == 0, \"Contract has been set up before\");\n    _owners = owners;\n  }\n\n  /// @notice Execute an n-of-n signed transaction specified by a (to, value, data, op) tuple\n  /// This transaction is a message call, i.e., either a CALL or a DELEGATECALL,\n  /// depending on the value of `op`. The arguments `to`, `value`, `data` are passed\n  /// as arguments to the CALL/DELEGATECALL.\n  /// @param to The destination address of the message call\n  /// @param value The amount of ETH being forwarded in the message call\n  /// @param data Any calldata being sent along with the message call\n  /// @param operation Specifies whether the message call is a `CALL` or a `DELEGATECALL`\n  /// @param signatures A sorted bytes string of concatenated signatures of each owner\n  function execTransaction(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation,\n    bytes[] memory signatures\n  )\n    public\n  {\n    bytes32 transactionHash = getTransactionHash(to, value, data, operation);\n    require(\n      !isExecuted[transactionHash],\n      \"Transacation has already been executed\"\n    );\n\n    address lastSigner = address(0);\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        _owners[i] == transactionHash.recover(signatures[i]),\n        \"Invalid signature\"\n      );\n      require(_owners[i] > lastSigner, \"Signers not in alphanumeric order\");\n      lastSigner = _owners[i];\n    }\n\n    execute(to, value, data, operation);\n\n    isExecuted[transactionHash] = true;\n  }\n\n  /// @notice Compute a unique transaction hash for a particular (to, value, data, op) tuple\n  /// @return A unique hash that owners are expected to sign and submit to\n  /// @notice Note that two transactions with identical values of (to, value, data, op)\n  /// are not distinguished.\n  function getTransactionHash(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(byte(0x19), _owners, to, value, data, uint8(operation))\n    );\n  }\n\n  /// @notice A getter function for the owners of the multisig\n  /// @return An array of addresses representing the owners\n  function getOwners()\n    public\n    view\n    returns (address[] memory)\n  {\n    return _owners;\n  }\n\n  /// @notice Execute a transaction on behalf of the multisignature wallet\n  function execute(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    internal\n  {\n    if (operation == Operation.Call)\n      require(executeCall(to, value, data), \"executeCall failed\");\n    else if (operation == Operation.DelegateCall)\n      require(executeDelegateCall(to, data), \"executeDelegateCall failed\");\n  }\n\n  /// @notice Execute a CALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeCall(address to, uint256 value, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := call(not(0), to, value, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  /// @notice Execute a DELEGATECALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeDelegateCall(address to, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := delegatecall(not(0), to, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n}\n", "flattened_code": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n\n/// @title MinimumViableMultisig - A multisig wallet supporting the minimum\n/// features required for state channels support\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice\n/// (a) Executes arbitrary transactions using `CALL` or `DELEGATECALL`\n/// (b) Requires n-of-n unanimous consent\n/// (c) Does not use on-chain address for signature verification\n/// (d) Uses hash-based instead of nonce-based replay protection\ncontract MinimumViableMultisig {\n\n  using ECDSA for bytes32;\n\n  address masterCopy;\n\n  mapping(bytes32 => bool) isExecuted;\n\n  address[] private _owners;\n\n  enum Operation {\n    Call,\n    DelegateCall\n  }\n\n  function ()\n    external\n    payable\n  {}\n\n  /// @notice Contract constructor\n  /// @param owners An array of unique addresses representing the multisig owners\n  function setup(address[] memory owners) public {\n    require(_owners.length == 0, \"Contract has been set up before\");\n    _owners = owners;\n  }\n\n  /// @notice Execute an n-of-n signed transaction specified by a (to, value, data, op) tuple\n  /// This transaction is a message call, i.e., either a CALL or a DELEGATECALL,\n  /// depending on the value of `op`. The arguments `to`, `value`, `data` are passed\n  /// as arguments to the CALL/DELEGATECALL.\n  /// @param to The destination address of the message call\n  /// @param value The amount of ETH being forwarded in the message call\n  /// @param data Any calldata being sent along with the message call\n  /// @param operation Specifies whether the message call is a `CALL` or a `DELEGATECALL`\n  /// @param signatures A sorted bytes string of concatenated signatures of each owner\n  function execTransaction(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation,\n    bytes[] memory signatures\n  )\n    public\n  {\n    bytes32 transactionHash = getTransactionHash(to, value, data, operation);\n    require(\n      !isExecuted[transactionHash],\n      \"Transacation has already been executed\"\n    );\n\n    address lastSigner = address(0);\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        _owners[i] == transactionHash.recover(signatures[i]),\n        \"Invalid signature\"\n      );\n      require(_owners[i] > lastSigner, \"Signers not in alphanumeric order\");\n      lastSigner = _owners[i];\n    }\n\n    execute(to, value, data, operation);\n\n    isExecuted[transactionHash] = true;\n  }\n\n  /// @notice Compute a unique transaction hash for a particular (to, value, data, op) tuple\n  /// @return A unique hash that owners are expected to sign and submit to\n  /// @notice Note that two transactions with identical values of (to, value, data, op)\n  /// are not distinguished.\n  function getTransactionHash(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(byte(0x19), _owners, to, value, data, uint8(operation))\n    );\n  }\n\n  /// @notice A getter function for the owners of the multisig\n  /// @return An array of addresses representing the owners\n  function getOwners()\n    public\n    view\n    returns (address[] memory)\n  {\n    return _owners;\n  }\n\n  /// @notice Execute a transaction on behalf of the multisignature wallet\n  function execute(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    internal\n  {\n    if (operation == Operation.Call)\n      require(executeCall(to, value, data), \"executeCall failed\");\n    else if (operation == Operation.DelegateCall)\n      require(executeDelegateCall(to, data), \"executeDelegateCall failed\");\n  }\n\n  /// @notice Execute a CALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeCall(address to, uint256 value, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := call(not(0), to, value, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  /// @notice Execute a DELEGATECALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeDelegateCall(address to, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := delegatecall(not(0), to, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n}\n", "commit_id": "f42c158ae781a5dd32a1cded55d49fe419b108ba"}, "fixed_version": {"raw_code": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\n\n/// @title MinimumViableMultisig - A multisig wallet supporting the minimum\n/// features required for state channels support\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice\n/// (a) Executes arbitrary transactions using `CALL` or `DELEGATECALL`\n/// (b) Requires n-of-n unanimous consent\n/// (c) Does not use on-chain address for signature verification\n/// (d) Uses hash-based instead of nonce-based replay protection\ncontract MinimumViableMultisig {\n\n  using ECDSA for bytes32;\n\n  address masterCopy;\n\n  mapping(bytes32 => bool) isExecuted;\n\n  address[] private _owners;\n\n  enum Operation {\n    Call,\n    DelegateCall\n  }\n\n  function ()\n    external\n    payable\n  {}\n\n  /// @notice Contract constructor\n  /// @param owners An array of unique addresses representing the multisig owners\n  function setup(address[] memory owners) public {\n    require(_owners.length == 0, \"Contract has been set up before\");\n    _owners = owners;\n  }\n\n  /// @notice Execute an n-of-n signed transaction specified by a (to, value, data, op) tuple\n  /// This transaction is a message call, i.e., either a CALL or a DELEGATECALL,\n  /// depending on the value of `op`. The arguments `to`, `value`, `data` are passed\n  /// as arguments to the CALL/DELEGATECALL.\n  /// @param to The destination address of the message call\n  /// @param value The amount of ETH being forwarded in the message call\n  /// @param data Any calldata being sent along with the message call\n  /// @param operation Specifies whether the message call is a `CALL` or a `DELEGATECALL`\n  /// @param signatures A sorted bytes string of concatenated signatures of each owner\n  function execTransaction(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation,\n    bytes[] memory signatures\n  )\n    public\n  {\n    bytes32 transactionHash = getTransactionHash(to, value, data, operation);\n    require(\n      !isExecuted[transactionHash],\n      \"Transacation has already been executed\"\n    );\n\n    isExecuted[transactionHash] = true;\n\n    address lastSigner = address(0);\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        _owners[i] == transactionHash.recover(signatures[i]),\n        \"Invalid signature\"\n      );\n      require(_owners[i] > lastSigner, \"Signers not in alphanumeric order\");\n      lastSigner = _owners[i];\n    }\n\n    execute(to, value, data, operation);\n  }\n\n  /// @notice Compute a unique transaction hash for a particular (to, value, data, op) tuple\n  /// @return A unique hash that owners are expected to sign and submit to\n  /// @notice Note that two transactions with identical values of (to, value, data, op)\n  /// are not distinguished.\n  function getTransactionHash(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(byte(0x19), _owners, to, value, data, uint8(operation))\n    );\n  }\n\n  /// @notice A getter function for the owners of the multisig\n  /// @return An array of addresses representing the owners\n  function getOwners()\n    public\n    view\n    returns (address[] memory)\n  {\n    return _owners;\n  }\n\n  /// @notice Execute a transaction on behalf of the multisignature wallet\n  function execute(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    internal\n  {\n    if (operation == Operation.Call)\n      require(executeCall(to, value, data), \"executeCall failed\");\n    else if (operation == Operation.DelegateCall)\n      require(executeDelegateCall(to, data), \"executeDelegateCall failed\");\n  }\n\n  /// @notice Execute a CALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeCall(address to, uint256 value, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := call(not(0), to, value, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  /// @notice Execute a DELEGATECALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeDelegateCall(address to, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := delegatecall(not(0), to, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n}\n", "flattened_code": "pragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n\n/// @title MinimumViableMultisig - A multisig wallet supporting the minimum\n/// features required for state channels support\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice\n/// (a) Executes arbitrary transactions using `CALL` or `DELEGATECALL`\n/// (b) Requires n-of-n unanimous consent\n/// (c) Does not use on-chain address for signature verification\n/// (d) Uses hash-based instead of nonce-based replay protection\ncontract MinimumViableMultisig {\n\n  using ECDSA for bytes32;\n\n  address masterCopy;\n\n  mapping(bytes32 => bool) isExecuted;\n\n  address[] private _owners;\n\n  enum Operation {\n    Call,\n    DelegateCall\n  }\n\n  function ()\n    external\n    payable\n  {}\n\n  /// @notice Contract constructor\n  /// @param owners An array of unique addresses representing the multisig owners\n  function setup(address[] memory owners) public {\n    require(_owners.length == 0, \"Contract has been set up before\");\n    _owners = owners;\n  }\n\n  /// @notice Execute an n-of-n signed transaction specified by a (to, value, data, op) tuple\n  /// This transaction is a message call, i.e., either a CALL or a DELEGATECALL,\n  /// depending on the value of `op`. The arguments `to`, `value`, `data` are passed\n  /// as arguments to the CALL/DELEGATECALL.\n  /// @param to The destination address of the message call\n  /// @param value The amount of ETH being forwarded in the message call\n  /// @param data Any calldata being sent along with the message call\n  /// @param operation Specifies whether the message call is a `CALL` or a `DELEGATECALL`\n  /// @param signatures A sorted bytes string of concatenated signatures of each owner\n  function execTransaction(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation,\n    bytes[] memory signatures\n  )\n    public\n  {\n    bytes32 transactionHash = getTransactionHash(to, value, data, operation);\n    require(\n      !isExecuted[transactionHash],\n      \"Transacation has already been executed\"\n    );\n\n    isExecuted[transactionHash] = true;\n\n    address lastSigner = address(0);\n    for (uint256 i = 0; i < _owners.length; i++) {\n      require(\n        _owners[i] == transactionHash.recover(signatures[i]),\n        \"Invalid signature\"\n      );\n      require(_owners[i] > lastSigner, \"Signers not in alphanumeric order\");\n      lastSigner = _owners[i];\n    }\n\n    execute(to, value, data, operation);\n  }\n\n  /// @notice Compute a unique transaction hash for a particular (to, value, data, op) tuple\n  /// @return A unique hash that owners are expected to sign and submit to\n  /// @notice Note that two transactions with identical values of (to, value, data, op)\n  /// are not distinguished.\n  function getTransactionHash(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    public\n    view\n    returns (bytes32)\n  {\n    return keccak256(\n      abi.encodePacked(byte(0x19), _owners, to, value, data, uint8(operation))\n    );\n  }\n\n  /// @notice A getter function for the owners of the multisig\n  /// @return An array of addresses representing the owners\n  function getOwners()\n    public\n    view\n    returns (address[] memory)\n  {\n    return _owners;\n  }\n\n  /// @notice Execute a transaction on behalf of the multisignature wallet\n  function execute(\n    address to,\n    uint256 value,\n    bytes memory data,\n    Operation operation\n  )\n    internal\n  {\n    if (operation == Operation.Call)\n      require(executeCall(to, value, data), \"executeCall failed\");\n    else if (operation == Operation.DelegateCall)\n      require(executeDelegateCall(to, data), \"executeDelegateCall failed\");\n  }\n\n  /// @notice Execute a CALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeCall(address to, uint256 value, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := call(not(0), to, value, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n  /// @notice Execute a DELEGATECALL on behalf of the multisignature wallet\n  /// @return A boolean indicating if the transaction was successful or not\n  function executeDelegateCall(address to, bytes memory data)\n    internal\n    returns (bool success)\n  {\n    assembly {\n      success := delegatecall(not(0), to, add(data, 0x20), mload(data), 0, 0)\n    }\n  }\n\n}\n", "commit_id": "ef5ba570d00511e7f434a425f99ca028b199f22d"}}