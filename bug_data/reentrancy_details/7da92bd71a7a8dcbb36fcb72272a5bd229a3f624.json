{"filename": "contracts/Marketplace.sol", "patch": "@@ -102,6 +102,7 @@ contract Marketplace {\n     stopInEmergency\n     verifyAdminOrStoreowner\n   {\n+    storeId += 1;\n \n     Warehouse.Store memory newStore;\n     newStore.storeowner = msg.sender;\n@@ -110,8 +111,6 @@ contract Marketplace {\n \n     emit StoreOpened(msg.sender, storeId);\n \n-    storeId += 1;\n-\n   }\n \n   /** @dev Lists an item for sale\n@@ -134,10 +133,12 @@ contract Marketplace {\n     // ensure price is positive\n     require(_price > 0);\n \n+    itemId += 1;\n+\n     itemList[itemId] = Warehouse.Item({place: _storeId, sku: itemId, name: _name,  price: _price, state: Warehouse.State.ForSale,\n       seller: msg.sender, buyer: 0});\n     emit ItemListed(_storeId, itemId);\n-    itemId += 1;\n+\n   }\n \n   /** @dev Buys an item listed for sale\n@@ -152,9 +153,9 @@ contract Marketplace {\n     paidEnough(itemList[sku].price)\n     checkValue(sku)\n   {\n-    itemList[sku].seller.transfer(itemList[sku].price);\n-    itemList[sku].buyer = msg.sender;\n     Warehouse.updateItemSold(itemList[sku]);\n+    itemList[sku].buyer = msg.sender;\n+    itemList[sku].seller.transfer(itemList[sku].price);\n     emit ItemSold(itemList[sku].place, sku);\n   }\n ", "project_link": "https://github.com/tserg/marketplace/commit/31b5814b7d8579d6f690adffd8dbcf07ebffd795", "bug_version": {"raw_code": "pragma solidity ^0.4.23;\n\nimport \"./Warehouse.sol\";\n\ncontract Marketplace {\n\n  // set owner\n  address public owner;\n\n  // circuit breaker\n\n  bool public stopped = false;\n\n  /*\n    storeId: total number of stores opened\n    itemId: total number of items listed\n  */\n  uint public storeId;\n  uint public itemId;\n\n  /*\n    userStatus: privileges granted to addresses\n    storeOwnerList: stores owned by each address\n    storeList: storeId mapped to Store\n    itemList: itemId mapped to Item\n  */\n  mapping (address => Warehouse.Status) public userStatus;\n  mapping (address => uint[]) public storeownerList;\n  mapping (uint => Warehouse.Store) public storeList;\n  mapping (uint => Warehouse.Item) public itemList;\n\n  event AdminAdded(address newAdmin);\n  event StoreownerAdded(address storeOwner);\n\n  event StoreOpened(address storeowner, uint storeId);\n  event StoreClosed(address storeowner, uint storeId);\n\n  event ItemListed(uint storeId, uint itemId);\n  event ItemSold(uint storeId, uint itemId);\n  event ItemUnlisted(uint storeId, uint itemId);\n\n  modifier verifyOwner { require(msg.sender == owner); _;}\n  modifier verifyAdmin { require(userStatus[msg.sender] == Warehouse.Status.Admin); _;}\n  modifier verifyAdminOrStoreowner { require(userStatus[msg.sender] == Warehouse.Status.Admin || userStatus[msg.sender] == Warehouse.Status.Storeowner); _;}\n  modifier verifyBuyerIsNotSeller (uint _sku) { require(itemList[_sku].seller != msg.sender); _;}\n\n  modifier forSale (uint _sku) {require(itemList[_sku].state == Warehouse.State.ForSale); _;}\n\n  modifier paidEnough(uint _price) {require(msg.value >= _price); _;}\n  modifier checkValue(uint _sku) {\n    _;\n    uint _price = itemList[_sku].price;\n    uint amountToRefund = msg.value - _price;\n    itemList[_sku].buyer.transfer(amountToRefund);\n  }\n\n  modifier stopInEmergency { require(!stopped); _;}\n\n  constructor() public {\n    owner = msg.sender;\n    storeId = 0;\n    itemId = 0;\n\n    // initialise contract creator as admin\n    userStatus[msg.sender] = Warehouse.Status.Admin;\n  }\n\n  /** @dev Sets an address as Admin\n    * @param _address Address to be set as Admin\n    */\n  function addAdmin(address _address) public verifyOwner {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    userStatus[_address] = Warehouse.Status.Admin;\n    emit AdminAdded(_address);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param _address Address to be set as Storeowner\n    */\n  function addStoreowner(address _address)\n    public\n    stopInEmergency\n    verifyAdmin\n  {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    // ensure address to be added is not already a storeowner\n    require(userStatus[_address] != Warehouse.Status.Storeowner);\n\n    userStatus[_address] = Warehouse.Status.Storeowner;\n    emit StoreownerAdded(_address);\n  }\n\n  /** @dev Opens a store for the current address\n    */\n\n  function openStore()\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n\n    Warehouse.Store memory newStore;\n    newStore.storeowner = msg.sender;\n    storeList[storeId] = newStore;\n    storeownerList[msg.sender].push(storeId);\n\n    emit StoreOpened(msg.sender, storeId);\n\n    storeId += 1;\n\n  }\n\n  /** @dev Lists an item for sale\n    * @param _storeId The store to list the item\n    * @param _name The name of the item\n    * @param _price The price of the item\n    */\n  function listItem(uint _storeId, string _name, uint _price)\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n    // ensure address is storeowner of the store where item is to be listed\n    require(storeList[_storeId].storeowner == msg.sender);\n\n    // ensure name is not empty\n    bytes memory tempName = bytes(_name);\n    require(tempName.length > 0);\n\n    // ensure price is positive\n    require(_price > 0);\n\n    itemList[itemId] = Warehouse.Item({place: _storeId, sku: itemId, name: _name,  price: _price, state: Warehouse.State.ForSale,\n      seller: msg.sender, buyer: 0});\n    emit ItemListed(_storeId, itemId);\n    itemId += 1;\n  }\n\n  /** @dev Buys an item listed for sale\n    * @param sku The id of the item to be bought\n    */\n  function buyItem(uint sku)\n    public\n    payable\n    stopInEmergency\n    forSale(sku)\n    verifyBuyerIsNotSeller(sku)\n    paidEnough(itemList[sku].price)\n    checkValue(sku)\n  {\n    itemList[sku].seller.transfer(itemList[sku].price);\n    itemList[sku].buyer = msg.sender;\n    Warehouse.updateItemSold(itemList[sku]);\n    emit ItemSold(itemList[sku].place, sku);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param sku The id of the item which details are sought\n    * @return place The store where the item is Listed\n    * @return sku The item ID\n    * @return name The name of the item\n    * @return state Whether the item has been sold\n    * @return seller The address of the Seller\n    * @return buyer The address of the Buyer (if any)\n    */\n  function fetchItem(uint _sku)\n    public\n    view\n    returns (uint place, uint sku, string name, uint price, uint state, address seller, address buyer)\n  {\n    place = itemList[_sku].place;\n    sku = itemList[_sku].sku;\n    name = itemList[_sku].name;\n    price = itemList[_sku].price;\n    state = uint(itemList[_sku].state);\n    seller = itemList[_sku].seller;\n    buyer = itemList[_sku].buyer;\n    return (place, sku, name, price, state, seller, buyer);\n  }\n\n  /** @dev Return the stores opened by an address\n    * @param _address Storeowner address to look up\n    * @return stores A list of stores opened by the address given\n    */\n  function fetchStoresByAddress(address _address)\n    public\n    view\n    returns (uint[] stores)\n  {\n    stores = storeownerList[_address];\n  }\n\n  /** @dev Return the storeowner of a stored\n    * @param _storeId The Store to look up\n    * @return _storeowner The address of the storeowner\n    */\n  function fetchStoreowner(uint _storeId)\n    public\n    view\n    returns (address _storeowner)\n  {\n    _storeowner = storeList[_storeId].storeowner;\n  }\n\n  /** @dev Destroy the contract\n    */\n  function kill()\n    public\n    verifyOwner\n  {\n    selfdestruct(owner);\n  }\n\n  /** @dev Stop the contract\n    */\n  function toggleContractActive()\n    public\n    verifyOwner\n  {\n    stopped = !stopped;\n  }\n\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\npragma solidity ^0.4.23;\n\nlibrary Warehouse {\n\n  /*\n    State: status of item listed for ForSale\n    Status: privileges granted to a user\n  */\n\n  enum State {ForSale, Sold}\n  enum Status {Shopper, Admin, Storeowner}\n\n  struct Store {\n    address storeowner;\n    uint[] items;\n  }\n\n  struct Item {\n    uint place;\n    uint sku;\n    string name;\n    uint price;\n    State state;\n    address seller;\n    address buyer;\n  }\n\n  /** @dev Update item status to Sold\n    * @param self The item that was sold\n    */\n  function updateItemSold(Item storage self)\n    public\n  {\n    self.state = State.Sold;\n  }\n\n}\n\ncontract Marketplace {\n\n  // set owner\n  address public owner;\n\n  // circuit breaker\n\n  bool public stopped = false;\n\n  /*\n    storeId: total number of stores opened\n    itemId: total number of items listed\n  */\n  uint public storeId;\n  uint public itemId;\n\n  /*\n    userStatus: privileges granted to addresses\n    storeOwnerList: stores owned by each address\n    storeList: storeId mapped to Store\n    itemList: itemId mapped to Item\n  */\n  mapping (address => Warehouse.Status) public userStatus;\n  mapping (address => uint[]) public storeownerList;\n  mapping (uint => Warehouse.Store) public storeList;\n  mapping (uint => Warehouse.Item) public itemList;\n\n  event AdminAdded(address newAdmin);\n  event StoreownerAdded(address storeOwner);\n\n  event StoreOpened(address storeowner, uint storeId);\n  event StoreClosed(address storeowner, uint storeId);\n\n  event ItemListed(uint storeId, uint itemId);\n  event ItemSold(uint storeId, uint itemId);\n  event ItemUnlisted(uint storeId, uint itemId);\n\n  modifier verifyOwner { require(msg.sender == owner); _;}\n  modifier verifyAdmin { require(userStatus[msg.sender] == Warehouse.Status.Admin); _;}\n  modifier verifyAdminOrStoreowner { require(userStatus[msg.sender] == Warehouse.Status.Admin || userStatus[msg.sender] == Warehouse.Status.Storeowner); _;}\n  modifier verifyBuyerIsNotSeller (uint _sku) { require(itemList[_sku].seller != msg.sender); _;}\n\n  modifier forSale (uint _sku) {require(itemList[_sku].state == Warehouse.State.ForSale); _;}\n\n  modifier paidEnough(uint _price) {require(msg.value >= _price); _;}\n  modifier checkValue(uint _sku) {\n    _;\n    uint _price = itemList[_sku].price;\n    uint amountToRefund = msg.value - _price;\n    itemList[_sku].buyer.transfer(amountToRefund);\n  }\n\n  modifier stopInEmergency { require(!stopped); _;}\n\n  constructor() public {\n    owner = msg.sender;\n    storeId = 0;\n    itemId = 0;\n\n    // initialise contract creator as admin\n    userStatus[msg.sender] = Warehouse.Status.Admin;\n  }\n\n  /** @dev Sets an address as Admin\n    * @param _address Address to be set as Admin\n    */\n  function addAdmin(address _address) public verifyOwner {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    userStatus[_address] = Warehouse.Status.Admin;\n    emit AdminAdded(_address);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param _address Address to be set as Storeowner\n    */\n  function addStoreowner(address _address)\n    public\n    stopInEmergency\n    verifyAdmin\n  {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    // ensure address to be added is not already a storeowner\n    require(userStatus[_address] != Warehouse.Status.Storeowner);\n\n    userStatus[_address] = Warehouse.Status.Storeowner;\n    emit StoreownerAdded(_address);\n  }\n\n  /** @dev Opens a store for the current address\n    */\n\n  function openStore()\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n\n    Warehouse.Store memory newStore;\n    newStore.storeowner = msg.sender;\n    storeList[storeId] = newStore;\n    storeownerList[msg.sender].push(storeId);\n\n    emit StoreOpened(msg.sender, storeId);\n\n    storeId += 1;\n\n  }\n\n  /** @dev Lists an item for sale\n    * @param _storeId The store to list the item\n    * @param _name The name of the item\n    * @param _price The price of the item\n    */\n  function listItem(uint _storeId, string _name, uint _price)\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n    // ensure address is storeowner of the store where item is to be listed\n    require(storeList[_storeId].storeowner == msg.sender);\n\n    // ensure name is not empty\n    bytes memory tempName = bytes(_name);\n    require(tempName.length > 0);\n\n    // ensure price is positive\n    require(_price > 0);\n\n    itemList[itemId] = Warehouse.Item({place: _storeId, sku: itemId, name: _name,  price: _price, state: Warehouse.State.ForSale,\n      seller: msg.sender, buyer: 0});\n    emit ItemListed(_storeId, itemId);\n    itemId += 1;\n  }\n\n  /** @dev Buys an item listed for sale\n    * @param sku The id of the item to be bought\n    */\n  function buyItem(uint sku)\n    public\n    payable\n    stopInEmergency\n    forSale(sku)\n    verifyBuyerIsNotSeller(sku)\n    paidEnough(itemList[sku].price)\n    checkValue(sku)\n  {\n    itemList[sku].seller.transfer(itemList[sku].price);\n    itemList[sku].buyer = msg.sender;\n    Warehouse.updateItemSold(itemList[sku]);\n    emit ItemSold(itemList[sku].place, sku);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param sku The id of the item which details are sought\n    * @return place The store where the item is Listed\n    * @return sku The item ID\n    * @return name The name of the item\n    * @return state Whether the item has been sold\n    * @return seller The address of the Seller\n    * @return buyer The address of the Buyer (if any)\n    */\n  function fetchItem(uint _sku)\n    public\n    view\n    returns (uint place, uint sku, string name, uint price, uint state, address seller, address buyer)\n  {\n    place = itemList[_sku].place;\n    sku = itemList[_sku].sku;\n    name = itemList[_sku].name;\n    price = itemList[_sku].price;\n    state = uint(itemList[_sku].state);\n    seller = itemList[_sku].seller;\n    buyer = itemList[_sku].buyer;\n    return (place, sku, name, price, state, seller, buyer);\n  }\n\n  /** @dev Return the stores opened by an address\n    * @param _address Storeowner address to look up\n    * @return stores A list of stores opened by the address given\n    */\n  function fetchStoresByAddress(address _address)\n    public\n    view\n    returns (uint[] stores)\n  {\n    stores = storeownerList[_address];\n  }\n\n  /** @dev Return the storeowner of a stored\n    * @param _storeId The Store to look up\n    * @return _storeowner The address of the storeowner\n    */\n  function fetchStoreowner(uint _storeId)\n    public\n    view\n    returns (address _storeowner)\n  {\n    _storeowner = storeList[_storeId].storeowner;\n  }\n\n  /** @dev Destroy the contract\n    */\n  function kill()\n    public\n    verifyOwner\n  {\n    selfdestruct(owner);\n  }\n\n  /** @dev Stop the contract\n    */\n  function toggleContractActive()\n    public\n    verifyOwner\n  {\n    stopped = !stopped;\n  }\n\n}\n", "commit_id": "7da92bd71a7a8dcbb36fcb72272a5bd229a3f624"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.23;\n\nimport \"./Warehouse.sol\";\n\ncontract Marketplace {\n\n  // set owner\n  address public owner;\n\n  // circuit breaker\n\n  bool public stopped = false;\n\n  /*\n    storeId: total number of stores opened\n    itemId: total number of items listed\n  */\n  uint public storeId;\n  uint public itemId;\n\n  /*\n    userStatus: privileges granted to addresses\n    storeOwnerList: stores owned by each address\n    storeList: storeId mapped to Store\n    itemList: itemId mapped to Item\n  */\n  mapping (address => Warehouse.Status) public userStatus;\n  mapping (address => uint[]) public storeownerList;\n  mapping (uint => Warehouse.Store) public storeList;\n  mapping (uint => Warehouse.Item) public itemList;\n\n  event AdminAdded(address newAdmin);\n  event StoreownerAdded(address storeOwner);\n\n  event StoreOpened(address storeowner, uint storeId);\n  event StoreClosed(address storeowner, uint storeId);\n\n  event ItemListed(uint storeId, uint itemId);\n  event ItemSold(uint storeId, uint itemId);\n  event ItemUnlisted(uint storeId, uint itemId);\n\n  modifier verifyOwner { require(msg.sender == owner); _;}\n  modifier verifyAdmin { require(userStatus[msg.sender] == Warehouse.Status.Admin); _;}\n  modifier verifyAdminOrStoreowner { require(userStatus[msg.sender] == Warehouse.Status.Admin || userStatus[msg.sender] == Warehouse.Status.Storeowner); _;}\n  modifier verifyBuyerIsNotSeller (uint _sku) { require(itemList[_sku].seller != msg.sender); _;}\n\n  modifier forSale (uint _sku) {require(itemList[_sku].state == Warehouse.State.ForSale); _;}\n\n  modifier paidEnough(uint _price) {require(msg.value >= _price); _;}\n  modifier checkValue(uint _sku) {\n    _;\n    uint _price = itemList[_sku].price;\n    uint amountToRefund = msg.value - _price;\n    itemList[_sku].buyer.transfer(amountToRefund);\n  }\n\n  modifier stopInEmergency { require(!stopped); _;}\n\n  constructor() public {\n    owner = msg.sender;\n    storeId = 0;\n    itemId = 0;\n\n    // initialise contract creator as admin\n    userStatus[msg.sender] = Warehouse.Status.Admin;\n  }\n\n  /** @dev Sets an address as Admin\n    * @param _address Address to be set as Admin\n    */\n  function addAdmin(address _address) public verifyOwner {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    userStatus[_address] = Warehouse.Status.Admin;\n    emit AdminAdded(_address);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param _address Address to be set as Storeowner\n    */\n  function addStoreowner(address _address)\n    public\n    stopInEmergency\n    verifyAdmin\n  {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    // ensure address to be added is not already a storeowner\n    require(userStatus[_address] != Warehouse.Status.Storeowner);\n\n    userStatus[_address] = Warehouse.Status.Storeowner;\n    emit StoreownerAdded(_address);\n  }\n\n  /** @dev Opens a store for the current address\n    */\n\n  function openStore()\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n    storeId += 1;\n\n    Warehouse.Store memory newStore;\n    newStore.storeowner = msg.sender;\n    storeList[storeId] = newStore;\n    storeownerList[msg.sender].push(storeId);\n\n    emit StoreOpened(msg.sender, storeId);\n\n  }\n\n  /** @dev Lists an item for sale\n    * @param _storeId The store to list the item\n    * @param _name The name of the item\n    * @param _price The price of the item\n    */\n  function listItem(uint _storeId, string _name, uint _price)\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n    // ensure address is storeowner of the store where item is to be listed\n    require(storeList[_storeId].storeowner == msg.sender);\n\n    // ensure name is not empty\n    bytes memory tempName = bytes(_name);\n    require(tempName.length > 0);\n\n    // ensure price is positive\n    require(_price > 0);\n\n    itemId += 1;\n\n    itemList[itemId] = Warehouse.Item({place: _storeId, sku: itemId, name: _name,  price: _price, state: Warehouse.State.ForSale,\n      seller: msg.sender, buyer: 0});\n    emit ItemListed(_storeId, itemId);\n\n  }\n\n  /** @dev Buys an item listed for sale\n    * @param sku The id of the item to be bought\n    */\n  function buyItem(uint sku)\n    public\n    payable\n    stopInEmergency\n    forSale(sku)\n    verifyBuyerIsNotSeller(sku)\n    paidEnough(itemList[sku].price)\n    checkValue(sku)\n  {\n    Warehouse.updateItemSold(itemList[sku]);\n    itemList[sku].buyer = msg.sender;\n    itemList[sku].seller.transfer(itemList[sku].price);\n    emit ItemSold(itemList[sku].place, sku);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param sku The id of the item which details are sought\n    * @return place The store where the item is Listed\n    * @return sku The item ID\n    * @return name The name of the item\n    * @return state Whether the item has been sold\n    * @return seller The address of the Seller\n    * @return buyer The address of the Buyer (if any)\n    */\n  function fetchItem(uint _sku)\n    public\n    view\n    returns (uint place, uint sku, string name, uint price, uint state, address seller, address buyer)\n  {\n    place = itemList[_sku].place;\n    sku = itemList[_sku].sku;\n    name = itemList[_sku].name;\n    price = itemList[_sku].price;\n    state = uint(itemList[_sku].state);\n    seller = itemList[_sku].seller;\n    buyer = itemList[_sku].buyer;\n    return (place, sku, name, price, state, seller, buyer);\n  }\n\n  /** @dev Return the stores opened by an address\n    * @param _address Storeowner address to look up\n    * @return stores A list of stores opened by the address given\n    */\n  function fetchStoresByAddress(address _address)\n    public\n    view\n    returns (uint[] stores)\n  {\n    stores = storeownerList[_address];\n  }\n\n  /** @dev Return the storeowner of a stored\n    * @param _storeId The Store to look up\n    * @return _storeowner The address of the storeowner\n    */\n  function fetchStoreowner(uint _storeId)\n    public\n    view\n    returns (address _storeowner)\n  {\n    _storeowner = storeList[_storeId].storeowner;\n  }\n\n  /** @dev Destroy the contract\n    */\n  function kill()\n    public\n    verifyOwner\n  {\n    selfdestruct(owner);\n  }\n\n  /** @dev Stop the contract\n    */\n  function toggleContractActive()\n    public\n    verifyOwner\n  {\n    stopped = !stopped;\n  }\n\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\npragma solidity ^0.4.23;\n\nlibrary Warehouse {\n\n  /*\n    State: status of item listed for ForSale\n    Status: privileges granted to a user\n  */\n\n  enum State {ForSale, Sold}\n  enum Status {Shopper, Admin, Storeowner}\n\n  struct Store {\n    address storeowner;\n    uint[] items;\n  }\n\n  struct Item {\n    uint place;\n    uint sku;\n    string name;\n    uint price;\n    State state;\n    address seller;\n    address buyer;\n  }\n\n  /** @dev Update item status to Sold\n    * @param self The item that was sold\n    */\n  function updateItemSold(Item storage self)\n    public\n  {\n    self.state = State.Sold;\n  }\n\n}\n\ncontract Marketplace {\n\n  // set owner\n  address public owner;\n\n  // circuit breaker\n\n  bool public stopped = false;\n\n  /*\n    storeId: total number of stores opened\n    itemId: total number of items listed\n  */\n  uint public storeId;\n  uint public itemId;\n\n  /*\n    userStatus: privileges granted to addresses\n    storeOwnerList: stores owned by each address\n    storeList: storeId mapped to Store\n    itemList: itemId mapped to Item\n  */\n  mapping (address => Warehouse.Status) public userStatus;\n  mapping (address => uint[]) public storeownerList;\n  mapping (uint => Warehouse.Store) public storeList;\n  mapping (uint => Warehouse.Item) public itemList;\n\n  event AdminAdded(address newAdmin);\n  event StoreownerAdded(address storeOwner);\n\n  event StoreOpened(address storeowner, uint storeId);\n  event StoreClosed(address storeowner, uint storeId);\n\n  event ItemListed(uint storeId, uint itemId);\n  event ItemSold(uint storeId, uint itemId);\n  event ItemUnlisted(uint storeId, uint itemId);\n\n  modifier verifyOwner { require(msg.sender == owner); _;}\n  modifier verifyAdmin { require(userStatus[msg.sender] == Warehouse.Status.Admin); _;}\n  modifier verifyAdminOrStoreowner { require(userStatus[msg.sender] == Warehouse.Status.Admin || userStatus[msg.sender] == Warehouse.Status.Storeowner); _;}\n  modifier verifyBuyerIsNotSeller (uint _sku) { require(itemList[_sku].seller != msg.sender); _;}\n\n  modifier forSale (uint _sku) {require(itemList[_sku].state == Warehouse.State.ForSale); _;}\n\n  modifier paidEnough(uint _price) {require(msg.value >= _price); _;}\n  modifier checkValue(uint _sku) {\n    _;\n    uint _price = itemList[_sku].price;\n    uint amountToRefund = msg.value - _price;\n    itemList[_sku].buyer.transfer(amountToRefund);\n  }\n\n  modifier stopInEmergency { require(!stopped); _;}\n\n  constructor() public {\n    owner = msg.sender;\n    storeId = 0;\n    itemId = 0;\n\n    // initialise contract creator as admin\n    userStatus[msg.sender] = Warehouse.Status.Admin;\n  }\n\n  /** @dev Sets an address as Admin\n    * @param _address Address to be set as Admin\n    */\n  function addAdmin(address _address) public verifyOwner {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    userStatus[_address] = Warehouse.Status.Admin;\n    emit AdminAdded(_address);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param _address Address to be set as Storeowner\n    */\n  function addStoreowner(address _address)\n    public\n    stopInEmergency\n    verifyAdmin\n  {\n    // ensure address to be added is not already an admin\n    require(userStatus[_address] != Warehouse.Status.Admin);\n\n    // ensure address to be added is not already a storeowner\n    require(userStatus[_address] != Warehouse.Status.Storeowner);\n\n    userStatus[_address] = Warehouse.Status.Storeowner;\n    emit StoreownerAdded(_address);\n  }\n\n  /** @dev Opens a store for the current address\n    */\n\n  function openStore()\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n    storeId += 1;\n\n    Warehouse.Store memory newStore;\n    newStore.storeowner = msg.sender;\n    storeList[storeId] = newStore;\n    storeownerList[msg.sender].push(storeId);\n\n    emit StoreOpened(msg.sender, storeId);\n\n  }\n\n  /** @dev Lists an item for sale\n    * @param _storeId The store to list the item\n    * @param _name The name of the item\n    * @param _price The price of the item\n    */\n  function listItem(uint _storeId, string _name, uint _price)\n    public\n    stopInEmergency\n    verifyAdminOrStoreowner\n  {\n    // ensure address is storeowner of the store where item is to be listed\n    require(storeList[_storeId].storeowner == msg.sender);\n\n    // ensure name is not empty\n    bytes memory tempName = bytes(_name);\n    require(tempName.length > 0);\n\n    // ensure price is positive\n    require(_price > 0);\n\n    itemId += 1;\n\n    itemList[itemId] = Warehouse.Item({place: _storeId, sku: itemId, name: _name,  price: _price, state: Warehouse.State.ForSale,\n      seller: msg.sender, buyer: 0});\n    emit ItemListed(_storeId, itemId);\n\n  }\n\n  /** @dev Buys an item listed for sale\n    * @param sku The id of the item to be bought\n    */\n  function buyItem(uint sku)\n    public\n    payable\n    stopInEmergency\n    forSale(sku)\n    verifyBuyerIsNotSeller(sku)\n    paidEnough(itemList[sku].price)\n    checkValue(sku)\n  {\n    Warehouse.updateItemSold(itemList[sku]);\n    itemList[sku].buyer = msg.sender;\n    itemList[sku].seller.transfer(itemList[sku].price);\n    emit ItemSold(itemList[sku].place, sku);\n  }\n\n  /** @dev Sets an address as storeOwner\n    * @param sku The id of the item which details are sought\n    * @return place The store where the item is Listed\n    * @return sku The item ID\n    * @return name The name of the item\n    * @return state Whether the item has been sold\n    * @return seller The address of the Seller\n    * @return buyer The address of the Buyer (if any)\n    */\n  function fetchItem(uint _sku)\n    public\n    view\n    returns (uint place, uint sku, string name, uint price, uint state, address seller, address buyer)\n  {\n    place = itemList[_sku].place;\n    sku = itemList[_sku].sku;\n    name = itemList[_sku].name;\n    price = itemList[_sku].price;\n    state = uint(itemList[_sku].state);\n    seller = itemList[_sku].seller;\n    buyer = itemList[_sku].buyer;\n    return (place, sku, name, price, state, seller, buyer);\n  }\n\n  /** @dev Return the stores opened by an address\n    * @param _address Storeowner address to look up\n    * @return stores A list of stores opened by the address given\n    */\n  function fetchStoresByAddress(address _address)\n    public\n    view\n    returns (uint[] stores)\n  {\n    stores = storeownerList[_address];\n  }\n\n  /** @dev Return the storeowner of a stored\n    * @param _storeId The Store to look up\n    * @return _storeowner The address of the storeowner\n    */\n  function fetchStoreowner(uint _storeId)\n    public\n    view\n    returns (address _storeowner)\n  {\n    _storeowner = storeList[_storeId].storeowner;\n  }\n\n  /** @dev Destroy the contract\n    */\n  function kill()\n    public\n    verifyOwner\n  {\n    selfdestruct(owner);\n  }\n\n  /** @dev Stop the contract\n    */\n  function toggleContractActive()\n    public\n    verifyOwner\n  {\n    stopped = !stopped;\n  }\n\n}\n", "commit_id": "31b5814b7d8579d6f690adffd8dbcf07ebffd795"}}