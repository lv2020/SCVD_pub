{"filename": "packages/contracts/contracts/zkopru/controllers/Coordinatable.sol", "patch": "@@ -180,8 +180,8 @@ contract Coordinatable is Storage {\n         address payable proposerAddr = msg.sender;\n         Proposer storage proposer = Storage.chain.proposers[proposerAddr];\n         require(proposer.reward >= amount, \"You can't withdraw more than you have\");\n-        payable(proposerAddr).transfer(amount);\n         proposer.reward -= amount;\n+        payable(proposerAddr).transfer(amount);\n     }\n \n ", "project_link": "https://github.com/wanseob/zkopru/commit/fa7b6a57ad31b73ee87b1479679d72b082037dc0", "bug_version": {"raw_code": " // SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\nimport { Storage } from \"../storage/Storage.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/introspection/IERC165.sol\";\nimport { Hash } from \"../libraries/Hash.sol\";\nimport { IConsensusProvider } from \"../../consensus/interfaces/IConsensusProvider.sol\";\nimport {\n    Header,\n    Proposer,\n    Blockchain,\n    Block,\n    Proposal,\n    Finalization,\n    MassDeposit,\n    WithdrawalTree,\n    Types\n} from \"../libraries/Types.sol\";\nimport { Deserializer } from \"../libraries/Deserializer.sol\";\n\n\ncontract Coordinatable is Storage {\n    using Types for *;\n\n    event NewProposal(uint256 proposalNum, bytes32 blockHash);\n    event Finalized(bytes32 blockHash);\n    event MassDepositCommit(uint256 index, bytes32 merged, uint256 fee);\n    event NewErc20(address tokenAddr);\n    event NewErc721(address tokenAddr);\n\n    /**\n     * @notice This function will be updated as the governance of Zkopru's been updated.\n     *         Currently Coordinator calls this function for the proof of stake.\n     *         Coordinator should pay more than MINIMUM_STAKE. See 'Configurated.sol'\n     */\n    function register() public payable {\n        stake(msg.sender);\n    }\n\n    function stake(address coordinator) public payable {\n        require(msg.value >= MINIMUM_STAKE, \"Should stake more than minimum amount of ETH\");\n        Proposer storage proposer = Storage.chain.proposers[coordinator];\n        proposer.stake += msg.value;\n    }\n\n    /**\n     * @notice This function will be updated as the governance of Zkopru's been updated.\n     */\n    function deregister() public {\n        address payable proposerAddr = msg.sender;\n        Proposer storage proposer = Storage.chain.proposers[proposerAddr];\n        require(proposer.exitAllowance <= block.number, \"Still in the challenge period\");\n        // Withdraw stake\n        proposerAddr.transfer(proposer.stake);\n        // Withdraw reward\n        payable(proposerAddr).transfer(proposer.reward);\n        // Delete proposer\n        delete Storage.chain.proposers[proposerAddr];\n    }\n\n    /**\n     * @dev Coordinator proposes a new block using this function. propose() will freeze\n     *      the current mass deposit for the next block proposer, and will go through\n     *      CHALLENGE_PERIOD.\n     * @param data Serialized newly minted block data\n     */\n    function propose(bytes memory data) public {\n        // Limit the maximum length\n        require(data.length <= MAX_BLOCK_SIZE);\n        Block memory _block = Deserializer.blockFromCalldataAt(0);\n        // The message sender address should be same with the proposer address\n        require(_block.header.proposer == msg.sender, \"Coordinator account is different with the message sender\");\n        Proposer storage proposer = Storage.chain.proposers[msg.sender];\n        // Check permission\n        IConsensusProvider(consensusProvider).openRoundIfNeeded();\n        require(isProposable(msg.sender), \"Not allowed to propose\");\n        // Duplicated proposal is not allowed\n        bytes32 checksum = keccak256(data);\n        require(Storage.chain.proposals[checksum].headerHash == bytes32(0), \"Already submitted\");\n        // Save opru proposal\n        bytes32 currentBlockHash = _block.header.hash();\n        Storage.chain.proposals[checksum] = Proposal(\n            currentBlockHash,\n            block.number + CHALLENGE_PERIOD\n        );\n        // Record l2 chain\n        Storage.chain.parentOf[currentBlockHash] = _block.header.parentBlock;\n        // Record reference for the inclusion proofs\n        Storage.chain.utxoRootOf[currentBlockHash] = _block.header.utxoRoot;\n        // Record reference for the withdrawal proofs when only if there exists update\n        if (Storage.chain.withdrawalRootOf[_block.header.parentBlock] != _block.header.withdrawalRoot) {\n            Storage.chain.withdrawalRootOf[currentBlockHash] = _block.header.withdrawalRoot;\n        }\n        // Update exit allowance period\n        proposer.exitAllowance = block.number + CHALLENGE_PERIOD;\n        // Freeze the latest mass deposit for the next block proposer\n        commitMassDeposit();\n        emit NewProposal(Storage.chain.proposedBlocks, currentBlockHash);\n        Storage.chain.proposedBlocks++;\n    }\n\n    /**\n     * @dev Coordinator can commit mass deposits. The pending deposits will be automatically\n     *      committed by propose() block. But to start the first propose() block, there\n     *      should be enough pending deposits, and the coordinator will commit them using\n     *      this standalone function.\n     */\n    function commitMassDeposit() public {\n        if(Storage.chain.stagedDeposits.merged != bytes32(0)) {\n            bytes32 depositHash = Storage.chain.stagedDeposits.hash();\n            Storage.chain.committedDeposits[depositHash] += 1;\n            emit MassDepositCommit(\n                Storage.chain.massDepositId,\n                Storage.chain.stagedDeposits.merged,\n                Storage.chain.stagedDeposits.fee\n            );\n            delete Storage.chain.stagedDeposits;\n            delete Storage.chain.stagedSize;\n            Storage.chain.massDepositId++;\n        }\n    }\n\n    /**\n     * @dev Coordinator can finalize a submitted block if it isn't slashed during the\n     *      challenge period. It updates the aggregated fee and withdrawal root.\n     * @param // Block data without tx details\n     */\n    function finalize(bytes memory) public {\n        Finalization memory finalization = Deserializer.finalizationFromCalldataAt(0);\n        Proposal storage proposal = Storage.chain.proposals[finalization.proposalChecksum];\n        // Check requirements\n        require(finalization.massDeposits.root() == finalization.header.depositRoot, \"Submitted different deposit root\");\n        require(finalization.massMigrations.root() == finalization.header.migrationRoot, \"Submitted different deposit root\");\n        require(finalization.header.hash() == proposal.headerHash, \"Invalid header data\");\n        require(!Storage.chain.slashed[proposal.headerHash], \"Slashed roll up can't be finalized\");\n        require(!Storage.chain.finalized[proposal.headerHash], \"Already finalized\");\n        require(finalization.header.parentBlock == Storage.chain.latest, \"The latest block should be its parent\");\n        require(finalization.header.parentBlock != proposal.headerHash, \"Reentrancy case\");\n        require(block.number > proposal.challengeDue, \"Still in challenge period\");\n\n        // Execute deposits and collect fees\n        for (uint256 i = 0; i < finalization.massDeposits.length; i++) {\n            MassDeposit memory deposit = finalization.massDeposits[i];\n            bytes32 massDepositHash = deposit.hash();\n            require(Storage.chain.committedDeposits[massDepositHash] > 0, \"MassDeposit does not exist.\");\n            Storage.chain.committedDeposits[massDepositHash] -= 1;\n        }\n\n        // Record mass migrations and collect fees.\n        // A MassMigration becomes a MassDeposit for the migration destination.\n        for (uint256 i = 0; i < finalization.massMigrations.length; i++) {\n            bytes32 migrationId = keccak256(\n                abi.encodePacked(\n                    finalization.proposalChecksum,\n                    finalization.massMigrations[i].hash()\n                )\n            );\n            require(!Storage.chain.migrations[migrationId], \"Same id exists. Migrate it first\");\n            Storage.chain.migrations[migrationId] = true;\n        }\n\n        // Give fee to the proposer\n        Proposer storage proposer = Storage.chain.proposers[finalization.header.proposer];\n        proposer.reward += finalization.header.fee;\n\n        // Update the chain\n        Storage.chain.finalized[proposal.headerHash] = true;\n        Storage.chain.finalizedUTXORoots[finalization.header.utxoRoot] = true;\n        Storage.chain.latest = proposal.headerHash;\n        emit Finalized(proposal.headerHash);\n        delete Storage.chain.proposals[finalization.proposalChecksum];\n    }\n\n    /**\n     * @dev Coordinators can withdraw aggregated transaction fees.\n     * @param amount Amount to withdraw.\n     */\n    function withdrawReward(uint256 amount) public {\n        address payable proposerAddr = msg.sender;\n        Proposer storage proposer = Storage.chain.proposers[proposerAddr];\n        require(proposer.reward >= amount, \"You can't withdraw more than you have\");\n        payable(proposerAddr).transfer(amount);\n        proposer.reward -= amount;\n    }\n\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /**\n     * @dev Provide registered erc20 token information for decryption\n     * TODO\n     * 1. verify erc20 token\n     * 2. governance to register the token address\n     */\n    function registerERC20(address tokenAddr) public {\n        require(!Storage.chain.registeredERC20s[tokenAddr], \"Already registered\");\n        // Make sure that this token is ERC20\n        try IERC20(tokenAddr).transfer(address(this), 0) returns (bool result) {\n            require(result, \"Failed to send dummy tx\");\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*reason*/) {\n            // pass: it means that this address is not ERC721\n            revert(\"does not support transfer()\");\n        }\n        try IERC20(tokenAddr).transferFrom(address(this), address(this), 0) returns (bool result) {\n            require(result, \"Failed to send dummy tx\");\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*reason*/) {\n            // pass: it means that this address is not ERC721\n            revert(\"does not support transfer()\");\n        }\n        try IERC20(tokenAddr).balanceOf(address(this)) returns (uint256) {\n            // success\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*reason*/) {\n            // pass: it means that this address is not ERC721\n            revert(\"does not support transfer()\");\n        }\n        // Make sure that this token is not an ERC721\n        try IERC165(tokenAddr).supportsInterface(_INTERFACE_ID_ERC721) returns (bool erc721) {\n            require(!erc721, \"This address seems an ERC721 contract\");\n        } catch Error(string memory /*reason*/) {\n            // success\n        } catch (bytes memory /*reason*/) {\n            // success\n        }\n        Storage.chain.registeredERC20s[tokenAddr] = true;\n        emit NewErc20(tokenAddr);\n    }\n\n    /**\n     * @dev Provide registered erc20 token information for decryption\n     * 1. verify erc721 token\n     * 2. governance to register the token address\n     */\n    function registerERC721(address tokenAddr) public {\n        require(!Storage.chain.registeredERC721s[tokenAddr], \"Already registered\");\n        // Make sure that this token is an ERC721\n        try IERC165(tokenAddr).supportsInterface(_INTERFACE_ID_ERC721) returns (bool erc721) {\n            require(erc721, \"This address is not an ERC721 contract\");\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory reason) {\n            revert(string(reason));\n        }\n        Storage.chain.registeredERC721s[tokenAddr] = true;\n        emit NewErc721(tokenAddr);\n    }\n\n    /**\n     * @dev You can override this function to implement your own consensus logic.\n     * @param proposerAddr Coordinator address to check the allowance of block proposing.\n     */\n    function isProposable(address proposerAddr) public view returns (bool) {\n        Proposer memory  proposer = Storage.chain.proposers[proposerAddr];\n        // You can add more consensus logic here\n        if (proposer.stake >= MINIMUM_STAKE) {\n            return IConsensusProvider(consensusProvider).isProposable(proposerAddr);\n        } else {\n            return false;\n        }\n    }\n}\n\n//  TODO - If the gas usage exceeds the challenge limit, the proposer will get slashed\n//  TODO - instant withdrawal\n//  TODO - guarantee of tx including\n//  Some thoughts - There exists a possibility of racing condition to get the slash reward\n", "flattened_code": "// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n\nstruct Hasher {\n    function (uint256, uint256) internal pure returns (uint256) parentOf;\n    uint256[] preHashedZero;\n}\n\nlibrary MerkleTreeLib {\n    using SafeMath for uint256;\n\n    function append(\n        Hasher memory self,\n        uint256 startingRoot,\n        uint256 index,\n        uint256[] memory leaves,\n        uint256[] memory initialSiblings\n    ) internal pure returns (uint256 newRoot) {\n        newRoot = startingRoot;\n        require(self.preHashedZero.length == initialSiblings.length + 1, \"Submitted invalid length of siblings\");\n        require(_startingLeafProof(self, startingRoot, index, initialSiblings), \"Invalid merkle proof of starting leaf node\");\n        uint256 nextIndex = index;\n        uint256[] memory nextSiblings = initialSiblings;\n        for (uint256 i = 0; i < leaves.length; i++) {\n            (newRoot, nextIndex, nextSiblings) = _append(self, nextIndex, leaves[i], nextSiblings);\n        }\n    }\n\n    function merkleProof(\n        Hasher memory self,\n        uint256 root,\n        uint256 leaf,\n        uint256 index,\n        uint256[] memory siblings\n    ) internal pure returns (bool) {\n        return merkleRoot(self, leaf, index, siblings) == root;\n    }\n\n    function merkleRoot(\n        Hasher memory self,\n        uint256 leaf,\n        uint256 index,\n        uint256[] memory siblings\n    ) internal pure returns (uint256) {\n        uint256 path = index;\n        uint256 node = leaf;\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // right sibling\n                node = self.parentOf(node, siblings[i]);\n            } else {\n                // left sibling\n                node = self.parentOf(siblings[i], node);\n            }\n            path >>= 1;\n        }\n        return node;\n    }\n\n    function _startingLeafProof(\n        Hasher memory self,\n        uint256 root,\n        uint256 index,\n        uint256[] memory siblings\n    ) internal pure returns (bool) {\n        uint256 path = index;\n        uint256 node = self.preHashedZero[0];\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // Right sibling should be a prehashed zero\n                if (siblings[i] != self.preHashedZero[i]) {\n                    return false;\n                }\n                node = self.parentOf(node, siblings[i]);\n            } else {\n                // Left sibling should not be a prehashed zero\n                if (siblings[i] == self.preHashedZero[i]) {\n                    return false;\n                }\n                node = self.parentOf(siblings[i], node);\n            }\n            path >>= 1;\n        }\n        return node == root;\n    }\n\n    function _append(\n        Hasher memory self,\n        uint256 index,\n        uint256 leaf,\n        uint256[] memory siblings\n    ) internal pure returns(\n        uint256 nextRoot,\n        uint256 nextIndex,\n        uint256[] memory nextSiblings\n    ) {\n        nextSiblings = new uint256[](siblings.length);\n        uint256 path = index;\n        uint256 node = leaf;\n        for (uint256 level = 0; level < siblings.length; level++) {\n            if (path % 2 == 0) {\n                // right empty sibling\n                nextSiblings[level] = node; // current node will be the next merkle proof's left sibling\n                node = self.parentOf(node, self.preHashedZero[level]);\n            } else {\n                // left sibling\n                nextSiblings[level] = siblings[level]; // keep current sibling\n                node = self.parentOf(siblings[level], node);\n            }\n            path >>= 1;\n        }\n        nextRoot = node;\n        nextIndex = index + 1;\n    }\n}\n\nlibrary SubTreeLib {\n    using MerkleTreeLib for Hasher;\n    using MerkleTreeLib for bytes32;\n\n    function appendSubTree(\n        Hasher memory self,\n        uint256 startingRoot,\n        uint256 index,\n        uint256 subTreeDepth,\n        uint256[] memory leaves,\n        uint256[] memory subTreeSiblings\n    ) internal pure returns (uint256 newRoot) {\n        newRoot = startingRoot;\n        require(index % (1 << subTreeDepth) == 0, \"Can't merge a subTree\");\n        require(\n            self.preHashedZero.length == subTreeDepth + subTreeSiblings.length + 1,\n            \"Should submit subtree's siblings\"\n        );\n        require(_emptySubTreeProof(self, startingRoot, index, subTreeDepth, subTreeSiblings), \"Insertion is not allowed\");\n        uint256 nextIndex = index;\n        uint256[][] memory subTrees = splitToSubTrees(leaves, subTreeDepth);\n        uint256[] memory nextSiblings = subTreeSiblings;\n        for (uint256 i = 0; i < subTrees.length; i++) {\n            (newRoot, nextIndex, nextSiblings) = _appendSubTree(\n                self,\n                nextIndex,\n                subTreeDepth,\n                subTrees[i],\n                nextSiblings\n            );\n        }\n        return newRoot;\n    }\n\n    function splitToSubTrees(\n        uint256[] memory leaves,\n        uint256 subTreeDepth\n    ) internal pure returns (uint256[][] memory subTrees) {\n        uint256 subTreeSize = 1 << subTreeDepth;\n        uint256 numOfSubTrees = (leaves.length / subTreeSize) + (leaves.length % subTreeSize == 0 ? 0 : 1);\n        subTrees = new uint256[][](numOfSubTrees);\n        for (uint256 i = 0; i < numOfSubTrees; i++) {\n            subTrees[i] = new uint256[](subTreeSize);\n        }\n        uint256 index = 0;\n        uint256 subTreeIndex = 0;\n        for (uint256 i = 0; i < leaves.length; i++) {\n            subTrees[subTreeIndex][index] = leaves[i];\n            if (index < subTreeSize - 1) {\n                index += 1;\n            } else {\n                index = 0;\n                subTreeIndex += 1;\n            }\n        }\n    }\n\n    /**\n     * @param siblings If the merkle tree depth is \"D\" and the subTree's\n     *          depth is \"d\", the length of the siblings should be \"D - d\".\n     */\n    function _emptySubTreeProof(\n        Hasher memory self,\n        uint256 root,\n        uint256 index,\n        uint256 subTreeDepth,\n        uint256[] memory siblings\n    ) internal pure returns (bool) {\n        uint256 subTreePath = index >> subTreeDepth;\n        uint256 path = subTreePath;\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // Right sibling should be a prehashed zero\n                if(siblings[i] != self.preHashedZero[i + subTreeDepth]) return false;\n            } else {\n                // Left sibling should not be a prehashed zero\n                if(siblings[i] == self.preHashedZero[i + subTreeDepth]) return false;\n            }\n            path >>= 1;\n        }\n        return self.merkleProof(root, self.preHashedZero[subTreeDepth], subTreePath, siblings);\n    }\n\n    function _appendSubTree(\n        Hasher memory self,\n        uint256 index,\n        uint256 subTreeDepth,\n        uint256[] memory leaves,\n        uint256[] memory siblings\n    ) internal pure returns(\n        uint256 nextRoot,\n        uint256 nextIndex,\n        uint256[] memory nextSiblings\n    ) {\n        uint256 subTreeSize = 1 << subTreeDepth;\n        require(leaves.length <= subTreeSize, \"Overflowed\");\n        nextSiblings = new uint256[](siblings.length);\n        uint256 subTreePath = index >> subTreeDepth;\n        uint256 path = subTreePath;\n        uint256 node = _subTreeRoot(self, subTreeDepth, leaves);\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // right empty sibling\n                nextSiblings[i] = node; // current node will be the next merkle proof's left sibling\n                node = self.parentOf(node, self.preHashedZero[i + subTreeDepth]);\n            } else {\n                // left sibling\n                nextSiblings[i] = siblings[i]; // keep current sibling\n                node = self.parentOf(siblings[i], node);\n            }\n            path >>= 1;\n        }\n        nextRoot = node;\n        nextIndex = index + (1 << subTreeDepth);\n    }\n\n    function _subTreeRoot(\n        Hasher memory self,\n        uint256 subTreeDepth,\n        uint256[] memory leaves\n    ) internal pure returns (uint256) {\n        // Example of a sub tree with depth 3\n        //                      1\n        //          10                       11\n        //    100        101         110           [111]\n        // 1000 1001  1010 1011   1100 [1101]  [1110] [1111]\n        //   o   o     o    o       o    x       x       x\n        //\n        // whereEmptyNodeStart (1101) = leaves.length + tree_size\n        // []: nodes that we can use the pre hashed zeroes\n        //\n        // * ([1101] << 0) is gte than (1101) => we can use the pre hashed zeroes\n        // * ([1110] << 0) is gte than (1101) => we can use the pre hashed zeroes\n        // * ([1111] << 0) is gte than (1101) => we can use pre hashed zeroes\n        // * ([111] << 1) is gte than (1101) => we can use pre hashed zeroes\n        // * (11 << 2) is less than (1101) => we cannot use pre hashed zeroes\n        // * (1 << 3) is less than (1101) => we cannot use pre hashed zeroes\n\n        uint256 treeSize = 1 << subTreeDepth;\n        require(leaves.length <= treeSize, \"Overflowed\");\n\n        uint256[] memory nodes = new uint256[](treeSize << 1); // we'll not use nodes[0]\n        uint256 emptyNode = treeSize + leaves.length; // we do not hash if we can use pre hashed zeroes\n\n        // From the bottom to the top\n        for (uint256 level = 0; level <= subTreeDepth; level++) {\n            uint256 leftMostOfTheFloor = treeSize >> level;\n            // From the right to the left\n            for (\n                uint256 nodeIndex = (leftMostOfTheFloor << 1 ) - 1;\n                nodeIndex >= leftMostOfTheFloor;\n                nodeIndex--\n            )\n            {\n                if (nodeIndex < emptyNode) {\n                    // This node is not an empty node\n                    if (level == 0) {\n                        // Leaf node\n                        nodes[nodeIndex] = leaves[nodeIndex - treeSize];\n                    } else {\n                        // Parent node\n                        uint256 leftChild = nodeIndex << 1;\n                        uint256 rightChild = leftChild + 1;\n                        nodes[nodeIndex] = self.parentOf(nodes[leftChild], nodes[rightChild]);\n                    }\n                } else {\n                    // Use pre hashed\n                    nodes[nodeIndex] = self.preHashedZero[level];\n                }\n            }\n            leftMostOfTheFloor >>= 1;\n            emptyNode >>= 1;\n        }\n        return nodes[1];\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity = 0.6.12;\n\n// Moved G1Point, G2Point struct to the top level - by ws\nstruct G1Point {\n    uint256 X;\n    uint256 Y;\n}\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n}\n\n\nlibrary Pairing {\n\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero. \n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require (success,\"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        // return out[0] != 0;\n        return true;\n    }\n}\n\nstruct Blockchain {\n    bytes32 genesis;\n    bytes32 latest;\n\n    // For coordinating\n    uint256 proposedBlocks;\n    mapping(address=>Proposer) proposers;\n    mapping(bytes32=>Proposal) proposals;\n    mapping(bytes32=>bool) finalized; // blockhash => finalized?\n    mapping(bytes32=>bool) slashed; // blockhash => slashed\n\n    // For inclusion reference\n    mapping(bytes32=>bytes32) parentOf; // childBlockHash => parentBlockHash\n    mapping(bytes32=>uint256) utxoRootOf; // blockhash => utxoRoot\n    mapping(uint256=>bool) finalizedUTXORoots; // all finalized utxo roots\n\n    // For deposit\n    MassDeposit stagedDeposits;\n    uint256 stagedSize;\n    uint256 massDepositId;\n    mapping(bytes32=>uint256) committedDeposits;\n\n    // For withdrawal\n    mapping(bytes32=>uint256) withdrawalRootOf; // header => withdrawalRoot\n    mapping(bytes32=>bool) withdrawn;\n    mapping(bytes32=>address) newWithdrawalOwner;\n\n    // For migrations\n    mapping(bytes32=>bool) migrations;\n\n    // For ERC20 and ERC721\n    mapping(address=>bool) registeredERC20s;\n    mapping(address=>bool) registeredERC721s;\n}\n\nstruct MassDeposit {\n    bytes32 merged;\n    uint256 fee;\n}\n\n// needs gas limit\nstruct MassMigration {\n    address destination;\n    uint256 totalETH;\n    MassDeposit migratingLeaves;\n    ERC20Migration[] erc20;\n    ERC721Migration[] erc721;\n}\n\nstruct ERC20Migration {\n    address addr;\n    uint256 amount;\n}\n\nstruct ERC721Migration {\n    address addr;\n    uint256[] nfts;\n}\n\nstruct WithdrawalTree {\n    // Merkle tree of WithdrawalTree notes\n    uint256 root;\n    uint256 index;\n}\n\nstruct Finalization {\n    bytes32 proposalChecksum;\n    Header header;\n    MassDeposit[] massDeposits;\n    MassMigration[] massMigrations;\n}\n\nstruct Proposer {\n    uint256 stake;\n    uint256 reward;\n    uint256 exitAllowance; // block number\n}\n\nstruct Proposal {\n    bytes32 headerHash;\n    uint256 challengeDue;\n}\n\nstruct Block {\n    Header header;\n    Body body;\n}\n\nstruct Header {\n    // basic data\n    address proposer;\n    bytes32 parentBlock;\n    uint256 fee;\n\n    // UTXO roll up\n    uint256 utxoRoot;\n    uint256 utxoIndex;\n\n    // Nullifier roll up\n    bytes32 nullifierRoot;\n\n    // Withdrawal roll up\n    uint256 withdrawalRoot;\n    uint256 withdrawalIndex;\n\n    // Transactions\n    bytes32 txRoot;\n    bytes32 depositRoot;\n    bytes32 migrationRoot;\n}\n\nstruct Body {\n    Transaction[] txs;\n    MassDeposit[] massDeposits;\n    MassMigration[] massMigrations;\n}\n\nstruct Transaction {\n    Inflow[] inflow;\n    Outflow[] outflow;\n    uint256 swap;\n    uint256 fee;\n    Proof proof;\n    bytes memo; // encrypted memo field\n}\n\nstruct Inflow {\n    uint256 inclusionRoot;\n    bytes32 nullifier;\n}\n\nstruct Outflow {\n    uint256 note;\n    uint8 outflowType; // 0 = UTXO, 1 = Withdrawal, 2 = Migration\n    PublicData publicData; // Only for withdrawal & migration\n}\n\nenum OutflowType { UTXO, Withdrawal, Migration }\n\n// Only used for migration\nstruct PublicData {\n    address to; // to == 0: UTXO / to == address(this): Withdrawal / else: Migration\n    uint256 eth;\n    address token;\n    uint256 amount;\n    uint256 nft;\n    uint256 fee;\n}\n\nstruct AtomicSwap {\n    uint256[2] binder;\n    uint256[2] counterpart;\n}\n\nstruct Proof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nlibrary Types {\n    function init(Blockchain storage chain, bytes32 genesis) internal {\n        chain.latest = genesis;\n        chain.genesis = genesis;\n        chain.proposedBlocks++;\n    }\n\n    function hash(Header memory header) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                header.proposer,\n                header.parentBlock,\n                header.fee,\n                header.utxoRoot,\n                header.utxoIndex,\n                header.nullifierRoot,\n                header.withdrawalRoot,\n                header.withdrawalIndex,\n                header.txRoot,\n                header.depositRoot,\n                header.migrationRoot\n            )\n        );\n    }\n\n    function hash(Transaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                toBytes(transaction.inflow),\n                toBytes(transaction.outflow),\n                transaction.swap,\n                toBytes(transaction.proof),\n                transaction.fee\n            )\n        );\n    }\n\n    function toBytes(Inflow memory inflow) internal pure returns (bytes memory) {\n        return abi.encodePacked(inflow.inclusionRoot, inflow.nullifier);\n    }\n\n    function toBytes(Inflow[] memory inflow) internal pure returns (bytes memory) {\n        bytes memory packed;\n        for(uint256 i = 0; i < inflow.length; i++) {\n            packed = abi.encodePacked(packed, toBytes(inflow[i]));\n        }\n        return packed;\n    }\n\n    function toBytes(Outflow memory outflow) internal pure returns (bytes memory) {\n        if(isUTXO(outflow)) {\n            return abi.encodePacked(outflow.note);\n        } else {\n            return abi.encodePacked(\n                outflow.note,\n                outflow.publicData.to,\n                outflow.publicData.eth,\n                outflow.publicData.token,\n                outflow.publicData.amount,\n                outflow.publicData.nft,\n                outflow.publicData.fee\n            );\n        }\n    }\n\n    function toBytes(Outflow[] memory outflow) internal pure returns (bytes memory) {\n        bytes memory packed;\n        for(uint256 i = 0; i < outflow.length; i++) {\n            packed = abi.encodePacked(packed, toBytes(outflow[i]));\n        }\n        return packed;\n    }\n\n    function toBytes(AtomicSwap memory swap) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            swap.binder,\n            swap.counterpart\n        );\n    }\n\n    function toBytes(Proof memory proof) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            proof.a.X,\n            proof.a.Y,\n            proof.b.X[0],\n            proof.b.X[1],\n            proof.b.Y[0],\n            proof.b.Y[1],\n            proof.c.X,\n            proof.c.Y\n        );\n    }\n\n    function withdrawalNote(Outflow memory outflow) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                outflow.publicData.to,\n                outflow.publicData.eth,\n                outflow.publicData.token,\n                outflow.publicData.amount,\n                outflow.publicData.nft,\n                outflow.publicData.fee\n            )\n        );\n    }\n\n    function isUTXO(Outflow memory outflow) internal pure returns (bool) {\n        return outflow.publicData.to == address(0);\n    }\n\n    function hash(MassDeposit memory massDeposit) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                massDeposit.merged,\n                massDeposit.fee\n            )\n        );\n    }\n    function hash(MassMigration memory massMigration) internal pure returns (bytes32) {\n        bytes memory packed;\n        packed = abi.encodePacked(\n            packed,\n            massMigration.destination,\n            massMigration.migratingLeaves.merged,\n            massMigration.migratingLeaves.fee\n        );\n        for(uint256 i = 0; i < massMigration.erc20.length; i++) {\n            packed = abi.encodePacked(\n                packed,\n                massMigration.erc20[i].addr,\n                massMigration.erc20[i].amount\n            );\n        }\n        for(uint256 i = 0; i < massMigration.erc20.length; i++) {\n            packed = abi.encodePacked(\n                packed,\n                massMigration.erc721[i].addr,\n                massMigration.erc721[i].nfts\n            );\n        }\n        return keccak256(packed);\n    }\n\n    function root(Transaction[] memory transactions) internal pure returns (bytes32) {\n        bytes32[] memory leaves = new bytes32[](transactions.length);\n        for(uint256 i = 0; i < transactions.length; i++) {\n            leaves[i] = hash(transactions[i]);\n        }\n        return root(leaves);\n    }\n\n    function root(MassDeposit[] memory massDeposits) internal pure returns (bytes32) {\n        bytes32[] memory leaves = new bytes32[](massDeposits.length);\n        for(uint256 i = 0; i < massDeposits.length; i++) {\n            leaves[i] = hash(massDeposits[i]);\n        }\n        return root(leaves);\n    }\n\n    function root(MassMigration[] memory massMigrations) internal pure returns (bytes32) {\n        bytes32[] memory leaves = new bytes32[](massMigrations.length);\n        for(uint256 i = 0; i < massMigrations.length; i++) {\n            leaves[i] = hash(massMigrations[i]);\n        }\n        return root(leaves);\n    }\n\n    function root(bytes32[] memory leaves) internal pure returns (bytes32) {\n        if(leaves.length == 0) {\n            return bytes32(0);\n        } else if(leaves.length == 1) {\n            return leaves[0];\n        }\n        bytes32[] memory nodes = new bytes32[]((leaves.length + 1)/2);\n        bool hasEmptyLeaf = leaves.length % 2 == 1;\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            if(hasEmptyLeaf && i == nodes.length - 1) {\n                nodes[i] = keccak256(abi.encodePacked(leaves[i*2], bytes32(0)));\n            } else {\n                nodes[i] = keccak256(abi.encodePacked(leaves[i*2], leaves[i*2+1]));\n            }\n        }\n        return root(nodes);\n    }\n\n    function root(uint256[] memory leaves) internal pure returns (bytes32) {\n        bytes32[] memory converted;\n        assembly {\n            converted := leaves\n        }\n        return root(converted);\n    }\n\n    function isEmpty(PublicData memory publicData) internal pure returns (bool) {\n        if(publicData.to != address(0)) return false;\n        if(publicData.eth != 0) return false;\n        if(publicData.token != address(0)) return false;\n        if(publicData.amount != 0) return false;\n        if(publicData.nft != 0) return false;\n        if(publicData.fee != 0) return false;\n        return true;\n    }\n\n    // TODO temporal calculation\n    function maxChallengeCost(Block memory blockData) internal pure returns (uint256 maxCost) {\n    }\n\n    function getSNARKSignature(\n        uint8 numberOfInputs,\n        uint8 numberOfOutputs\n    ) internal pure returns (uint256) {\n        return (uint256(numberOfInputs) << 128) + numberOfOutputs;\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\npragma experimental ABIEncoderV2;\n\n\nlibrary SNARK {\n    using Pairing for *;\n    \n    struct VerifyingKey {\n        G1Point alpha1;\n        G2Point beta2;\n        G2Point gamma2;\n        G2Point delta2;\n        G1Point[] ic;\n    }\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    function verify(VerifyingKey memory vk, uint256[] memory input, Proof memory proof) internal view returns (bool) {\n        require(input.length + 1 == vk.ic.length,\"verifier-bad-input\");\n        // Compute the linear combination vkX\n        G1Point memory vkX = G1Point(0, 0);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.a.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.a.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.b.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.b.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.b.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.b.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.c.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.c.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\n            vkX = Pairing.plus(vkX, Pairing.scalar_mul(vk.ic[i + 1], input[i]));\n        }\n        vkX = Pairing.plus(vkX, vk.ic[0]);\n        return Pairing.pairing(\n            Pairing.negate(proof.a),\n            proof.b,\n            vk.alpha1,\n            vk.beta2,\n            vkX,\n            vk.gamma2,\n            proof.c,\n            vk.delta2\n        );\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract Config is Ownable {\n    uint256 constant public UTXO_TREE_DEPTH = 48;\n    uint256 constant public MAX_UTXO = (1 << UTXO_TREE_DEPTH);\n    uint256 constant public WITHDRAWAL_TREE_DEPTH = 48;\n    uint256 constant public MAX_WITHDRAWAL = (1 << WITHDRAWAL_TREE_DEPTH);\n    uint256 constant public NULLIFIER_TREE_DEPTH = 254;\n\n    uint256 constant public UTXO_SUB_TREE_DEPTH = 5; // 32 items at once\n    uint256 constant public UTXO_SUB_TREE_SIZE = 1 << UTXO_SUB_TREE_DEPTH;\n    uint256 constant public WITHDRAWAL_SUB_TREE_DEPTH = 5; // 32 items at once\n    uint256 constant public WITHDRAWAL_SUB_TREE_SIZE = 1 << WITHDRAWAL_SUB_TREE_DEPTH;\n\n    uint256 public MAX_BLOCK_SIZE = 200000; // 3.2M gas for calldata\n    uint256 public MAX_VALIDATION_GAS = 6000000; // 6M gas\n    // 46523 blocks when the challenge period is 7 days and average block time is 13 sec\n    uint256 public CHALLENGE_PERIOD = 46523;\n    uint256 public MINIMUM_STAKE = 32 ether;\n    uint256 public REF_DEPTH = 128;\n\n    address public consensusProvider;\n}\n\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\nlibrary SMT254 {\n    // in Solidity: keccak256('exist')\n    // in Web3JS: soliditySha3('exist')\n    bytes32 constant public EXIST = bytes32(uint256(1));\n    // in Solidity: keccak256(abi.encodePacked(bytes32(0)))\n    // in Web3JS: soliditySha3(0)\n    bytes32 constant public NON_EXIST = 0;\n\n    function inclusionProof(\n        bytes32 root,\n        bytes32 leaf,\n        bytes32[254] memory siblings\n    ) internal pure returns(bool) {\n        return merkleProof(root, leaf, EXIST, siblings);\n    }\n\n    function nonInclusionProof(\n        bytes32 root,\n        bytes32 leaf,\n        bytes32[254] memory siblings\n    ) internal pure returns(bool) {\n        return merkleProof(root, leaf, NON_EXIST, siblings);\n    }\n\n    function merkleProof(\n        bytes32 root,\n        bytes32 leaf,\n        bytes32 value,\n        bytes32[254] memory siblings\n    ) internal pure returns(bool) {\n        require(calculateRoot(leaf, value, siblings) == root, \"Invalid merkle proof\");\n        return true;\n    }\n\n    function calculateRoot(\n        bytes32 leaf,\n        bytes32 value,\n        bytes32[254] memory siblings\n    ) internal pure returns (bytes32) {\n        bytes32 cursor = value;\n        uint256 path = uint256(leaf);\n        for (uint16 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // Right sibling\n                cursor = keccak256(abi.encodePacked(cursor, siblings[i]));\n            } else {\n                // Left sibling\n                cursor = keccak256(abi.encodePacked(siblings[i], cursor));\n            }\n            path = path >> 1;\n        }\n        return cursor;\n    }\n\n    function fill(\n        bytes32 prevRoot,\n        bytes32 leaf,\n        bytes32[254] memory siblings\n    ) internal pure returns (bytes32 nextRoot) {\n        // Prove that the array of sibling is valid and also the leaf does not exist in the tree\n        require(nonInclusionProof(prevRoot, leaf, siblings), \"Failed to build the previous root using the leaf and its sibling\");\n        // Calculate the new root when the leaf exists using its proven siblings\n        nextRoot = calculateRoot(leaf, EXIST, siblings);\n        // Make sure it has been updated\n        require(prevRoot != nextRoot, \"Already existing leaf\");\n    }\n\n    function fill(\n        bytes32 prevRoot,\n        bytes32[] memory leaves,\n        bytes32[254][] memory siblings\n    ) internal pure returns (bytes32 nextRoot) {\n        // Inspect the RollUp structure\n        require(leaves.length == siblings.length, \"Both array should have same length\");\n        // Start from the root\n        bytes32 root = prevRoot;\n        // Update the root using fill function\n        for (uint256 i = 0; i < leaves.length; i ++) {\n            root = fill(root, leaves[i], siblings[i]);\n        }\n        return root;\n    }\n}\n\ncontract Storage is Config {\n    // State of the layer2 blockchain is maintained by the optimistic roll up\n    Blockchain chain;\n\n    // Addresses where to execute the given function call\n    mapping(bytes4=>address) public proxied;\n\n    // Addresses of onchain validation contracts\n    mapping(bytes4=>address) public validators;\n\n    // SNARK verifying keys assigned by the setup wizard for each tx type\n    mapping(uint256=>SNARK.VerifyingKey) vks;\n\n    // Addresses allowed to migrate from. Setup wizard manages the list\n    mapping(address=>bool) public allowedMigrants;\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n\nlibrary Poseidon2 {\n    /**\n     * @dev This is a dummy implementation for contract compilation\n     * We'll use a generated library by circomlib instead of this dummy library\n     * Please see\n     * 1. migrations/3_deploy_poseidon.js\n     * 2. https://github.com/iden3/circomlib/blob/master/src/poseidon_gencontract.js\n     */\n    function poseidon(uint256[] calldata) external pure returns(uint256) {\n        return 0;\n    }\n}\n\nlibrary Poseidon3 {\n    /**\n     * @dev This is a dummy implementation for contract compilation\n     * We'll use a generated library by circomlib instead of this dummy library\n     * Please see\n     * 1. migrations/3_deploy_poseidon.js\n     * 2. https://github.com/iden3/circomlib/blob/master/src/poseidon_gencontract.js\n     */\n    function poseidon(uint256[] calldata) external pure returns(uint256) {\n        return 0;\n    }\n}\n\nlibrary Poseidon4 {\n    /**\n     * @dev This is a dummy implementation for contract compilation\n     * We'll use a generated library by circomlib instead of this dummy library\n     * Please see\n     * 1. migrations/3_deploy_poseidon.js\n     * 2. https://github.com/iden3/circomlib/blob/master/src/poseidon_gencontract.js\n     */\n    function poseidon(uint256[] calldata) external pure returns(uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev This will be used to provide hash functions to calculate roll up.\n *      Please see MerkleTreeLib.sol from 'merkle-tree-rollup'.\n */\nlibrary Hash {\n    uint256 constant k =  21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    function poseidon() internal pure returns (Hasher memory) {\n        return Hasher(poseidonParentOf, poseidonPrehashedZeroes());\n    }\n\n    /**\n     * @dev Costs about 100k gas\n     */\n    function poseidonParentOf(uint256 left, uint256 right) internal pure returns (uint256) {\n        uint256[] memory res = new uint256[](2);\n        res[0] = left;\n        res[1] = right;\n        try Poseidon2.poseidon(res) returns (uint256 val) {\n            return val;\n        } catch {\n            revert(\"poseidon hash error\");\n        }\n    }\n\n    function poseidonPrehashedZeroes() internal pure returns (uint256[] memory preHashed) {\n        preHashed = new uint256[](49);\n        preHashed[0] = 0;\n        preHashed[1] = 10600974484483636649191836183331859514454108476826376357941356292578099372400;\n        preHashed[2] = 21794476778427377126059366449788686607895945400675042941280102093665559598175;\n        preHashed[3] = 2436929412409273971247897342963836206109725384909989018993604443786196167079;\n        preHashed[4] = 16795971212351522389263710863137077078214825169846509011929499600964499735050;\n        preHashed[5] = 13219681652802262400226541382497744859725228879557499223706656560508858332284;\n        preHashed[6] = 16077415043335295839603287133858682446972083000831421492129903860562380669637;\n        preHashed[7] = 502327552794018830492963939468986095778588873732395241302862672501374866469;\n        preHashed[8] = 17316932530822847310778297511893782089230531647975443264466851693705942399213;\n        preHashed[9] = 15616967174077889152093898696441462010235212806608416549656188924405260247520;\n        preHashed[10] = 12190821404971533019165426092513461076028437957291902632838999055821897583490;\n        preHashed[11] = 16555028449797792480572832506992372535201158677714945803879012251354763331859;\n        preHashed[12] = 8231705230240651230537572725530833127444944283000004623928536619628228934194;\n        preHashed[13] = 3077550723437915419104207012579575734231701844853976167144530179212424050931;\n        preHashed[14] = 21763696456923873365073754080645198026461423046360831704057969664583515901721;\n        preHashed[15] = 67141086259845765994826791686185563664511508469575310323320621339898305036;\n        preHashed[16] = 3624208598265904886738968685803615152975472463538997991139575048534610424717;\n        preHashed[17] = 8676144851288185870896103351878389773782247068899092359631289704737412042232;\n        preHashed[18] = 13238330640648007528634160449350536125916169295342140059757257691192126867979;\n        preHashed[19] = 7629979400019171337168423414609244365318871324132477886392009656933248919644;\n        preHashed[20] = 17216708267491716820765977769753349546409338100471140224707568935140015239541;\n        preHashed[21] = 11032037682276971475370797274652951818817419346055678538386520770346150554858;\n        preHashed[22] = 10513188655612264610639309345357023572819674417089822243543789426195372519458;\n        preHashed[23] = 20830246484199144121270459776609618477426103665100784158598304005532171231316;\n        preHashed[24] = 14643959052806370295783622182926307921956713992546430641832487667576487046071;\n        preHashed[25] = 12119291572639831440678081618795940194258648574679550148918006799979881284464;\n        preHashed[26] = 13750563915408596218593142901395486535832472899236176573304451439811156557055;\n        preHashed[27] = 12907606178576131793702229776336195584587379579829260210095886803937822938528;\n        preHashed[28] = 13566176060365945107460500823464340046804824004704104386373703757946826255443;\n        preHashed[29] = 3009017506736485220239996395726299306996097787311048019632232229030423680587;\n        preHashed[30] = 21724845982339994137711944825542880106108735522617894947541637950424101339449;\n        preHashed[31] = 60386645284463199583445465572728164220538858039953884251650918083929763515;\n        preHashed[32] = 1592711413674761513405971810003404198688350605293799559384385405041395766194;\n        preHashed[33] = 14301516436643055045149109088855694557420746657725164659766413999811862291456;\n        preHashed[34] = 15921849220790204754735378712104286100899979049583142302521522792105492783919;\n        preHashed[35] = 731934832871647620741636264208684467123503262905121663067794120328092378570;\n        preHashed[36] = 18594386615908007655786955006792973928646499172983204159345011756342104179726;\n        preHashed[37] = 21403312021111361442177462312539794489440477815302791844841091759479516900086;\n        preHashed[38] = 17895432372310760551979403007617520876638797221531830301793148922789216157001;\n        preHashed[39] = 4046320522306284054744909476688821930829401455132175453981105518049156544596;\n        preHashed[40] = 21308652235294521203949455324101573347326725563669617684423526382035190882040;\n        preHashed[41] = 9307558633100119005416786313499541804276667918366544329554442874107210818008;\n        preHashed[42] = 12096189432791920614550311407338568058300637088225040717271755202689760990069;\n        preHashed[43] = 19823437509870604295178309989523899027391648832731860668528138144905229555596;\n        preHashed[44] = 6964798124447762099265638561733651799459494941130544021880669315667107478958;\n        preHashed[45] = 7270233836638236002899669836456396743979691360169767700191498626702755802269;\n        preHashed[46] = 1740310102929396229334577845559329925566414851949444893300244205344733658171;\n        preHashed[47] = 9023345516637064449644297334443052792369346575394200069833851209363060173178;\n        preHashed[48] = 3092784425575682849215806387188191163008086618667633588848126820278484295451;\n    }\n\n    function keccak() internal pure returns (Hasher memory) {\n        return Hasher(keccakParentOf, keccakPrehashedZeroes());\n    }\n\n    function keccakParentOf(uint256 left, uint256 right) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(left, right)));\n    }\n\n    function keccakPrehashedZeroes() internal pure returns (uint256[] memory preHashed) {\n        preHashed = new uint256[](49);\n        preHashed[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        preHashed[1] = 0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5;\n        preHashed[2] = 0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30;\n        preHashed[3] = 0x21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85;\n        preHashed[4] = 0xe58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344;\n        preHashed[5] = 0x0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d;\n        preHashed[6] = 0x887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968;\n        preHashed[7] = 0xffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83;\n        preHashed[8] = 0x9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af;\n        preHashed[9] = 0xcefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0;\n        preHashed[10] = 0xf9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5;\n        preHashed[11] = 0xf8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892;\n        preHashed[12] = 0x3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c;\n        preHashed[13] = 0xc1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb;\n        preHashed[14] = 0x5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc;\n        preHashed[15] = 0xda7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2;\n        preHashed[16] = 0x2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f;\n        preHashed[17] = 0xe1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a;\n        preHashed[18] = 0x5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0;\n        preHashed[19] = 0xb46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0;\n        preHashed[20] = 0xc65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2;\n        preHashed[21] = 0xf4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9;\n        preHashed[22] = 0x5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377;\n        preHashed[23] = 0x4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652;\n        preHashed[24] = 0xcdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef;\n        preHashed[25] = 0x0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d;\n        preHashed[26] = 0xb8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0;\n        preHashed[27] = 0x838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e;\n        preHashed[28] = 0x662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e;\n        preHashed[29] = 0x388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322;\n        preHashed[30] = 0x93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735;\n        preHashed[31] = 0x8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9;\n        preHashed[32] = 0x27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757;\n        preHashed[33] = 0xbf558bebd2ceec7f3c5dce04a4782f88c2c6036ae78ee206d0bc5289d20461a2;\n        preHashed[34] = 0xe21908c2968c0699040a6fd866a577a99a9d2ec88745c815fd4a472c789244da;\n        preHashed[35] = 0xae824d72ddc272aab68a8c3022e36f10454437c1886f3ff9927b64f232df414f;\n        preHashed[36] = 0x27e429a4bef3083bc31a671d046ea5c1f5b8c3094d72868d9dfdc12c7334ac5f;\n        preHashed[37] = 0x743cc5c365a9a6a15c1f240ac25880c7a9d1de290696cb766074a1d83d927816;\n        preHashed[38] = 0x4adcf616c3bfabf63999a01966c998b7bb572774035a63ead49da73b5987f347;\n        preHashed[39] = 0x75786645d0c5dd7c04a2f8a75dcae085213652f5bce3ea8b9b9bedd1cab3c5e9;\n        preHashed[40] = 0xb88b152c9b8a7b79637d35911848b0c41e7cc7cca2ab4fe9a15f9c38bb4bb939;\n        preHashed[41] = 0x0c4e2d8ce834ffd7a6cd85d7113d4521abb857774845c4291e6f6d010d97e318;\n        preHashed[42] = 0x5bc799d83e3bb31501b3da786680df30fbc18eb41cbce611e8c0e9c72f69571c;\n        preHashed[43] = 0xa10d3ef857d04d9c03ead7c6317d797a090fa1271ad9c7addfbcb412e9643d4f;\n        preHashed[44] = 0xb33b1809c42623f474055fa9400a2027a7a885c8dfa4efe20666b4ee27d7529c;\n        preHashed[45] = 0x134d7f28d53f175f6bf4b62faa2110d5b76f0f770c15e628181c1fcc18f970a9;\n        preHashed[46] = 0xc34d24b2fc8c50ca9c07a7156ef4e5ff4bdf002eda0b11c1d359d0b59a546807;\n        preHashed[47] = 0x04dbb9db631457879b27e0dfdbe50158fd9cf9b4cf77605c4ac4c95bd65fc9f6;\n        preHashed[48] = 0xf9295a686647cb999090819cda700820c282c613cedcd218540bbc6f37b01c65;\n    }\n}\n\ncontract UserInteractable is Storage {\n    uint256 public constant SNARK_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 public constant RANGE_LIMIT = SNARK_FIELD >> 32;\n    using MerkleTreeLib for *;\n    using SafeMath for uint256;\n\n    event Deposit(uint256 indexed queuedAt, uint256 note, uint256 fee);\n\n    /**\n     * @notice Users can use zkopru network by submitting a new homomorphically hiden note.\n     * @param spendingPubKey P = poseidon(p*G, N) https://github.com/zkopru-network/zkopru/issues/34#issuecomment-666988505\n     * @param salt 254bit salt for the privacy\n     * @param eth Amount of Ether to deposit\n     * @param token Token address of ERC20 or ERC721. It can be undefined.\n     * @param amount Amount of ERC20 when the token param is defined and it is an ERC20\n     * @param nft NFT id when the token param is defined and it is an ERC721\n     * @param fee Amount of fee to give to the coordinator\n     */\n    function deposit(\n        uint256 spendingPubKey,\n        uint256 salt,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 fee\n    ) public payable {\n        _deposit(spendingPubKey, salt, eth, token, amount, nft, fee);\n    }\n    \n    /**\n     * @notice Users can withdraw notes when only after they're finazlied.\n     * @param note Note hash in layer 2. It is a poseidon hash\n     * @param owner The original owner's address of the note\n     * @param eth Amount of Ether to withdraw out\n     * @param token Token address of ERC20 or ERC721. It can be undefined.\n     * @param amount Amount of ERC20 when the token param is defined and it is an ERC20\n     * @param nft NFT id when the token param is defined and it is an ERC721\n     * @param callerFee Amount of fee to give to the caller. This can be used when the withdrawer account has no ETH.\n     * @param blockHash Finalized block hash to find the finalized withdrawal root\n     * @param leafIndex The index of your withdrawal note's leaf in the given tree.\n     * @param siblings Inclusion proof data\n     */\n    function withdraw(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee,\n        bytes32 blockHash,\n        uint256 leafIndex,\n        uint256[] memory siblings\n    ) public {\n        return _withdraw(\n            note,\n            owner,\n            eth,\n            token,\n            amount,\n            nft,\n            callerFee,\n            blockHash,\n            leafIndex,\n            siblings\n        );\n    }\n\n    /**\n     * @notice Someone can pay in advance for unfinalized withdrawals\n     * @param note Poseidon note hash of the withdrawal\n     * @param owner Address of the note\n     * @param eth Amount of Ether to withdraw out\n     * @param token Token address of ERC20 or ERC721. It can be undefined.\n     * @param amount Amount of ERC20 when the token param is defined and it is an ERC20\n     * @param nft NFT id when the token param is defined and it is an ERC721\n     * @param callerFee Amount of fee to give to the caller. This can be used when the withdrawer account has no ETH.\n     * @param signature ECDSA signature\n     */\n    function payInAdvance(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee,\n        uint256 prepayFeeInEth,\n        uint256 prepayFeeInToken,\n        bytes memory signature\n    ) public payable {\n        bytes32 withdrawalHash = _withdrawalHash(\n            note,\n            owner,\n            eth,\n            token,\n            amount,\n            nft,\n            callerFee\n        );\n        require(!Storage.chain.withdrawn[withdrawalHash], \"Already withdrawn\");\n\n        address newOwner = Storage.chain.newWithdrawalOwner[withdrawalHash];\n        address currentOwner = newOwner == address(0) ? owner : newOwner;\n        address prepayer = msg.sender;\n        bytes32 payInAdvanceMsg = keccak256(\n            abi.encodePacked(\n                prepayer,\n                withdrawalHash,\n                prepayFeeInEth,\n                prepayFeeInToken\n            )\n        );\n        // verify original owner's signature\n        require(\n            _verifySignature(\n                currentOwner,\n                payInAdvanceMsg,\n                signature\n            ),\n            \"Invalid owner signature\"\n        );\n        uint ethToWithdraw = eth.sub(prepayFeeInEth);\n        uint tokenToWithdraw = amount.sub(prepayFeeInToken);\n        require(msg.value == eth, 'not enough ether');\n        // prepay tokens\n        if (Storage.chain.registeredERC20s[token]) {\n            IERC20(token).transferFrom(prepayer, currentOwner, tokenToWithdraw);\n        } else if (Storage.chain.registeredERC721s[token]){\n            revert(\"Does not support NFT prepay\");\n        }\n        // prepay ether\n        _sendEth(currentOwner, ethToWithdraw);\n        // transfer ownership\n        Storage.chain.newWithdrawalOwner[withdrawalHash] = prepayer;\n    }\n\n    function _deposit(\n        uint256 spendingPubKey,\n        uint256 salt,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 fee\n    ) internal {\n        // range check\n        require(amount < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(eth < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(fee < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(nft < SNARK_FIELD, \"Does not support too big nubmer of nft id\");\n        // check eth value\n        require(eth.add(fee) == msg.value, \"Inexact amount of eth\");\n        require(Storage.chain.stagedSize < 1024, \"Should wait until it is committed\");\n        // check note fields\n        require(_checkNoteFields(eth, token, amount, nft));\n\n        //TODO: require(fee >= specified fee);\n        // Validate the note is same with the hash result\n        uint256[] memory assetHashInputs = new uint256[](4);\n        assetHashInputs[0] = eth;\n        assetHashInputs[1] = uint256(token);\n        assetHashInputs[2] = amount; //erc20 amount\n        assetHashInputs[3] = nft;\n        uint256 assetHash = Poseidon4.poseidon(assetHashInputs);\n        uint256[] memory resultHashInputs = new uint256[](3);\n        resultHashInputs[0] = spendingPubKey;\n        resultHashInputs[1] = salt;\n        resultHashInputs[2] = assetHash;\n        uint256 note = Poseidon3.poseidon(resultHashInputs);\n        // Receive token\n        if (token != address(0) && amount != 0) {\n            try IERC20(token).transferFrom(msg.sender, address(this), amount) {\n            } catch {\n                revert(\"Transfer ERC20 failed\");\n            }\n        } else if (token != address(0)) {\n            try IERC721(token).transferFrom(msg.sender, address(this), nft) {\n            } catch {\n                revert(\"Transfer NFT failed\");\n            }\n        }\n        // Update the mass deposit\n        Storage.chain.stagedDeposits.merged = keccak256(abi.encodePacked(Storage.chain.stagedDeposits.merged, note));\n        Storage.chain.stagedDeposits.fee = Storage.chain.stagedDeposits.fee.add(fee);\n        Storage.chain.stagedSize = Storage.chain.stagedSize.add(1);\n        // Emit event. Coordinator should subscribe this event.\n        emit Deposit(Storage.chain.massDepositId, note, fee);\n    }\n\n    function _withdraw(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee,\n        bytes32 blockHash,\n        uint256 leafIndex,\n        uint256[] memory siblings\n    ) internal {\n        // range check\n        require(amount < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(eth < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(callerFee < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(nft < SNARK_FIELD, \"Does not support too big nubmer of nft id\");\n        // check note fields\n        require(_checkNoteFields(eth, token, amount, nft));\n        // check the reference block is finalized\n        require(Storage.chain.finalized[blockHash], \"Not a finalized block\");\n        uint256 root = Storage.chain.withdrawalRootOf[blockHash];\n        bytes32 withdrawalHash = _withdrawalHash(\n            note,\n            owner,\n            eth,\n            token,\n            amount,\n            nft,\n            callerFee\n        );\n        // Should not allow double-withdrawing\n        require(!Storage.chain.withdrawn[withdrawalHash], \"Already withdrawn\");\n        // Mark as withdrawn\n        Storage.chain.withdrawn[withdrawalHash] = true;\n        // Check whether new owner exists\n        address to = Storage.chain.newWithdrawalOwner[withdrawalHash] != address(0)\n            ? Storage.chain.newWithdrawalOwner[withdrawalHash]\n            : owner;\n\n        // inclusion proof\n        bool inclusion = Hash.keccak().merkleProof(\n            root,\n            uint256(withdrawalHash),\n            leafIndex,\n            siblings\n        );\n        require(inclusion, \"The given withdrawal note does not exist\");\n        // Withdraw ETH & get fee\n        if(to == msg.sender) {\n            _sendEth(to, eth.add(callerFee));\n        } else {\n            _sendEth(to, eth);\n            _sendEth(msg.sender, callerFee);\n        }\n        // Withdraw tokens if exists\n        if (Storage.chain.registeredERC20s[token]) {\n            IERC20(token).transfer(to, amount);\n        } else if (Storage.chain.registeredERC721s[token]){\n            require(nft != 0, \"Circuit cannot accept NFT id 0. Please deposit other NFT.\");\n            IERC721(token).transferFrom(address(this), to, nft);\n        }\n    }\n\n    function _withdrawalHash(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                note,\n                owner,\n                eth,\n                token,\n                amount,\n                nft,\n                callerFee\n            )\n        );\n    }\n\n    function _verifySignature(\n        address signer,\n        bytes32 message,\n        bytes memory sig\n    ) internal pure returns (bool) {\n        require(sig.length == 65);\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\n        return signer == ecrecover(prefixedHash, v, r, s);\n    }\n\n    function _checkNoteFields(\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft\n    ) internal view returns (bool) {\n        if (token == address(0)) {\n            require(nft == 0 && amount == 0, \"Ether note does not have amount field & nft field\");\n            require(eth != 0, \"Should have ETH field\");\n        } else {\n            // this note contains token value\n            bool isERC20 = Storage.chain.registeredERC20s[token];\n            bool isERC721 = Storage.chain.registeredERC721s[token];\n            require(isERC20 || isERC721, \"Not a registered token. Reigster that token first\");\n            if (isERC20) {\n                require(nft == 0, \"ERC20 does have NFT field\");\n            } else if (isERC721){\n                require(nft != 0, \"Circuit cannot accept NFT id 0. Please deposit other NFT.\");\n                require(amount == 0, \"ERC721 does have amount field\");\n            }\n        }\n        return true;\n    }\n\n    function _sendEth(address to, uint val) internal {\n        if (val > 0) {\n            (bool success, ) = to.call{ value: val }(\"\");\n            require(success, \"Failed to send ETH\");\n        }\n    }\n}\n", "commit_id": "b626813e10ae69884b0ba554e641184652a1c0e5"}, "fixed_version": {"raw_code": " // SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\nimport { Storage } from \"../storage/Storage.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/introspection/IERC165.sol\";\nimport { Hash } from \"../libraries/Hash.sol\";\nimport { IConsensusProvider } from \"../../consensus/interfaces/IConsensusProvider.sol\";\nimport {\n    Header,\n    Proposer,\n    Blockchain,\n    Block,\n    Proposal,\n    Finalization,\n    MassDeposit,\n    WithdrawalTree,\n    Types\n} from \"../libraries/Types.sol\";\nimport { Deserializer } from \"../libraries/Deserializer.sol\";\n\n\ncontract Coordinatable is Storage {\n    using Types for *;\n\n    event NewProposal(uint256 proposalNum, bytes32 blockHash);\n    event Finalized(bytes32 blockHash);\n    event MassDepositCommit(uint256 index, bytes32 merged, uint256 fee);\n    event NewErc20(address tokenAddr);\n    event NewErc721(address tokenAddr);\n\n    /**\n     * @notice This function will be updated as the governance of Zkopru's been updated.\n     *         Currently Coordinator calls this function for the proof of stake.\n     *         Coordinator should pay more than MINIMUM_STAKE. See 'Configurated.sol'\n     */\n    function register() public payable {\n        stake(msg.sender);\n    }\n\n    function stake(address coordinator) public payable {\n        require(msg.value >= MINIMUM_STAKE, \"Should stake more than minimum amount of ETH\");\n        Proposer storage proposer = Storage.chain.proposers[coordinator];\n        proposer.stake += msg.value;\n    }\n\n    /**\n     * @notice This function will be updated as the governance of Zkopru's been updated.\n     */\n    function deregister() public {\n        address payable proposerAddr = msg.sender;\n        Proposer storage proposer = Storage.chain.proposers[proposerAddr];\n        require(proposer.exitAllowance <= block.number, \"Still in the challenge period\");\n        // Withdraw stake\n        proposerAddr.transfer(proposer.stake);\n        // Withdraw reward\n        payable(proposerAddr).transfer(proposer.reward);\n        // Delete proposer\n        delete Storage.chain.proposers[proposerAddr];\n    }\n\n    /**\n     * @dev Coordinator proposes a new block using this function. propose() will freeze\n     *      the current mass deposit for the next block proposer, and will go through\n     *      CHALLENGE_PERIOD.\n     * @param data Serialized newly minted block data\n     */\n    function propose(bytes memory data) public {\n        // Limit the maximum length\n        require(data.length <= MAX_BLOCK_SIZE);\n        Block memory _block = Deserializer.blockFromCalldataAt(0);\n        // The message sender address should be same with the proposer address\n        require(_block.header.proposer == msg.sender, \"Coordinator account is different with the message sender\");\n        Proposer storage proposer = Storage.chain.proposers[msg.sender];\n        // Check permission\n        IConsensusProvider(consensusProvider).openRoundIfNeeded();\n        require(isProposable(msg.sender), \"Not allowed to propose\");\n        // Duplicated proposal is not allowed\n        bytes32 checksum = keccak256(data);\n        require(Storage.chain.proposals[checksum].headerHash == bytes32(0), \"Already submitted\");\n        // Save opru proposal\n        bytes32 currentBlockHash = _block.header.hash();\n        Storage.chain.proposals[checksum] = Proposal(\n            currentBlockHash,\n            block.number + CHALLENGE_PERIOD\n        );\n        // Record l2 chain\n        Storage.chain.parentOf[currentBlockHash] = _block.header.parentBlock;\n        // Record reference for the inclusion proofs\n        Storage.chain.utxoRootOf[currentBlockHash] = _block.header.utxoRoot;\n        // Record reference for the withdrawal proofs when only if there exists update\n        if (Storage.chain.withdrawalRootOf[_block.header.parentBlock] != _block.header.withdrawalRoot) {\n            Storage.chain.withdrawalRootOf[currentBlockHash] = _block.header.withdrawalRoot;\n        }\n        // Update exit allowance period\n        proposer.exitAllowance = block.number + CHALLENGE_PERIOD;\n        // Freeze the latest mass deposit for the next block proposer\n        commitMassDeposit();\n        emit NewProposal(Storage.chain.proposedBlocks, currentBlockHash);\n        Storage.chain.proposedBlocks++;\n    }\n\n    /**\n     * @dev Coordinator can commit mass deposits. The pending deposits will be automatically\n     *      committed by propose() block. But to start the first propose() block, there\n     *      should be enough pending deposits, and the coordinator will commit them using\n     *      this standalone function.\n     */\n    function commitMassDeposit() public {\n        if(Storage.chain.stagedDeposits.merged != bytes32(0)) {\n            bytes32 depositHash = Storage.chain.stagedDeposits.hash();\n            Storage.chain.committedDeposits[depositHash] += 1;\n            emit MassDepositCommit(\n                Storage.chain.massDepositId,\n                Storage.chain.stagedDeposits.merged,\n                Storage.chain.stagedDeposits.fee\n            );\n            delete Storage.chain.stagedDeposits;\n            delete Storage.chain.stagedSize;\n            Storage.chain.massDepositId++;\n        }\n    }\n\n    /**\n     * @dev Coordinator can finalize a submitted block if it isn't slashed during the\n     *      challenge period. It updates the aggregated fee and withdrawal root.\n     * @param // Block data without tx details\n     */\n    function finalize(bytes memory) public {\n        Finalization memory finalization = Deserializer.finalizationFromCalldataAt(0);\n        Proposal storage proposal = Storage.chain.proposals[finalization.proposalChecksum];\n        // Check requirements\n        require(finalization.massDeposits.root() == finalization.header.depositRoot, \"Submitted different deposit root\");\n        require(finalization.massMigrations.root() == finalization.header.migrationRoot, \"Submitted different deposit root\");\n        require(finalization.header.hash() == proposal.headerHash, \"Invalid header data\");\n        require(!Storage.chain.slashed[proposal.headerHash], \"Slashed roll up can't be finalized\");\n        require(!Storage.chain.finalized[proposal.headerHash], \"Already finalized\");\n        require(finalization.header.parentBlock == Storage.chain.latest, \"The latest block should be its parent\");\n        require(finalization.header.parentBlock != proposal.headerHash, \"Reentrancy case\");\n        require(block.number > proposal.challengeDue, \"Still in challenge period\");\n\n        // Execute deposits and collect fees\n        for (uint256 i = 0; i < finalization.massDeposits.length; i++) {\n            MassDeposit memory deposit = finalization.massDeposits[i];\n            bytes32 massDepositHash = deposit.hash();\n            require(Storage.chain.committedDeposits[massDepositHash] > 0, \"MassDeposit does not exist.\");\n            Storage.chain.committedDeposits[massDepositHash] -= 1;\n        }\n\n        // Record mass migrations and collect fees.\n        // A MassMigration becomes a MassDeposit for the migration destination.\n        for (uint256 i = 0; i < finalization.massMigrations.length; i++) {\n            bytes32 migrationId = keccak256(\n                abi.encodePacked(\n                    finalization.proposalChecksum,\n                    finalization.massMigrations[i].hash()\n                )\n            );\n            require(!Storage.chain.migrations[migrationId], \"Same id exists. Migrate it first\");\n            Storage.chain.migrations[migrationId] = true;\n        }\n\n        // Give fee to the proposer\n        Proposer storage proposer = Storage.chain.proposers[finalization.header.proposer];\n        proposer.reward += finalization.header.fee;\n\n        // Update the chain\n        Storage.chain.finalized[proposal.headerHash] = true;\n        Storage.chain.finalizedUTXORoots[finalization.header.utxoRoot] = true;\n        Storage.chain.latest = proposal.headerHash;\n        emit Finalized(proposal.headerHash);\n        delete Storage.chain.proposals[finalization.proposalChecksum];\n    }\n\n    /**\n     * @dev Coordinators can withdraw aggregated transaction fees.\n     * @param amount Amount to withdraw.\n     */\n    function withdrawReward(uint256 amount) public {\n        address payable proposerAddr = msg.sender;\n        Proposer storage proposer = Storage.chain.proposers[proposerAddr];\n        require(proposer.reward >= amount, \"You can't withdraw more than you have\");\n        proposer.reward -= amount;\n        payable(proposerAddr).transfer(amount);\n    }\n\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /**\n     * @dev Provide registered erc20 token information for decryption\n     * TODO\n     * 1. verify erc20 token\n     * 2. governance to register the token address\n     */\n    function registerERC20(address tokenAddr) public {\n        require(!Storage.chain.registeredERC20s[tokenAddr], \"Already registered\");\n        // Make sure that this token is ERC20\n        try IERC20(tokenAddr).transfer(address(this), 0) returns (bool result) {\n            require(result, \"Failed to send dummy tx\");\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*reason*/) {\n            // pass: it means that this address is not ERC721\n            revert(\"does not support transfer()\");\n        }\n        try IERC20(tokenAddr).transferFrom(address(this), address(this), 0) returns (bool result) {\n            require(result, \"Failed to send dummy tx\");\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*reason*/) {\n            // pass: it means that this address is not ERC721\n            revert(\"does not support transfer()\");\n        }\n        try IERC20(tokenAddr).balanceOf(address(this)) returns (uint256) {\n            // success\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory /*reason*/) {\n            // pass: it means that this address is not ERC721\n            revert(\"does not support transfer()\");\n        }\n        // Make sure that this token is not an ERC721\n        try IERC165(tokenAddr).supportsInterface(_INTERFACE_ID_ERC721) returns (bool erc721) {\n            require(!erc721, \"This address seems an ERC721 contract\");\n        } catch Error(string memory /*reason*/) {\n            // success\n        } catch (bytes memory /*reason*/) {\n            // success\n        }\n        Storage.chain.registeredERC20s[tokenAddr] = true;\n        emit NewErc20(tokenAddr);\n    }\n\n    /**\n     * @dev Provide registered erc20 token information for decryption\n     * 1. verify erc721 token\n     * 2. governance to register the token address\n     */\n    function registerERC721(address tokenAddr) public {\n        require(!Storage.chain.registeredERC721s[tokenAddr], \"Already registered\");\n        // Make sure that this token is an ERC721\n        try IERC165(tokenAddr).supportsInterface(_INTERFACE_ID_ERC721) returns (bool erc721) {\n            require(erc721, \"This address is not an ERC721 contract\");\n        } catch Error(string memory reason) {\n            revert(reason);\n        } catch (bytes memory reason) {\n            revert(string(reason));\n        }\n        Storage.chain.registeredERC721s[tokenAddr] = true;\n        emit NewErc721(tokenAddr);\n    }\n\n    /**\n     * @dev You can override this function to implement your own consensus logic.\n     * @param proposerAddr Coordinator address to check the allowance of block proposing.\n     */\n    function isProposable(address proposerAddr) public view returns (bool) {\n        Proposer memory  proposer = Storage.chain.proposers[proposerAddr];\n        // You can add more consensus logic here\n        if (proposer.stake >= MINIMUM_STAKE) {\n            return IConsensusProvider(consensusProvider).isProposable(proposerAddr);\n        } else {\n            return false;\n        }\n    }\n}\n\n//  TODO - If the gas usage exceeds the challenge limit, the proposer will get slashed\n//  TODO - instant withdrawal\n//  TODO - guarantee of tx including\n//  Some thoughts - There exists a possibility of racing condition to get the slash reward\n", "flattened_code": "// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n\nstruct Hasher {\n    function (uint256, uint256) internal pure returns (uint256) parentOf;\n    uint256[] preHashedZero;\n}\n\nlibrary MerkleTreeLib {\n    using SafeMath for uint256;\n\n    function append(\n        Hasher memory self,\n        uint256 startingRoot,\n        uint256 index,\n        uint256[] memory leaves,\n        uint256[] memory initialSiblings\n    ) internal pure returns (uint256 newRoot) {\n        newRoot = startingRoot;\n        require(self.preHashedZero.length == initialSiblings.length + 1, \"Submitted invalid length of siblings\");\n        require(_startingLeafProof(self, startingRoot, index, initialSiblings), \"Invalid merkle proof of starting leaf node\");\n        uint256 nextIndex = index;\n        uint256[] memory nextSiblings = initialSiblings;\n        for (uint256 i = 0; i < leaves.length; i++) {\n            (newRoot, nextIndex, nextSiblings) = _append(self, nextIndex, leaves[i], nextSiblings);\n        }\n    }\n\n    function merkleProof(\n        Hasher memory self,\n        uint256 root,\n        uint256 leaf,\n        uint256 index,\n        uint256[] memory siblings\n    ) internal pure returns (bool) {\n        return merkleRoot(self, leaf, index, siblings) == root;\n    }\n\n    function merkleRoot(\n        Hasher memory self,\n        uint256 leaf,\n        uint256 index,\n        uint256[] memory siblings\n    ) internal pure returns (uint256) {\n        uint256 path = index;\n        uint256 node = leaf;\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // right sibling\n                node = self.parentOf(node, siblings[i]);\n            } else {\n                // left sibling\n                node = self.parentOf(siblings[i], node);\n            }\n            path >>= 1;\n        }\n        return node;\n    }\n\n    function _startingLeafProof(\n        Hasher memory self,\n        uint256 root,\n        uint256 index,\n        uint256[] memory siblings\n    ) internal pure returns (bool) {\n        uint256 path = index;\n        uint256 node = self.preHashedZero[0];\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // Right sibling should be a prehashed zero\n                if (siblings[i] != self.preHashedZero[i]) {\n                    return false;\n                }\n                node = self.parentOf(node, siblings[i]);\n            } else {\n                // Left sibling should not be a prehashed zero\n                if (siblings[i] == self.preHashedZero[i]) {\n                    return false;\n                }\n                node = self.parentOf(siblings[i], node);\n            }\n            path >>= 1;\n        }\n        return node == root;\n    }\n\n    function _append(\n        Hasher memory self,\n        uint256 index,\n        uint256 leaf,\n        uint256[] memory siblings\n    ) internal pure returns(\n        uint256 nextRoot,\n        uint256 nextIndex,\n        uint256[] memory nextSiblings\n    ) {\n        nextSiblings = new uint256[](siblings.length);\n        uint256 path = index;\n        uint256 node = leaf;\n        for (uint256 level = 0; level < siblings.length; level++) {\n            if (path % 2 == 0) {\n                // right empty sibling\n                nextSiblings[level] = node; // current node will be the next merkle proof's left sibling\n                node = self.parentOf(node, self.preHashedZero[level]);\n            } else {\n                // left sibling\n                nextSiblings[level] = siblings[level]; // keep current sibling\n                node = self.parentOf(siblings[level], node);\n            }\n            path >>= 1;\n        }\n        nextRoot = node;\n        nextIndex = index + 1;\n    }\n}\n\nlibrary SubTreeLib {\n    using MerkleTreeLib for Hasher;\n    using MerkleTreeLib for bytes32;\n\n    function appendSubTree(\n        Hasher memory self,\n        uint256 startingRoot,\n        uint256 index,\n        uint256 subTreeDepth,\n        uint256[] memory leaves,\n        uint256[] memory subTreeSiblings\n    ) internal pure returns (uint256 newRoot) {\n        newRoot = startingRoot;\n        require(index % (1 << subTreeDepth) == 0, \"Can't merge a subTree\");\n        require(\n            self.preHashedZero.length == subTreeDepth + subTreeSiblings.length + 1,\n            \"Should submit subtree's siblings\"\n        );\n        require(_emptySubTreeProof(self, startingRoot, index, subTreeDepth, subTreeSiblings), \"Insertion is not allowed\");\n        uint256 nextIndex = index;\n        uint256[][] memory subTrees = splitToSubTrees(leaves, subTreeDepth);\n        uint256[] memory nextSiblings = subTreeSiblings;\n        for (uint256 i = 0; i < subTrees.length; i++) {\n            (newRoot, nextIndex, nextSiblings) = _appendSubTree(\n                self,\n                nextIndex,\n                subTreeDepth,\n                subTrees[i],\n                nextSiblings\n            );\n        }\n        return newRoot;\n    }\n\n    function splitToSubTrees(\n        uint256[] memory leaves,\n        uint256 subTreeDepth\n    ) internal pure returns (uint256[][] memory subTrees) {\n        uint256 subTreeSize = 1 << subTreeDepth;\n        uint256 numOfSubTrees = (leaves.length / subTreeSize) + (leaves.length % subTreeSize == 0 ? 0 : 1);\n        subTrees = new uint256[][](numOfSubTrees);\n        for (uint256 i = 0; i < numOfSubTrees; i++) {\n            subTrees[i] = new uint256[](subTreeSize);\n        }\n        uint256 index = 0;\n        uint256 subTreeIndex = 0;\n        for (uint256 i = 0; i < leaves.length; i++) {\n            subTrees[subTreeIndex][index] = leaves[i];\n            if (index < subTreeSize - 1) {\n                index += 1;\n            } else {\n                index = 0;\n                subTreeIndex += 1;\n            }\n        }\n    }\n\n    /**\n     * @param siblings If the merkle tree depth is \"D\" and the subTree's\n     *          depth is \"d\", the length of the siblings should be \"D - d\".\n     */\n    function _emptySubTreeProof(\n        Hasher memory self,\n        uint256 root,\n        uint256 index,\n        uint256 subTreeDepth,\n        uint256[] memory siblings\n    ) internal pure returns (bool) {\n        uint256 subTreePath = index >> subTreeDepth;\n        uint256 path = subTreePath;\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // Right sibling should be a prehashed zero\n                if(siblings[i] != self.preHashedZero[i + subTreeDepth]) return false;\n            } else {\n                // Left sibling should not be a prehashed zero\n                if(siblings[i] == self.preHashedZero[i + subTreeDepth]) return false;\n            }\n            path >>= 1;\n        }\n        return self.merkleProof(root, self.preHashedZero[subTreeDepth], subTreePath, siblings);\n    }\n\n    function _appendSubTree(\n        Hasher memory self,\n        uint256 index,\n        uint256 subTreeDepth,\n        uint256[] memory leaves,\n        uint256[] memory siblings\n    ) internal pure returns(\n        uint256 nextRoot,\n        uint256 nextIndex,\n        uint256[] memory nextSiblings\n    ) {\n        uint256 subTreeSize = 1 << subTreeDepth;\n        require(leaves.length <= subTreeSize, \"Overflowed\");\n        nextSiblings = new uint256[](siblings.length);\n        uint256 subTreePath = index >> subTreeDepth;\n        uint256 path = subTreePath;\n        uint256 node = _subTreeRoot(self, subTreeDepth, leaves);\n        for (uint256 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // right empty sibling\n                nextSiblings[i] = node; // current node will be the next merkle proof's left sibling\n                node = self.parentOf(node, self.preHashedZero[i + subTreeDepth]);\n            } else {\n                // left sibling\n                nextSiblings[i] = siblings[i]; // keep current sibling\n                node = self.parentOf(siblings[i], node);\n            }\n            path >>= 1;\n        }\n        nextRoot = node;\n        nextIndex = index + (1 << subTreeDepth);\n    }\n\n    function _subTreeRoot(\n        Hasher memory self,\n        uint256 subTreeDepth,\n        uint256[] memory leaves\n    ) internal pure returns (uint256) {\n        // Example of a sub tree with depth 3\n        //                      1\n        //          10                       11\n        //    100        101         110           [111]\n        // 1000 1001  1010 1011   1100 [1101]  [1110] [1111]\n        //   o   o     o    o       o    x       x       x\n        //\n        // whereEmptyNodeStart (1101) = leaves.length + tree_size\n        // []: nodes that we can use the pre hashed zeroes\n        //\n        // * ([1101] << 0) is gte than (1101) => we can use the pre hashed zeroes\n        // * ([1110] << 0) is gte than (1101) => we can use the pre hashed zeroes\n        // * ([1111] << 0) is gte than (1101) => we can use pre hashed zeroes\n        // * ([111] << 1) is gte than (1101) => we can use pre hashed zeroes\n        // * (11 << 2) is less than (1101) => we cannot use pre hashed zeroes\n        // * (1 << 3) is less than (1101) => we cannot use pre hashed zeroes\n\n        uint256 treeSize = 1 << subTreeDepth;\n        require(leaves.length <= treeSize, \"Overflowed\");\n\n        uint256[] memory nodes = new uint256[](treeSize << 1); // we'll not use nodes[0]\n        uint256 emptyNode = treeSize + leaves.length; // we do not hash if we can use pre hashed zeroes\n\n        // From the bottom to the top\n        for (uint256 level = 0; level <= subTreeDepth; level++) {\n            uint256 leftMostOfTheFloor = treeSize >> level;\n            // From the right to the left\n            for (\n                uint256 nodeIndex = (leftMostOfTheFloor << 1 ) - 1;\n                nodeIndex >= leftMostOfTheFloor;\n                nodeIndex--\n            )\n            {\n                if (nodeIndex < emptyNode) {\n                    // This node is not an empty node\n                    if (level == 0) {\n                        // Leaf node\n                        nodes[nodeIndex] = leaves[nodeIndex - treeSize];\n                    } else {\n                        // Parent node\n                        uint256 leftChild = nodeIndex << 1;\n                        uint256 rightChild = leftChild + 1;\n                        nodes[nodeIndex] = self.parentOf(nodes[leftChild], nodes[rightChild]);\n                    }\n                } else {\n                    // Use pre hashed\n                    nodes[nodeIndex] = self.preHashedZero[level];\n                }\n            }\n            leftMostOfTheFloor >>= 1;\n            emptyNode >>= 1;\n        }\n        return nodes[1];\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// Copyright 2017 Christian Reitwiessner\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// 2019 OKIMS\n\npragma solidity = 0.6.12;\n\n// Moved G1Point, G2Point struct to the top level - by ws\nstruct G1Point {\n    uint256 X;\n    uint256 Y;\n}\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] X;\n    uint256[2] Y;\n}\n\n\nlibrary Pairing {\n\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    /*\n     * @return The negation of p, i.e. p.plus(p.negate()) should be zero. \n     */\n    function negate(G1Point memory p) internal pure returns (G1Point memory) {\n\n        // The prime q in the base field F_q for G1\n        if (p.X == 0 && p.Y == 0) {\n            return G1Point(0, 0);\n        } else {\n            return G1Point(p.X, PRIME_Q - (p.Y % PRIME_Q));\n        }\n    }\n\n    /*\n     * @return The sum of two points of G1\n     */\n    function plus(\n        G1Point memory p1,\n        G1Point memory p2\n    ) internal view returns (G1Point memory r) {\n\n        uint256[4] memory input;\n        input[0] = p1.X;\n        input[1] = p1.Y;\n        input[2] = p2.X;\n        input[3] = p2.Y;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success,\"pairing-add-failed\");\n    }\n\n    /*\n     * @return The product of a point on G1 and a scalar, i.e.\n     *         p == p.scalar_mul(1) and p.plus(p) == p.scalar_mul(2) for all\n     *         points p.\n     */\n    function scalar_mul(G1Point memory p, uint256 s) internal view returns (G1Point memory r) {\n\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n        require (success,\"pairing-mul-failed\");\n    }\n\n    /* @return The result of computing the pairing check\n     *         e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n     *         For example,\n     *         pairing([P1(), P1().negate()], [P2(), P2()]) should return true.\n     */\n    function pairing(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n\n        G1Point[4] memory p1 = [a1, b1, c1, d1];\n        G2Point[4] memory p2 = [a2, b2, c2, d2];\n\n        uint256 inputSize = 24;\n        uint256[] memory input = new uint256[](inputSize);\n\n        for (uint256 i = 0; i < 4; i++) {\n            uint256 j = i * 6;\n            input[j + 0] = p1[i].X;\n            input[j + 1] = p1[i].Y;\n            input[j + 2] = p2[i].X[0];\n            input[j + 3] = p2[i].X[1];\n            input[j + 4] = p2[i].Y[0];\n            input[j + 5] = p2[i].Y[1];\n        }\n\n        uint256[1] memory out;\n        bool success;\n\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n            // Use \"invalid\" to make gas estimation work\n            switch success case 0 { invalid() }\n        }\n\n        require(success, \"pairing-opcode-failed\");\n\n        // return out[0] != 0;\n        return true;\n    }\n}\n\nstruct Blockchain {\n    bytes32 genesis;\n    bytes32 latest;\n\n    // For coordinating\n    uint256 proposedBlocks;\n    mapping(address=>Proposer) proposers;\n    mapping(bytes32=>Proposal) proposals;\n    mapping(bytes32=>bool) finalized; // blockhash => finalized?\n    mapping(bytes32=>bool) slashed; // blockhash => slashed\n\n    // For inclusion reference\n    mapping(bytes32=>bytes32) parentOf; // childBlockHash => parentBlockHash\n    mapping(bytes32=>uint256) utxoRootOf; // blockhash => utxoRoot\n    mapping(uint256=>bool) finalizedUTXORoots; // all finalized utxo roots\n\n    // For deposit\n    MassDeposit stagedDeposits;\n    uint256 stagedSize;\n    uint256 massDepositId;\n    mapping(bytes32=>uint256) committedDeposits;\n\n    // For withdrawal\n    mapping(bytes32=>uint256) withdrawalRootOf; // header => withdrawalRoot\n    mapping(bytes32=>bool) withdrawn;\n    mapping(bytes32=>address) newWithdrawalOwner;\n\n    // For migrations\n    mapping(bytes32=>bool) migrations;\n\n    // For ERC20 and ERC721\n    mapping(address=>bool) registeredERC20s;\n    mapping(address=>bool) registeredERC721s;\n}\n\nstruct MassDeposit {\n    bytes32 merged;\n    uint256 fee;\n}\n\n// needs gas limit\nstruct MassMigration {\n    address destination;\n    uint256 totalETH;\n    MassDeposit migratingLeaves;\n    ERC20Migration[] erc20;\n    ERC721Migration[] erc721;\n}\n\nstruct ERC20Migration {\n    address addr;\n    uint256 amount;\n}\n\nstruct ERC721Migration {\n    address addr;\n    uint256[] nfts;\n}\n\nstruct WithdrawalTree {\n    // Merkle tree of WithdrawalTree notes\n    uint256 root;\n    uint256 index;\n}\n\nstruct Finalization {\n    bytes32 proposalChecksum;\n    Header header;\n    MassDeposit[] massDeposits;\n    MassMigration[] massMigrations;\n}\n\nstruct Proposer {\n    uint256 stake;\n    uint256 reward;\n    uint256 exitAllowance; // block number\n}\n\nstruct Proposal {\n    bytes32 headerHash;\n    uint256 challengeDue;\n}\n\nstruct Block {\n    Header header;\n    Body body;\n}\n\nstruct Header {\n    // basic data\n    address proposer;\n    bytes32 parentBlock;\n    uint256 fee;\n\n    // UTXO roll up\n    uint256 utxoRoot;\n    uint256 utxoIndex;\n\n    // Nullifier roll up\n    bytes32 nullifierRoot;\n\n    // Withdrawal roll up\n    uint256 withdrawalRoot;\n    uint256 withdrawalIndex;\n\n    // Transactions\n    bytes32 txRoot;\n    bytes32 depositRoot;\n    bytes32 migrationRoot;\n}\n\nstruct Body {\n    Transaction[] txs;\n    MassDeposit[] massDeposits;\n    MassMigration[] massMigrations;\n}\n\nstruct Transaction {\n    Inflow[] inflow;\n    Outflow[] outflow;\n    uint256 swap;\n    uint256 fee;\n    Proof proof;\n    bytes memo; // encrypted memo field\n}\n\nstruct Inflow {\n    uint256 inclusionRoot;\n    bytes32 nullifier;\n}\n\nstruct Outflow {\n    uint256 note;\n    uint8 outflowType; // 0 = UTXO, 1 = Withdrawal, 2 = Migration\n    PublicData publicData; // Only for withdrawal & migration\n}\n\nenum OutflowType { UTXO, Withdrawal, Migration }\n\n// Only used for migration\nstruct PublicData {\n    address to; // to == 0: UTXO / to == address(this): Withdrawal / else: Migration\n    uint256 eth;\n    address token;\n    uint256 amount;\n    uint256 nft;\n    uint256 fee;\n}\n\nstruct AtomicSwap {\n    uint256[2] binder;\n    uint256[2] counterpart;\n}\n\nstruct Proof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nlibrary Types {\n    function init(Blockchain storage chain, bytes32 genesis) internal {\n        chain.latest = genesis;\n        chain.genesis = genesis;\n        chain.proposedBlocks++;\n    }\n\n    function hash(Header memory header) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                header.proposer,\n                header.parentBlock,\n                header.fee,\n                header.utxoRoot,\n                header.utxoIndex,\n                header.nullifierRoot,\n                header.withdrawalRoot,\n                header.withdrawalIndex,\n                header.txRoot,\n                header.depositRoot,\n                header.migrationRoot\n            )\n        );\n    }\n\n    function hash(Transaction memory transaction) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                toBytes(transaction.inflow),\n                toBytes(transaction.outflow),\n                transaction.swap,\n                toBytes(transaction.proof),\n                transaction.fee\n            )\n        );\n    }\n\n    function toBytes(Inflow memory inflow) internal pure returns (bytes memory) {\n        return abi.encodePacked(inflow.inclusionRoot, inflow.nullifier);\n    }\n\n    function toBytes(Inflow[] memory inflow) internal pure returns (bytes memory) {\n        bytes memory packed;\n        for(uint256 i = 0; i < inflow.length; i++) {\n            packed = abi.encodePacked(packed, toBytes(inflow[i]));\n        }\n        return packed;\n    }\n\n    function toBytes(Outflow memory outflow) internal pure returns (bytes memory) {\n        if(isUTXO(outflow)) {\n            return abi.encodePacked(outflow.note);\n        } else {\n            return abi.encodePacked(\n                outflow.note,\n                outflow.publicData.to,\n                outflow.publicData.eth,\n                outflow.publicData.token,\n                outflow.publicData.amount,\n                outflow.publicData.nft,\n                outflow.publicData.fee\n            );\n        }\n    }\n\n    function toBytes(Outflow[] memory outflow) internal pure returns (bytes memory) {\n        bytes memory packed;\n        for(uint256 i = 0; i < outflow.length; i++) {\n            packed = abi.encodePacked(packed, toBytes(outflow[i]));\n        }\n        return packed;\n    }\n\n    function toBytes(AtomicSwap memory swap) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            swap.binder,\n            swap.counterpart\n        );\n    }\n\n    function toBytes(Proof memory proof) internal pure returns (bytes memory) {\n        return abi.encodePacked(\n            proof.a.X,\n            proof.a.Y,\n            proof.b.X[0],\n            proof.b.X[1],\n            proof.b.Y[0],\n            proof.b.Y[1],\n            proof.c.X,\n            proof.c.Y\n        );\n    }\n\n    function withdrawalNote(Outflow memory outflow) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                outflow.publicData.to,\n                outflow.publicData.eth,\n                outflow.publicData.token,\n                outflow.publicData.amount,\n                outflow.publicData.nft,\n                outflow.publicData.fee\n            )\n        );\n    }\n\n    function isUTXO(Outflow memory outflow) internal pure returns (bool) {\n        return outflow.publicData.to == address(0);\n    }\n\n    function hash(MassDeposit memory massDeposit) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                massDeposit.merged,\n                massDeposit.fee\n            )\n        );\n    }\n    function hash(MassMigration memory massMigration) internal pure returns (bytes32) {\n        bytes memory packed;\n        packed = abi.encodePacked(\n            packed,\n            massMigration.destination,\n            massMigration.migratingLeaves.merged,\n            massMigration.migratingLeaves.fee\n        );\n        for(uint256 i = 0; i < massMigration.erc20.length; i++) {\n            packed = abi.encodePacked(\n                packed,\n                massMigration.erc20[i].addr,\n                massMigration.erc20[i].amount\n            );\n        }\n        for(uint256 i = 0; i < massMigration.erc20.length; i++) {\n            packed = abi.encodePacked(\n                packed,\n                massMigration.erc721[i].addr,\n                massMigration.erc721[i].nfts\n            );\n        }\n        return keccak256(packed);\n    }\n\n    function root(Transaction[] memory transactions) internal pure returns (bytes32) {\n        bytes32[] memory leaves = new bytes32[](transactions.length);\n        for(uint256 i = 0; i < transactions.length; i++) {\n            leaves[i] = hash(transactions[i]);\n        }\n        return root(leaves);\n    }\n\n    function root(MassDeposit[] memory massDeposits) internal pure returns (bytes32) {\n        bytes32[] memory leaves = new bytes32[](massDeposits.length);\n        for(uint256 i = 0; i < massDeposits.length; i++) {\n            leaves[i] = hash(massDeposits[i]);\n        }\n        return root(leaves);\n    }\n\n    function root(MassMigration[] memory massMigrations) internal pure returns (bytes32) {\n        bytes32[] memory leaves = new bytes32[](massMigrations.length);\n        for(uint256 i = 0; i < massMigrations.length; i++) {\n            leaves[i] = hash(massMigrations[i]);\n        }\n        return root(leaves);\n    }\n\n    function root(bytes32[] memory leaves) internal pure returns (bytes32) {\n        if(leaves.length == 0) {\n            return bytes32(0);\n        } else if(leaves.length == 1) {\n            return leaves[0];\n        }\n        bytes32[] memory nodes = new bytes32[]((leaves.length + 1)/2);\n        bool hasEmptyLeaf = leaves.length % 2 == 1;\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            if(hasEmptyLeaf && i == nodes.length - 1) {\n                nodes[i] = keccak256(abi.encodePacked(leaves[i*2], bytes32(0)));\n            } else {\n                nodes[i] = keccak256(abi.encodePacked(leaves[i*2], leaves[i*2+1]));\n            }\n        }\n        return root(nodes);\n    }\n\n    function root(uint256[] memory leaves) internal pure returns (bytes32) {\n        bytes32[] memory converted;\n        assembly {\n            converted := leaves\n        }\n        return root(converted);\n    }\n\n    function isEmpty(PublicData memory publicData) internal pure returns (bool) {\n        if(publicData.to != address(0)) return false;\n        if(publicData.eth != 0) return false;\n        if(publicData.token != address(0)) return false;\n        if(publicData.amount != 0) return false;\n        if(publicData.nft != 0) return false;\n        if(publicData.fee != 0) return false;\n        return true;\n    }\n\n    // TODO temporal calculation\n    function maxChallengeCost(Block memory blockData) internal pure returns (uint256 maxCost) {\n    }\n\n    function getSNARKSignature(\n        uint8 numberOfInputs,\n        uint8 numberOfOutputs\n    ) internal pure returns (uint256) {\n        return (uint256(numberOfInputs) << 128) + numberOfOutputs;\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\npragma experimental ABIEncoderV2;\n\n\nlibrary SNARK {\n    using Pairing for *;\n    \n    struct VerifyingKey {\n        G1Point alpha1;\n        G2Point beta2;\n        G2Point gamma2;\n        G2Point delta2;\n        G1Point[] ic;\n    }\n\n    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    function verify(VerifyingKey memory vk, uint256[] memory input, Proof memory proof) internal view returns (bool) {\n        require(input.length + 1 == vk.ic.length,\"verifier-bad-input\");\n        // Compute the linear combination vkX\n        G1Point memory vkX = G1Point(0, 0);\n\n        // Make sure that proof.A, B, and C are each less than the prime q\n        require(proof.a.X < PRIME_Q, \"verifier-aX-gte-prime-q\");\n        require(proof.a.Y < PRIME_Q, \"verifier-aY-gte-prime-q\");\n\n        require(proof.b.X[0] < PRIME_Q, \"verifier-bX0-gte-prime-q\");\n        require(proof.b.Y[0] < PRIME_Q, \"verifier-bY0-gte-prime-q\");\n\n        require(proof.b.X[1] < PRIME_Q, \"verifier-bX1-gte-prime-q\");\n        require(proof.b.Y[1] < PRIME_Q, \"verifier-bY1-gte-prime-q\");\n\n        require(proof.c.X < PRIME_Q, \"verifier-cX-gte-prime-q\");\n        require(proof.c.Y < PRIME_Q, \"verifier-cY-gte-prime-q\");\n\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < SNARK_SCALAR_FIELD,\"verifier-gte-snark-scalar-field\");\n            vkX = Pairing.plus(vkX, Pairing.scalar_mul(vk.ic[i + 1], input[i]));\n        }\n        vkX = Pairing.plus(vkX, vk.ic[0]);\n        return Pairing.pairing(\n            Pairing.negate(proof.a),\n            proof.b,\n            vk.alpha1,\n            vk.beta2,\n            vkX,\n            vk.gamma2,\n            proof.c,\n            vk.delta2\n        );\n    }\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ncontract Config is Ownable {\n    uint256 constant public UTXO_TREE_DEPTH = 48;\n    uint256 constant public MAX_UTXO = (1 << UTXO_TREE_DEPTH);\n    uint256 constant public WITHDRAWAL_TREE_DEPTH = 48;\n    uint256 constant public MAX_WITHDRAWAL = (1 << WITHDRAWAL_TREE_DEPTH);\n    uint256 constant public NULLIFIER_TREE_DEPTH = 254;\n\n    uint256 constant public UTXO_SUB_TREE_DEPTH = 5; // 32 items at once\n    uint256 constant public UTXO_SUB_TREE_SIZE = 1 << UTXO_SUB_TREE_DEPTH;\n    uint256 constant public WITHDRAWAL_SUB_TREE_DEPTH = 5; // 32 items at once\n    uint256 constant public WITHDRAWAL_SUB_TREE_SIZE = 1 << WITHDRAWAL_SUB_TREE_DEPTH;\n\n    uint256 public MAX_BLOCK_SIZE = 200000; // 3.2M gas for calldata\n    uint256 public MAX_VALIDATION_GAS = 6000000; // 6M gas\n    // 46523 blocks when the challenge period is 7 days and average block time is 13 sec\n    uint256 public CHALLENGE_PERIOD = 46523;\n    uint256 public MINIMUM_STAKE = 32 ether;\n    uint256 public REF_DEPTH = 128;\n\n    address public consensusProvider;\n}\n\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\nlibrary SMT254 {\n    // in Solidity: keccak256('exist')\n    // in Web3JS: soliditySha3('exist')\n    bytes32 constant public EXIST = bytes32(uint256(1));\n    // in Solidity: keccak256(abi.encodePacked(bytes32(0)))\n    // in Web3JS: soliditySha3(0)\n    bytes32 constant public NON_EXIST = 0;\n\n    function inclusionProof(\n        bytes32 root,\n        bytes32 leaf,\n        bytes32[254] memory siblings\n    ) internal pure returns(bool) {\n        return merkleProof(root, leaf, EXIST, siblings);\n    }\n\n    function nonInclusionProof(\n        bytes32 root,\n        bytes32 leaf,\n        bytes32[254] memory siblings\n    ) internal pure returns(bool) {\n        return merkleProof(root, leaf, NON_EXIST, siblings);\n    }\n\n    function merkleProof(\n        bytes32 root,\n        bytes32 leaf,\n        bytes32 value,\n        bytes32[254] memory siblings\n    ) internal pure returns(bool) {\n        require(calculateRoot(leaf, value, siblings) == root, \"Invalid merkle proof\");\n        return true;\n    }\n\n    function calculateRoot(\n        bytes32 leaf,\n        bytes32 value,\n        bytes32[254] memory siblings\n    ) internal pure returns (bytes32) {\n        bytes32 cursor = value;\n        uint256 path = uint256(leaf);\n        for (uint16 i = 0; i < siblings.length; i++) {\n            if (path % 2 == 0) {\n                // Right sibling\n                cursor = keccak256(abi.encodePacked(cursor, siblings[i]));\n            } else {\n                // Left sibling\n                cursor = keccak256(abi.encodePacked(siblings[i], cursor));\n            }\n            path = path >> 1;\n        }\n        return cursor;\n    }\n\n    function fill(\n        bytes32 prevRoot,\n        bytes32 leaf,\n        bytes32[254] memory siblings\n    ) internal pure returns (bytes32 nextRoot) {\n        // Prove that the array of sibling is valid and also the leaf does not exist in the tree\n        require(nonInclusionProof(prevRoot, leaf, siblings), \"Failed to build the previous root using the leaf and its sibling\");\n        // Calculate the new root when the leaf exists using its proven siblings\n        nextRoot = calculateRoot(leaf, EXIST, siblings);\n        // Make sure it has been updated\n        require(prevRoot != nextRoot, \"Already existing leaf\");\n    }\n\n    function fill(\n        bytes32 prevRoot,\n        bytes32[] memory leaves,\n        bytes32[254][] memory siblings\n    ) internal pure returns (bytes32 nextRoot) {\n        // Inspect the RollUp structure\n        require(leaves.length == siblings.length, \"Both array should have same length\");\n        // Start from the root\n        bytes32 root = prevRoot;\n        // Update the root using fill function\n        for (uint256 i = 0; i < leaves.length; i ++) {\n            root = fill(root, leaves[i], siblings[i]);\n        }\n        return root;\n    }\n}\n\ncontract Storage is Config {\n    // State of the layer2 blockchain is maintained by the optimistic roll up\n    Blockchain chain;\n\n    // Addresses where to execute the given function call\n    mapping(bytes4=>address) public proxied;\n\n    // Addresses of onchain validation contracts\n    mapping(bytes4=>address) public validators;\n\n    // SNARK verifying keys assigned by the setup wizard for each tx type\n    mapping(uint256=>SNARK.VerifyingKey) vks;\n\n    // Addresses allowed to migrate from. Setup wizard manages the list\n    mapping(address=>bool) public allowedMigrants;\n}\n// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity = 0.6.12;\n\n\nlibrary Poseidon2 {\n    /**\n     * @dev This is a dummy implementation for contract compilation\n     * We'll use a generated library by circomlib instead of this dummy library\n     * Please see\n     * 1. migrations/3_deploy_poseidon.js\n     * 2. https://github.com/iden3/circomlib/blob/master/src/poseidon_gencontract.js\n     */\n    function poseidon(uint256[] calldata) external pure returns(uint256) {\n        return 0;\n    }\n}\n\nlibrary Poseidon3 {\n    /**\n     * @dev This is a dummy implementation for contract compilation\n     * We'll use a generated library by circomlib instead of this dummy library\n     * Please see\n     * 1. migrations/3_deploy_poseidon.js\n     * 2. https://github.com/iden3/circomlib/blob/master/src/poseidon_gencontract.js\n     */\n    function poseidon(uint256[] calldata) external pure returns(uint256) {\n        return 0;\n    }\n}\n\nlibrary Poseidon4 {\n    /**\n     * @dev This is a dummy implementation for contract compilation\n     * We'll use a generated library by circomlib instead of this dummy library\n     * Please see\n     * 1. migrations/3_deploy_poseidon.js\n     * 2. https://github.com/iden3/circomlib/blob/master/src/poseidon_gencontract.js\n     */\n    function poseidon(uint256[] calldata) external pure returns(uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev This will be used to provide hash functions to calculate roll up.\n *      Please see MerkleTreeLib.sol from 'merkle-tree-rollup'.\n */\nlibrary Hash {\n    uint256 constant k =  21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n    function poseidon() internal pure returns (Hasher memory) {\n        return Hasher(poseidonParentOf, poseidonPrehashedZeroes());\n    }\n\n    /**\n     * @dev Costs about 100k gas\n     */\n    function poseidonParentOf(uint256 left, uint256 right) internal pure returns (uint256) {\n        uint256[] memory res = new uint256[](2);\n        res[0] = left;\n        res[1] = right;\n        try Poseidon2.poseidon(res) returns (uint256 val) {\n            return val;\n        } catch {\n            revert(\"poseidon hash error\");\n        }\n    }\n\n    function poseidonPrehashedZeroes() internal pure returns (uint256[] memory preHashed) {\n        preHashed = new uint256[](49);\n        preHashed[0] = 0;\n        preHashed[1] = 10600974484483636649191836183331859514454108476826376357941356292578099372400;\n        preHashed[2] = 21794476778427377126059366449788686607895945400675042941280102093665559598175;\n        preHashed[3] = 2436929412409273971247897342963836206109725384909989018993604443786196167079;\n        preHashed[4] = 16795971212351522389263710863137077078214825169846509011929499600964499735050;\n        preHashed[5] = 13219681652802262400226541382497744859725228879557499223706656560508858332284;\n        preHashed[6] = 16077415043335295839603287133858682446972083000831421492129903860562380669637;\n        preHashed[7] = 502327552794018830492963939468986095778588873732395241302862672501374866469;\n        preHashed[8] = 17316932530822847310778297511893782089230531647975443264466851693705942399213;\n        preHashed[9] = 15616967174077889152093898696441462010235212806608416549656188924405260247520;\n        preHashed[10] = 12190821404971533019165426092513461076028437957291902632838999055821897583490;\n        preHashed[11] = 16555028449797792480572832506992372535201158677714945803879012251354763331859;\n        preHashed[12] = 8231705230240651230537572725530833127444944283000004623928536619628228934194;\n        preHashed[13] = 3077550723437915419104207012579575734231701844853976167144530179212424050931;\n        preHashed[14] = 21763696456923873365073754080645198026461423046360831704057969664583515901721;\n        preHashed[15] = 67141086259845765994826791686185563664511508469575310323320621339898305036;\n        preHashed[16] = 3624208598265904886738968685803615152975472463538997991139575048534610424717;\n        preHashed[17] = 8676144851288185870896103351878389773782247068899092359631289704737412042232;\n        preHashed[18] = 13238330640648007528634160449350536125916169295342140059757257691192126867979;\n        preHashed[19] = 7629979400019171337168423414609244365318871324132477886392009656933248919644;\n        preHashed[20] = 17216708267491716820765977769753349546409338100471140224707568935140015239541;\n        preHashed[21] = 11032037682276971475370797274652951818817419346055678538386520770346150554858;\n        preHashed[22] = 10513188655612264610639309345357023572819674417089822243543789426195372519458;\n        preHashed[23] = 20830246484199144121270459776609618477426103665100784158598304005532171231316;\n        preHashed[24] = 14643959052806370295783622182926307921956713992546430641832487667576487046071;\n        preHashed[25] = 12119291572639831440678081618795940194258648574679550148918006799979881284464;\n        preHashed[26] = 13750563915408596218593142901395486535832472899236176573304451439811156557055;\n        preHashed[27] = 12907606178576131793702229776336195584587379579829260210095886803937822938528;\n        preHashed[28] = 13566176060365945107460500823464340046804824004704104386373703757946826255443;\n        preHashed[29] = 3009017506736485220239996395726299306996097787311048019632232229030423680587;\n        preHashed[30] = 21724845982339994137711944825542880106108735522617894947541637950424101339449;\n        preHashed[31] = 60386645284463199583445465572728164220538858039953884251650918083929763515;\n        preHashed[32] = 1592711413674761513405971810003404198688350605293799559384385405041395766194;\n        preHashed[33] = 14301516436643055045149109088855694557420746657725164659766413999811862291456;\n        preHashed[34] = 15921849220790204754735378712104286100899979049583142302521522792105492783919;\n        preHashed[35] = 731934832871647620741636264208684467123503262905121663067794120328092378570;\n        preHashed[36] = 18594386615908007655786955006792973928646499172983204159345011756342104179726;\n        preHashed[37] = 21403312021111361442177462312539794489440477815302791844841091759479516900086;\n        preHashed[38] = 17895432372310760551979403007617520876638797221531830301793148922789216157001;\n        preHashed[39] = 4046320522306284054744909476688821930829401455132175453981105518049156544596;\n        preHashed[40] = 21308652235294521203949455324101573347326725563669617684423526382035190882040;\n        preHashed[41] = 9307558633100119005416786313499541804276667918366544329554442874107210818008;\n        preHashed[42] = 12096189432791920614550311407338568058300637088225040717271755202689760990069;\n        preHashed[43] = 19823437509870604295178309989523899027391648832731860668528138144905229555596;\n        preHashed[44] = 6964798124447762099265638561733651799459494941130544021880669315667107478958;\n        preHashed[45] = 7270233836638236002899669836456396743979691360169767700191498626702755802269;\n        preHashed[46] = 1740310102929396229334577845559329925566414851949444893300244205344733658171;\n        preHashed[47] = 9023345516637064449644297334443052792369346575394200069833851209363060173178;\n        preHashed[48] = 3092784425575682849215806387188191163008086618667633588848126820278484295451;\n    }\n\n    function keccak() internal pure returns (Hasher memory) {\n        return Hasher(keccakParentOf, keccakPrehashedZeroes());\n    }\n\n    function keccakParentOf(uint256 left, uint256 right) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(left, right)));\n    }\n\n    function keccakPrehashedZeroes() internal pure returns (uint256[] memory preHashed) {\n        preHashed = new uint256[](49);\n        preHashed[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;\n        preHashed[1] = 0xad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5;\n        preHashed[2] = 0xb4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30;\n        preHashed[3] = 0x21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85;\n        preHashed[4] = 0xe58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344;\n        preHashed[5] = 0x0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d;\n        preHashed[6] = 0x887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968;\n        preHashed[7] = 0xffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83;\n        preHashed[8] = 0x9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af;\n        preHashed[9] = 0xcefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0;\n        preHashed[10] = 0xf9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5;\n        preHashed[11] = 0xf8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892;\n        preHashed[12] = 0x3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c;\n        preHashed[13] = 0xc1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb;\n        preHashed[14] = 0x5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc;\n        preHashed[15] = 0xda7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2;\n        preHashed[16] = 0x2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f;\n        preHashed[17] = 0xe1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a;\n        preHashed[18] = 0x5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0;\n        preHashed[19] = 0xb46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0;\n        preHashed[20] = 0xc65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2;\n        preHashed[21] = 0xf4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9;\n        preHashed[22] = 0x5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377;\n        preHashed[23] = 0x4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652;\n        preHashed[24] = 0xcdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef;\n        preHashed[25] = 0x0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d;\n        preHashed[26] = 0xb8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0;\n        preHashed[27] = 0x838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e;\n        preHashed[28] = 0x662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e;\n        preHashed[29] = 0x388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322;\n        preHashed[30] = 0x93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735;\n        preHashed[31] = 0x8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9;\n        preHashed[32] = 0x27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757;\n        preHashed[33] = 0xbf558bebd2ceec7f3c5dce04a4782f88c2c6036ae78ee206d0bc5289d20461a2;\n        preHashed[34] = 0xe21908c2968c0699040a6fd866a577a99a9d2ec88745c815fd4a472c789244da;\n        preHashed[35] = 0xae824d72ddc272aab68a8c3022e36f10454437c1886f3ff9927b64f232df414f;\n        preHashed[36] = 0x27e429a4bef3083bc31a671d046ea5c1f5b8c3094d72868d9dfdc12c7334ac5f;\n        preHashed[37] = 0x743cc5c365a9a6a15c1f240ac25880c7a9d1de290696cb766074a1d83d927816;\n        preHashed[38] = 0x4adcf616c3bfabf63999a01966c998b7bb572774035a63ead49da73b5987f347;\n        preHashed[39] = 0x75786645d0c5dd7c04a2f8a75dcae085213652f5bce3ea8b9b9bedd1cab3c5e9;\n        preHashed[40] = 0xb88b152c9b8a7b79637d35911848b0c41e7cc7cca2ab4fe9a15f9c38bb4bb939;\n        preHashed[41] = 0x0c4e2d8ce834ffd7a6cd85d7113d4521abb857774845c4291e6f6d010d97e318;\n        preHashed[42] = 0x5bc799d83e3bb31501b3da786680df30fbc18eb41cbce611e8c0e9c72f69571c;\n        preHashed[43] = 0xa10d3ef857d04d9c03ead7c6317d797a090fa1271ad9c7addfbcb412e9643d4f;\n        preHashed[44] = 0xb33b1809c42623f474055fa9400a2027a7a885c8dfa4efe20666b4ee27d7529c;\n        preHashed[45] = 0x134d7f28d53f175f6bf4b62faa2110d5b76f0f770c15e628181c1fcc18f970a9;\n        preHashed[46] = 0xc34d24b2fc8c50ca9c07a7156ef4e5ff4bdf002eda0b11c1d359d0b59a546807;\n        preHashed[47] = 0x04dbb9db631457879b27e0dfdbe50158fd9cf9b4cf77605c4ac4c95bd65fc9f6;\n        preHashed[48] = 0xf9295a686647cb999090819cda700820c282c613cedcd218540bbc6f37b01c65;\n    }\n}\n\ncontract UserInteractable is Storage {\n    uint256 public constant SNARK_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 public constant RANGE_LIMIT = SNARK_FIELD >> 32;\n    using MerkleTreeLib for *;\n    using SafeMath for uint256;\n\n    event Deposit(uint256 indexed queuedAt, uint256 note, uint256 fee);\n\n    /**\n     * @notice Users can use zkopru network by submitting a new homomorphically hiden note.\n     * @param spendingPubKey P = poseidon(p*G, N) https://github.com/zkopru-network/zkopru/issues/34#issuecomment-666988505\n     * @param salt 254bit salt for the privacy\n     * @param eth Amount of Ether to deposit\n     * @param token Token address of ERC20 or ERC721. It can be undefined.\n     * @param amount Amount of ERC20 when the token param is defined and it is an ERC20\n     * @param nft NFT id when the token param is defined and it is an ERC721\n     * @param fee Amount of fee to give to the coordinator\n     */\n    function deposit(\n        uint256 spendingPubKey,\n        uint256 salt,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 fee\n    ) public payable {\n        _deposit(spendingPubKey, salt, eth, token, amount, nft, fee);\n    }\n    \n    /**\n     * @notice Users can withdraw notes when only after they're finazlied.\n     * @param note Note hash in layer 2. It is a poseidon hash\n     * @param owner The original owner's address of the note\n     * @param eth Amount of Ether to withdraw out\n     * @param token Token address of ERC20 or ERC721. It can be undefined.\n     * @param amount Amount of ERC20 when the token param is defined and it is an ERC20\n     * @param nft NFT id when the token param is defined and it is an ERC721\n     * @param callerFee Amount of fee to give to the caller. This can be used when the withdrawer account has no ETH.\n     * @param blockHash Finalized block hash to find the finalized withdrawal root\n     * @param leafIndex The index of your withdrawal note's leaf in the given tree.\n     * @param siblings Inclusion proof data\n     */\n    function withdraw(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee,\n        bytes32 blockHash,\n        uint256 leafIndex,\n        uint256[] memory siblings\n    ) public {\n        return _withdraw(\n            note,\n            owner,\n            eth,\n            token,\n            amount,\n            nft,\n            callerFee,\n            blockHash,\n            leafIndex,\n            siblings\n        );\n    }\n\n    /**\n     * @notice Someone can pay in advance for unfinalized withdrawals\n     * @param note Poseidon note hash of the withdrawal\n     * @param owner Address of the note\n     * @param eth Amount of Ether to withdraw out\n     * @param token Token address of ERC20 or ERC721. It can be undefined.\n     * @param amount Amount of ERC20 when the token param is defined and it is an ERC20\n     * @param nft NFT id when the token param is defined and it is an ERC721\n     * @param callerFee Amount of fee to give to the caller. This can be used when the withdrawer account has no ETH.\n     * @param signature ECDSA signature\n     */\n    function payInAdvance(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee,\n        uint256 prepayFeeInEth,\n        uint256 prepayFeeInToken,\n        bytes memory signature\n    ) public payable {\n        bytes32 withdrawalHash = _withdrawalHash(\n            note,\n            owner,\n            eth,\n            token,\n            amount,\n            nft,\n            callerFee\n        );\n        require(!Storage.chain.withdrawn[withdrawalHash], \"Already withdrawn\");\n\n        address newOwner = Storage.chain.newWithdrawalOwner[withdrawalHash];\n        address currentOwner = newOwner == address(0) ? owner : newOwner;\n        address prepayer = msg.sender;\n        bytes32 payInAdvanceMsg = keccak256(\n            abi.encodePacked(\n                prepayer,\n                withdrawalHash,\n                prepayFeeInEth,\n                prepayFeeInToken\n            )\n        );\n        // verify original owner's signature\n        require(\n            _verifySignature(\n                currentOwner,\n                payInAdvanceMsg,\n                signature\n            ),\n            \"Invalid owner signature\"\n        );\n        uint ethToWithdraw = eth.sub(prepayFeeInEth);\n        uint tokenToWithdraw = amount.sub(prepayFeeInToken);\n        require(msg.value == eth, 'not enough ether');\n        // prepay tokens\n        if (Storage.chain.registeredERC20s[token]) {\n            IERC20(token).transferFrom(prepayer, currentOwner, tokenToWithdraw);\n        } else if (Storage.chain.registeredERC721s[token]){\n            revert(\"Does not support NFT prepay\");\n        }\n        // prepay ether\n        _sendEth(currentOwner, ethToWithdraw);\n        // transfer ownership\n        Storage.chain.newWithdrawalOwner[withdrawalHash] = prepayer;\n    }\n\n    function _deposit(\n        uint256 spendingPubKey,\n        uint256 salt,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 fee\n    ) internal {\n        // range check\n        require(amount < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(eth < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(fee < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(nft < SNARK_FIELD, \"Does not support too big nubmer of nft id\");\n        // check eth value\n        require(eth.add(fee) == msg.value, \"Inexact amount of eth\");\n        require(Storage.chain.stagedSize < 1024, \"Should wait until it is committed\");\n        // check note fields\n        require(_checkNoteFields(eth, token, amount, nft));\n\n        //TODO: require(fee >= specified fee);\n        // Validate the note is same with the hash result\n        uint256[] memory assetHashInputs = new uint256[](4);\n        assetHashInputs[0] = eth;\n        assetHashInputs[1] = uint256(token);\n        assetHashInputs[2] = amount; //erc20 amount\n        assetHashInputs[3] = nft;\n        uint256 assetHash = Poseidon4.poseidon(assetHashInputs);\n        uint256[] memory resultHashInputs = new uint256[](3);\n        resultHashInputs[0] = spendingPubKey;\n        resultHashInputs[1] = salt;\n        resultHashInputs[2] = assetHash;\n        uint256 note = Poseidon3.poseidon(resultHashInputs);\n        // Receive token\n        if (token != address(0) && amount != 0) {\n            try IERC20(token).transferFrom(msg.sender, address(this), amount) {\n            } catch {\n                revert(\"Transfer ERC20 failed\");\n            }\n        } else if (token != address(0)) {\n            try IERC721(token).transferFrom(msg.sender, address(this), nft) {\n            } catch {\n                revert(\"Transfer NFT failed\");\n            }\n        }\n        // Update the mass deposit\n        Storage.chain.stagedDeposits.merged = keccak256(abi.encodePacked(Storage.chain.stagedDeposits.merged, note));\n        Storage.chain.stagedDeposits.fee = Storage.chain.stagedDeposits.fee.add(fee);\n        Storage.chain.stagedSize = Storage.chain.stagedSize.add(1);\n        // Emit event. Coordinator should subscribe this event.\n        emit Deposit(Storage.chain.massDepositId, note, fee);\n    }\n\n    function _withdraw(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee,\n        bytes32 blockHash,\n        uint256 leafIndex,\n        uint256[] memory siblings\n    ) internal {\n        // range check\n        require(amount < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(eth < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(callerFee < RANGE_LIMIT, \"Too big value can cause the overflow inside the SNARK\");\n        require(nft < SNARK_FIELD, \"Does not support too big nubmer of nft id\");\n        // check note fields\n        require(_checkNoteFields(eth, token, amount, nft));\n        // check the reference block is finalized\n        require(Storage.chain.finalized[blockHash], \"Not a finalized block\");\n        uint256 root = Storage.chain.withdrawalRootOf[blockHash];\n        bytes32 withdrawalHash = _withdrawalHash(\n            note,\n            owner,\n            eth,\n            token,\n            amount,\n            nft,\n            callerFee\n        );\n        // Should not allow double-withdrawing\n        require(!Storage.chain.withdrawn[withdrawalHash], \"Already withdrawn\");\n        // Mark as withdrawn\n        Storage.chain.withdrawn[withdrawalHash] = true;\n        // Check whether new owner exists\n        address to = Storage.chain.newWithdrawalOwner[withdrawalHash] != address(0)\n            ? Storage.chain.newWithdrawalOwner[withdrawalHash]\n            : owner;\n\n        // inclusion proof\n        bool inclusion = Hash.keccak().merkleProof(\n            root,\n            uint256(withdrawalHash),\n            leafIndex,\n            siblings\n        );\n        require(inclusion, \"The given withdrawal note does not exist\");\n        // Withdraw ETH & get fee\n        if(to == msg.sender) {\n            _sendEth(to, eth.add(callerFee));\n        } else {\n            _sendEth(to, eth);\n            _sendEth(msg.sender, callerFee);\n        }\n        // Withdraw tokens if exists\n        if (Storage.chain.registeredERC20s[token]) {\n            IERC20(token).transfer(to, amount);\n        } else if (Storage.chain.registeredERC721s[token]){\n            require(nft != 0, \"Circuit cannot accept NFT id 0. Please deposit other NFT.\");\n            IERC721(token).transferFrom(address(this), to, nft);\n        }\n    }\n\n    function _withdrawalHash(\n        uint256 note,\n        address owner,\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft,\n        uint256 callerFee\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                note,\n                owner,\n                eth,\n                token,\n                amount,\n                nft,\n                callerFee\n            )\n        );\n    }\n\n    function _verifySignature(\n        address signer,\n        bytes32 message,\n        bytes memory sig\n    ) internal pure returns (bool) {\n        require(sig.length == 65);\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n        bytes32 prefixedHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\n        return signer == ecrecover(prefixedHash, v, r, s);\n    }\n\n    function _checkNoteFields(\n        uint256 eth,\n        address token,\n        uint256 amount,\n        uint256 nft\n    ) internal view returns (bool) {\n        if (token == address(0)) {\n            require(nft == 0 && amount == 0, \"Ether note does not have amount field & nft field\");\n            require(eth != 0, \"Should have ETH field\");\n        } else {\n            // this note contains token value\n            bool isERC20 = Storage.chain.registeredERC20s[token];\n            bool isERC721 = Storage.chain.registeredERC721s[token];\n            require(isERC20 || isERC721, \"Not a registered token. Reigster that token first\");\n            if (isERC20) {\n                require(nft == 0, \"ERC20 does have NFT field\");\n            } else if (isERC721){\n                require(nft != 0, \"Circuit cannot accept NFT id 0. Please deposit other NFT.\");\n                require(amount == 0, \"ERC721 does have amount field\");\n            }\n        }\n        return true;\n    }\n\n    function _sendEth(address to, uint val) internal {\n        if (val > 0) {\n            (bool success, ) = to.call{ value: val }(\"\");\n            require(success, \"Failed to send ETH\");\n        }\n    }\n}\n", "commit_id": "fa7b6a57ad31b73ee87b1479679d72b082037dc0"}}