{"filename": "LIP_5/contracts/NFTStaking.sol", "patch": "@@ -7,6 +7,7 @@ import '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\n import '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\n import '@openzeppelin/contracts/utils/math/SafeMath.sol';\n import '@openzeppelin/contracts/access/Ownable.sol';\n+import '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n \n struct STAKE {\n     uint256 amount;\n@@ -25,7 +26,7 @@ struct POOL {\n     uint256 maxPerClaim;\n }\n \n-contract NFTStaking is Context, ERC1155Holder, Ownable {\n+contract NFTStaking is Context, ERC1155Holder, Ownable, ReentrancyGuard {\n     using SafeMath for uint256;\n \n     /// @dev map poolId to staking Pool detail\n@@ -41,11 +42,11 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n         stakingPoolsCount = 0;\n     }\n \n-    function setTokenAddress(IERC20 _tokenAddress) external onlyOwner {\n+    function setTokenAddress(IERC20 _tokenAddress) external nonReentrant onlyOwner {\n         _token = _tokenAddress;\n     }\n \n-    function setNftTokenAddress(IERC1155 _nftTokenAddress) external onlyOwner {\n+    function setNftTokenAddress(IERC1155 _nftTokenAddress) external nonReentrant onlyOwner {\n         _nftToken = _nftTokenAddress;\n     }\n \n@@ -118,7 +119,8 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n         // get pool that gives max possible rewards at the current time instance\n         POOL memory poolInfo = getPool(_nftId, _staker);\n         uint poolId = poolInfo.poolId;\n-        return balances[poolId][_staker];\n+        STAKE memory balance = balances[poolId][_staker];\n+        return balance;\n     }\n \n     /**\n@@ -205,7 +207,7 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n         return totalReward;\n     }\n \n-    function claimReward(uint256 _poolId) public {\n+    function claimReward(uint256 _poolId) external nonReentrant {\n         uint256 reward = rewardOf(_poolId, _msgSender());\n         POOL memory poolInfo = stakingPools[_poolId];\n         STAKE storage balance = balances[_poolId][_msgSender()];\n@@ -224,7 +226,7 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n      * @param _poolId is the pool identifier\n      * @param _amount is the NFT count to stake\n      */\n-    function stake(uint256 _poolId, uint256 _amount) external {\n+    function stake(uint256 _poolId, uint256 _amount) external nonReentrant {\n         POOL memory poolInfo = stakingPools[_poolId];\n \n         _nftToken.safeTransferFrom(_msgSender(), address(this), poolInfo.nftTokenId, _amount, '');\n@@ -253,7 +255,7 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n      * @notice unstake current staking\n      * @param _poolId is the pool identifier\n      */\n-    function unstake(uint256 _poolId, uint256 _count) external {\n+    function unstake(uint256 _poolId, uint256 _count) external nonReentrant {\n         require(balances[_poolId][_msgSender()].amount > 0, 'Not staking');\n \n         POOL memory poolInfo = stakingPools[_poolId];\n@@ -282,7 +284,7 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n      * @param _poolId is the pool id to contribute reward\n      * @param _amount is the amount to put\n      */\n-    function notifyRewards(uint256 _poolId, uint256 _amount) public onlyOwner {\n+    function notifyRewards(uint256 _poolId, uint256 _amount) external nonReentrant onlyOwner {\n         require(_amount > 0, \"NFTStaking.notifyRewards: Can't add zero amount!\");\n \n         POOL storage poolInfo = stakingPools[_poolId];\n@@ -298,7 +300,7 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n      * @param poolId is the pool id to contribute reward\n      * @param amount is the amount to claim\n      */\n-    function withdrawRewards(uint256 poolId, uint256 amount) public onlyOwner {\n+    function withdrawRewards(uint256 poolId, uint256 amount) external nonReentrant onlyOwner {\n         require(stakingPools[poolId].totalRewards >= amount, 'NFTStaking.withdrawRewards: Not enough remaining rewards!');\n         POOL storage poolInfo = stakingPools[poolId];\n         _token.transfer(_msgSender(), amount);\n@@ -317,7 +319,7 @@ contract NFTStaking is Context, ERC1155Holder, Ownable {\n         uint256 _rewardPerNFT,\n         uint256 _rewardPeriod,\n         uint256 _maxPerClaim\n-    ) public onlyOwner {\n+    ) external nonReentrant onlyOwner {\n         uint256 poolId = stakingPoolsCount;\n         require(_rewardPeriod > 0, \"NFTStaking.addPool: Rewards period can NOT be 0\");\n         require(_maxPerClaim > 0, \"NFTStaking.addPool: Rewards max per each claim can NOT be 0\");", "project_link": "https://github.com/KiraCore/liquidity-program/commit/60983bafc664f4606523897cf9fef410f164bdc2", "bug_version": {"raw_code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\nstruct STAKE {\n    uint256 amount;\n    uint256 rewardSoFar;\n    uint256 firstStakedAt;\n    uint256 lastClaimedAt;\n}\n\nstruct POOL {\n    uint256 poolId;\n    uint256 nftTokenId;\n    uint256 totalStakes;\n    uint256 totalRewards;\n    uint256 rewardPerNFT;\n    uint256 rewardPeriod;\n    uint256 maxPerClaim;\n}\n\ncontract NFTStaking is Context, ERC1155Holder, Ownable {\n    using SafeMath for uint256;\n\n    /// @dev map poolId to staking Pool detail\n    uint public stakingPoolsCount;\n    mapping(uint256 => POOL) stakingPools;\n    mapping(uint256 => mapping(address => STAKE)) balances;\n    IERC20 private _token;\n    IERC1155 private _nftToken;\n\n    constructor(IERC20 _tokenAddress, IERC1155 _nftTokenAddress) {\n        _token = _tokenAddress;\n        _nftToken = _nftTokenAddress;\n        stakingPoolsCount = 0;\n    }\n\n    function setTokenAddress(IERC20 _tokenAddress) external onlyOwner {\n        _token = _tokenAddress;\n    }\n\n    function setNftTokenAddress(IERC1155 _nftTokenAddress) external onlyOwner {\n        _nftToken = _nftTokenAddress;\n    }\n\n    event Stake(uint256 indexed poolId, address staker, uint256 amount);\n    event Unstake(uint256 indexed poolId, address staker, uint256 amount);\n    event Withdraw(uint256 indexed poolId, address staker, uint256 amount);\n\n    /**\n     * @notice get remaining rewards from all existing pools\n     * @return rewardsTotal\n     */\n    function getReservedRewards() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            POOL memory pool = stakingPools[i];\n            uint256 poolRewards = pool.totalRewards;\n            total = total.add(poolRewards);\n        }\n        return total;\n    }\n\n    /**\n     * @notice get staking pool by id\n     * @param _poolId is the staking pool identifier\n     * @return stakingPool\n     */\n    function getPool(uint256 _poolId) public view returns (POOL memory) {\n      return stakingPools[_poolId];\n    }\n\n    /**\n     * @notice gets staking pool by NFT id with highest remaining rewards that the staker can claim\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whom we are looking for the best pool\n     * @return stakingPool\n     */\n    function getPool(uint256 _nftId, address _staker) public view returns (POOL memory) {\n        POOL memory poolInfoBestClaim;\n        POOL memory poolInfoBestAvailable;\n        uint256 bestClaimRewards = 0;\n        uint256 bestAvailableRewards = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            uint256 poolNftId = stakingPools[i].nftTokenId;\n            if (poolNftId == _nftId) {\n                uint256 clamableRewards = rewardOf(i, _staker);\n                uint256 availableRewards = stakingPools[i].totalRewards;\n                if (clamableRewards >= bestClaimRewards) {\n                    poolInfoBestClaim = stakingPools[i];\n                    bestClaimRewards = clamableRewards;\n                }\n                if (availableRewards >= bestAvailableRewards) {\n                    poolInfoBestAvailable = stakingPools[i];\n                    bestAvailableRewards = availableRewards;\n                }\n            }\n        }\n      \n      // if there is no rewards to be claimed, get pool with higer number of rewards that can be distributed\n      if (bestClaimRewards == 0) return poolInfoBestAvailable;\n      return poolInfoBestClaim;\n    }\n\n    /**\n     * @notice gets the staker balance of for the staking pool that can give the most rewards\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return stakingBalance\n     */\n    function getBalance(uint256 _nftId, address _staker) public view returns (STAKE memory) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        return balances[poolId][_staker];\n    }\n\n    /**\n     * @notice gets amount of staker claimable rewards by nft identifier\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return claimable rewards amount\n     */\n    function getRewards(uint256 _nftId, address _staker) public view returns (uint256) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        uint rewards = rewardOf(poolId, _staker);\n        return rewards;\n    }\n\n    /**\n     * @notice calculate total stakes of staker\n     * @param _poolId is the pool identifier\n     * @param _staker is the address of staker\n     * @return _total\n     */\n    function totalStakeOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].amount;\n    }\n\n    /**\n     * @notice calculate entire stake amount\n     * @param _poolId is the pool identifier\n     * @return _total\n     */\n    function getTotalStakes(uint256 _poolId) public view returns (uint256) {\n        return stakingPools[_poolId].totalStakes;\n    }\n\n    /**\n     * @notice get the first staked time\n     * @param _poolId is the pool identifier\n     * @return firstStakedAt\n     */\n    function getFirstStakedAtOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].firstStakedAt;\n    }\n\n    /**\n     * @notice get total claimed reward of staker\n     * @param _poolId is the pool identifier\n     * @return rewardSoFar\n     */\n    function getRewardSoFarOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].rewardSoFar;\n    }\n\n    /**\n     * @notice calculate reward of staker\n     * @param _poolId is the pool identifier\n     * @return reward is the reward amount of the staker\n     */\n    function rewardOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        STAKE memory stakeDetail = balances[_poolId][_staker];\n\n        // if staker is NOT staking the token anymore then rewards is 0\n        // notice that lastClaimedAt is set at the time of stake event occuring, if user didnt staked anything then timePassed calculations would NOT be valid\n        if (stakeDetail.amount == 0) return 0;\n\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        uint256 timeNow = block.timestamp;\n        // passed time in seconds since the last claim\n        uint256 timePassed = timeNow - stakeDetail.lastClaimedAt;\n        uint256 totalReward = stakeDetail.amount.mul(poolInfo.rewardPerNFT).mul(timePassed).div(poolInfo.rewardPeriod);\n\n        // there can be a situation where someone is staking for a very long time and no one is claiming, then sudenly 1 person ruggs everyone\n        // to solve this issue we force people to claim every time they accumulate maxPerClaim and thus available rewards don't suddenly go to 0\n        if (totalReward > poolInfo.maxPerClaim) totalReward = poolInfo.maxPerClaim;\n\n        // there can be a situation where someone is staking longer than others and claimed multiple times\n        // we should inform everyone about this by decreasing everyone max claim\n        uint256 fairRewardPerNFT = poolInfo.totalRewards.div(poolInfo.totalStakes);\n        uint256 maxFairReward = stakeDetail.amount.mul(fairRewardPerNFT);\n        if (totalReward > maxFairReward) totalReward = maxFairReward;\n\n        if (totalReward > poolInfo.totalRewards) totalReward = poolInfo.totalRewards;\n        return totalReward;\n    }\n\n    function claimReward(uint256 _poolId) public {\n        uint256 reward = rewardOf(_poolId, _msgSender());\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        _token.transfer(_msgSender(), reward);\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        emit Withdraw(_poolId, _msgSender(), reward);\n    }\n\n    /**\n     * @notice stake NFT\n     * @param _poolId is the pool identifier\n     * @param _amount is the NFT count to stake\n     */\n    function stake(uint256 _poolId, uint256 _amount) external {\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        _nftToken.safeTransferFrom(_msgSender(), address(this), poolInfo.nftTokenId, _amount, '');\n\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        if (balance.amount > 0) {\n            uint256 reward = rewardOf(_poolId, _msgSender());\n\n            _token.transfer(_msgSender(), reward);\n            balance.rewardSoFar = balance.rewardSoFar.add(reward);\n            poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n            emit Withdraw(_poolId, _msgSender(), reward);\n        }\n        if (balance.amount == 0) balance.firstStakedAt = block.timestamp;\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.amount = balance.amount.add(_amount);\n        stakingPools[_poolId].totalStakes = stakingPools[_poolId].totalStakes.add(_amount);\n\n        emit Stake(_poolId, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice unstake current staking\n     * @param _poolId is the pool identifier\n     */\n    function unstake(uint256 _poolId, uint256 _count) external {\n        require(balances[_poolId][_msgSender()].amount > 0, 'Not staking');\n\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n        uint256 reward = rewardOf(_poolId, _msgSender()).div(balance.amount).mul(_count);\n\n        _token.transfer(_msgSender(), reward);\n        _nftToken.safeTransferFrom(address(this), _msgSender(), poolInfo.nftTokenId, _count, '');\n\n        poolInfo.totalStakes = poolInfo.totalStakes.sub(_count);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        balance.amount = balance.amount.sub(_count);\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n\n        if (balance.amount == 0) {\n            balance.firstStakedAt = 0;\n            balance.lastClaimedAt = 0;\n        }\n\n        emit Unstake(_poolId, _msgSender(), _count);\n    }\n\n    /**\n     * @notice function to notify contract how many rewards to assign for the specific pool\n     * @param _poolId is the pool id to contribute reward\n     * @param _amount is the amount to put\n     */\n    function notifyRewards(uint256 _poolId, uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"NFTStaking.notifyRewards: Can't add zero amount!\");\n\n        POOL storage poolInfo = stakingPools[_poolId];\n        uint total = _token.balanceOf(address(this));\n        uint reserved = getReservedRewards();\n\n        require(total.sub(reserved) >= _amount, \"NFTStaking.notifyRewards: Can't add more tokens than available\");\n        poolInfo.totalRewards = poolInfo.totalRewards.add(_amount);\n    }\n\n    /**\n     * @notice function to claim staking rewards from the contract\n     * @param poolId is the pool id to contribute reward\n     * @param amount is the amount to claim\n     */\n    function withdrawRewards(uint256 poolId, uint256 amount) public onlyOwner {\n        require(stakingPools[poolId].totalRewards >= amount, 'NFTStaking.withdrawRewards: Not enough remaining rewards!');\n        POOL storage poolInfo = stakingPools[poolId];\n        _token.transfer(_msgSender(), amount);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(amount);\n    }\n\n    /**\n     * @notice adds new staking pool\n     * @param _nftTokenId is the token id that can be staked to the pool\n     * @param _rewardPerNFT is the amount of rewards token can receive over the rewar period \n     * @param _rewardPeriod is the numer of seconds within each nft can earn the amount equal to rewardPerNFT\n     * @param _maxPerClaim each account has restriction regarding max amount per each rewards claim, this way rewards do NOT suddenly disappear when users check their rewards balances\n     */\n    function addPool(\n        uint256 _nftTokenId,\n        uint256 _rewardPerNFT,\n        uint256 _rewardPeriod,\n        uint256 _maxPerClaim\n    ) public onlyOwner {\n        uint256 poolId = stakingPoolsCount;\n        require(_rewardPeriod > 0, \"NFTStaking.addPool: Rewards period can NOT be 0\");\n        require(_maxPerClaim > 0, \"NFTStaking.addPool: Rewards max per each claim can NOT be 0\");\n        require(stakingPools[poolId].rewardPerNFT == 0, 'NFTStaking.addPool: Pool already exists!');\n        require(stakingPools[poolId].poolId == 0, 'NFTStaking.addPool: poolId already exists!');\n        require(stakingPools[poolId].rewardPeriod == 0, 'NFTStaking.addPool: Pool already exists!');\n\n        stakingPools[poolId] = POOL(poolId, _nftTokenId, 0, 0, _rewardPerNFT, _rewardPeriod, _maxPerClaim);\n        stakingPoolsCount++;\n    }\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\nstruct STAKE {\n    uint256 amount;\n    uint256 rewardSoFar;\n    uint256 firstStakedAt;\n    uint256 lastClaimedAt;\n}\n\nstruct POOL {\n    uint256 poolId;\n    uint256 nftTokenId;\n    uint256 totalStakes;\n    uint256 totalRewards;\n    uint256 rewardPerNFT;\n    uint256 rewardPeriod;\n    uint256 maxPerClaim;\n}\n\ncontract NFTStaking is Context, ERC1155Holder, Ownable {\n    using SafeMath for uint256;\n\n    /// @dev map poolId to staking Pool detail\n    uint public stakingPoolsCount;\n    mapping(uint256 => POOL) stakingPools;\n    mapping(uint256 => mapping(address => STAKE)) balances;\n    IERC20 private _token;\n    IERC1155 private _nftToken;\n\n    constructor(IERC20 _tokenAddress, IERC1155 _nftTokenAddress) {\n        _token = _tokenAddress;\n        _nftToken = _nftTokenAddress;\n        stakingPoolsCount = 0;\n    }\n\n    function setTokenAddress(IERC20 _tokenAddress) external onlyOwner {\n        _token = _tokenAddress;\n    }\n\n    function setNftTokenAddress(IERC1155 _nftTokenAddress) external onlyOwner {\n        _nftToken = _nftTokenAddress;\n    }\n\n    event Stake(uint256 indexed poolId, address staker, uint256 amount);\n    event Unstake(uint256 indexed poolId, address staker, uint256 amount);\n    event Withdraw(uint256 indexed poolId, address staker, uint256 amount);\n\n    /**\n     * @notice get remaining rewards from all existing pools\n     * @return rewardsTotal\n     */\n    function getReservedRewards() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            POOL memory pool = stakingPools[i];\n            uint256 poolRewards = pool.totalRewards;\n            total = total.add(poolRewards);\n        }\n        return total;\n    }\n\n    /**\n     * @notice get staking pool by id\n     * @param _poolId is the staking pool identifier\n     * @return stakingPool\n     */\n    function getPool(uint256 _poolId) public view returns (POOL memory) {\n      return stakingPools[_poolId];\n    }\n\n    /**\n     * @notice gets staking pool by NFT id with highest remaining rewards that the staker can claim\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whom we are looking for the best pool\n     * @return stakingPool\n     */\n    function getPool(uint256 _nftId, address _staker) public view returns (POOL memory) {\n        POOL memory poolInfoBestClaim;\n        POOL memory poolInfoBestAvailable;\n        uint256 bestClaimRewards = 0;\n        uint256 bestAvailableRewards = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            uint256 poolNftId = stakingPools[i].nftTokenId;\n            if (poolNftId == _nftId) {\n                uint256 clamableRewards = rewardOf(i, _staker);\n                uint256 availableRewards = stakingPools[i].totalRewards;\n                if (clamableRewards >= bestClaimRewards) {\n                    poolInfoBestClaim = stakingPools[i];\n                    bestClaimRewards = clamableRewards;\n                }\n                if (availableRewards >= bestAvailableRewards) {\n                    poolInfoBestAvailable = stakingPools[i];\n                    bestAvailableRewards = availableRewards;\n                }\n            }\n        }\n      \n      // if there is no rewards to be claimed, get pool with higer number of rewards that can be distributed\n      if (bestClaimRewards == 0) return poolInfoBestAvailable;\n      return poolInfoBestClaim;\n    }\n\n    /**\n     * @notice gets the staker balance of for the staking pool that can give the most rewards\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return stakingBalance\n     */\n    function getBalance(uint256 _nftId, address _staker) public view returns (STAKE memory) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        return balances[poolId][_staker];\n    }\n\n    /**\n     * @notice gets amount of staker claimable rewards by nft identifier\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return claimable rewards amount\n     */\n    function getRewards(uint256 _nftId, address _staker) public view returns (uint256) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        uint rewards = rewardOf(poolId, _staker);\n        return rewards;\n    }\n\n    /**\n     * @notice calculate total stakes of staker\n     * @param _poolId is the pool identifier\n     * @param _staker is the address of staker\n     * @return _total\n     */\n    function totalStakeOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].amount;\n    }\n\n    /**\n     * @notice calculate entire stake amount\n     * @param _poolId is the pool identifier\n     * @return _total\n     */\n    function getTotalStakes(uint256 _poolId) public view returns (uint256) {\n        return stakingPools[_poolId].totalStakes;\n    }\n\n    /**\n     * @notice get the first staked time\n     * @param _poolId is the pool identifier\n     * @return firstStakedAt\n     */\n    function getFirstStakedAtOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].firstStakedAt;\n    }\n\n    /**\n     * @notice get total claimed reward of staker\n     * @param _poolId is the pool identifier\n     * @return rewardSoFar\n     */\n    function getRewardSoFarOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].rewardSoFar;\n    }\n\n    /**\n     * @notice calculate reward of staker\n     * @param _poolId is the pool identifier\n     * @return reward is the reward amount of the staker\n     */\n    function rewardOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        STAKE memory stakeDetail = balances[_poolId][_staker];\n\n        // if staker is NOT staking the token anymore then rewards is 0\n        // notice that lastClaimedAt is set at the time of stake event occuring, if user didnt staked anything then timePassed calculations would NOT be valid\n        if (stakeDetail.amount == 0) return 0;\n\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        uint256 timeNow = block.timestamp;\n        // passed time in seconds since the last claim\n        uint256 timePassed = timeNow - stakeDetail.lastClaimedAt;\n        uint256 totalReward = stakeDetail.amount.mul(poolInfo.rewardPerNFT).mul(timePassed).div(poolInfo.rewardPeriod);\n\n        // there can be a situation where someone is staking for a very long time and no one is claiming, then sudenly 1 person ruggs everyone\n        // to solve this issue we force people to claim every time they accumulate maxPerClaim and thus available rewards don't suddenly go to 0\n        if (totalReward > poolInfo.maxPerClaim) totalReward = poolInfo.maxPerClaim;\n\n        // there can be a situation where someone is staking longer than others and claimed multiple times\n        // we should inform everyone about this by decreasing everyone max claim\n        uint256 fairRewardPerNFT = poolInfo.totalRewards.div(poolInfo.totalStakes);\n        uint256 maxFairReward = stakeDetail.amount.mul(fairRewardPerNFT);\n        if (totalReward > maxFairReward) totalReward = maxFairReward;\n\n        if (totalReward > poolInfo.totalRewards) totalReward = poolInfo.totalRewards;\n        return totalReward;\n    }\n\n    function claimReward(uint256 _poolId) public {\n        uint256 reward = rewardOf(_poolId, _msgSender());\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        _token.transfer(_msgSender(), reward);\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        emit Withdraw(_poolId, _msgSender(), reward);\n    }\n\n    /**\n     * @notice stake NFT\n     * @param _poolId is the pool identifier\n     * @param _amount is the NFT count to stake\n     */\n    function stake(uint256 _poolId, uint256 _amount) external {\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        _nftToken.safeTransferFrom(_msgSender(), address(this), poolInfo.nftTokenId, _amount, '');\n\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        if (balance.amount > 0) {\n            uint256 reward = rewardOf(_poolId, _msgSender());\n\n            _token.transfer(_msgSender(), reward);\n            balance.rewardSoFar = balance.rewardSoFar.add(reward);\n            poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n            emit Withdraw(_poolId, _msgSender(), reward);\n        }\n        if (balance.amount == 0) balance.firstStakedAt = block.timestamp;\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.amount = balance.amount.add(_amount);\n        stakingPools[_poolId].totalStakes = stakingPools[_poolId].totalStakes.add(_amount);\n\n        emit Stake(_poolId, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice unstake current staking\n     * @param _poolId is the pool identifier\n     */\n    function unstake(uint256 _poolId, uint256 _count) external {\n        require(balances[_poolId][_msgSender()].amount > 0, 'Not staking');\n\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n        uint256 reward = rewardOf(_poolId, _msgSender()).div(balance.amount).mul(_count);\n\n        _token.transfer(_msgSender(), reward);\n        _nftToken.safeTransferFrom(address(this), _msgSender(), poolInfo.nftTokenId, _count, '');\n\n        poolInfo.totalStakes = poolInfo.totalStakes.sub(_count);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        balance.amount = balance.amount.sub(_count);\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n\n        if (balance.amount == 0) {\n            balance.firstStakedAt = 0;\n            balance.lastClaimedAt = 0;\n        }\n\n        emit Unstake(_poolId, _msgSender(), _count);\n    }\n\n    /**\n     * @notice function to notify contract how many rewards to assign for the specific pool\n     * @param _poolId is the pool id to contribute reward\n     * @param _amount is the amount to put\n     */\n    function notifyRewards(uint256 _poolId, uint256 _amount) public onlyOwner {\n        require(_amount > 0, \"NFTStaking.notifyRewards: Can't add zero amount!\");\n\n        POOL storage poolInfo = stakingPools[_poolId];\n        uint total = _token.balanceOf(address(this));\n        uint reserved = getReservedRewards();\n\n        require(total.sub(reserved) >= _amount, \"NFTStaking.notifyRewards: Can't add more tokens than available\");\n        poolInfo.totalRewards = poolInfo.totalRewards.add(_amount);\n    }\n\n    /**\n     * @notice function to claim staking rewards from the contract\n     * @param poolId is the pool id to contribute reward\n     * @param amount is the amount to claim\n     */\n    function withdrawRewards(uint256 poolId, uint256 amount) public onlyOwner {\n        require(stakingPools[poolId].totalRewards >= amount, 'NFTStaking.withdrawRewards: Not enough remaining rewards!');\n        POOL storage poolInfo = stakingPools[poolId];\n        _token.transfer(_msgSender(), amount);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(amount);\n    }\n\n    /**\n     * @notice adds new staking pool\n     * @param _nftTokenId is the token id that can be staked to the pool\n     * @param _rewardPerNFT is the amount of rewards token can receive over the rewar period \n     * @param _rewardPeriod is the numer of seconds within each nft can earn the amount equal to rewardPerNFT\n     * @param _maxPerClaim each account has restriction regarding max amount per each rewards claim, this way rewards do NOT suddenly disappear when users check their rewards balances\n     */\n    function addPool(\n        uint256 _nftTokenId,\n        uint256 _rewardPerNFT,\n        uint256 _rewardPeriod,\n        uint256 _maxPerClaim\n    ) public onlyOwner {\n        uint256 poolId = stakingPoolsCount;\n        require(_rewardPeriod > 0, \"NFTStaking.addPool: Rewards period can NOT be 0\");\n        require(_maxPerClaim > 0, \"NFTStaking.addPool: Rewards max per each claim can NOT be 0\");\n        require(stakingPools[poolId].rewardPerNFT == 0, 'NFTStaking.addPool: Pool already exists!');\n        require(stakingPools[poolId].poolId == 0, 'NFTStaking.addPool: poolId already exists!');\n        require(stakingPools[poolId].rewardPeriod == 0, 'NFTStaking.addPool: Pool already exists!');\n\n        stakingPools[poolId] = POOL(poolId, _nftTokenId, 0, 0, _rewardPerNFT, _rewardPeriod, _maxPerClaim);\n        stakingPoolsCount++;\n    }\n}\n", "commit_id": "e0b0c7d660c8cfc4b647e600c82ca27580ff8194"}, "fixed_version": {"raw_code": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Context.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC1155/IERC1155.sol';\nimport '@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol';\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nstruct STAKE {\n    uint256 amount;\n    uint256 rewardSoFar;\n    uint256 firstStakedAt;\n    uint256 lastClaimedAt;\n}\n\nstruct POOL {\n    uint256 poolId;\n    uint256 nftTokenId;\n    uint256 totalStakes;\n    uint256 totalRewards;\n    uint256 rewardPerNFT;\n    uint256 rewardPeriod;\n    uint256 maxPerClaim;\n}\n\ncontract NFTStaking is Context, ERC1155Holder, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    /// @dev map poolId to staking Pool detail\n    uint public stakingPoolsCount;\n    mapping(uint256 => POOL) stakingPools;\n    mapping(uint256 => mapping(address => STAKE)) balances;\n    IERC20 private _token;\n    IERC1155 private _nftToken;\n\n    constructor(IERC20 _tokenAddress, IERC1155 _nftTokenAddress) {\n        _token = _tokenAddress;\n        _nftToken = _nftTokenAddress;\n        stakingPoolsCount = 0;\n    }\n\n    function setTokenAddress(IERC20 _tokenAddress) external nonReentrant onlyOwner {\n        _token = _tokenAddress;\n    }\n\n    function setNftTokenAddress(IERC1155 _nftTokenAddress) external nonReentrant onlyOwner {\n        _nftToken = _nftTokenAddress;\n    }\n\n    event Stake(uint256 indexed poolId, address staker, uint256 amount);\n    event Unstake(uint256 indexed poolId, address staker, uint256 amount);\n    event Withdraw(uint256 indexed poolId, address staker, uint256 amount);\n\n    /**\n     * @notice get remaining rewards from all existing pools\n     * @return rewardsTotal\n     */\n    function getReservedRewards() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            POOL memory pool = stakingPools[i];\n            uint256 poolRewards = pool.totalRewards;\n            total = total.add(poolRewards);\n        }\n        return total;\n    }\n\n    /**\n     * @notice get staking pool by id\n     * @param _poolId is the staking pool identifier\n     * @return stakingPool\n     */\n    function getPool(uint256 _poolId) public view returns (POOL memory) {\n      return stakingPools[_poolId];\n    }\n\n    /**\n     * @notice gets staking pool by NFT id with highest remaining rewards that the staker can claim\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whom we are looking for the best pool\n     * @return stakingPool\n     */\n    function getPool(uint256 _nftId, address _staker) public view returns (POOL memory) {\n        POOL memory poolInfoBestClaim;\n        POOL memory poolInfoBestAvailable;\n        uint256 bestClaimRewards = 0;\n        uint256 bestAvailableRewards = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            uint256 poolNftId = stakingPools[i].nftTokenId;\n            if (poolNftId == _nftId) {\n                uint256 clamableRewards = rewardOf(i, _staker);\n                uint256 availableRewards = stakingPools[i].totalRewards;\n                if (clamableRewards >= bestClaimRewards) {\n                    poolInfoBestClaim = stakingPools[i];\n                    bestClaimRewards = clamableRewards;\n                }\n                if (availableRewards >= bestAvailableRewards) {\n                    poolInfoBestAvailable = stakingPools[i];\n                    bestAvailableRewards = availableRewards;\n                }\n            }\n        }\n      \n      // if there is no rewards to be claimed, get pool with higer number of rewards that can be distributed\n      if (bestClaimRewards == 0) return poolInfoBestAvailable;\n      return poolInfoBestClaim;\n    }\n\n    /**\n     * @notice gets the staker balance of for the staking pool that can give the most rewards\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return stakingBalance\n     */\n    function getBalance(uint256 _nftId, address _staker) public view returns (STAKE memory) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        STAKE memory balance = balances[poolId][_staker];\n        return balance;\n    }\n\n    /**\n     * @notice gets amount of staker claimable rewards by nft identifier\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return claimable rewards amount\n     */\n    function getRewards(uint256 _nftId, address _staker) public view returns (uint256) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        uint rewards = rewardOf(poolId, _staker);\n        return rewards;\n    }\n\n    /**\n     * @notice calculate total stakes of staker\n     * @param _poolId is the pool identifier\n     * @param _staker is the address of staker\n     * @return _total\n     */\n    function totalStakeOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].amount;\n    }\n\n    /**\n     * @notice calculate entire stake amount\n     * @param _poolId is the pool identifier\n     * @return _total\n     */\n    function getTotalStakes(uint256 _poolId) public view returns (uint256) {\n        return stakingPools[_poolId].totalStakes;\n    }\n\n    /**\n     * @notice get the first staked time\n     * @param _poolId is the pool identifier\n     * @return firstStakedAt\n     */\n    function getFirstStakedAtOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].firstStakedAt;\n    }\n\n    /**\n     * @notice get total claimed reward of staker\n     * @param _poolId is the pool identifier\n     * @return rewardSoFar\n     */\n    function getRewardSoFarOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].rewardSoFar;\n    }\n\n    /**\n     * @notice calculate reward of staker\n     * @param _poolId is the pool identifier\n     * @return reward is the reward amount of the staker\n     */\n    function rewardOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        STAKE memory stakeDetail = balances[_poolId][_staker];\n\n        // if staker is NOT staking the token anymore then rewards is 0\n        // notice that lastClaimedAt is set at the time of stake event occuring, if user didnt staked anything then timePassed calculations would NOT be valid\n        if (stakeDetail.amount == 0) return 0;\n\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        uint256 timeNow = block.timestamp;\n        // passed time in seconds since the last claim\n        uint256 timePassed = timeNow - stakeDetail.lastClaimedAt;\n        uint256 totalReward = stakeDetail.amount.mul(poolInfo.rewardPerNFT).mul(timePassed).div(poolInfo.rewardPeriod);\n\n        // there can be a situation where someone is staking for a very long time and no one is claiming, then sudenly 1 person ruggs everyone\n        // to solve this issue we force people to claim every time they accumulate maxPerClaim and thus available rewards don't suddenly go to 0\n        if (totalReward > poolInfo.maxPerClaim) totalReward = poolInfo.maxPerClaim;\n\n        // there can be a situation where someone is staking longer than others and claimed multiple times\n        // we should inform everyone about this by decreasing everyone max claim\n        uint256 fairRewardPerNFT = poolInfo.totalRewards.div(poolInfo.totalStakes);\n        uint256 maxFairReward = stakeDetail.amount.mul(fairRewardPerNFT);\n        if (totalReward > maxFairReward) totalReward = maxFairReward;\n\n        if (totalReward > poolInfo.totalRewards) totalReward = poolInfo.totalRewards;\n        return totalReward;\n    }\n\n    function claimReward(uint256 _poolId) external nonReentrant {\n        uint256 reward = rewardOf(_poolId, _msgSender());\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        _token.transfer(_msgSender(), reward);\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        emit Withdraw(_poolId, _msgSender(), reward);\n    }\n\n    /**\n     * @notice stake NFT\n     * @param _poolId is the pool identifier\n     * @param _amount is the NFT count to stake\n     */\n    function stake(uint256 _poolId, uint256 _amount) external nonReentrant {\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        _nftToken.safeTransferFrom(_msgSender(), address(this), poolInfo.nftTokenId, _amount, '');\n\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        if (balance.amount > 0) {\n            uint256 reward = rewardOf(_poolId, _msgSender());\n\n            _token.transfer(_msgSender(), reward);\n            balance.rewardSoFar = balance.rewardSoFar.add(reward);\n            poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n            emit Withdraw(_poolId, _msgSender(), reward);\n        }\n        if (balance.amount == 0) balance.firstStakedAt = block.timestamp;\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.amount = balance.amount.add(_amount);\n        stakingPools[_poolId].totalStakes = stakingPools[_poolId].totalStakes.add(_amount);\n\n        emit Stake(_poolId, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice unstake current staking\n     * @param _poolId is the pool identifier\n     */\n    function unstake(uint256 _poolId, uint256 _count) external nonReentrant {\n        require(balances[_poolId][_msgSender()].amount > 0, 'Not staking');\n\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n        uint256 reward = rewardOf(_poolId, _msgSender()).div(balance.amount).mul(_count);\n\n        _token.transfer(_msgSender(), reward);\n        _nftToken.safeTransferFrom(address(this), _msgSender(), poolInfo.nftTokenId, _count, '');\n\n        poolInfo.totalStakes = poolInfo.totalStakes.sub(_count);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        balance.amount = balance.amount.sub(_count);\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n\n        if (balance.amount == 0) {\n            balance.firstStakedAt = 0;\n            balance.lastClaimedAt = 0;\n        }\n\n        emit Unstake(_poolId, _msgSender(), _count);\n    }\n\n    /**\n     * @notice function to notify contract how many rewards to assign for the specific pool\n     * @param _poolId is the pool id to contribute reward\n     * @param _amount is the amount to put\n     */\n    function notifyRewards(uint256 _poolId, uint256 _amount) external nonReentrant onlyOwner {\n        require(_amount > 0, \"NFTStaking.notifyRewards: Can't add zero amount!\");\n\n        POOL storage poolInfo = stakingPools[_poolId];\n        uint total = _token.balanceOf(address(this));\n        uint reserved = getReservedRewards();\n\n        require(total.sub(reserved) >= _amount, \"NFTStaking.notifyRewards: Can't add more tokens than available\");\n        poolInfo.totalRewards = poolInfo.totalRewards.add(_amount);\n    }\n\n    /**\n     * @notice function to claim staking rewards from the contract\n     * @param poolId is the pool id to contribute reward\n     * @param amount is the amount to claim\n     */\n    function withdrawRewards(uint256 poolId, uint256 amount) external nonReentrant onlyOwner {\n        require(stakingPools[poolId].totalRewards >= amount, 'NFTStaking.withdrawRewards: Not enough remaining rewards!');\n        POOL storage poolInfo = stakingPools[poolId];\n        _token.transfer(_msgSender(), amount);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(amount);\n    }\n\n    /**\n     * @notice adds new staking pool\n     * @param _nftTokenId is the token id that can be staked to the pool\n     * @param _rewardPerNFT is the amount of rewards token can receive over the rewar period \n     * @param _rewardPeriod is the numer of seconds within each nft can earn the amount equal to rewardPerNFT\n     * @param _maxPerClaim each account has restriction regarding max amount per each rewards claim, this way rewards do NOT suddenly disappear when users check their rewards balances\n     */\n    function addPool(\n        uint256 _nftTokenId,\n        uint256 _rewardPerNFT,\n        uint256 _rewardPeriod,\n        uint256 _maxPerClaim\n    ) external nonReentrant onlyOwner {\n        uint256 poolId = stakingPoolsCount;\n        require(_rewardPeriod > 0, \"NFTStaking.addPool: Rewards period can NOT be 0\");\n        require(_maxPerClaim > 0, \"NFTStaking.addPool: Rewards max per each claim can NOT be 0\");\n        require(stakingPools[poolId].rewardPerNFT == 0, 'NFTStaking.addPool: Pool already exists!');\n        require(stakingPools[poolId].poolId == 0, 'NFTStaking.addPool: poolId already exists!');\n        require(stakingPools[poolId].rewardPeriod == 0, 'NFTStaking.addPool: Pool already exists!');\n\n        stakingPools[poolId] = POOL(poolId, _nftTokenId, 0, 0, _rewardPerNFT, _rewardPeriod, _maxPerClaim);\n        stakingPoolsCount++;\n    }\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: Unlicense\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\nstruct STAKE {\n    uint256 amount;\n    uint256 rewardSoFar;\n    uint256 firstStakedAt;\n    uint256 lastClaimedAt;\n}\n\nstruct POOL {\n    uint256 poolId;\n    uint256 nftTokenId;\n    uint256 totalStakes;\n    uint256 totalRewards;\n    uint256 rewardPerNFT;\n    uint256 rewardPeriod;\n    uint256 maxPerClaim;\n}\n\ncontract NFTStaking is Context, ERC1155Holder, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    /// @dev map poolId to staking Pool detail\n    uint public stakingPoolsCount;\n    mapping(uint256 => POOL) stakingPools;\n    mapping(uint256 => mapping(address => STAKE)) balances;\n    IERC20 private _token;\n    IERC1155 private _nftToken;\n\n    constructor(IERC20 _tokenAddress, IERC1155 _nftTokenAddress) {\n        _token = _tokenAddress;\n        _nftToken = _nftTokenAddress;\n        stakingPoolsCount = 0;\n    }\n\n    function setTokenAddress(IERC20 _tokenAddress) external nonReentrant onlyOwner {\n        _token = _tokenAddress;\n    }\n\n    function setNftTokenAddress(IERC1155 _nftTokenAddress) external nonReentrant onlyOwner {\n        _nftToken = _nftTokenAddress;\n    }\n\n    event Stake(uint256 indexed poolId, address staker, uint256 amount);\n    event Unstake(uint256 indexed poolId, address staker, uint256 amount);\n    event Withdraw(uint256 indexed poolId, address staker, uint256 amount);\n\n    /**\n     * @notice get remaining rewards from all existing pools\n     * @return rewardsTotal\n     */\n    function getReservedRewards() public view returns (uint256) {\n        uint256 total = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            POOL memory pool = stakingPools[i];\n            uint256 poolRewards = pool.totalRewards;\n            total = total.add(poolRewards);\n        }\n        return total;\n    }\n\n    /**\n     * @notice get staking pool by id\n     * @param _poolId is the staking pool identifier\n     * @return stakingPool\n     */\n    function getPool(uint256 _poolId) public view returns (POOL memory) {\n      return stakingPools[_poolId];\n    }\n\n    /**\n     * @notice gets staking pool by NFT id with highest remaining rewards that the staker can claim\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whom we are looking for the best pool\n     * @return stakingPool\n     */\n    function getPool(uint256 _nftId, address _staker) public view returns (POOL memory) {\n        POOL memory poolInfoBestClaim;\n        POOL memory poolInfoBestAvailable;\n        uint256 bestClaimRewards = 0;\n        uint256 bestAvailableRewards = 0;\n        for (uint i = 0; i < stakingPoolsCount; i++) {\n            uint256 poolNftId = stakingPools[i].nftTokenId;\n            if (poolNftId == _nftId) {\n                uint256 clamableRewards = rewardOf(i, _staker);\n                uint256 availableRewards = stakingPools[i].totalRewards;\n                if (clamableRewards >= bestClaimRewards) {\n                    poolInfoBestClaim = stakingPools[i];\n                    bestClaimRewards = clamableRewards;\n                }\n                if (availableRewards >= bestAvailableRewards) {\n                    poolInfoBestAvailable = stakingPools[i];\n                    bestAvailableRewards = availableRewards;\n                }\n            }\n        }\n      \n      // if there is no rewards to be claimed, get pool with higer number of rewards that can be distributed\n      if (bestClaimRewards == 0) return poolInfoBestAvailable;\n      return poolInfoBestClaim;\n    }\n\n    /**\n     * @notice gets the staker balance of for the staking pool that can give the most rewards\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return stakingBalance\n     */\n    function getBalance(uint256 _nftId, address _staker) public view returns (STAKE memory) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        STAKE memory balance = balances[poolId][_staker];\n        return balance;\n    }\n\n    /**\n     * @notice gets amount of staker claimable rewards by nft identifier\n     * @param _nftId is the NFT identifier\n     * @param _staker is the staker for whose stake we are looking for\n     * @return claimable rewards amount\n     */\n    function getRewards(uint256 _nftId, address _staker) public view returns (uint256) {\n        // get pool that gives max possible rewards at the current time instance\n        POOL memory poolInfo = getPool(_nftId, _staker);\n        uint poolId = poolInfo.poolId;\n        uint rewards = rewardOf(poolId, _staker);\n        return rewards;\n    }\n\n    /**\n     * @notice calculate total stakes of staker\n     * @param _poolId is the pool identifier\n     * @param _staker is the address of staker\n     * @return _total\n     */\n    function totalStakeOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].amount;\n    }\n\n    /**\n     * @notice calculate entire stake amount\n     * @param _poolId is the pool identifier\n     * @return _total\n     */\n    function getTotalStakes(uint256 _poolId) public view returns (uint256) {\n        return stakingPools[_poolId].totalStakes;\n    }\n\n    /**\n     * @notice get the first staked time\n     * @param _poolId is the pool identifier\n     * @return firstStakedAt\n     */\n    function getFirstStakedAtOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].firstStakedAt;\n    }\n\n    /**\n     * @notice get total claimed reward of staker\n     * @param _poolId is the pool identifier\n     * @return rewardSoFar\n     */\n    function getRewardSoFarOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        return balances[_poolId][_staker].rewardSoFar;\n    }\n\n    /**\n     * @notice calculate reward of staker\n     * @param _poolId is the pool identifier\n     * @return reward is the reward amount of the staker\n     */\n    function rewardOf(uint256 _poolId, address _staker) public view returns (uint256) {\n        STAKE memory stakeDetail = balances[_poolId][_staker];\n\n        // if staker is NOT staking the token anymore then rewards is 0\n        // notice that lastClaimedAt is set at the time of stake event occuring, if user didnt staked anything then timePassed calculations would NOT be valid\n        if (stakeDetail.amount == 0) return 0;\n\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        uint256 timeNow = block.timestamp;\n        // passed time in seconds since the last claim\n        uint256 timePassed = timeNow - stakeDetail.lastClaimedAt;\n        uint256 totalReward = stakeDetail.amount.mul(poolInfo.rewardPerNFT).mul(timePassed).div(poolInfo.rewardPeriod);\n\n        // there can be a situation where someone is staking for a very long time and no one is claiming, then sudenly 1 person ruggs everyone\n        // to solve this issue we force people to claim every time they accumulate maxPerClaim and thus available rewards don't suddenly go to 0\n        if (totalReward > poolInfo.maxPerClaim) totalReward = poolInfo.maxPerClaim;\n\n        // there can be a situation where someone is staking longer than others and claimed multiple times\n        // we should inform everyone about this by decreasing everyone max claim\n        uint256 fairRewardPerNFT = poolInfo.totalRewards.div(poolInfo.totalStakes);\n        uint256 maxFairReward = stakeDetail.amount.mul(fairRewardPerNFT);\n        if (totalReward > maxFairReward) totalReward = maxFairReward;\n\n        if (totalReward > poolInfo.totalRewards) totalReward = poolInfo.totalRewards;\n        return totalReward;\n    }\n\n    function claimReward(uint256 _poolId) external nonReentrant {\n        uint256 reward = rewardOf(_poolId, _msgSender());\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        _token.transfer(_msgSender(), reward);\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        emit Withdraw(_poolId, _msgSender(), reward);\n    }\n\n    /**\n     * @notice stake NFT\n     * @param _poolId is the pool identifier\n     * @param _amount is the NFT count to stake\n     */\n    function stake(uint256 _poolId, uint256 _amount) external nonReentrant {\n        POOL memory poolInfo = stakingPools[_poolId];\n\n        _nftToken.safeTransferFrom(_msgSender(), address(this), poolInfo.nftTokenId, _amount, '');\n\n        STAKE storage balance = balances[_poolId][_msgSender()];\n\n        if (balance.amount > 0) {\n            uint256 reward = rewardOf(_poolId, _msgSender());\n\n            _token.transfer(_msgSender(), reward);\n            balance.rewardSoFar = balance.rewardSoFar.add(reward);\n            poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n            emit Withdraw(_poolId, _msgSender(), reward);\n        }\n        if (balance.amount == 0) balance.firstStakedAt = block.timestamp;\n\n        balance.lastClaimedAt = block.timestamp;\n        balance.amount = balance.amount.add(_amount);\n        stakingPools[_poolId].totalStakes = stakingPools[_poolId].totalStakes.add(_amount);\n\n        emit Stake(_poolId, _msgSender(), _amount);\n    }\n\n    /**\n     * @notice unstake current staking\n     * @param _poolId is the pool identifier\n     */\n    function unstake(uint256 _poolId, uint256 _count) external nonReentrant {\n        require(balances[_poolId][_msgSender()].amount > 0, 'Not staking');\n\n        POOL memory poolInfo = stakingPools[_poolId];\n        STAKE storage balance = balances[_poolId][_msgSender()];\n        uint256 reward = rewardOf(_poolId, _msgSender()).div(balance.amount).mul(_count);\n\n        _token.transfer(_msgSender(), reward);\n        _nftToken.safeTransferFrom(address(this), _msgSender(), poolInfo.nftTokenId, _count, '');\n\n        poolInfo.totalStakes = poolInfo.totalStakes.sub(_count);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(reward);\n\n        balance.amount = balance.amount.sub(_count);\n        balance.rewardSoFar = balance.rewardSoFar.add(reward);\n\n        if (balance.amount == 0) {\n            balance.firstStakedAt = 0;\n            balance.lastClaimedAt = 0;\n        }\n\n        emit Unstake(_poolId, _msgSender(), _count);\n    }\n\n    /**\n     * @notice function to notify contract how many rewards to assign for the specific pool\n     * @param _poolId is the pool id to contribute reward\n     * @param _amount is the amount to put\n     */\n    function notifyRewards(uint256 _poolId, uint256 _amount) external nonReentrant onlyOwner {\n        require(_amount > 0, \"NFTStaking.notifyRewards: Can't add zero amount!\");\n\n        POOL storage poolInfo = stakingPools[_poolId];\n        uint total = _token.balanceOf(address(this));\n        uint reserved = getReservedRewards();\n\n        require(total.sub(reserved) >= _amount, \"NFTStaking.notifyRewards: Can't add more tokens than available\");\n        poolInfo.totalRewards = poolInfo.totalRewards.add(_amount);\n    }\n\n    /**\n     * @notice function to claim staking rewards from the contract\n     * @param poolId is the pool id to contribute reward\n     * @param amount is the amount to claim\n     */\n    function withdrawRewards(uint256 poolId, uint256 amount) external nonReentrant onlyOwner {\n        require(stakingPools[poolId].totalRewards >= amount, 'NFTStaking.withdrawRewards: Not enough remaining rewards!');\n        POOL storage poolInfo = stakingPools[poolId];\n        _token.transfer(_msgSender(), amount);\n        poolInfo.totalRewards = poolInfo.totalRewards.sub(amount);\n    }\n\n    /**\n     * @notice adds new staking pool\n     * @param _nftTokenId is the token id that can be staked to the pool\n     * @param _rewardPerNFT is the amount of rewards token can receive over the rewar period \n     * @param _rewardPeriod is the numer of seconds within each nft can earn the amount equal to rewardPerNFT\n     * @param _maxPerClaim each account has restriction regarding max amount per each rewards claim, this way rewards do NOT suddenly disappear when users check their rewards balances\n     */\n    function addPool(\n        uint256 _nftTokenId,\n        uint256 _rewardPerNFT,\n        uint256 _rewardPeriod,\n        uint256 _maxPerClaim\n    ) external nonReentrant onlyOwner {\n        uint256 poolId = stakingPoolsCount;\n        require(_rewardPeriod > 0, \"NFTStaking.addPool: Rewards period can NOT be 0\");\n        require(_maxPerClaim > 0, \"NFTStaking.addPool: Rewards max per each claim can NOT be 0\");\n        require(stakingPools[poolId].rewardPerNFT == 0, 'NFTStaking.addPool: Pool already exists!');\n        require(stakingPools[poolId].poolId == 0, 'NFTStaking.addPool: poolId already exists!');\n        require(stakingPools[poolId].rewardPeriod == 0, 'NFTStaking.addPool: Pool already exists!');\n\n        stakingPools[poolId] = POOL(poolId, _nftTokenId, 0, 0, _rewardPerNFT, _rewardPeriod, _maxPerClaim);\n        stakingPoolsCount++;\n    }\n}\n", "commit_id": "60983bafc664f4606523897cf9fef410f164bdc2"}}