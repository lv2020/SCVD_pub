{"filename": "contracts/Characters.sol", "patch": "@@ -230,53 +230,26 @@ contract Characters is Initializable, ERC721Upgradeable, AccessControlUpgradeabl\n     );\n   }\n \n-  function fight(uint256 self, uint256 betAmount) \n-    public \n-    onlyNonContract \n-    characterOf(self) \n-    available(self)\n-    hasBalance(betAmount) {\n+  // cannot be performed infinite times. has a timelock\n+  function fightSpecific(uint256 self, uint256 target, uint256 betAmount) public available(self) {\n+    fightStats[self] = FightCount(now, fightStats[self].count+1, (fightStats[self].count+1) % 4 == 0);\n+    _fight(self, target, betAmount, 10); // 90% reward penalization\n+  }\n \n+  // can be performed as much as you want\n+  function fight(uint256 self, uint256 betAmount) public {\n     uint256 target = _getRandomTarget(self);\n-    (bool won, uint256 initH, uint256 finalH) = _fight(self, target);\n-    require(initH >= finalH, \"final health cannot be higher\");\n-\n-    fightStats[self] = FightCount(now, fightStats[self].count+1, (fightStats[self].count+1) % 4 == 0);\n-    if (won) {\n-      if (cdrFee[msg.sender] == 0) {\n-        cdrFee[msg.sender] = now;\n-      }\n-      \n-      uint difficulty = 1100; // 10% winnings base\n-      if (finalH <= initH.div(10)) { // less than 10% health\n-        difficulty = 3000; // 3x payout\n-      } else if (finalH <= initH.div(4)) { // less than 25% health\n-        difficulty = 2000; // 2x payout\n-      } else if (finalH <= initH.div(2)) { // less than 50% health\n-        difficulty = 1500; // 1,5x payout\n-      } else if (finalH <= initH.mul(3).div(4)) { // less than 75% health \n-        difficulty = 1250;\n-      }\n-      uint reward = betAmount.mul(difficulty).div(1000);\n-      tokenRewards[msg.sender] = tokenRewards[msg.sender].add(reward);\n-    } else {\n-      if (tokenRewards[msg.sender] >= betAmount) { // has ingame balance\n-        tokenRewards[msg.sender] = tokenRewards[msg.sender].sub(betAmount);\n-      } else { // doesn't have full ingame balance\n-        uint256 wb = betAmount.sub(tokenRewards[msg.sender]);\n-        tokenRewards[msg.sender] = 0;\n-        battleWagerToken.transferFrom(msg.sender, address(this), wb);        \n-        cdrFee[msg.sender] = 0;\n-      }\n-    }\n+    _fight(self, target, betAmount, 100);\n   }\n \n+  // claimRewards from ingame balance\n   function claimRewards() public onlyNonContract {\n     require(tokenRewards[msg.sender] > 0, \"nothing to claim\");\n     uint256 tax = uint256(getCurrentClaimTax()).add(100).mul(10); // eg. (13 + 100) * 10 = 1130\n     uint256 claimable = tokenRewards[msg.sender].mul(tax).div(1000);\n \n     tokenRewards[msg.sender] = 0; // reset, taxed amount stays in the contract as it was already ours.\n+    cdrFee[msg.sender] = 0;\n     battleWagerToken.safeTransfer(msg.sender, claimable);\n   }\n \n@@ -291,7 +264,54 @@ contract Characters is Initializable, ERC721Upgradeable, AccessControlUpgradeabl\n     return i;\n   }\n \n-  function _fight(uint256 self, uint256 target) private view returns(bool won, uint256 ih, uint256 fh) {\n+  function _fight(uint256 self, uint256 target, uint256 betAmount, uint256 rewardPercentage) \n+    private\n+    onlyNonContract \n+    characterOf(self) \n+    hasBalance(betAmount) {\n+\n+    (bool won, uint256 initH, uint256 finalH) = _performFight(self, target);\n+    require(initH >= finalH, \"final health cannot be higher\");\n+\n+    if (won) {\n+      _onFightWon(initH, finalH, betAmount, rewardPercentage);\n+    } else {\n+      _onFightLost(betAmount);\n+    }\n+  }\n+\n+  function _onFightWon(uint256 initH, uint256 finalH, uint256 betAmount, uint256 rewardPercentage) private {\n+    if (cdrFee[msg.sender] == 0) {\n+      cdrFee[msg.sender] = now;\n+    }\n+      \n+    uint difficulty = 100; // 10% winnings base\n+    if (finalH <= initH.div(10)) { // less than 10% health\n+      difficulty = 2000; // 2x payout\n+    } else if (finalH <= initH.div(4)) { // less than 25% health\n+      difficulty = 1000; // 1x payout\n+    } else if (finalH <= initH.div(2)) { // less than 50% health\n+      difficulty = 500; // 0,5x payout\n+    } else if (finalH <= initH.mul(3).div(4)) { // less than 75% health \n+      difficulty = 250; // 25% payout\n+    }\n+    uint reward = betAmount.mul(difficulty).div(1000).mul(rewardPercentage * 10).div(1000);\n+    tokenRewards[msg.sender] = tokenRewards[msg.sender].add(reward);\n+  }\n+\n+  function _onFightLost(uint256 betAmount) private {\n+    // gotta pay the bet\n+    if (tokenRewards[msg.sender] >= betAmount) { // has enough ingame balance, use it\n+      tokenRewards[msg.sender] = tokenRewards[msg.sender].sub(betAmount);\n+    } else { // doesn't have full ingame balance, use wallet balance + ingame balance if any\n+      uint256 wb = betAmount.sub(tokenRewards[msg.sender]);\n+      tokenRewards[msg.sender] = 0;\n+      cdrFee[msg.sender] = 0;\n+      battleWagerToken.transferFrom(msg.sender, address(this), wb);        \n+    }\n+  }\n+\n+  function _performFight(uint256 self, uint256 target) private view returns(bool won, uint256 ih, uint256 fh) {\n     Character memory att = characters[self];\n     Character memory trg = characters[target];\n ", "project_link": "https://github.com/saantiaguilera/classic-nft-ponzi/commit/1626514b7689f701535916e24b4e722e3464110d", "solc_version": "0.4.0", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "e8a3a47b3843ea380ebc728c846d2d12fbdcd5d6"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "1626514b7689f701535916e24b4e722e3464110d"}}