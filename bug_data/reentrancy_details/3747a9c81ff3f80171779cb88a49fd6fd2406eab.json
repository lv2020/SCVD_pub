{"filename": "solidity/xcall/contracts/CallService.sol", "patch": "@@ -199,6 +199,8 @@ contract CallService is IBSH, ICallService, IFixedFees, Initializable {\n     ) external override {\n         Types.CSMessageRequest memory req = proxyReqs[_reqId];\n         require(!isNullCSMessageRequest(req), \"InvalidRequestId\");\n+        // cleanup\n+        delete proxyReqs[_reqId];\n \n         //TODO require BTPAddress validation\n         (string memory netFrom, ) = req.from.splitBTPAddress();\n@@ -219,9 +221,6 @@ contract CallService is IBSH, ICallService, IFixedFees, Initializable {\n //            errMsg = string(\"unknownError \").concat(Strings.bytesToHex(err));\n         }\n \n-        // cleanup\n-        delete proxyReqs[_reqId];\n-\n         // send response only when there was a rollback\n         if (req.rollback) {\n             bytes memory payload = Types.CSMessageResponse(\n@@ -255,6 +254,7 @@ contract CallService is IBSH, ICallService, IFixedFees, Initializable {\n         Types.CallRequest memory req = requests[_sn];\n         require(!isNullCallRequest(req), \"InvalidSerialNum\");\n         require(req.enabled, \"RollbackNotEnabled\");\n+        cleanupCallRequest(_sn);\n \n         try this.tryHandleCallMessage(\n             req.from,\n@@ -264,7 +264,6 @@ contract CallService is IBSH, ICallService, IFixedFees, Initializable {\n         } catch {\n             //logging\n         }\n-        cleanupCallRequest(_sn);\n     }\n \n     /* Implementation-specific eventlog */", "project_link": "https://github.com/icon-project/btp/commit/3747a9c81ff3f80171779cb88a49fd6fd2406eab", "bug_version": {"raw_code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\npragma abicoder v2;\n\nimport \"./interfaces/IBMC.sol\";\nimport \"./interfaces/IBSH.sol\";\nimport \"./interfaces/ICallService.sol\";\nimport \"./interfaces/ICallServiceReceiver.sol\";\nimport \"./interfaces/IFixedFees.sol\";\nimport \"./libraries/Strings.sol\";\nimport \"./libraries/Integers.sol\";\nimport \"./libraries/ParseAddress.sol\";\nimport \"./libraries/Types.sol\";\nimport \"./libraries/RLPEncodeStruct.sol\";\nimport \"./libraries/RLPDecodeStruct.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract CallService is IBSH, ICallService, IFixedFees, Initializable {\n    using Strings for string;\n    using Integers for uint;\n    using ParseAddress for address;\n    using ParseAddress for string;\n    using RLPEncodeStruct for Types.CSMessage;\n    using RLPEncodeStruct for Types.CSMessageRequest;\n    using RLPEncodeStruct for Types.CSMessageResponse;\n    using RLPDecodeStruct for bytes;\n\n    uint256 private constant MAX_DATA_SIZE = 2048;\n    uint256 private constant MAX_ROLLBACK_SIZE = 1024;\n    string private constant SERVICE = \"xcall\";\n    address private bmc;\n    string private btpAddress;\n    uint256 private lastSn;\n    uint256 private lastReqId;\n\n    mapping(uint256 => Types.CallRequest) private requests;\n    mapping(uint256 => Types.CSMessageRequest) private proxyReqs;\n\n    // for fee-related operations\n    uint256 private constant EXA = 1000000000000000000; //10^18\n    string private constant FEE_DEFAULT = \"default\";\n    address private owner;\n    address private adminAddress;\n    mapping(string => Types.FeeConfig) private feeTable;\n    mapping(string => uint256) private accruedFeeTable;\n\n    modifier onlyBMC() {\n        require(msg.sender == bmc, \"OnlyBMC\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OnlyOwner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == this.admin(), \"OnlyAdmin\");\n        _;\n    }\n\n    function initialize(\n        address _bmc\n    ) public initializer {\n        owner = msg.sender;\n\n        // set bmc address only for the first deploy\n        bmc = _bmc;\n        string memory bmcBtpAddress = IBMC(bmc).getBmcBtpAddress();\n        (string memory _net, ) = bmcBtpAddress.splitBTPAddress();\n        btpAddress = string(\"btp://\")\n            .concat(_net)\n            .concat(\"/\")\n            .concat(address(this).toString());\n\n        // set default fees to (10, 1) ICX\n        if (isNullFeeConfig(feeTable[FEE_DEFAULT])) {\n            feeTable[FEE_DEFAULT] = Types.FeeConfig(\n                EXA * 10,\n                EXA,\n                true\n            );\n        }\n    }\n\n    function checkService(\n        string calldata _svc\n    ) internal pure {\n        require(SERVICE.compareTo(_svc), \"InvalidServiceName\");\n    }\n\n    function getNextSn(\n    ) internal returns (uint256) {\n        lastSn = lastSn + 1;\n        return lastSn;\n    }\n\n    function getNextReqId(\n    ) internal returns (uint256) {\n        lastReqId = lastReqId + 1;\n        return lastReqId;\n    }\n\n    function cleanupCallRequest(\n        uint256 sn\n    ) internal {\n        delete requests[sn];\n        emit CallRequestCleared(sn);\n    }\n\n    function isNullCallRequest(\n        Types.CallRequest memory req\n    ) internal pure returns (bool) {\n        return req.from == address(0);\n    }\n\n    function isNullCSMessageRequest(\n        Types.CSMessageRequest memory req\n    ) internal pure returns (bool) {\n        return bytes(req.from).length == 0;\n    }\n\n    function isNullFeeConfig(\n        Types.FeeConfig memory fc\n    ) internal pure returns (bool) {\n        return !fc.exists;\n    }\n\n    function totalFee(\n        Types.FeeConfig memory _fc\n    ) internal pure returns (uint256) {\n        return _fc.relay + _fc.protocol;\n    }\n\n    /**\n       @notice Sends a call message to the contract on the destination chain.\n       @dev Only allowed to be called from the contract.\n       @param _to The BTP address of the callee on the destination chain\n       @param _data The calldata specific to the target contract\n       @param _rollback (Optional) The data for restoring the caller state when an error occurred\n       @return The serial number of the request\n     */\n    function sendCallMessage(\n        string calldata _to,\n        bytes calldata _data,\n        bytes calldata _rollback\n    ) external payable override returns (uint256) {\n        address caller = msg.sender;\n        // Note if caller is a contract in construction, will revert\n        require(caller.code.length > 0, \"SenderNotAContract\");\n\n        // check size of payloads to avoid abusing\n        require(_data.length <= MAX_DATA_SIZE, \"MaxDataSizeExceeded\");\n        require(_rollback.length <= MAX_ROLLBACK_SIZE, \"MaxRollbackSizeExceeded\");\n\n        //TODO require BTPAddress validation\n        (string memory netTo, string memory dstAccount) = _to.splitBTPAddress();\n        require(bytes(dstAccount).length > 0, \"invalid _to\");\n        Types.FeeConfig memory feeConfig = getFeeConfig(netTo);\n\n        //TODO payable check\n        require(msg.value >= totalFee(feeConfig), \"InsufficientFee\");\n\n        // accumulate fees per type\n        accruedFeeTable[Types.FEE_RELAY]=accruedFeeTable[Types.FEE_RELAY]+feeConfig.relay;\n        accruedFeeTable[Types.FEE_PROTOCOL]=accruedFeeTable[Types.FEE_PROTOCOL]+msg.value-feeConfig.relay;\n\n        // send message\n        uint256 sn = getNextSn();\n        bool rollbackEnabled = _rollback.length > 0;\n        if (rollbackEnabled) {\n            requests[sn] = Types.CallRequest(\n                caller,\n                _to,\n                _rollback,\n                false\n            );\n        }\n        bytes memory payload = Types.CSMessageRequest(\n            caller.toString(),\n            dstAccount,\n            sn,\n            rollbackEnabled,\n            _data\n        ).encodeCSMessageRequest();\n        sendBTPMessage(netTo, Types.CS_REQUEST, sn, payload);\n        emit CallMessageSent(caller, _to, sn, _data);\n        return sn;\n    }\n\n    /**\n       @notice Executes the requested call.\n       @dev Caller should be ...\n       @param _reqId The request Id\n     */\n    function executeCall(\n        uint256 _reqId\n    ) external override {\n        Types.CSMessageRequest memory req = proxyReqs[_reqId];\n        require(!isNullCSMessageRequest(req), \"InvalidRequestId\");\n\n        //TODO require BTPAddress validation\n        (string memory netFrom, ) = req.from.splitBTPAddress();\n        int errCode = Types.CS_RESP_SUCCESS;\n        address csrAddress = req.to.parseAddress();\n        string memory errMsg;\n        try this.tryHandleCallMessage(\n            csrAddress,\n            req.from,\n            req.data\n        ) {\n        } catch Error(string memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = err;\n        } catch (bytes memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = string(\"unknownError\");\n//            errMsg = string(\"unknownError \").concat(Strings.bytesToHex(err));\n        }\n\n        // cleanup\n        delete proxyReqs[_reqId];\n\n        // send response only when there was a rollback\n        if (req.rollback) {\n            bytes memory payload = Types.CSMessageResponse(\n                req.sn,\n                errCode,\n                errMsg\n            ).encodeCSMessageResponse();\n            uint256 sn = getNextSn();\n            sendBTPMessage(netFrom, Types.CS_RESPONSE, sn, payload);\n        }\n    }\n\n    //  @dev To catch for invalid address of ICallServiceReceiver\n    function tryHandleCallMessage(\n        address csrAddress,\n        string memory from,\n        bytes memory data\n    ) external {\n        require(msg.sender == address(this), \"OnlyInternal\");\n        ICallServiceReceiver(csrAddress).handleCallMessage(from, data);\n    }\n\n    /**\n       @notice Rollbacks the caller state of the request '_sn'.\n       @dev Caller should be ...\n       @param _sn The serial number of the previous request\n     */\n    function executeRollback(\n        uint256 _sn\n    ) external override {\n        Types.CallRequest memory req = requests[_sn];\n        require(!isNullCallRequest(req), \"InvalidSerialNum\");\n        require(req.enabled, \"RollbackNotEnabled\");\n\n        try this.tryHandleCallMessage(\n            req.from,\n            btpAddress,\n            req.rollback\n        ){\n        } catch {\n            //logging\n        }\n        cleanupCallRequest(_sn);\n    }\n\n    /* Implementation-specific eventlog */\n    event CallMessageSent(\n        address indexed _from,\n        string indexed _to,\n        uint256 indexed _sn,\n        bytes _data\n    );\n\n    /* Implementation-specific eventlog */\n    event CallRequestCleared(\n        uint256 indexed _sn\n    );\n\n    /* ========== Interfaces with BMC ========== */\n    /**\n       @notice Handle BTP Message from other blockchain.\n       @dev Accept the message only from the BMC.\n       Every BSH must implement this function\n       @param _from    Network Address of source network\n       @param _svc     Name of the service\n       @param _sn      Serial number of the message\n       @param _msg     Serialized bytes of ServiceMessage\n   */\n    function handleBTPMessage(\n        string calldata _from,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        Types.CSMessage memory csMsg = _msg.decodeCSMessage();\n        if (csMsg.msgType == Types.CS_REQUEST) {\n            handleRequest(_from, _sn, csMsg.payload);\n        } else if (csMsg.msgType == Types.CS_RESPONSE) {\n            handleResponse(csMsg.payload.decodeCSMessageResponse());\n        } else {\n            //TODO make revert message\n            string memory errMsg = string(\"UnknownMsgType(\")\n                .concat(uint(csMsg.msgType).toString())\n                .concat(string(\")\"));\n            revert(errMsg);\n        }\n    }\n\n    /**\n       @notice Handle the error on delivering the message.\n       @dev Accept the error only from the BMC.\n       Every BSH must implement this function\n       @param _src     BTP Address of BMC generates the error\n       @param _svc     Name of the service\n       @param _sn      Serial number of the original message\n       @param _code    Code of the error\n       @param _msg     Message of the error\n   */\n    function handleBTPError(\n        string calldata _src,\n        string calldata _svc,\n        uint256 _sn,\n        uint256 _code,\n        string calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        string memory errMsg = string(\"BTPError{code=\")\n            .concat(uint(_code).toString())\n            .concat(string(\", msg=\"))\n            .concat(_msg)\n            .concat(string(\"}\"));\n        handleResponse(Types.CSMessageResponse(\n            _sn,\n            Types.CS_RESP_BTP_ERROR,\n            errMsg\n        ));\n    }\n    /* ========================================= */\n\n    function sendBTPMessage(\n        string memory netTo,\n        int msgType,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        bytes memory csMsg = Types.CSMessage(\n            msgType,\n            msgPayload\n        ).encodeCSMessage();\n        IBMC(bmc).sendMessage(\n            netTo,\n            SERVICE,\n            sn,\n            csMsg\n        );\n    }\n\n    function handleRequest(\n        string memory netFrom,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        Types.CSMessageRequest memory req = msgPayload.decodeCSMessageRequest();\n        //TODO make btpaddress\n        string memory from = string(\"btp://\")\n            .concat(netFrom)\n            .concat(string(\"/\"))\n            .concat(req.from);\n        uint256 reqId = getNextReqId();\n        proxyReqs[reqId] = Types.CSMessageRequest(\n            from,\n            req.to,\n            sn,\n            req.rollback,\n            req.data\n        );\n        emit CallMessage(from, req.to, sn, reqId, req.data);\n    }\n\n    function handleResponse(\n        Types.CSMessageResponse memory res\n    ) internal {\n        Types.CallRequest memory req = requests[res.sn];\n        if (!isNullCallRequest(req)) {\n            if (res.code == Types.CS_RESP_SUCCESS){\n                cleanupCallRequest(res.sn);\n            } else {\n                //emit rollback event\n                require(req.rollback.length > 0, \"NoRollbackData\");\n                req.enabled=true;\n                requests[res.sn]=req;\n                emit RollbackMessage(res.sn, req.rollback, res.msg);\n            }\n        }\n    }\n\n    function admin(\n    ) external view returns (address) {\n        if (adminAddress == address(0)) {\n            return owner;\n        }\n        return adminAddress;\n    }\n\n    function setAdmin(\n        address _address\n    ) external onlyOwner {\n        adminAddress = _address;\n    }\n\n    function getFeeConfig(\n        string memory net\n    ) internal view returns (Types.FeeConfig memory) {\n        Types.FeeConfig memory feeConfig = feeTable[net];\n        if (isNullFeeConfig(feeConfig)) {\n            feeConfig = feeTable[FEE_DEFAULT];\n        }\n        return feeConfig;\n    }\n\n    /**\n       @notice Gets the fixed fee for the given network address and type.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The fee amount in loop\n     */\n    function fixedFee(\n        string calldata _net,\n        string calldata _type\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        string memory feeType = _type.lower();\n        if (feeType.compareTo(Types.FEE_RELAY)) {\n            return feeConfig.relay;\n        } else if (feeType.compareTo(Types.FEE_PROTOCOL)) {\n            return feeConfig.protocol;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n       @notice Gets the total fixed fees for the given network address.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @return The total fees amount in loop\n     */\n    function totalFixedFees(\n        string calldata _net\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        return totalFee(feeConfig);\n    }\n\n    /**\n       @notice Sets the fixed fees for the given network address.\n       @dev Only the admin wallet can invoke this.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    function setFixedFees(\n        string calldata _net,\n        uint256 _relay,\n        uint256 _protocol\n    ) external override onlyAdmin {\n        //TODO _net validation revert(\"InvalidNetworkAddress\")\n        feeTable[_net] = Types.FeeConfig(\n            _relay,\n            _protocol,\n            true\n        );\n        emit FixedFeesUpdated(_net, _relay, _protocol);\n    }\n\n    /**\n       @notice Gets the total accrued fees for the given type.\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The total accrued fees in loop\n     */\n    function accruedFees(\n        string calldata _type\n    ) external view override returns (uint256) {\n        return accruedFeeTable[_type];\n    }\n\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\npragma abicoder v2;\n\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n//pragma pragma\n\ninterface IBMC {\n    /**\n        @notice Returns BTP Address of BMC\n        @return BTP Address of BMC\n     */\n    function getBmcBtpAddress() external view returns (string memory);\n\n    /**\n        @notice Send the message to a specific network.\n        @dev Caller must be an registered BSH.\n        @param _to      Network Address of destination network\n        @param _svc     Name of the service\n        @param _sn      Serial number of the message, it should be positive\n        @param _msg     Serialized bytes of Service Message\n     */\n    function sendMessage(\n        string calldata _to,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface IBSH {\n    /**\n       @notice Handle BTP Message from other blockchain.\n       @dev Accept the message only from the BMC.\n       Every BSH must implement this function\n       @param _from    Network Address of source network\n       @param _svc     Name of the service\n       @param _sn      Serial number of the message\n       @param _msg     Serialized bytes of ServiceMessage\n   */\n    function handleBTPMessage(\n        string calldata _from,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external;\n\n    /**\n       @notice Handle the error on delivering the message.\n       @dev Accept the error only from the BMC.\n       Every BSH must implement this function\n       @param _src     BTP Address of BMC generates the error\n       @param _svc     Name of the service\n       @param _sn      Serial number of the original message\n       @param _code    Code of the error\n       @param _msg     Message of the error\n   */\n    function handleBTPError(\n        string calldata _src,\n        string calldata _svc,\n        uint256 _sn,\n        uint256 _code,\n        string calldata _msg\n    ) external;\n\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface ICallService {\n    /*======== At the source CALL_BSH ========*/\n    /**\n       @notice Sends a call message to the contract on the destination chain.\n       @dev Only allowed to be called from the contract.\n       @param _to The BTP address of the callee on the destination chain\n       @param _data The calldata specific to the target contract\n       @param _rollback (Optional) The data for restoring the caller state when an error occurred\n       @return The serial number of the request\n     */\n    function sendCallMessage(\n        string calldata _to,\n        bytes calldata _data,\n        bytes calldata _rollback\n    ) external payable returns (uint256);\n\n    /**\n       @notice Notifies the user that a rollback operation is required for the request '_sn'.\n       @param _sn The serial number of the previous request\n       @param _rollback The data for recovering that was given by the caller\n       @param _reason The error message that caused this rollback\n     */\n    event RollbackMessage(\n        uint256 indexed _sn,\n        bytes _rollback,\n        string _reason\n    );\n\n    /**\n       @notice Rollbacks the caller state of the request '_sn'.\n       @dev Caller should be ...\n       @param _sn The serial number of the previous request\n     */\n    function executeRollback(\n        uint256 _sn\n    ) external;\n\n    /*======== At the destination CALL_BSH ========*/\n    /**\n       @notice Notifies the user that a new call message has arrived.\n       @param _from The BTP address of the caller on the source chain\n       @param _to A string representation of the callee address\n       @param _sn The serial number of the request from the source\n       @param _reqId The request id of the destination chain\n       @param _data The calldata\n     */\n    event CallMessage(\n        string indexed _from,\n        string indexed _to,\n        uint256 indexed _sn,\n        uint256 _reqId,\n        bytes _data\n    );\n\n    /**\n       @notice Executes the requested call.\n       @dev Caller should be ...\n       @param _reqId The request Id\n     */\n    function executeCall(\n        uint256 _reqId\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface ICallServiceReceiver {\n    /**\n       @notice Handles the call message received from the source chain.\n       @dev Only called from the Call Message Service.\n       @param _from The BTP address of the caller on the source chain\n       @param _data The calldata delivered from the caller\n     */\n    function handleCallMessage(\n        string calldata _from,\n        bytes calldata _data\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface IFixedFees {\n    /**\n       @notice Gets the fixed fee for the given network address and type.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The fee amount in loop\n     */\n    function fixedFee(\n        string calldata _net,\n        string calldata _type\n    ) external view returns (uint256);\n\n    /**\n       @notice Gets the total fixed fees for the given network address.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @return The total fees amount in loop\n     */\n    function totalFixedFees(\n        string calldata _net\n    ) external view returns (uint256);\n\n    /**\n       @notice Sets the fixed fees for the given network address.\n       @dev Only the admin wallet can invoke this.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    function setFixedFees(\n        string calldata _net,\n        uint256 _relay,\n        uint256 _protocol\n    ) external;\n\n    /**\n       @notice Gets the total accrued fees for the given type.\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The total accrued fees in loop\n     */\n    function accruedFees(\n        string calldata _type\n    ) external view returns (uint256);\n\n    /**\n       @notice Notifies the user that the fees have been successfully updated.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    event FixedFeesUpdated(\n        string indexed _net,\n        uint256 _relay,\n        uint256 _protocol\n    );\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * Strings Library\n *\n * This is a simple library of string functions which try to simplify\n * string operations in solidity.\n *\n * Please be aware some of these functions can be quite gas heavy so use them only when necessary\n *\n * The original library was modified. If you want to know more about the original version\n * please check this link: https://github.com/willitscale/solidity-util.git\n */\nlibrary Strings {\n    /**\n     * splitBTPAddress\n     *\n     * Split the BTP Address format i.e. btp://1234.iconee/0x123456789\n     * into Network_address (1234.iconee) and Server_address (0x123456789)\n     *\n     * @param _base String base BTP Address format to be split\n     * @dev _base must follow a BTP Address format\n     *\n     * @return string, string   The resulting strings of Network_address and Server_address\n     */\n    function splitBTPAddress(string memory _base)\n        internal\n        pure\n        returns (string memory, string memory)\n    {\n        string[] memory temp = split(_base, \"/\");\n        return (temp[2], temp[3]);\n    }\n\n    function bytesToHex(bytes memory buffer) public pure returns (string memory) {\n        if (buffer.length == 0) {\n            return string(\"0x\");\n        }\n        // Fixed buffer size for hexadecimal convertion\n        bytes memory converted = new bytes(buffer.length * 2);\n\n        bytes memory _base = \"0123456789abcdef\";\n\n        for (uint256 i = 0; i < buffer.length; i++) {\n            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\n        }\n\n        return string(abi.encodePacked(\"0x\", converted));\n    }\n\n    /**\n     * Concat\n     *\n     * Appends two strings together and returns a new value\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string which will be the concatenated\n     *              prefix\n     * @param _value The value to be the concatenated suffix\n     * @return string The resulting string from combinging the base and value\n     */\n    function concat(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(abi.encodePacked(_base, _value));\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function indexOf(string memory _base, string memory _value)\n        internal\n        pure\n        returns (int256)\n    {\n        return _indexOf(_base, _value, 0);\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string starting\n     * from a defined offset\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @param _offset The starting point to start searching from which can start\n     *                from 0, but must not exceed the length of the string\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function _indexOf(\n        string memory _base,\n        string memory _value,\n        uint256 _offset\n    ) internal pure returns (int256) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint256 i = _offset; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] == _valueBytes[0]) {\n                return int256(i);\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Length\n     *\n     * Returns the length of the specified string\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string to be measured\n     * @return uint The length of the passed string\n     */\n    function length(string memory _base) internal pure returns (uint256) {\n        bytes memory _baseBytes = bytes(_base);\n        return _baseBytes.length;\n    }\n\n    /*\n     * String Split (Very high gas cost)\n     *\n     * Splits a string into an array of strings based off the delimiter value.\n     * Please note this can be quite a gas expensive function due to the use of\n     * storage so only use if really required.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string value to be split.\n     * @param _value The delimiter to split the string on which must be a single\n     *               character\n     * @return string[] An array of values split based off the delimiter, but\n     *                  do not container the delimiter.\n     */\n    function split(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string[] memory splitArr)\n    {\n        bytes memory _baseBytes = bytes(_base);\n\n        uint256 _offset = 0;\n        uint256 _splitsCount = 1;\n        while (_offset < _baseBytes.length - 1) {\n            int256 _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1) break;\n            else {\n                _splitsCount++;\n                _offset = uint256(_limit) + 1;\n            }\n        }\n\n        splitArr = new string[](_splitsCount);\n\n        _offset = 0;\n        _splitsCount = 0;\n        while (_offset < _baseBytes.length - 1) {\n            int256 _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1) {\n                _limit = int256(_baseBytes.length);\n            }\n\n            string memory _tmp = new string(uint256(_limit) - _offset);\n            bytes memory _tmpBytes = bytes(_tmp);\n\n            uint256 j = 0;\n            for (uint256 i = _offset; i < uint256(_limit); i++) {\n                _tmpBytes[j++] = _baseBytes[i];\n            }\n            _offset = uint256(_limit) + 1;\n            splitArr[_splitsCount++] = string(_tmpBytes);\n        }\n        return splitArr;\n    }\n\n    /**\n     * Compare To\n     *\n     * Compares the characters of two strings, to ensure that they have an\n     * identical footprint\n     *\n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string base to compare against\n     * @param _value The string the base is being compared to\n     * @return bool Simply notates if the two string have an equivalent\n     */\n    function compareTo(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool)\n    {\n        if (\n            keccak256(abi.encodePacked(_base)) ==\n            keccak256(abi.encodePacked(_value))\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Lower\n     *\n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string\n     */\n    function lower(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     *\n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * Integers Library\n *\n * In summary this is a simple library of integer functions which allow a simple\n * conversion to and from strings\n *\n * The original library was modified. If you want to know more about the original version\n * please check this link: https://github.com/willitscale/solidity-util.git\n */\nlibrary Integers {\n    /**\n     * Parse Int\n     *\n     * Converts an ASCII string value into an uint as long as the string\n     * its self is a valid unsigned integer\n     *\n     * @param _value The ASCII string to be converted to an unsigned integer\n     * @return _ret The unsigned value of the ASCII string\n     */\n    function parseInt(string memory _value)\n    public\n    pure\n    returns (uint _ret) {\n        bytes memory _bytesValue = bytes(_value);\n        uint j = 1;\n        for(uint i = _bytesValue.length-1; i >= 0 && i < _bytesValue.length; i--) {\n            assert(uint8(_bytesValue[i]) >= 48 && uint8(_bytesValue[i]) <= 57);\n            _ret += (uint8(_bytesValue[i]) - 48)*j;\n            j*=10;\n        }\n    }\n\n    /**\n     * To String\n     *\n     * Converts an unsigned integer to the ASCII string equivalent value\n     *\n     * @param _base The unsigned integer to be converted to a string\n     * @return string The resulting ASCII string value\n     */\n    function toString(uint _base)\n    internal\n    pure\n    returns (string memory) {\n        if (_base == 0) {\n            return string(\"0\");\n        }\n        bytes memory _tmp = new bytes(32);\n        uint i;\n        for(i = 0;_base > 0;i++) {\n            _tmp[i] = bytes1(uint8((_base % 10) + 48));\n            _base /= 10;\n        }\n        bytes memory _real = new bytes(i--);\n        for(uint j = 0; j < _real.length; j++) {\n            //not allowed i-- if i==0\n            _real[j] = _tmp[i-j];\n        }\n        return string(_real);\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/*\n * Utility library of inline functions on addresses\n */\nlibrary ParseAddress {\n    /**\n     * @dev Get a checksummed string hex representation of an account address.\n     * @param account address The account to get the checksum for.\n     * @return The checksummed account string in ASCII format. Note that leading\n     * \"0x\" is not included.\n     */\n    function toString(address account) internal pure returns (string memory) {\n        // call internal function for converting an account to a checksummed string.\n        return _toChecksumString(account);\n    }\n\n    /**\n     * @dev Get a fixed-size array of whether or not each character in an account\n     * will be capitalized in the checksum.\n     * @param account address The account to get the checksum capitalization\n     * information for.\n     * @return A fixed-size array of booleans that signify if each character or\n     * \"nibble\" of the hex encoding of the address will be capitalized by the\n     * checksum.\n     */\n    function getChecksumCapitalizedCharacters(address account)\n        internal\n        pure\n        returns (bool[40] memory)\n    {\n        // call internal function for computing characters capitalized in checksum.\n        return _toChecksumCapsFlags(account);\n    }\n\n    /**\n     * @dev Determine whether a string hex representation of an account address\n     * matches the ERC-55 checksum of that address.\n     * @param accountChecksum string The checksummed account string in ASCII\n     * format. Note that a leading \"0x\" MUST NOT be included.\n     * @return A boolean signifying whether or not the checksum is valid.\n     */\n    function isChecksumValid(string calldata accountChecksum)\n        internal\n        pure\n        returns (bool)\n    {\n        // call internal function for validating checksum strings.\n        return _isChecksumValid(accountChecksum);\n    }\n\n    function _toChecksumString(address account)\n        internal\n        pure\n        returns (string memory asciiString)\n    {\n        // convert the account argument from address to bytes.\n        bytes20 data = bytes20(account);\n\n        // create an in-memory fixed-size bytes array.\n        bytes memory asciiBytes = new bytes(40);\n\n        // declare variable types.\n        uint8 b;\n        uint8 leftNibble;\n        uint8 rightNibble;\n        bool leftCaps;\n        bool rightCaps;\n        uint8 asciiOffset;\n\n        // get the capitalized characters in the actual checksum.\n        bool[40] memory caps = _toChecksumCapsFlags(account);\n\n        // iterate over bytes, processing left and right nibble in each iteration.\n        for (uint256 i = 0; i < data.length; i++) {\n            // locate the byte and extract each nibble.\n            b = uint8(uint160(data) / (2**(8 * (19 - i))));\n            leftNibble = b / 16;\n            rightNibble = b - 16 * leftNibble;\n\n            // locate and extract each capitalization status.\n            leftCaps = caps[2 * i];\n            rightCaps = caps[2 * i + 1];\n\n            // get the offset from nibble value to ascii character for left nibble.\n            asciiOffset = _getAsciiOffset(leftNibble, leftCaps);\n\n            // add the converted character to the byte array.\n            asciiBytes[2 * i] = bytes1(leftNibble + asciiOffset);\n\n            // get the offset from nibble value to ascii character for right nibble.\n            asciiOffset = _getAsciiOffset(rightNibble, rightCaps);\n\n            // add the converted character to the byte array.\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + asciiOffset);\n        }\n\n        return string(abi.encodePacked(\"0x\", string(asciiBytes)));\n    }\n\n    function _toChecksumCapsFlags(address account)\n        internal\n        pure\n        returns (bool[40] memory characterCapitalized)\n    {\n        // convert the address to bytes.\n        bytes20 a = bytes20(account);\n\n        // hash the address (used to calculate checksum).\n        bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));\n\n        // declare variable types.\n        uint8 leftNibbleAddress;\n        uint8 rightNibbleAddress;\n        uint8 leftNibbleHash;\n        uint8 rightNibbleHash;\n\n        // iterate over bytes, processing left and right nibble in each iteration.\n        for (uint256 i; i < a.length; i++) {\n            // locate the byte and extract each nibble for the address and the hash.\n            rightNibbleAddress = uint8(a[i]) % 16;\n            leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;\n            rightNibbleHash = uint8(b[i]) % 16;\n            leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;\n\n            characterCapitalized[2 * i] = (leftNibbleAddress > 9 &&\n                leftNibbleHash > 7);\n            characterCapitalized[2 * i + 1] = (rightNibbleAddress > 9 &&\n                rightNibbleHash > 7);\n        }\n    }\n\n    function _isChecksumValid(string memory provided)\n        internal\n        pure\n        returns (bool ok)\n    {\n        // convert the provided string into account type.\n        address account = _toAddress(provided);\n\n        // return false in the event the account conversion returned null address.\n        if (account == address(0)) {\n            // ensure that provided address is not also the null address first.\n            bytes memory b = bytes(provided);\n            for (uint256 i; i < b.length; i++) {\n                if (b[i] != hex\"30\") {\n                    return false;\n                }\n            }\n        }\n\n        // get the capitalized characters in the actual checksum.\n        string memory actual = _toChecksumString(account);\n\n        // compare provided string to actual checksum string to test for validity.\n        return (keccak256(abi.encodePacked(actual)) ==\n            keccak256(abi.encodePacked(provided)));\n    }\n\n    function _getAsciiOffset(uint8 nibble, bool caps)\n        internal\n        pure\n        returns (uint8 offset)\n    {\n        // to convert to ascii characters, add 48 to 0-9, 55 to A-F, & 87 to a-f.\n        if (nibble < 10) {\n            offset = 48;\n        } else if (caps) {\n            offset = 55;\n        } else {\n            offset = 87;\n        }\n    }\n\n    function _toAddress(string memory account)\n        internal\n        pure\n        returns (address accountAddress)\n    {\n        // convert the account argument from address to bytes.\n        bytes memory accountBytes = bytes(account);\n\n        // create a new fixed-size byte array for the ascii bytes of the address.\n        bytes memory accountAddressBytes = new bytes(20);\n\n        // declare variable types.\n        uint8 b;\n        uint8 nibble;\n        uint8 asciiOffset;\n\n        // only proceed if the provided string has a length of 40.\n        if (accountBytes.length == 40) {\n            for (uint256 i; i < 40; i++) {\n                // get the byte in question.\n                b = uint8(accountBytes[i]);\n\n                // ensure that the byte is a valid ascii character (0-9, A-F, a-f)\n                if (b < 48) return address(0);\n                if (57 < b && b < 65) return address(0);\n                if (70 < b && b < 97) return address(0);\n                if (102 < b) return address(0); //bytes(hex\"\");\n\n                // find the offset from ascii encoding to the nibble representation.\n                if (b < 65) {\n                    // 0-9\n                    asciiOffset = 48;\n                } else if (70 < b) {\n                    // a-f\n                    asciiOffset = 87;\n                } else {\n                    // A-F\n                    asciiOffset = 55;\n                }\n\n                // store left nibble on even iterations, then store byte on odd ones.\n                if (i % 2 == 0) {\n                    nibble = b - asciiOffset;\n                } else {\n                    accountAddressBytes[(i - 1) / 2] = (\n                        bytes1(16 * nibble + (b - asciiOffset))\n                    );\n                }\n            }\n\n            // pack up the fixed-size byte array and cast it to accountAddress.\n            bytes memory packed = abi.encodePacked(accountAddressBytes);\n            assembly {\n                accountAddress := mload(add(packed, 20))\n            }\n        }\n    }\n\n    // based on https://ethereum.stackexchange.com/a/56499/48410\n    function _toAsciiString(bytes20 data)\n        internal\n        pure\n        returns (string memory asciiString)\n    {\n        // create an in-memory fixed-size bytes array.\n        bytes memory asciiBytes = new bytes(40);\n\n        // declare variable types.\n        uint8 b;\n        uint8 leftNibble;\n        uint8 rightNibble;\n\n        // iterate over bytes, processing left and right nibble in each iteration.\n        for (uint256 i = 0; i < data.length; i++) {\n            // locate the byte and extract each nibble.\n            b = uint8(uint160(data) / (2**(8 * (19 - i))));\n            leftNibble = b / 16;\n            rightNibble = b - 16 * leftNibble;\n\n            // to convert to ascii characters, add 48 to 0-9 and 87 to a-f.\n            asciiBytes[2 * i] = bytes1(\n                leftNibble + (leftNibble < 10 ? 48 : 87)\n            );\n            asciiBytes[2 * i + 1] = bytes1(\n                rightNibble + (rightNibble < 10 ? 48 : 87)\n            );\n        }\n\n        return string(asciiBytes);\n    }\n\n    function parseAddress(\n        string memory account\n    ) internal pure returns (address accountAddress)\n    {\n        bytes memory accountBytes = bytes(account);\n        require(\n            accountBytes.length == 42 &&\n            accountBytes[0] == bytes1(\"0\") &&\n            accountBytes[1] == bytes1(\"x\"),\n            \"Invalid address format\"\n        );\n\n        // create a new fixed-size byte array for the ascii bytes of the address.\n        bytes memory accountAddressBytes = new bytes(20);\n\n        // declare variable types.\n        uint8 b;\n        uint8 nibble;\n        uint8 asciiOffset;\n\n        for (uint256 i = 0; i < 40; i++) {\n            // get the byte in question.\n            b = uint8(accountBytes[i + 2]);\n\n            bool isValidASCII = true;\n            // ensure that the byte is a valid ascii character (0-9, A-F, a-f)\n            if (b < 48) isValidASCII = false;\n            if (57 < b && b < 65) isValidASCII = false;\n            if (70 < b && b < 97) isValidASCII = false;\n            if (102 < b) isValidASCII = false; //bytes(hex\"\");\n\n            // If string contains invalid ASCII characters, revert()\n            if (!isValidASCII) revert(\"Invalid address\");\n\n            // find the offset from ascii encoding to the nibble representation.\n            if (b < 65) {\n                // 0-9\n                asciiOffset = 48;\n            } else if (70 < b) {\n                // a-f\n                asciiOffset = 87;\n            } else {\n                // A-F\n                asciiOffset = 55;\n            }\n\n            // store left nibble on even iterations, then store byte on odd ones.\n            if (i % 2 == 0) {\n                nibble = b - asciiOffset;\n            } else {\n                accountAddressBytes[(i - 1) / 2] = (\n                bytes1(16 * nibble + (b - asciiOffset))\n                );\n            }\n        }\n\n        // pack up the fixed-size byte array and cast it to accountAddress.\n        bytes memory packed = abi.encodePacked(accountAddressBytes);\n        assembly {\n            accountAddress := mload(add(packed, 20))\n        }\n\n        // return false in the event the account conversion returned null address.\n        if (accountAddress == address(0)) {\n            // ensure that provided address is not also the null address first.\n            for (uint256 i = 2; i < accountBytes.length; i++)\n                require(accountBytes[i] == hex\"30\", \"Invalid address\");\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * @notice List of ALL Struct being used to Encode and Decode RLP Messages\n */\nlibrary Types {\n    int constant CS_REQUEST = 1;\n    int constant CS_RESPONSE = 2;\n\n    struct CallRequest {\n        address from;\n        string to;\n        bytes rollback;\n        bool enabled;\n    }\n\n    struct CSMessage {\n        int msgType;\n        bytes payload;\n    }\n\n    struct CSMessageRequest {\n        string from;\n        string to;\n        uint256 sn;\n        bool rollback;\n        bytes data;\n    }\n\n    int constant CS_RESP_SUCCESS = 0;\n    int constant CS_RESP_FAILURE = -1;\n    int constant CS_RESP_BTP_ERROR = -2;\n\n    struct CSMessageResponse {\n        uint256 sn;\n        int code;\n        string msg;\n    }\n\n    string constant FEE_RELAY = \"relay\";\n    string constant FEE_PROTOCOL = \"protocol\";\n\n    struct FeeConfig {\n        uint256 relay;\n        uint256 protocol;\n        bool exists;//only for null check\n    }\n\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n//pragma pragma\n\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * @title RLPEncode\n * @dev A simple RLP encoding library.\n * @author Bakaoh\n * The original code was modified. For more info, please check the link:\n * https://github.com/bakaoh/solidity-rlp-encode.git\n */\nlibrary RLPEncode {\n    int8 internal constant MAX_INT8 = type(int8).max;\n    int16 internal constant MAX_INT16 = type(int16).max;\n    int24 internal constant MAX_INT24 = type(int24).max;\n    int32 internal constant MAX_INT32 = type(int32).max;\n    int40 internal constant MAX_INT40 = type(int40).max;\n    int48 internal constant MAX_INT48 = type(int48).max;\n    int56 internal constant MAX_INT56 = type(int56).max;\n    int64 internal constant MAX_INT64 = type(int64).max;\n    int72 internal constant MAX_INT72 = type(int72).max;\n    int80 internal constant MAX_INT80 = type(int80).max;\n    int88 internal constant MAX_INT88 = type(int88).max;\n    int96 internal constant MAX_INT96 = type(int96).max;\n    int104 internal constant MAX_INT104 = type(int104).max;\n    int112 internal constant MAX_INT112 = type(int112).max;\n    int120 internal constant MAX_INT120 = type(int120).max;\n    int128 internal constant MAX_INT128 = type(int128).max;\n\n    uint8 internal constant MAX_UINT8 = type(uint8).max;\n    uint16 internal constant MAX_UINT16 = type(uint16).max;\n    uint24 internal constant MAX_UINT24 = type(uint24).max;\n    uint32 internal constant MAX_UINT32 = type(uint32).max;\n    uint40 internal constant MAX_UINT40 = type(uint40).max;\n    uint48 internal constant MAX_UINT48 = type(uint48).max;\n    uint56 internal constant MAX_UINT56 = type(uint56).max;\n    uint64 internal constant MAX_UINT64 = type(uint64).max;\n    uint72 internal constant MAX_UINT72 = type(uint72).max;\n    uint80 internal constant MAX_UINT80 = type(uint80).max;\n    uint88 internal constant MAX_UINT88 = type(uint88).max;\n    uint96 internal constant MAX_UINT96 = type(uint96).max;\n    uint104 internal constant MAX_UINT104 = type(uint104).max;\n    uint112 internal constant MAX_UINT112 = type(uint112).max;\n    uint120 internal constant MAX_UINT120 = type(uint120).max;\n    uint128 internal constant MAX_UINT128 = type(uint128).max;\n\n    /*\n     * Internal functions\n     */\n\n    /**\n     * @dev RLP encodes a byte string.\n     * @param self The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeBytes(bytes memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory encoded;\n        if (self.length == 1 && uint8(self[0]) <= 128) {\n            encoded = self;\n        } else {\n            encoded = concat(encodeLength(self.length, 128), self);\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(bytes[] memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory list = flatten(self);\n        return concat(encodeLength(list.length, 192), list);\n    }\n\n    /**\n     * @dev RLP encodes a string.\n     * @param self The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeString(string memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return encodeBytes(bytes(self));\n    }\n\n    /**\n     * @dev RLP encodes an address.\n     * @param self The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory inputBytes;\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, self)\n            )\n            mstore(0x40, add(m, 52))\n            inputBytes := m\n        }\n        return encodeBytes(inputBytes);\n    }\n\n    /**\n     * @dev RLP encodes a uint.\n     * @param self The uint to encode.\n     * @return The RLP encoded uint in bytes.\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        uint nBytes = bitLength(self)/8 + 1;\n        bytes memory uintBytes = encodeUintByLength(self);\n        if (nBytes - uintBytes.length > 0) {\n            uintBytes = abi.encodePacked(bytes1(0), uintBytes);\n        }\n        return encodeBytes(uintBytes);\n    }\n\n    /**\n     * @dev convert int to strict bytes.\n     * @notice only handle to int128 due to contract code size limit\n     * @param n The int to convert.\n     * @return The int in strict bytes without padding.\n     */\n    function intToStrictBytes(int256 n) internal pure returns (bytes memory) {\n        if (-MAX_INT8 - 1 <= n && n <= MAX_INT8) {\n            return abi.encodePacked(int8(n));\n        } else if (-MAX_INT16 - 1 <= n && n <= MAX_INT16) {\n            return abi.encodePacked(int16(n));\n        } else if (-MAX_INT24 - 1 <= n && n <= MAX_INT24) {\n            return abi.encodePacked(int24(n));\n        } else if (-MAX_INT32 - 1 <= n && n <= MAX_INT32) {\n            return abi.encodePacked(int32(n));\n        } else if (-MAX_INT40 - 1 <= n && n <= MAX_INT40) {\n            return abi.encodePacked(int40(n));\n        } else if (-MAX_INT48 - 1 <= n && n <= MAX_INT48) {\n            return abi.encodePacked(int48(n));\n        } else if (-MAX_INT56 - 1 <= n && n <= MAX_INT56) {\n            return abi.encodePacked(int56(n));\n        } else if (-MAX_INT64 - 1 <= n && n <= MAX_INT64) {\n            return abi.encodePacked(int64(n));\n        } else if (-MAX_INT72 - 1 <= n && n <= MAX_INT72) {\n            return abi.encodePacked(int72(n));\n        } else if (-MAX_INT80 - 1 <= n && n <= MAX_INT80) {\n            return abi.encodePacked(int80(n));\n        } else if (-MAX_INT88 - 1 <= n && n <= MAX_INT88) {\n            return abi.encodePacked(int88(n));\n        } else if (-MAX_INT96 - 1 <= n && n <= MAX_INT96) {\n            return abi.encodePacked(int96(n));\n        } else if (-MAX_INT104 - 1 <= n && n <= MAX_INT104) {\n            return abi.encodePacked(int104(n));\n        } else if (-MAX_INT112 - 1 <= n && n <= MAX_INT112) {\n            return abi.encodePacked(int112(n));\n        } else if (-MAX_INT120 - 1 <= n && n <= MAX_INT120) {\n            return abi.encodePacked(int120(n));\n        }\n        require(-MAX_INT128 - 1 <= n && n <= MAX_INT128, \"outOfBounds: [-2^128-1, 2^128]\");\n        return abi.encodePacked(int128(n));\n    }\n\n    /**\n     * @dev RLP encodes an int.\n     * @param self The int to encode.\n     * @return The RLP encoded int in bytes.\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeBytes(intToStrictBytes(self));\n    }\n\n    /**\n     * @dev RLP encodes a bool.\n     * @param self The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (self ? bytes1(0x01) : bytes1(0x00));\n        return encoded;\n    }\n\n    /*\n     * Private functions\n     */\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint256 len, uint256 offset)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen - i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function toBinary(uint256 _x) private pure returns (bytes memory) {\n        //  Modify library to make it work properly when _x = 0\n        if (_x == 0) {\n            return abi.encodePacked(uint8(_x));\n        }\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), _x)\n        }\n        uint256 i;\n        for (i = 0; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n        return res;\n    }\n\n    /**\n     * @dev Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i;\n        for (i = 0; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n\n    /**\n     * @dev Concatenates two bytes.\n     * @notice From: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol.\n     * @param _preBytes First byte string.\n     * @param _postBytes Second byte string.\n     * @return Both byte string combined.\n     */\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            tempBytes := mload(0x40)\n\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            let mc := add(tempBytes, 0x20)\n            let end := add(mc, length)\n\n            for {\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            mc := end\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31)\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @dev convert uint to strict bytes.\n     * @notice only handle to uint128 due to contract code size limit\n     * @param length The uint to convert.\n     * @return The uint in strict bytes without padding.\n     */\n    function encodeUintByLength(uint256 length)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (length < MAX_UINT8) {\n            return abi.encodePacked(uint8(length));\n        } else if (length >= MAX_UINT8 && length < MAX_UINT16) {\n            return abi.encodePacked(uint16(length));\n        } else if (length >= MAX_UINT16 && length < MAX_UINT24) {\n            return abi.encodePacked(uint24(length));\n        } else if (length >= MAX_UINT24 && length < MAX_UINT32) {\n            return abi.encodePacked(uint32(length));\n        } else if (length >= MAX_UINT32 && length < MAX_UINT40) {\n            return abi.encodePacked(uint40(length));\n        } else if (length >= MAX_UINT40 && length < MAX_UINT48) {\n            return abi.encodePacked(uint48(length));\n        } else if (length >= MAX_UINT48 && length < MAX_UINT56) {\n            return abi.encodePacked(uint56(length));\n        } else if (length >= MAX_UINT56 && length < MAX_UINT64) {\n            return abi.encodePacked(uint64(length));\n        } else if (length >= MAX_UINT64 && length < MAX_UINT72) {\n            return abi.encodePacked(uint72(length));\n        } else if (length >= MAX_UINT72 && length < MAX_UINT80) {\n            return abi.encodePacked(uint80(length));\n        } else if (length >= MAX_UINT80 && length < MAX_UINT88) {\n            return abi.encodePacked(uint88(length));\n        } else if (length >= MAX_UINT88 && length < MAX_UINT96) {\n            return abi.encodePacked(uint96(length));\n        } else if (length >= MAX_UINT96 && length < MAX_UINT104) {\n            return abi.encodePacked(uint104(length));\n        } else if (length >= MAX_UINT104 && length < MAX_UINT112) {\n            return abi.encodePacked(uint112(length));\n        } else if (length >= MAX_UINT112 && length < MAX_UINT120) {\n            return abi.encodePacked(uint120(length));\n        }\n        require(length >= MAX_UINT120 && length < MAX_UINT128, \"outOfBounds: [0, 2^128]\");\n        return abi.encodePacked(uint128(length));\n    }\n\n    function bitLength(uint256 n) internal pure returns (uint256) {\n        uint256 count;\n        while (n != 0) {\n            count += 1;\n            n >>= 1;\n        }\n        return count;\n    }\n}\n\nlibrary RLPEncodeStruct {\n    using RLPEncode for bytes;\n    using RLPEncode for string;\n    using RLPEncode for uint256;\n    using RLPEncode for int256;\n    using RLPEncode for address;\n    using RLPEncode for bool;\n\n    using RLPEncodeStruct for Types.CSMessage;\n    using RLPEncodeStruct for Types.CSMessageRequest;\n    using RLPEncodeStruct for Types.CSMessageResponse;\n\n    uint8 internal constant LIST_SHORT_START = 0xc0;\n    uint8 internal constant LIST_LONG_START = 0xf7;\n\n    function encodeCSMessage(Types.CSMessage memory _bs)\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory _rlp =\n        abi.encodePacked(\n            _bs.msgType.encodeInt(),\n            _bs.payload.encodeBytes()\n        );\n        return abi.encodePacked(addLength(_rlp.length, false), _rlp);\n    }\n\n    function encodeCSMessageRequest(Types.CSMessageRequest memory _bs)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory _rlp =\n            abi.encodePacked(\n                _bs.from.encodeString(),\n                _bs.to.encodeString(),\n                _bs.sn.encodeUint(),\n                _bs.rollback.encodeBool(),\n                _bs.data.encodeBytes()\n            );\n        return abi.encodePacked(addLength(_rlp.length, false), _rlp);\n    }\n\n    function encodeCSMessageResponse(Types.CSMessageResponse memory _bs)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory _rlp =\n            abi.encodePacked(\n                _bs.sn.encodeUint(),\n                _bs.code.encodeInt(),\n                _bs.msg.encodeString()\n            );\n        return abi.encodePacked(addLength(_rlp.length, false), _rlp);\n    }\n\n    //  Adding LIST_HEAD_START by length\n    //  There are two cases:\n    //  1. List contains less than or equal 55 elements (total payload of the RLP) -> LIST_HEAD_START = LIST_SHORT_START + [0-55] = [0xC0 - 0xF7]\n    //  2. List contains more than 55 elements:\n    //  - Total Payload = 512 elements = 0x0200\n    //  - Length of Total Payload = 2\n    //  => LIST_HEAD_START = \\x (LIST_LONG_START + length of Total Payload) \\x (Total Payload) = \\x(F7 + 2) \\x(0200) = \\xF9 \\x0200 = 0xF90200\n    function addLength(uint256 length, bool isLongList)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (length > 55 && !isLongList) {\n            bytes memory payLoadSize = RLPEncode.encodeUintByLength(length);\n            return\n                abi.encodePacked(\n                    addLength(payLoadSize.length, true),\n                    payLoadSize\n                );\n        } else if (length <= 55 && !isLongList) {\n            return abi.encodePacked(uint8(LIST_SHORT_START + length));\n        }\n        return abi.encodePacked(uint8(LIST_LONG_START + length));\n    }\n\n    function emptyListHeadStart() internal pure returns (bytes memory) {\n        bytes memory payLoadSize = RLPEncode.encodeUintByLength(0);\n        return\n            abi.encodePacked(\n                abi.encodePacked(uint8(LIST_LONG_START + payLoadSize.length)),\n                payLoadSize\n            );\n    }\n\n    function emptyListShortStart() internal pure returns (bytes memory) {\n        return abi.encodePacked(LIST_SHORT_START);\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n//pragma pragma\n\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/*\n *  Change supporting solidity compiler version\n *  The original code can be found via this link: https://github.com/hamdiallam/Solidity-RLP.git\n */\n\nlibrary RLPDecode {\n    uint8 private constant STRING_SHORT_START = 0x80;\n    uint8 private constant STRING_LONG_START = 0xb8;\n    uint8 private constant LIST_SHORT_START = 0xc0;\n    uint8 private constant LIST_LONG_START = 0xf8;\n    uint8 private constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"Must have next elements\");\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item)\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self)\n        internal\n        pure\n        returns (Iterator memory)\n    {\n        require(isList(self), \"Must be a list\");\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item)\n        internal\n        pure\n        returns (RLPItem[] memory)\n    {\n        require(isList(item), \"Must be a list\");\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"Must have length 1\");\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21, \"Must have length 21\");\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33, \"Invalid uint number\");\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    function toInt(RLPItem memory item) internal pure returns (int256) {\n        if ((toBytes(item)[0] & 0x80) == 0x80) {\n            return int256(toUint(item)) - int256(2**(toBytes(item).length * 8));\n        }\n        return int256(toUint(item));\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33, \"Must have length 33\");\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0, \"Invalid length\");\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (\n            byte0 < STRING_LONG_START ||\n            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\n        ) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n\nlibrary RLPDecodeStruct {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using RLPDecode for bytes;\n\n    using RLPDecodeStruct for bytes;\n\n    uint8 private constant LIST_SHORT_START = 0xc0;\n    uint8 private constant LIST_LONG_START = 0xf7;\n\n    function decodeCSMessage(bytes memory _rlp)\n        internal\n        pure\n        returns (Types.CSMessage memory)\n    {\n        RLPDecode.RLPItem[] memory ls = _rlp.toRlpItem().toList();\n        return\n            Types.CSMessage(\n                ls[0].toInt(),\n                ls[1].toBytes() //  bytes array of RLPEncode(Data)\n            );\n    }\n\n    function decodeCSMessageRequest(bytes memory _rlp)\n        internal\n        pure\n    returns (Types.CSMessageRequest memory)\n    {\n        RLPDecode.RLPItem[] memory ls = _rlp.toRlpItem().toList();\n        return\n        Types.CSMessageRequest(\n            string(ls[0].toBytes()),\n            string(ls[1].toBytes()),\n            ls[2].toUint(),\n            ls[3].toBoolean(),\n            ls[4].toBytes()\n        );\n    }\n\n    function decodeCSMessageResponse(bytes memory _rlp)\n        internal\n        pure\n    returns (Types.CSMessageResponse memory)\n    {\n        RLPDecode.RLPItem[] memory ls = _rlp.toRlpItem().toList();\n        return\n        Types.CSMessageResponse(\n            ls[0].toUint(),\n            int(ls[1].toInt()),\n            string(ls[2].toBytes())\n        );\n    }\n\n}\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n\ncontract CallService is IBSH, ICallService, IFixedFees, Initializable {\n    using Strings for string;\n    using Integers for uint;\n    using ParseAddress for address;\n    using ParseAddress for string;\n    using RLPEncodeStruct for Types.CSMessage;\n    using RLPEncodeStruct for Types.CSMessageRequest;\n    using RLPEncodeStruct for Types.CSMessageResponse;\n    using RLPDecodeStruct for bytes;\n\n    uint256 private constant MAX_DATA_SIZE = 2048;\n    uint256 private constant MAX_ROLLBACK_SIZE = 1024;\n    string private constant SERVICE = \"xcall\";\n    address private bmc;\n    string private btpAddress;\n    uint256 private lastSn;\n    uint256 private lastReqId;\n\n    mapping(uint256 => Types.CallRequest) private requests;\n    mapping(uint256 => Types.CSMessageRequest) private proxyReqs;\n\n    // for fee-related operations\n    uint256 private constant EXA = 1000000000000000000; //10^18\n    string private constant FEE_DEFAULT = \"default\";\n    address private owner;\n    address private adminAddress;\n    mapping(string => Types.FeeConfig) private feeTable;\n    mapping(string => uint256) private accruedFeeTable;\n\n    modifier onlyBMC() {\n        require(msg.sender == bmc, \"OnlyBMC\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OnlyOwner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == this.admin(), \"OnlyAdmin\");\n        _;\n    }\n\n    function initialize(\n        address _bmc\n    ) public initializer {\n        owner = msg.sender;\n\n        // set bmc address only for the first deploy\n        bmc = _bmc;\n        string memory bmcBtpAddress = IBMC(bmc).getBmcBtpAddress();\n        (string memory _net, ) = bmcBtpAddress.splitBTPAddress();\n        btpAddress = string(\"btp://\")\n            .concat(_net)\n            .concat(\"/\")\n            .concat(address(this).toString());\n\n        // set default fees to (10, 1) ICX\n        if (isNullFeeConfig(feeTable[FEE_DEFAULT])) {\n            feeTable[FEE_DEFAULT] = Types.FeeConfig(\n                EXA * 10,\n                EXA,\n                true\n            );\n        }\n    }\n\n    function checkService(\n        string calldata _svc\n    ) internal pure {\n        require(SERVICE.compareTo(_svc), \"InvalidServiceName\");\n    }\n\n    function getNextSn(\n    ) internal returns (uint256) {\n        lastSn = lastSn + 1;\n        return lastSn;\n    }\n\n    function getNextReqId(\n    ) internal returns (uint256) {\n        lastReqId = lastReqId + 1;\n        return lastReqId;\n    }\n\n    function cleanupCallRequest(\n        uint256 sn\n    ) internal {\n        delete requests[sn];\n        emit CallRequestCleared(sn);\n    }\n\n    function isNullCallRequest(\n        Types.CallRequest memory req\n    ) internal pure returns (bool) {\n        return req.from == address(0);\n    }\n\n    function isNullCSMessageRequest(\n        Types.CSMessageRequest memory req\n    ) internal pure returns (bool) {\n        return bytes(req.from).length == 0;\n    }\n\n    function isNullFeeConfig(\n        Types.FeeConfig memory fc\n    ) internal pure returns (bool) {\n        return !fc.exists;\n    }\n\n    function totalFee(\n        Types.FeeConfig memory _fc\n    ) internal pure returns (uint256) {\n        return _fc.relay + _fc.protocol;\n    }\n\n    /**\n       @notice Sends a call message to the contract on the destination chain.\n       @dev Only allowed to be called from the contract.\n       @param _to The BTP address of the callee on the destination chain\n       @param _data The calldata specific to the target contract\n       @param _rollback (Optional) The data for restoring the caller state when an error occurred\n       @return The serial number of the request\n     */\n    function sendCallMessage(\n        string calldata _to,\n        bytes calldata _data,\n        bytes calldata _rollback\n    ) external payable override returns (uint256) {\n        address caller = msg.sender;\n        // Note if caller is a contract in construction, will revert\n        require(caller.code.length > 0, \"SenderNotAContract\");\n\n        // check size of payloads to avoid abusing\n        require(_data.length <= MAX_DATA_SIZE, \"MaxDataSizeExceeded\");\n        require(_rollback.length <= MAX_ROLLBACK_SIZE, \"MaxRollbackSizeExceeded\");\n\n        //TODO require BTPAddress validation\n        (string memory netTo, string memory dstAccount) = _to.splitBTPAddress();\n        require(bytes(dstAccount).length > 0, \"invalid _to\");\n        Types.FeeConfig memory feeConfig = getFeeConfig(netTo);\n\n        //TODO payable check\n        require(msg.value >= totalFee(feeConfig), \"InsufficientFee\");\n\n        // accumulate fees per type\n        accruedFeeTable[Types.FEE_RELAY]=accruedFeeTable[Types.FEE_RELAY]+feeConfig.relay;\n        accruedFeeTable[Types.FEE_PROTOCOL]=accruedFeeTable[Types.FEE_PROTOCOL]+msg.value-feeConfig.relay;\n\n        // send message\n        uint256 sn = getNextSn();\n        bool rollbackEnabled = _rollback.length > 0;\n        if (rollbackEnabled) {\n            requests[sn] = Types.CallRequest(\n                caller,\n                _to,\n                _rollback,\n                false\n            );\n        }\n        bytes memory payload = Types.CSMessageRequest(\n            caller.toString(),\n            dstAccount,\n            sn,\n            rollbackEnabled,\n            _data\n        ).encodeCSMessageRequest();\n        sendBTPMessage(netTo, Types.CS_REQUEST, sn, payload);\n        emit CallMessageSent(caller, _to, sn, _data);\n        return sn;\n    }\n\n    /**\n       @notice Executes the requested call.\n       @dev Caller should be ...\n       @param _reqId The request Id\n     */\n    function executeCall(\n        uint256 _reqId\n    ) external override {\n        Types.CSMessageRequest memory req = proxyReqs[_reqId];\n        require(!isNullCSMessageRequest(req), \"InvalidRequestId\");\n\n        //TODO require BTPAddress validation\n        (string memory netFrom, ) = req.from.splitBTPAddress();\n        int errCode = Types.CS_RESP_SUCCESS;\n        address csrAddress = req.to.parseAddress();\n        string memory errMsg;\n        try this.tryHandleCallMessage(\n            csrAddress,\n            req.from,\n            req.data\n        ) {\n        } catch Error(string memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = err;\n        } catch (bytes memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = string(\"unknownError\");\n//            errMsg = string(\"unknownError \").concat(Strings.bytesToHex(err));\n        }\n\n        // cleanup\n        delete proxyReqs[_reqId];\n\n        // send response only when there was a rollback\n        if (req.rollback) {\n            bytes memory payload = Types.CSMessageResponse(\n                req.sn,\n                errCode,\n                errMsg\n            ).encodeCSMessageResponse();\n            uint256 sn = getNextSn();\n            sendBTPMessage(netFrom, Types.CS_RESPONSE, sn, payload);\n        }\n    }\n\n    //  @dev To catch for invalid address of ICallServiceReceiver\n    function tryHandleCallMessage(\n        address csrAddress,\n        string memory from,\n        bytes memory data\n    ) external {\n        require(msg.sender == address(this), \"OnlyInternal\");\n        ICallServiceReceiver(csrAddress).handleCallMessage(from, data);\n    }\n\n    /**\n       @notice Rollbacks the caller state of the request '_sn'.\n       @dev Caller should be ...\n       @param _sn The serial number of the previous request\n     */\n    function executeRollback(\n        uint256 _sn\n    ) external override {\n        Types.CallRequest memory req = requests[_sn];\n        require(!isNullCallRequest(req), \"InvalidSerialNum\");\n        require(req.enabled, \"RollbackNotEnabled\");\n\n        try this.tryHandleCallMessage(\n            req.from,\n            btpAddress,\n            req.rollback\n        ){\n        } catch {\n            //logging\n        }\n        cleanupCallRequest(_sn);\n    }\n\n    /* Implementation-specific eventlog */\n    event CallMessageSent(\n        address indexed _from,\n        string indexed _to,\n        uint256 indexed _sn,\n        bytes _data\n    );\n\n    /* Implementation-specific eventlog */\n    event CallRequestCleared(\n        uint256 indexed _sn\n    );\n\n    /* ========== Interfaces with BMC ========== */\n    /**\n       @notice Handle BTP Message from other blockchain.\n       @dev Accept the message only from the BMC.\n       Every BSH must implement this function\n       @param _from    Network Address of source network\n       @param _svc     Name of the service\n       @param _sn      Serial number of the message\n       @param _msg     Serialized bytes of ServiceMessage\n   */\n    function handleBTPMessage(\n        string calldata _from,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        Types.CSMessage memory csMsg = _msg.decodeCSMessage();\n        if (csMsg.msgType == Types.CS_REQUEST) {\n            handleRequest(_from, _sn, csMsg.payload);\n        } else if (csMsg.msgType == Types.CS_RESPONSE) {\n            handleResponse(csMsg.payload.decodeCSMessageResponse());\n        } else {\n            //TODO make revert message\n            string memory errMsg = string(\"UnknownMsgType(\")\n                .concat(uint(csMsg.msgType).toString())\n                .concat(string(\")\"));\n            revert(errMsg);\n        }\n    }\n\n    /**\n       @notice Handle the error on delivering the message.\n       @dev Accept the error only from the BMC.\n       Every BSH must implement this function\n       @param _src     BTP Address of BMC generates the error\n       @param _svc     Name of the service\n       @param _sn      Serial number of the original message\n       @param _code    Code of the error\n       @param _msg     Message of the error\n   */\n    function handleBTPError(\n        string calldata _src,\n        string calldata _svc,\n        uint256 _sn,\n        uint256 _code,\n        string calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        string memory errMsg = string(\"BTPError{code=\")\n            .concat(uint(_code).toString())\n            .concat(string(\", msg=\"))\n            .concat(_msg)\n            .concat(string(\"}\"));\n        handleResponse(Types.CSMessageResponse(\n            _sn,\n            Types.CS_RESP_BTP_ERROR,\n            errMsg\n        ));\n    }\n    /* ========================================= */\n\n    function sendBTPMessage(\n        string memory netTo,\n        int msgType,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        bytes memory csMsg = Types.CSMessage(\n            msgType,\n            msgPayload\n        ).encodeCSMessage();\n        IBMC(bmc).sendMessage(\n            netTo,\n            SERVICE,\n            sn,\n            csMsg\n        );\n    }\n\n    function handleRequest(\n        string memory netFrom,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        Types.CSMessageRequest memory req = msgPayload.decodeCSMessageRequest();\n        //TODO make btpaddress\n        string memory from = string(\"btp://\")\n            .concat(netFrom)\n            .concat(string(\"/\"))\n            .concat(req.from);\n        uint256 reqId = getNextReqId();\n        proxyReqs[reqId] = Types.CSMessageRequest(\n            from,\n            req.to,\n            sn,\n            req.rollback,\n            req.data\n        );\n        emit CallMessage(from, req.to, sn, reqId, req.data);\n    }\n\n    function handleResponse(\n        Types.CSMessageResponse memory res\n    ) internal {\n        Types.CallRequest memory req = requests[res.sn];\n        if (!isNullCallRequest(req)) {\n            if (res.code == Types.CS_RESP_SUCCESS){\n                cleanupCallRequest(res.sn);\n            } else {\n                //emit rollback event\n                require(req.rollback.length > 0, \"NoRollbackData\");\n                req.enabled=true;\n                requests[res.sn]=req;\n                emit RollbackMessage(res.sn, req.rollback, res.msg);\n            }\n        }\n    }\n\n    function admin(\n    ) external view returns (address) {\n        if (adminAddress == address(0)) {\n            return owner;\n        }\n        return adminAddress;\n    }\n\n    function setAdmin(\n        address _address\n    ) external onlyOwner {\n        adminAddress = _address;\n    }\n\n    function getFeeConfig(\n        string memory net\n    ) internal view returns (Types.FeeConfig memory) {\n        Types.FeeConfig memory feeConfig = feeTable[net];\n        if (isNullFeeConfig(feeConfig)) {\n            feeConfig = feeTable[FEE_DEFAULT];\n        }\n        return feeConfig;\n    }\n\n    /**\n       @notice Gets the fixed fee for the given network address and type.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The fee amount in loop\n     */\n    function fixedFee(\n        string calldata _net,\n        string calldata _type\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        string memory feeType = _type.lower();\n        if (feeType.compareTo(Types.FEE_RELAY)) {\n            return feeConfig.relay;\n        } else if (feeType.compareTo(Types.FEE_PROTOCOL)) {\n            return feeConfig.protocol;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n       @notice Gets the total fixed fees for the given network address.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @return The total fees amount in loop\n     */\n    function totalFixedFees(\n        string calldata _net\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        return totalFee(feeConfig);\n    }\n\n    /**\n       @notice Sets the fixed fees for the given network address.\n       @dev Only the admin wallet can invoke this.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    function setFixedFees(\n        string calldata _net,\n        uint256 _relay,\n        uint256 _protocol\n    ) external override onlyAdmin {\n        //TODO _net validation revert(\"InvalidNetworkAddress\")\n        feeTable[_net] = Types.FeeConfig(\n            _relay,\n            _protocol,\n            true\n        );\n        emit FixedFeesUpdated(_net, _relay, _protocol);\n    }\n\n    /**\n       @notice Gets the total accrued fees for the given type.\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The total accrued fees in loop\n     */\n    function accruedFees(\n        string calldata _type\n    ) external view override returns (uint256) {\n        return accruedFeeTable[_type];\n    }\n\n}\n", "commit_id": "c052aec3579a9106f9ebc3594a25135dff3db356"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\npragma abicoder v2;\n\nimport \"./interfaces/IBMC.sol\";\nimport \"./interfaces/IBSH.sol\";\nimport \"./interfaces/ICallService.sol\";\nimport \"./interfaces/ICallServiceReceiver.sol\";\nimport \"./interfaces/IFixedFees.sol\";\nimport \"./libraries/Strings.sol\";\nimport \"./libraries/Integers.sol\";\nimport \"./libraries/ParseAddress.sol\";\nimport \"./libraries/Types.sol\";\nimport \"./libraries/RLPEncodeStruct.sol\";\nimport \"./libraries/RLPDecodeStruct.sol\";\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\ncontract CallService is IBSH, ICallService, IFixedFees, Initializable {\n    using Strings for string;\n    using Integers for uint;\n    using ParseAddress for address;\n    using ParseAddress for string;\n    using RLPEncodeStruct for Types.CSMessage;\n    using RLPEncodeStruct for Types.CSMessageRequest;\n    using RLPEncodeStruct for Types.CSMessageResponse;\n    using RLPDecodeStruct for bytes;\n\n    uint256 private constant MAX_DATA_SIZE = 2048;\n    uint256 private constant MAX_ROLLBACK_SIZE = 1024;\n    string private constant SERVICE = \"xcall\";\n    address private bmc;\n    string private btpAddress;\n    uint256 private lastSn;\n    uint256 private lastReqId;\n\n    mapping(uint256 => Types.CallRequest) private requests;\n    mapping(uint256 => Types.CSMessageRequest) private proxyReqs;\n\n    // for fee-related operations\n    uint256 private constant EXA = 1000000000000000000; //10^18\n    string private constant FEE_DEFAULT = \"default\";\n    address private owner;\n    address private adminAddress;\n    mapping(string => Types.FeeConfig) private feeTable;\n    mapping(string => uint256) private accruedFeeTable;\n\n    modifier onlyBMC() {\n        require(msg.sender == bmc, \"OnlyBMC\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OnlyOwner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == this.admin(), \"OnlyAdmin\");\n        _;\n    }\n\n    function initialize(\n        address _bmc\n    ) public initializer {\n        owner = msg.sender;\n\n        // set bmc address only for the first deploy\n        bmc = _bmc;\n        string memory bmcBtpAddress = IBMC(bmc).getBmcBtpAddress();\n        (string memory _net, ) = bmcBtpAddress.splitBTPAddress();\n        btpAddress = string(\"btp://\")\n            .concat(_net)\n            .concat(\"/\")\n            .concat(address(this).toString());\n\n        // set default fees to (10, 1) ICX\n        if (isNullFeeConfig(feeTable[FEE_DEFAULT])) {\n            feeTable[FEE_DEFAULT] = Types.FeeConfig(\n                EXA * 10,\n                EXA,\n                true\n            );\n        }\n    }\n\n    function checkService(\n        string calldata _svc\n    ) internal pure {\n        require(SERVICE.compareTo(_svc), \"InvalidServiceName\");\n    }\n\n    function getNextSn(\n    ) internal returns (uint256) {\n        lastSn = lastSn + 1;\n        return lastSn;\n    }\n\n    function getNextReqId(\n    ) internal returns (uint256) {\n        lastReqId = lastReqId + 1;\n        return lastReqId;\n    }\n\n    function cleanupCallRequest(\n        uint256 sn\n    ) internal {\n        delete requests[sn];\n        emit CallRequestCleared(sn);\n    }\n\n    function isNullCallRequest(\n        Types.CallRequest memory req\n    ) internal pure returns (bool) {\n        return req.from == address(0);\n    }\n\n    function isNullCSMessageRequest(\n        Types.CSMessageRequest memory req\n    ) internal pure returns (bool) {\n        return bytes(req.from).length == 0;\n    }\n\n    function isNullFeeConfig(\n        Types.FeeConfig memory fc\n    ) internal pure returns (bool) {\n        return !fc.exists;\n    }\n\n    function totalFee(\n        Types.FeeConfig memory _fc\n    ) internal pure returns (uint256) {\n        return _fc.relay + _fc.protocol;\n    }\n\n    /**\n       @notice Sends a call message to the contract on the destination chain.\n       @dev Only allowed to be called from the contract.\n       @param _to The BTP address of the callee on the destination chain\n       @param _data The calldata specific to the target contract\n       @param _rollback (Optional) The data for restoring the caller state when an error occurred\n       @return The serial number of the request\n     */\n    function sendCallMessage(\n        string calldata _to,\n        bytes calldata _data,\n        bytes calldata _rollback\n    ) external payable override returns (uint256) {\n        address caller = msg.sender;\n        // Note if caller is a contract in construction, will revert\n        require(caller.code.length > 0, \"SenderNotAContract\");\n\n        // check size of payloads to avoid abusing\n        require(_data.length <= MAX_DATA_SIZE, \"MaxDataSizeExceeded\");\n        require(_rollback.length <= MAX_ROLLBACK_SIZE, \"MaxRollbackSizeExceeded\");\n\n        //TODO require BTPAddress validation\n        (string memory netTo, string memory dstAccount) = _to.splitBTPAddress();\n        require(bytes(dstAccount).length > 0, \"invalid _to\");\n        Types.FeeConfig memory feeConfig = getFeeConfig(netTo);\n\n        //TODO payable check\n        require(msg.value >= totalFee(feeConfig), \"InsufficientFee\");\n\n        // accumulate fees per type\n        accruedFeeTable[Types.FEE_RELAY]=accruedFeeTable[Types.FEE_RELAY]+feeConfig.relay;\n        accruedFeeTable[Types.FEE_PROTOCOL]=accruedFeeTable[Types.FEE_PROTOCOL]+msg.value-feeConfig.relay;\n\n        // send message\n        uint256 sn = getNextSn();\n        bool rollbackEnabled = _rollback.length > 0;\n        if (rollbackEnabled) {\n            requests[sn] = Types.CallRequest(\n                caller,\n                _to,\n                _rollback,\n                false\n            );\n        }\n        bytes memory payload = Types.CSMessageRequest(\n            caller.toString(),\n            dstAccount,\n            sn,\n            rollbackEnabled,\n            _data\n        ).encodeCSMessageRequest();\n        sendBTPMessage(netTo, Types.CS_REQUEST, sn, payload);\n        emit CallMessageSent(caller, _to, sn, _data);\n        return sn;\n    }\n\n    /**\n       @notice Executes the requested call.\n       @dev Caller should be ...\n       @param _reqId The request Id\n     */\n    function executeCall(\n        uint256 _reqId\n    ) external override {\n        Types.CSMessageRequest memory req = proxyReqs[_reqId];\n        require(!isNullCSMessageRequest(req), \"InvalidRequestId\");\n        // cleanup\n        delete proxyReqs[_reqId];\n\n        //TODO require BTPAddress validation\n        (string memory netFrom, ) = req.from.splitBTPAddress();\n        int errCode = Types.CS_RESP_SUCCESS;\n        address csrAddress = req.to.parseAddress();\n        string memory errMsg;\n        try this.tryHandleCallMessage(\n            csrAddress,\n            req.from,\n            req.data\n        ) {\n        } catch Error(string memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = err;\n        } catch (bytes memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = string(\"unknownError\");\n//            errMsg = string(\"unknownError \").concat(Strings.bytesToHex(err));\n        }\n\n        // send response only when there was a rollback\n        if (req.rollback) {\n            bytes memory payload = Types.CSMessageResponse(\n                req.sn,\n                errCode,\n                errMsg\n            ).encodeCSMessageResponse();\n            uint256 sn = getNextSn();\n            sendBTPMessage(netFrom, Types.CS_RESPONSE, sn, payload);\n        }\n    }\n\n    //  @dev To catch for invalid address of ICallServiceReceiver\n    function tryHandleCallMessage(\n        address csrAddress,\n        string memory from,\n        bytes memory data\n    ) external {\n        require(msg.sender == address(this), \"OnlyInternal\");\n        ICallServiceReceiver(csrAddress).handleCallMessage(from, data);\n    }\n\n    /**\n       @notice Rollbacks the caller state of the request '_sn'.\n       @dev Caller should be ...\n       @param _sn The serial number of the previous request\n     */\n    function executeRollback(\n        uint256 _sn\n    ) external override {\n        Types.CallRequest memory req = requests[_sn];\n        require(!isNullCallRequest(req), \"InvalidSerialNum\");\n        require(req.enabled, \"RollbackNotEnabled\");\n        cleanupCallRequest(_sn);\n\n        try this.tryHandleCallMessage(\n            req.from,\n            btpAddress,\n            req.rollback\n        ){\n        } catch {\n            //logging\n        }\n    }\n\n    /* Implementation-specific eventlog */\n    event CallMessageSent(\n        address indexed _from,\n        string indexed _to,\n        uint256 indexed _sn,\n        bytes _data\n    );\n\n    /* Implementation-specific eventlog */\n    event CallRequestCleared(\n        uint256 indexed _sn\n    );\n\n    /* ========== Interfaces with BMC ========== */\n    /**\n       @notice Handle BTP Message from other blockchain.\n       @dev Accept the message only from the BMC.\n       Every BSH must implement this function\n       @param _from    Network Address of source network\n       @param _svc     Name of the service\n       @param _sn      Serial number of the message\n       @param _msg     Serialized bytes of ServiceMessage\n   */\n    function handleBTPMessage(\n        string calldata _from,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        Types.CSMessage memory csMsg = _msg.decodeCSMessage();\n        if (csMsg.msgType == Types.CS_REQUEST) {\n            handleRequest(_from, _sn, csMsg.payload);\n        } else if (csMsg.msgType == Types.CS_RESPONSE) {\n            handleResponse(csMsg.payload.decodeCSMessageResponse());\n        } else {\n            //TODO make revert message\n            string memory errMsg = string(\"UnknownMsgType(\")\n                .concat(uint(csMsg.msgType).toString())\n                .concat(string(\")\"));\n            revert(errMsg);\n        }\n    }\n\n    /**\n       @notice Handle the error on delivering the message.\n       @dev Accept the error only from the BMC.\n       Every BSH must implement this function\n       @param _src     BTP Address of BMC generates the error\n       @param _svc     Name of the service\n       @param _sn      Serial number of the original message\n       @param _code    Code of the error\n       @param _msg     Message of the error\n   */\n    function handleBTPError(\n        string calldata _src,\n        string calldata _svc,\n        uint256 _sn,\n        uint256 _code,\n        string calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        string memory errMsg = string(\"BTPError{code=\")\n            .concat(uint(_code).toString())\n            .concat(string(\", msg=\"))\n            .concat(_msg)\n            .concat(string(\"}\"));\n        handleResponse(Types.CSMessageResponse(\n            _sn,\n            Types.CS_RESP_BTP_ERROR,\n            errMsg\n        ));\n    }\n    /* ========================================= */\n\n    function sendBTPMessage(\n        string memory netTo,\n        int msgType,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        bytes memory csMsg = Types.CSMessage(\n            msgType,\n            msgPayload\n        ).encodeCSMessage();\n        IBMC(bmc).sendMessage(\n            netTo,\n            SERVICE,\n            sn,\n            csMsg\n        );\n    }\n\n    function handleRequest(\n        string memory netFrom,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        Types.CSMessageRequest memory req = msgPayload.decodeCSMessageRequest();\n        //TODO make btpaddress\n        string memory from = string(\"btp://\")\n            .concat(netFrom)\n            .concat(string(\"/\"))\n            .concat(req.from);\n        uint256 reqId = getNextReqId();\n        proxyReqs[reqId] = Types.CSMessageRequest(\n            from,\n            req.to,\n            sn,\n            req.rollback,\n            req.data\n        );\n        emit CallMessage(from, req.to, sn, reqId, req.data);\n    }\n\n    function handleResponse(\n        Types.CSMessageResponse memory res\n    ) internal {\n        Types.CallRequest memory req = requests[res.sn];\n        if (!isNullCallRequest(req)) {\n            if (res.code == Types.CS_RESP_SUCCESS){\n                cleanupCallRequest(res.sn);\n            } else {\n                //emit rollback event\n                require(req.rollback.length > 0, \"NoRollbackData\");\n                req.enabled=true;\n                requests[res.sn]=req;\n                emit RollbackMessage(res.sn, req.rollback, res.msg);\n            }\n        }\n    }\n\n    function admin(\n    ) external view returns (address) {\n        if (adminAddress == address(0)) {\n            return owner;\n        }\n        return adminAddress;\n    }\n\n    function setAdmin(\n        address _address\n    ) external onlyOwner {\n        adminAddress = _address;\n    }\n\n    function getFeeConfig(\n        string memory net\n    ) internal view returns (Types.FeeConfig memory) {\n        Types.FeeConfig memory feeConfig = feeTable[net];\n        if (isNullFeeConfig(feeConfig)) {\n            feeConfig = feeTable[FEE_DEFAULT];\n        }\n        return feeConfig;\n    }\n\n    /**\n       @notice Gets the fixed fee for the given network address and type.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The fee amount in loop\n     */\n    function fixedFee(\n        string calldata _net,\n        string calldata _type\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        string memory feeType = _type.lower();\n        if (feeType.compareTo(Types.FEE_RELAY)) {\n            return feeConfig.relay;\n        } else if (feeType.compareTo(Types.FEE_PROTOCOL)) {\n            return feeConfig.protocol;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n       @notice Gets the total fixed fees for the given network address.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @return The total fees amount in loop\n     */\n    function totalFixedFees(\n        string calldata _net\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        return totalFee(feeConfig);\n    }\n\n    /**\n       @notice Sets the fixed fees for the given network address.\n       @dev Only the admin wallet can invoke this.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    function setFixedFees(\n        string calldata _net,\n        uint256 _relay,\n        uint256 _protocol\n    ) external override onlyAdmin {\n        //TODO _net validation revert(\"InvalidNetworkAddress\")\n        feeTable[_net] = Types.FeeConfig(\n            _relay,\n            _protocol,\n            true\n        );\n        emit FixedFeesUpdated(_net, _relay, _protocol);\n    }\n\n    /**\n       @notice Gets the total accrued fees for the given type.\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The total accrued fees in loop\n     */\n    function accruedFees(\n        string calldata _type\n    ) external view override returns (uint256) {\n        return accruedFeeTable[_type];\n    }\n\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\npragma abicoder v2;\n\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n//pragma pragma\n\ninterface IBMC {\n    /**\n        @notice Returns BTP Address of BMC\n        @return BTP Address of BMC\n     */\n    function getBmcBtpAddress() external view returns (string memory);\n\n    /**\n        @notice Send the message to a specific network.\n        @dev Caller must be an registered BSH.\n        @param _to      Network Address of destination network\n        @param _svc     Name of the service\n        @param _sn      Serial number of the message, it should be positive\n        @param _msg     Serialized bytes of Service Message\n     */\n    function sendMessage(\n        string calldata _to,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface IBSH {\n    /**\n       @notice Handle BTP Message from other blockchain.\n       @dev Accept the message only from the BMC.\n       Every BSH must implement this function\n       @param _from    Network Address of source network\n       @param _svc     Name of the service\n       @param _sn      Serial number of the message\n       @param _msg     Serialized bytes of ServiceMessage\n   */\n    function handleBTPMessage(\n        string calldata _from,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external;\n\n    /**\n       @notice Handle the error on delivering the message.\n       @dev Accept the error only from the BMC.\n       Every BSH must implement this function\n       @param _src     BTP Address of BMC generates the error\n       @param _svc     Name of the service\n       @param _sn      Serial number of the original message\n       @param _code    Code of the error\n       @param _msg     Message of the error\n   */\n    function handleBTPError(\n        string calldata _src,\n        string calldata _svc,\n        uint256 _sn,\n        uint256 _code,\n        string calldata _msg\n    ) external;\n\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface ICallService {\n    /*======== At the source CALL_BSH ========*/\n    /**\n       @notice Sends a call message to the contract on the destination chain.\n       @dev Only allowed to be called from the contract.\n       @param _to The BTP address of the callee on the destination chain\n       @param _data The calldata specific to the target contract\n       @param _rollback (Optional) The data for restoring the caller state when an error occurred\n       @return The serial number of the request\n     */\n    function sendCallMessage(\n        string calldata _to,\n        bytes calldata _data,\n        bytes calldata _rollback\n    ) external payable returns (uint256);\n\n    /**\n       @notice Notifies the user that a rollback operation is required for the request '_sn'.\n       @param _sn The serial number of the previous request\n       @param _rollback The data for recovering that was given by the caller\n       @param _reason The error message that caused this rollback\n     */\n    event RollbackMessage(\n        uint256 indexed _sn,\n        bytes _rollback,\n        string _reason\n    );\n\n    /**\n       @notice Rollbacks the caller state of the request '_sn'.\n       @dev Caller should be ...\n       @param _sn The serial number of the previous request\n     */\n    function executeRollback(\n        uint256 _sn\n    ) external;\n\n    /*======== At the destination CALL_BSH ========*/\n    /**\n       @notice Notifies the user that a new call message has arrived.\n       @param _from The BTP address of the caller on the source chain\n       @param _to A string representation of the callee address\n       @param _sn The serial number of the request from the source\n       @param _reqId The request id of the destination chain\n       @param _data The calldata\n     */\n    event CallMessage(\n        string indexed _from,\n        string indexed _to,\n        uint256 indexed _sn,\n        uint256 _reqId,\n        bytes _data\n    );\n\n    /**\n       @notice Executes the requested call.\n       @dev Caller should be ...\n       @param _reqId The request Id\n     */\n    function executeCall(\n        uint256 _reqId\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface ICallServiceReceiver {\n    /**\n       @notice Handles the call message received from the source chain.\n       @dev Only called from the Call Message Service.\n       @param _from The BTP address of the caller on the source chain\n       @param _data The calldata delivered from the caller\n     */\n    function handleCallMessage(\n        string calldata _from,\n        bytes calldata _data\n    ) external;\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\ninterface IFixedFees {\n    /**\n       @notice Gets the fixed fee for the given network address and type.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The fee amount in loop\n     */\n    function fixedFee(\n        string calldata _net,\n        string calldata _type\n    ) external view returns (uint256);\n\n    /**\n       @notice Gets the total fixed fees for the given network address.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @return The total fees amount in loop\n     */\n    function totalFixedFees(\n        string calldata _net\n    ) external view returns (uint256);\n\n    /**\n       @notice Sets the fixed fees for the given network address.\n       @dev Only the admin wallet can invoke this.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    function setFixedFees(\n        string calldata _net,\n        uint256 _relay,\n        uint256 _protocol\n    ) external;\n\n    /**\n       @notice Gets the total accrued fees for the given type.\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The total accrued fees in loop\n     */\n    function accruedFees(\n        string calldata _type\n    ) external view returns (uint256);\n\n    /**\n       @notice Notifies the user that the fees have been successfully updated.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    event FixedFeesUpdated(\n        string indexed _net,\n        uint256 _relay,\n        uint256 _protocol\n    );\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * Strings Library\n *\n * This is a simple library of string functions which try to simplify\n * string operations in solidity.\n *\n * Please be aware some of these functions can be quite gas heavy so use them only when necessary\n *\n * The original library was modified. If you want to know more about the original version\n * please check this link: https://github.com/willitscale/solidity-util.git\n */\nlibrary Strings {\n    /**\n     * splitBTPAddress\n     *\n     * Split the BTP Address format i.e. btp://1234.iconee/0x123456789\n     * into Network_address (1234.iconee) and Server_address (0x123456789)\n     *\n     * @param _base String base BTP Address format to be split\n     * @dev _base must follow a BTP Address format\n     *\n     * @return string, string   The resulting strings of Network_address and Server_address\n     */\n    function splitBTPAddress(string memory _base)\n        internal\n        pure\n        returns (string memory, string memory)\n    {\n        string[] memory temp = split(_base, \"/\");\n        return (temp[2], temp[3]);\n    }\n\n    function bytesToHex(bytes memory buffer) public pure returns (string memory) {\n        if (buffer.length == 0) {\n            return string(\"0x\");\n        }\n        // Fixed buffer size for hexadecimal convertion\n        bytes memory converted = new bytes(buffer.length * 2);\n\n        bytes memory _base = \"0123456789abcdef\";\n\n        for (uint256 i = 0; i < buffer.length; i++) {\n            converted[i * 2] = _base[uint8(buffer[i]) / _base.length];\n            converted[i * 2 + 1] = _base[uint8(buffer[i]) % _base.length];\n        }\n\n        return string(abi.encodePacked(\"0x\", converted));\n    }\n\n    /**\n     * Concat\n     *\n     * Appends two strings together and returns a new value\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string which will be the concatenated\n     *              prefix\n     * @param _value The value to be the concatenated suffix\n     * @return string The resulting string from combinging the base and value\n     */\n    function concat(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(abi.encodePacked(_base, _value));\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function indexOf(string memory _base, string memory _value)\n        internal\n        pure\n        returns (int256)\n    {\n        return _indexOf(_base, _value, 0);\n    }\n\n    /**\n     * Index Of\n     *\n     * Locates and returns the position of a character within a string starting\n     * from a defined offset\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string acting as the haystack to be\n     *              searched\n     * @param _value The needle to search for, at present this is currently\n     *               limited to one character\n     * @param _offset The starting point to start searching from which can start\n     *                from 0, but must not exceed the length of the string\n     * @return int The position of the needle starting from 0 and returning -1\n     *             in the case of no matches found\n     */\n    function _indexOf(\n        string memory _base,\n        string memory _value,\n        uint256 _offset\n    ) internal pure returns (int256) {\n        bytes memory _baseBytes = bytes(_base);\n        bytes memory _valueBytes = bytes(_value);\n\n        assert(_valueBytes.length == 1);\n\n        for (uint256 i = _offset; i < _baseBytes.length; i++) {\n            if (_baseBytes[i] == _valueBytes[0]) {\n                return int256(i);\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n     * Length\n     *\n     * Returns the length of the specified string\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string to be measured\n     * @return uint The length of the passed string\n     */\n    function length(string memory _base) internal pure returns (uint256) {\n        bytes memory _baseBytes = bytes(_base);\n        return _baseBytes.length;\n    }\n\n    /*\n     * String Split (Very high gas cost)\n     *\n     * Splits a string into an array of strings based off the delimiter value.\n     * Please note this can be quite a gas expensive function due to the use of\n     * storage so only use if really required.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string value to be split.\n     * @param _value The delimiter to split the string on which must be a single\n     *               character\n     * @return string[] An array of values split based off the delimiter, but\n     *                  do not container the delimiter.\n     */\n    function split(string memory _base, string memory _value)\n        internal\n        pure\n        returns (string[] memory splitArr)\n    {\n        bytes memory _baseBytes = bytes(_base);\n\n        uint256 _offset = 0;\n        uint256 _splitsCount = 1;\n        while (_offset < _baseBytes.length - 1) {\n            int256 _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1) break;\n            else {\n                _splitsCount++;\n                _offset = uint256(_limit) + 1;\n            }\n        }\n\n        splitArr = new string[](_splitsCount);\n\n        _offset = 0;\n        _splitsCount = 0;\n        while (_offset < _baseBytes.length - 1) {\n            int256 _limit = _indexOf(_base, _value, _offset);\n            if (_limit == -1) {\n                _limit = int256(_baseBytes.length);\n            }\n\n            string memory _tmp = new string(uint256(_limit) - _offset);\n            bytes memory _tmpBytes = bytes(_tmp);\n\n            uint256 j = 0;\n            for (uint256 i = _offset; i < uint256(_limit); i++) {\n                _tmpBytes[j++] = _baseBytes[i];\n            }\n            _offset = uint256(_limit) + 1;\n            splitArr[_splitsCount++] = string(_tmpBytes);\n        }\n        return splitArr;\n    }\n\n    /**\n     * Compare To\n     *\n     * Compares the characters of two strings, to ensure that they have an\n     * identical footprint\n     *\n     * @param _base When being used for a data type this is the extended object\n     *               otherwise this is the string base to compare against\n     * @param _value The string the base is being compared to\n     * @return bool Simply notates if the two string have an equivalent\n     */\n    function compareTo(string memory _base, string memory _value)\n        internal\n        pure\n        returns (bool)\n    {\n        if (\n            keccak256(abi.encodePacked(_base)) ==\n            keccak256(abi.encodePacked(_value))\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Lower\n     *\n     * Converts all the values of a string to their corresponding lower case\n     * value.\n     *\n     * @param _base When being used for a data type this is the extended object\n     *              otherwise this is the string base to convert to lower case\n     * @return string\n     */\n    function lower(string memory _base)\n        internal\n        pure\n        returns (string memory) {\n        bytes memory _baseBytes = bytes(_base);\n        for (uint i = 0; i < _baseBytes.length; i++) {\n            _baseBytes[i] = _lower(_baseBytes[i]);\n        }\n        return string(_baseBytes);\n    }\n\n    /**\n     * Lower\n     *\n     * Convert an alphabetic character to lower case and return the original\n     * value when not alphabetic\n     *\n     * @param _b1 The byte to be converted to lower case\n     * @return bytes1 The converted value if the passed value was alphabetic\n     *                and in a upper case otherwise returns the original value\n     */\n    function _lower(bytes1 _b1)\n        private\n        pure\n        returns (bytes1) {\n\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\n            return bytes1(uint8(_b1) + 32);\n        }\n\n        return _b1;\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * Integers Library\n *\n * In summary this is a simple library of integer functions which allow a simple\n * conversion to and from strings\n *\n * The original library was modified. If you want to know more about the original version\n * please check this link: https://github.com/willitscale/solidity-util.git\n */\nlibrary Integers {\n    /**\n     * Parse Int\n     *\n     * Converts an ASCII string value into an uint as long as the string\n     * its self is a valid unsigned integer\n     *\n     * @param _value The ASCII string to be converted to an unsigned integer\n     * @return _ret The unsigned value of the ASCII string\n     */\n    function parseInt(string memory _value)\n    public\n    pure\n    returns (uint _ret) {\n        bytes memory _bytesValue = bytes(_value);\n        uint j = 1;\n        for(uint i = _bytesValue.length-1; i >= 0 && i < _bytesValue.length; i--) {\n            assert(uint8(_bytesValue[i]) >= 48 && uint8(_bytesValue[i]) <= 57);\n            _ret += (uint8(_bytesValue[i]) - 48)*j;\n            j*=10;\n        }\n    }\n\n    /**\n     * To String\n     *\n     * Converts an unsigned integer to the ASCII string equivalent value\n     *\n     * @param _base The unsigned integer to be converted to a string\n     * @return string The resulting ASCII string value\n     */\n    function toString(uint _base)\n    internal\n    pure\n    returns (string memory) {\n        if (_base == 0) {\n            return string(\"0\");\n        }\n        bytes memory _tmp = new bytes(32);\n        uint i;\n        for(i = 0;_base > 0;i++) {\n            _tmp[i] = bytes1(uint8((_base % 10) + 48));\n            _base /= 10;\n        }\n        bytes memory _real = new bytes(i--);\n        for(uint j = 0; j < _real.length; j++) {\n            //not allowed i-- if i==0\n            _real[j] = _tmp[i-j];\n        }\n        return string(_real);\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/*\n * Utility library of inline functions on addresses\n */\nlibrary ParseAddress {\n    /**\n     * @dev Get a checksummed string hex representation of an account address.\n     * @param account address The account to get the checksum for.\n     * @return The checksummed account string in ASCII format. Note that leading\n     * \"0x\" is not included.\n     */\n    function toString(address account) internal pure returns (string memory) {\n        // call internal function for converting an account to a checksummed string.\n        return _toChecksumString(account);\n    }\n\n    /**\n     * @dev Get a fixed-size array of whether or not each character in an account\n     * will be capitalized in the checksum.\n     * @param account address The account to get the checksum capitalization\n     * information for.\n     * @return A fixed-size array of booleans that signify if each character or\n     * \"nibble\" of the hex encoding of the address will be capitalized by the\n     * checksum.\n     */\n    function getChecksumCapitalizedCharacters(address account)\n        internal\n        pure\n        returns (bool[40] memory)\n    {\n        // call internal function for computing characters capitalized in checksum.\n        return _toChecksumCapsFlags(account);\n    }\n\n    /**\n     * @dev Determine whether a string hex representation of an account address\n     * matches the ERC-55 checksum of that address.\n     * @param accountChecksum string The checksummed account string in ASCII\n     * format. Note that a leading \"0x\" MUST NOT be included.\n     * @return A boolean signifying whether or not the checksum is valid.\n     */\n    function isChecksumValid(string calldata accountChecksum)\n        internal\n        pure\n        returns (bool)\n    {\n        // call internal function for validating checksum strings.\n        return _isChecksumValid(accountChecksum);\n    }\n\n    function _toChecksumString(address account)\n        internal\n        pure\n        returns (string memory asciiString)\n    {\n        // convert the account argument from address to bytes.\n        bytes20 data = bytes20(account);\n\n        // create an in-memory fixed-size bytes array.\n        bytes memory asciiBytes = new bytes(40);\n\n        // declare variable types.\n        uint8 b;\n        uint8 leftNibble;\n        uint8 rightNibble;\n        bool leftCaps;\n        bool rightCaps;\n        uint8 asciiOffset;\n\n        // get the capitalized characters in the actual checksum.\n        bool[40] memory caps = _toChecksumCapsFlags(account);\n\n        // iterate over bytes, processing left and right nibble in each iteration.\n        for (uint256 i = 0; i < data.length; i++) {\n            // locate the byte and extract each nibble.\n            b = uint8(uint160(data) / (2**(8 * (19 - i))));\n            leftNibble = b / 16;\n            rightNibble = b - 16 * leftNibble;\n\n            // locate and extract each capitalization status.\n            leftCaps = caps[2 * i];\n            rightCaps = caps[2 * i + 1];\n\n            // get the offset from nibble value to ascii character for left nibble.\n            asciiOffset = _getAsciiOffset(leftNibble, leftCaps);\n\n            // add the converted character to the byte array.\n            asciiBytes[2 * i] = bytes1(leftNibble + asciiOffset);\n\n            // get the offset from nibble value to ascii character for right nibble.\n            asciiOffset = _getAsciiOffset(rightNibble, rightCaps);\n\n            // add the converted character to the byte array.\n            asciiBytes[2 * i + 1] = bytes1(rightNibble + asciiOffset);\n        }\n\n        return string(abi.encodePacked(\"0x\", string(asciiBytes)));\n    }\n\n    function _toChecksumCapsFlags(address account)\n        internal\n        pure\n        returns (bool[40] memory characterCapitalized)\n    {\n        // convert the address to bytes.\n        bytes20 a = bytes20(account);\n\n        // hash the address (used to calculate checksum).\n        bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));\n\n        // declare variable types.\n        uint8 leftNibbleAddress;\n        uint8 rightNibbleAddress;\n        uint8 leftNibbleHash;\n        uint8 rightNibbleHash;\n\n        // iterate over bytes, processing left and right nibble in each iteration.\n        for (uint256 i; i < a.length; i++) {\n            // locate the byte and extract each nibble for the address and the hash.\n            rightNibbleAddress = uint8(a[i]) % 16;\n            leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;\n            rightNibbleHash = uint8(b[i]) % 16;\n            leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;\n\n            characterCapitalized[2 * i] = (leftNibbleAddress > 9 &&\n                leftNibbleHash > 7);\n            characterCapitalized[2 * i + 1] = (rightNibbleAddress > 9 &&\n                rightNibbleHash > 7);\n        }\n    }\n\n    function _isChecksumValid(string memory provided)\n        internal\n        pure\n        returns (bool ok)\n    {\n        // convert the provided string into account type.\n        address account = _toAddress(provided);\n\n        // return false in the event the account conversion returned null address.\n        if (account == address(0)) {\n            // ensure that provided address is not also the null address first.\n            bytes memory b = bytes(provided);\n            for (uint256 i; i < b.length; i++) {\n                if (b[i] != hex\"30\") {\n                    return false;\n                }\n            }\n        }\n\n        // get the capitalized characters in the actual checksum.\n        string memory actual = _toChecksumString(account);\n\n        // compare provided string to actual checksum string to test for validity.\n        return (keccak256(abi.encodePacked(actual)) ==\n            keccak256(abi.encodePacked(provided)));\n    }\n\n    function _getAsciiOffset(uint8 nibble, bool caps)\n        internal\n        pure\n        returns (uint8 offset)\n    {\n        // to convert to ascii characters, add 48 to 0-9, 55 to A-F, & 87 to a-f.\n        if (nibble < 10) {\n            offset = 48;\n        } else if (caps) {\n            offset = 55;\n        } else {\n            offset = 87;\n        }\n    }\n\n    function _toAddress(string memory account)\n        internal\n        pure\n        returns (address accountAddress)\n    {\n        // convert the account argument from address to bytes.\n        bytes memory accountBytes = bytes(account);\n\n        // create a new fixed-size byte array for the ascii bytes of the address.\n        bytes memory accountAddressBytes = new bytes(20);\n\n        // declare variable types.\n        uint8 b;\n        uint8 nibble;\n        uint8 asciiOffset;\n\n        // only proceed if the provided string has a length of 40.\n        if (accountBytes.length == 40) {\n            for (uint256 i; i < 40; i++) {\n                // get the byte in question.\n                b = uint8(accountBytes[i]);\n\n                // ensure that the byte is a valid ascii character (0-9, A-F, a-f)\n                if (b < 48) return address(0);\n                if (57 < b && b < 65) return address(0);\n                if (70 < b && b < 97) return address(0);\n                if (102 < b) return address(0); //bytes(hex\"\");\n\n                // find the offset from ascii encoding to the nibble representation.\n                if (b < 65) {\n                    // 0-9\n                    asciiOffset = 48;\n                } else if (70 < b) {\n                    // a-f\n                    asciiOffset = 87;\n                } else {\n                    // A-F\n                    asciiOffset = 55;\n                }\n\n                // store left nibble on even iterations, then store byte on odd ones.\n                if (i % 2 == 0) {\n                    nibble = b - asciiOffset;\n                } else {\n                    accountAddressBytes[(i - 1) / 2] = (\n                        bytes1(16 * nibble + (b - asciiOffset))\n                    );\n                }\n            }\n\n            // pack up the fixed-size byte array and cast it to accountAddress.\n            bytes memory packed = abi.encodePacked(accountAddressBytes);\n            assembly {\n                accountAddress := mload(add(packed, 20))\n            }\n        }\n    }\n\n    // based on https://ethereum.stackexchange.com/a/56499/48410\n    function _toAsciiString(bytes20 data)\n        internal\n        pure\n        returns (string memory asciiString)\n    {\n        // create an in-memory fixed-size bytes array.\n        bytes memory asciiBytes = new bytes(40);\n\n        // declare variable types.\n        uint8 b;\n        uint8 leftNibble;\n        uint8 rightNibble;\n\n        // iterate over bytes, processing left and right nibble in each iteration.\n        for (uint256 i = 0; i < data.length; i++) {\n            // locate the byte and extract each nibble.\n            b = uint8(uint160(data) / (2**(8 * (19 - i))));\n            leftNibble = b / 16;\n            rightNibble = b - 16 * leftNibble;\n\n            // to convert to ascii characters, add 48 to 0-9 and 87 to a-f.\n            asciiBytes[2 * i] = bytes1(\n                leftNibble + (leftNibble < 10 ? 48 : 87)\n            );\n            asciiBytes[2 * i + 1] = bytes1(\n                rightNibble + (rightNibble < 10 ? 48 : 87)\n            );\n        }\n\n        return string(asciiBytes);\n    }\n\n    function parseAddress(\n        string memory account\n    ) internal pure returns (address accountAddress)\n    {\n        bytes memory accountBytes = bytes(account);\n        require(\n            accountBytes.length == 42 &&\n            accountBytes[0] == bytes1(\"0\") &&\n            accountBytes[1] == bytes1(\"x\"),\n            \"Invalid address format\"\n        );\n\n        // create a new fixed-size byte array for the ascii bytes of the address.\n        bytes memory accountAddressBytes = new bytes(20);\n\n        // declare variable types.\n        uint8 b;\n        uint8 nibble;\n        uint8 asciiOffset;\n\n        for (uint256 i = 0; i < 40; i++) {\n            // get the byte in question.\n            b = uint8(accountBytes[i + 2]);\n\n            bool isValidASCII = true;\n            // ensure that the byte is a valid ascii character (0-9, A-F, a-f)\n            if (b < 48) isValidASCII = false;\n            if (57 < b && b < 65) isValidASCII = false;\n            if (70 < b && b < 97) isValidASCII = false;\n            if (102 < b) isValidASCII = false; //bytes(hex\"\");\n\n            // If string contains invalid ASCII characters, revert()\n            if (!isValidASCII) revert(\"Invalid address\");\n\n            // find the offset from ascii encoding to the nibble representation.\n            if (b < 65) {\n                // 0-9\n                asciiOffset = 48;\n            } else if (70 < b) {\n                // a-f\n                asciiOffset = 87;\n            } else {\n                // A-F\n                asciiOffset = 55;\n            }\n\n            // store left nibble on even iterations, then store byte on odd ones.\n            if (i % 2 == 0) {\n                nibble = b - asciiOffset;\n            } else {\n                accountAddressBytes[(i - 1) / 2] = (\n                bytes1(16 * nibble + (b - asciiOffset))\n                );\n            }\n        }\n\n        // pack up the fixed-size byte array and cast it to accountAddress.\n        bytes memory packed = abi.encodePacked(accountAddressBytes);\n        assembly {\n            accountAddress := mload(add(packed, 20))\n        }\n\n        // return false in the event the account conversion returned null address.\n        if (accountAddress == address(0)) {\n            // ensure that provided address is not also the null address first.\n            for (uint256 i = 2; i < accountBytes.length; i++)\n                require(accountBytes[i] == hex\"30\", \"Invalid address\");\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * @notice List of ALL Struct being used to Encode and Decode RLP Messages\n */\nlibrary Types {\n    int constant CS_REQUEST = 1;\n    int constant CS_RESPONSE = 2;\n\n    struct CallRequest {\n        address from;\n        string to;\n        bytes rollback;\n        bool enabled;\n    }\n\n    struct CSMessage {\n        int msgType;\n        bytes payload;\n    }\n\n    struct CSMessageRequest {\n        string from;\n        string to;\n        uint256 sn;\n        bool rollback;\n        bytes data;\n    }\n\n    int constant CS_RESP_SUCCESS = 0;\n    int constant CS_RESP_FAILURE = -1;\n    int constant CS_RESP_BTP_ERROR = -2;\n\n    struct CSMessageResponse {\n        uint256 sn;\n        int code;\n        string msg;\n    }\n\n    string constant FEE_RELAY = \"relay\";\n    string constant FEE_PROTOCOL = \"protocol\";\n\n    struct FeeConfig {\n        uint256 relay;\n        uint256 protocol;\n        bool exists;//only for null check\n    }\n\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n//pragma pragma\n\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/**\n * @title RLPEncode\n * @dev A simple RLP encoding library.\n * @author Bakaoh\n * The original code was modified. For more info, please check the link:\n * https://github.com/bakaoh/solidity-rlp-encode.git\n */\nlibrary RLPEncode {\n    int8 internal constant MAX_INT8 = type(int8).max;\n    int16 internal constant MAX_INT16 = type(int16).max;\n    int24 internal constant MAX_INT24 = type(int24).max;\n    int32 internal constant MAX_INT32 = type(int32).max;\n    int40 internal constant MAX_INT40 = type(int40).max;\n    int48 internal constant MAX_INT48 = type(int48).max;\n    int56 internal constant MAX_INT56 = type(int56).max;\n    int64 internal constant MAX_INT64 = type(int64).max;\n    int72 internal constant MAX_INT72 = type(int72).max;\n    int80 internal constant MAX_INT80 = type(int80).max;\n    int88 internal constant MAX_INT88 = type(int88).max;\n    int96 internal constant MAX_INT96 = type(int96).max;\n    int104 internal constant MAX_INT104 = type(int104).max;\n    int112 internal constant MAX_INT112 = type(int112).max;\n    int120 internal constant MAX_INT120 = type(int120).max;\n    int128 internal constant MAX_INT128 = type(int128).max;\n\n    uint8 internal constant MAX_UINT8 = type(uint8).max;\n    uint16 internal constant MAX_UINT16 = type(uint16).max;\n    uint24 internal constant MAX_UINT24 = type(uint24).max;\n    uint32 internal constant MAX_UINT32 = type(uint32).max;\n    uint40 internal constant MAX_UINT40 = type(uint40).max;\n    uint48 internal constant MAX_UINT48 = type(uint48).max;\n    uint56 internal constant MAX_UINT56 = type(uint56).max;\n    uint64 internal constant MAX_UINT64 = type(uint64).max;\n    uint72 internal constant MAX_UINT72 = type(uint72).max;\n    uint80 internal constant MAX_UINT80 = type(uint80).max;\n    uint88 internal constant MAX_UINT88 = type(uint88).max;\n    uint96 internal constant MAX_UINT96 = type(uint96).max;\n    uint104 internal constant MAX_UINT104 = type(uint104).max;\n    uint112 internal constant MAX_UINT112 = type(uint112).max;\n    uint120 internal constant MAX_UINT120 = type(uint120).max;\n    uint128 internal constant MAX_UINT128 = type(uint128).max;\n\n    /*\n     * Internal functions\n     */\n\n    /**\n     * @dev RLP encodes a byte string.\n     * @param self The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeBytes(bytes memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory encoded;\n        if (self.length == 1 && uint8(self[0]) <= 128) {\n            encoded = self;\n        } else {\n            encoded = concat(encodeLength(self.length, 128), self);\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev RLP encodes a list of RLP encoded byte byte strings.\n     * @param self The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function encodeList(bytes[] memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory list = flatten(self);\n        return concat(encodeLength(list.length, 192), list);\n    }\n\n    /**\n     * @dev RLP encodes a string.\n     * @param self The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function encodeString(string memory self)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return encodeBytes(bytes(self));\n    }\n\n    /**\n     * @dev RLP encodes an address.\n     * @param self The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function encodeAddress(address self) internal pure returns (bytes memory) {\n        bytes memory inputBytes;\n        assembly {\n            let m := mload(0x40)\n            mstore(\n                add(m, 20),\n                xor(0x140000000000000000000000000000000000000000, self)\n            )\n            mstore(0x40, add(m, 52))\n            inputBytes := m\n        }\n        return encodeBytes(inputBytes);\n    }\n\n    /**\n     * @dev RLP encodes a uint.\n     * @param self The uint to encode.\n     * @return The RLP encoded uint in bytes.\n     */\n    function encodeUint(uint256 self) internal pure returns (bytes memory) {\n        uint nBytes = bitLength(self)/8 + 1;\n        bytes memory uintBytes = encodeUintByLength(self);\n        if (nBytes - uintBytes.length > 0) {\n            uintBytes = abi.encodePacked(bytes1(0), uintBytes);\n        }\n        return encodeBytes(uintBytes);\n    }\n\n    /**\n     * @dev convert int to strict bytes.\n     * @notice only handle to int128 due to contract code size limit\n     * @param n The int to convert.\n     * @return The int in strict bytes without padding.\n     */\n    function intToStrictBytes(int256 n) internal pure returns (bytes memory) {\n        if (-MAX_INT8 - 1 <= n && n <= MAX_INT8) {\n            return abi.encodePacked(int8(n));\n        } else if (-MAX_INT16 - 1 <= n && n <= MAX_INT16) {\n            return abi.encodePacked(int16(n));\n        } else if (-MAX_INT24 - 1 <= n && n <= MAX_INT24) {\n            return abi.encodePacked(int24(n));\n        } else if (-MAX_INT32 - 1 <= n && n <= MAX_INT32) {\n            return abi.encodePacked(int32(n));\n        } else if (-MAX_INT40 - 1 <= n && n <= MAX_INT40) {\n            return abi.encodePacked(int40(n));\n        } else if (-MAX_INT48 - 1 <= n && n <= MAX_INT48) {\n            return abi.encodePacked(int48(n));\n        } else if (-MAX_INT56 - 1 <= n && n <= MAX_INT56) {\n            return abi.encodePacked(int56(n));\n        } else if (-MAX_INT64 - 1 <= n && n <= MAX_INT64) {\n            return abi.encodePacked(int64(n));\n        } else if (-MAX_INT72 - 1 <= n && n <= MAX_INT72) {\n            return abi.encodePacked(int72(n));\n        } else if (-MAX_INT80 - 1 <= n && n <= MAX_INT80) {\n            return abi.encodePacked(int80(n));\n        } else if (-MAX_INT88 - 1 <= n && n <= MAX_INT88) {\n            return abi.encodePacked(int88(n));\n        } else if (-MAX_INT96 - 1 <= n && n <= MAX_INT96) {\n            return abi.encodePacked(int96(n));\n        } else if (-MAX_INT104 - 1 <= n && n <= MAX_INT104) {\n            return abi.encodePacked(int104(n));\n        } else if (-MAX_INT112 - 1 <= n && n <= MAX_INT112) {\n            return abi.encodePacked(int112(n));\n        } else if (-MAX_INT120 - 1 <= n && n <= MAX_INT120) {\n            return abi.encodePacked(int120(n));\n        }\n        require(-MAX_INT128 - 1 <= n && n <= MAX_INT128, \"outOfBounds: [-2^128-1, 2^128]\");\n        return abi.encodePacked(int128(n));\n    }\n\n    /**\n     * @dev RLP encodes an int.\n     * @param self The int to encode.\n     * @return The RLP encoded int in bytes.\n     */\n    function encodeInt(int256 self) internal pure returns (bytes memory) {\n        return encodeBytes(intToStrictBytes(self));\n    }\n\n    /**\n     * @dev RLP encodes a bool.\n     * @param self The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function encodeBool(bool self) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (self ? bytes1(0x01) : bytes1(0x00));\n        return encoded;\n    }\n\n    /*\n     * Private functions\n     */\n\n    /**\n     * @dev Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param len The length of the string or the payload.\n     * @param offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function encodeLength(uint256 len, uint256 offset)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory encoded;\n        if (len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes32(len + offset)[31];\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes32(lenLen + offset + 55)[31];\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes32((len / (256**(lenLen - i))) % 256)[31];\n            }\n        }\n        return encoded;\n    }\n\n    /**\n     * @dev Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function toBinary(uint256 _x) private pure returns (bytes memory) {\n        //  Modify library to make it work properly when _x = 0\n        if (_x == 0) {\n            return abi.encodePacked(uint8(_x));\n        }\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), _x)\n        }\n        uint256 i;\n        for (i = 0; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n        return res;\n    }\n\n    /**\n     * @dev Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256**(32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @dev Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i;\n        for (i = 0; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n\n    /**\n     * @dev Concatenates two bytes.\n     * @notice From: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol.\n     * @param _preBytes First byte string.\n     * @param _postBytes Second byte string.\n     * @return Both byte string combined.\n     */\n    function concat(bytes memory _preBytes, bytes memory _postBytes)\n        private\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            tempBytes := mload(0x40)\n\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            let mc := add(tempBytes, 0x20)\n            let end := add(mc, length)\n\n            for {\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            mc := end\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31)\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @dev convert uint to strict bytes.\n     * @notice only handle to uint128 due to contract code size limit\n     * @param length The uint to convert.\n     * @return The uint in strict bytes without padding.\n     */\n    function encodeUintByLength(uint256 length)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (length < MAX_UINT8) {\n            return abi.encodePacked(uint8(length));\n        } else if (length >= MAX_UINT8 && length < MAX_UINT16) {\n            return abi.encodePacked(uint16(length));\n        } else if (length >= MAX_UINT16 && length < MAX_UINT24) {\n            return abi.encodePacked(uint24(length));\n        } else if (length >= MAX_UINT24 && length < MAX_UINT32) {\n            return abi.encodePacked(uint32(length));\n        } else if (length >= MAX_UINT32 && length < MAX_UINT40) {\n            return abi.encodePacked(uint40(length));\n        } else if (length >= MAX_UINT40 && length < MAX_UINT48) {\n            return abi.encodePacked(uint48(length));\n        } else if (length >= MAX_UINT48 && length < MAX_UINT56) {\n            return abi.encodePacked(uint56(length));\n        } else if (length >= MAX_UINT56 && length < MAX_UINT64) {\n            return abi.encodePacked(uint64(length));\n        } else if (length >= MAX_UINT64 && length < MAX_UINT72) {\n            return abi.encodePacked(uint72(length));\n        } else if (length >= MAX_UINT72 && length < MAX_UINT80) {\n            return abi.encodePacked(uint80(length));\n        } else if (length >= MAX_UINT80 && length < MAX_UINT88) {\n            return abi.encodePacked(uint88(length));\n        } else if (length >= MAX_UINT88 && length < MAX_UINT96) {\n            return abi.encodePacked(uint96(length));\n        } else if (length >= MAX_UINT96 && length < MAX_UINT104) {\n            return abi.encodePacked(uint104(length));\n        } else if (length >= MAX_UINT104 && length < MAX_UINT112) {\n            return abi.encodePacked(uint112(length));\n        } else if (length >= MAX_UINT112 && length < MAX_UINT120) {\n            return abi.encodePacked(uint120(length));\n        }\n        require(length >= MAX_UINT120 && length < MAX_UINT128, \"outOfBounds: [0, 2^128]\");\n        return abi.encodePacked(uint128(length));\n    }\n\n    function bitLength(uint256 n) internal pure returns (uint256) {\n        uint256 count;\n        while (n != 0) {\n            count += 1;\n            n >>= 1;\n        }\n        return count;\n    }\n}\n\nlibrary RLPEncodeStruct {\n    using RLPEncode for bytes;\n    using RLPEncode for string;\n    using RLPEncode for uint256;\n    using RLPEncode for int256;\n    using RLPEncode for address;\n    using RLPEncode for bool;\n\n    using RLPEncodeStruct for Types.CSMessage;\n    using RLPEncodeStruct for Types.CSMessageRequest;\n    using RLPEncodeStruct for Types.CSMessageResponse;\n\n    uint8 internal constant LIST_SHORT_START = 0xc0;\n    uint8 internal constant LIST_LONG_START = 0xf7;\n\n    function encodeCSMessage(Types.CSMessage memory _bs)\n    internal\n    pure\n    returns (bytes memory)\n    {\n        bytes memory _rlp =\n        abi.encodePacked(\n            _bs.msgType.encodeInt(),\n            _bs.payload.encodeBytes()\n        );\n        return abi.encodePacked(addLength(_rlp.length, false), _rlp);\n    }\n\n    function encodeCSMessageRequest(Types.CSMessageRequest memory _bs)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory _rlp =\n            abi.encodePacked(\n                _bs.from.encodeString(),\n                _bs.to.encodeString(),\n                _bs.sn.encodeUint(),\n                _bs.rollback.encodeBool(),\n                _bs.data.encodeBytes()\n            );\n        return abi.encodePacked(addLength(_rlp.length, false), _rlp);\n    }\n\n    function encodeCSMessageResponse(Types.CSMessageResponse memory _bs)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory _rlp =\n            abi.encodePacked(\n                _bs.sn.encodeUint(),\n                _bs.code.encodeInt(),\n                _bs.msg.encodeString()\n            );\n        return abi.encodePacked(addLength(_rlp.length, false), _rlp);\n    }\n\n    //  Adding LIST_HEAD_START by length\n    //  There are two cases:\n    //  1. List contains less than or equal 55 elements (total payload of the RLP) -> LIST_HEAD_START = LIST_SHORT_START + [0-55] = [0xC0 - 0xF7]\n    //  2. List contains more than 55 elements:\n    //  - Total Payload = 512 elements = 0x0200\n    //  - Length of Total Payload = 2\n    //  => LIST_HEAD_START = \\x (LIST_LONG_START + length of Total Payload) \\x (Total Payload) = \\x(F7 + 2) \\x(0200) = \\xF9 \\x0200 = 0xF90200\n    function addLength(uint256 length, bool isLongList)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (length > 55 && !isLongList) {\n            bytes memory payLoadSize = RLPEncode.encodeUintByLength(length);\n            return\n                abi.encodePacked(\n                    addLength(payLoadSize.length, true),\n                    payLoadSize\n                );\n        } else if (length <= 55 && !isLongList) {\n            return abi.encodePacked(uint8(LIST_SHORT_START + length));\n        }\n        return abi.encodePacked(uint8(LIST_LONG_START + length));\n    }\n\n    function emptyListHeadStart() internal pure returns (bytes memory) {\n        bytes memory payLoadSize = RLPEncode.encodeUintByLength(0);\n        return\n            abi.encodePacked(\n                abi.encodePacked(uint8(LIST_LONG_START + payLoadSize.length)),\n                payLoadSize\n            );\n    }\n\n    function emptyListShortStart() internal pure returns (bytes memory) {\n        return abi.encodePacked(LIST_SHORT_START);\n    }\n}\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n//pragma pragma\n\n// IGNORE_LICENSE-Identifier: Apache-2.0\npragma solidity >=0.8.0 <0.8.5;\n\n/*\n *  Change supporting solidity compiler version\n *  The original code can be found via this link: https://github.com/hamdiallam/Solidity-RLP.git\n */\n\nlibrary RLPDecode {\n    uint8 private constant STRING_SHORT_START = 0x80;\n    uint8 private constant STRING_LONG_START = 0xb8;\n    uint8 private constant LIST_SHORT_START = 0xc0;\n    uint8 private constant LIST_LONG_START = 0xf8;\n    uint8 private constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint256 len;\n        uint256 memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item; // Item that's being iterated over.\n        uint256 nextPtr; // Position of the next item in the list.\n    }\n\n    /*\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\n     * @param self The iterator.\n     * @return The next element in the iteration.\n     */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self), \"Must have next elements\");\n\n        uint256 ptr = self.nextPtr;\n        uint256 itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n     * @dev Returns true if the iteration has more elements.\n     * @param self The iterator.\n     * @return true if the iteration has more elements.\n     */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function toRlpItem(bytes memory item)\n        internal\n        pure\n        returns (RLPItem memory)\n    {\n        uint256 memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n     * @dev Create an iterator. Reverts if item is not a list.\n     * @param self The RLP item.\n     * @return An 'Iterator' over the item.\n     */\n    function iterator(RLPItem memory self)\n        internal\n        pure\n        returns (Iterator memory)\n    {\n        require(isList(self), \"Must be a list\");\n\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len;\n    }\n\n    /*\n     * @param item RLP encoded bytes\n     */\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n        return item.len - _payloadOffset(item.memPtr);\n    }\n\n    /*\n     * @param item RLP encoded list in bytes\n     */\n    function toList(RLPItem memory item)\n        internal\n        pure\n        returns (RLPItem[] memory)\n    {\n        require(isList(item), \"Must be a list\");\n\n        uint256 items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 dataLen;\n        for (uint256 i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr);\n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START) return false;\n        return true;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n\n        uint256 ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1, \"Must have length 1\");\n        uint256 result;\n        uint256 memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21, \"Must have length 21\");\n\n        return address(uint160(toUint(item)));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\n        require(item.len > 0 && item.len <= 33, \"Invalid uint number\");\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset;\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + offset;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    function toInt(RLPItem memory item) internal pure returns (int256) {\n        if ((toBytes(item)[0] & 0x80) == 0x80) {\n            return int256(toUint(item)) - int256(2**(toBytes(item).length * 8));\n        }\n        return int256(toUint(item));\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n        // one byte prefix\n        require(item.len == 33, \"Must have length 33\");\n\n        uint256 result;\n        uint256 memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0, \"Invalid length\");\n\n        uint256 offset = _payloadOffset(item.memPtr);\n        uint256 len = item.len - offset; // data length\n        bytes memory result = new bytes(len);\n\n        uint256 destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(item.memPtr + offset, destPtr, len);\n        return result;\n    }\n\n    /*\n     * Private Helpers\n     */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint256) {\n        if (item.len == 0) return 0;\n\n        uint256 count = 0;\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint256 endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\n            count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\n        uint256 itemLen;\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) itemLen = 1;\n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n\n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        } else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n        uint256 byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) return 0;\n        else if (\n            byte0 < STRING_LONG_START ||\n            (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\n        ) return 1;\n        else if (byte0 < LIST_SHORT_START)\n            // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n     * @param src Pointer to source\n     * @param dest Pointer to destination\n     * @param len Amount of memory to copy from the source\n     */\n    function copy(\n        uint256 src,\n        uint256 dest,\n        uint256 len\n    ) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint256 mask = 256**(WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n\nlibrary RLPDecodeStruct {\n    using RLPDecode for RLPDecode.RLPItem;\n    using RLPDecode for RLPDecode.Iterator;\n    using RLPDecode for bytes;\n\n    using RLPDecodeStruct for bytes;\n\n    uint8 private constant LIST_SHORT_START = 0xc0;\n    uint8 private constant LIST_LONG_START = 0xf7;\n\n    function decodeCSMessage(bytes memory _rlp)\n        internal\n        pure\n        returns (Types.CSMessage memory)\n    {\n        RLPDecode.RLPItem[] memory ls = _rlp.toRlpItem().toList();\n        return\n            Types.CSMessage(\n                ls[0].toInt(),\n                ls[1].toBytes() //  bytes array of RLPEncode(Data)\n            );\n    }\n\n    function decodeCSMessageRequest(bytes memory _rlp)\n        internal\n        pure\n    returns (Types.CSMessageRequest memory)\n    {\n        RLPDecode.RLPItem[] memory ls = _rlp.toRlpItem().toList();\n        return\n        Types.CSMessageRequest(\n            string(ls[0].toBytes()),\n            string(ls[1].toBytes()),\n            ls[2].toUint(),\n            ls[3].toBoolean(),\n            ls[4].toBytes()\n        );\n    }\n\n    function decodeCSMessageResponse(bytes memory _rlp)\n        internal\n        pure\n    returns (Types.CSMessageResponse memory)\n    {\n        RLPDecode.RLPItem[] memory ls = _rlp.toRlpItem().toList();\n        return\n        Types.CSMessageResponse(\n            ls[0].toUint(),\n            int(ls[1].toInt()),\n            string(ls[2].toBytes())\n        );\n    }\n\n}\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n\ncontract CallService is IBSH, ICallService, IFixedFees, Initializable {\n    using Strings for string;\n    using Integers for uint;\n    using ParseAddress for address;\n    using ParseAddress for string;\n    using RLPEncodeStruct for Types.CSMessage;\n    using RLPEncodeStruct for Types.CSMessageRequest;\n    using RLPEncodeStruct for Types.CSMessageResponse;\n    using RLPDecodeStruct for bytes;\n\n    uint256 private constant MAX_DATA_SIZE = 2048;\n    uint256 private constant MAX_ROLLBACK_SIZE = 1024;\n    string private constant SERVICE = \"xcall\";\n    address private bmc;\n    string private btpAddress;\n    uint256 private lastSn;\n    uint256 private lastReqId;\n\n    mapping(uint256 => Types.CallRequest) private requests;\n    mapping(uint256 => Types.CSMessageRequest) private proxyReqs;\n\n    // for fee-related operations\n    uint256 private constant EXA = 1000000000000000000; //10^18\n    string private constant FEE_DEFAULT = \"default\";\n    address private owner;\n    address private adminAddress;\n    mapping(string => Types.FeeConfig) private feeTable;\n    mapping(string => uint256) private accruedFeeTable;\n\n    modifier onlyBMC() {\n        require(msg.sender == bmc, \"OnlyBMC\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"OnlyOwner\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == this.admin(), \"OnlyAdmin\");\n        _;\n    }\n\n    function initialize(\n        address _bmc\n    ) public initializer {\n        owner = msg.sender;\n\n        // set bmc address only for the first deploy\n        bmc = _bmc;\n        string memory bmcBtpAddress = IBMC(bmc).getBmcBtpAddress();\n        (string memory _net, ) = bmcBtpAddress.splitBTPAddress();\n        btpAddress = string(\"btp://\")\n            .concat(_net)\n            .concat(\"/\")\n            .concat(address(this).toString());\n\n        // set default fees to (10, 1) ICX\n        if (isNullFeeConfig(feeTable[FEE_DEFAULT])) {\n            feeTable[FEE_DEFAULT] = Types.FeeConfig(\n                EXA * 10,\n                EXA,\n                true\n            );\n        }\n    }\n\n    function checkService(\n        string calldata _svc\n    ) internal pure {\n        require(SERVICE.compareTo(_svc), \"InvalidServiceName\");\n    }\n\n    function getNextSn(\n    ) internal returns (uint256) {\n        lastSn = lastSn + 1;\n        return lastSn;\n    }\n\n    function getNextReqId(\n    ) internal returns (uint256) {\n        lastReqId = lastReqId + 1;\n        return lastReqId;\n    }\n\n    function cleanupCallRequest(\n        uint256 sn\n    ) internal {\n        delete requests[sn];\n        emit CallRequestCleared(sn);\n    }\n\n    function isNullCallRequest(\n        Types.CallRequest memory req\n    ) internal pure returns (bool) {\n        return req.from == address(0);\n    }\n\n    function isNullCSMessageRequest(\n        Types.CSMessageRequest memory req\n    ) internal pure returns (bool) {\n        return bytes(req.from).length == 0;\n    }\n\n    function isNullFeeConfig(\n        Types.FeeConfig memory fc\n    ) internal pure returns (bool) {\n        return !fc.exists;\n    }\n\n    function totalFee(\n        Types.FeeConfig memory _fc\n    ) internal pure returns (uint256) {\n        return _fc.relay + _fc.protocol;\n    }\n\n    /**\n       @notice Sends a call message to the contract on the destination chain.\n       @dev Only allowed to be called from the contract.\n       @param _to The BTP address of the callee on the destination chain\n       @param _data The calldata specific to the target contract\n       @param _rollback (Optional) The data for restoring the caller state when an error occurred\n       @return The serial number of the request\n     */\n    function sendCallMessage(\n        string calldata _to,\n        bytes calldata _data,\n        bytes calldata _rollback\n    ) external payable override returns (uint256) {\n        address caller = msg.sender;\n        // Note if caller is a contract in construction, will revert\n        require(caller.code.length > 0, \"SenderNotAContract\");\n\n        // check size of payloads to avoid abusing\n        require(_data.length <= MAX_DATA_SIZE, \"MaxDataSizeExceeded\");\n        require(_rollback.length <= MAX_ROLLBACK_SIZE, \"MaxRollbackSizeExceeded\");\n\n        //TODO require BTPAddress validation\n        (string memory netTo, string memory dstAccount) = _to.splitBTPAddress();\n        require(bytes(dstAccount).length > 0, \"invalid _to\");\n        Types.FeeConfig memory feeConfig = getFeeConfig(netTo);\n\n        //TODO payable check\n        require(msg.value >= totalFee(feeConfig), \"InsufficientFee\");\n\n        // accumulate fees per type\n        accruedFeeTable[Types.FEE_RELAY]=accruedFeeTable[Types.FEE_RELAY]+feeConfig.relay;\n        accruedFeeTable[Types.FEE_PROTOCOL]=accruedFeeTable[Types.FEE_PROTOCOL]+msg.value-feeConfig.relay;\n\n        // send message\n        uint256 sn = getNextSn();\n        bool rollbackEnabled = _rollback.length > 0;\n        if (rollbackEnabled) {\n            requests[sn] = Types.CallRequest(\n                caller,\n                _to,\n                _rollback,\n                false\n            );\n        }\n        bytes memory payload = Types.CSMessageRequest(\n            caller.toString(),\n            dstAccount,\n            sn,\n            rollbackEnabled,\n            _data\n        ).encodeCSMessageRequest();\n        sendBTPMessage(netTo, Types.CS_REQUEST, sn, payload);\n        emit CallMessageSent(caller, _to, sn, _data);\n        return sn;\n    }\n\n    /**\n       @notice Executes the requested call.\n       @dev Caller should be ...\n       @param _reqId The request Id\n     */\n    function executeCall(\n        uint256 _reqId\n    ) external override {\n        Types.CSMessageRequest memory req = proxyReqs[_reqId];\n        require(!isNullCSMessageRequest(req), \"InvalidRequestId\");\n        // cleanup\n        delete proxyReqs[_reqId];\n\n        //TODO require BTPAddress validation\n        (string memory netFrom, ) = req.from.splitBTPAddress();\n        int errCode = Types.CS_RESP_SUCCESS;\n        address csrAddress = req.to.parseAddress();\n        string memory errMsg;\n        try this.tryHandleCallMessage(\n            csrAddress,\n            req.from,\n            req.data\n        ) {\n        } catch Error(string memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = err;\n        } catch (bytes memory err) {\n            errCode = Types.CS_RESP_FAILURE;\n            errMsg = string(\"unknownError\");\n//            errMsg = string(\"unknownError \").concat(Strings.bytesToHex(err));\n        }\n\n        // send response only when there was a rollback\n        if (req.rollback) {\n            bytes memory payload = Types.CSMessageResponse(\n                req.sn,\n                errCode,\n                errMsg\n            ).encodeCSMessageResponse();\n            uint256 sn = getNextSn();\n            sendBTPMessage(netFrom, Types.CS_RESPONSE, sn, payload);\n        }\n    }\n\n    //  @dev To catch for invalid address of ICallServiceReceiver\n    function tryHandleCallMessage(\n        address csrAddress,\n        string memory from,\n        bytes memory data\n    ) external {\n        require(msg.sender == address(this), \"OnlyInternal\");\n        ICallServiceReceiver(csrAddress).handleCallMessage(from, data);\n    }\n\n    /**\n       @notice Rollbacks the caller state of the request '_sn'.\n       @dev Caller should be ...\n       @param _sn The serial number of the previous request\n     */\n    function executeRollback(\n        uint256 _sn\n    ) external override {\n        Types.CallRequest memory req = requests[_sn];\n        require(!isNullCallRequest(req), \"InvalidSerialNum\");\n        require(req.enabled, \"RollbackNotEnabled\");\n        cleanupCallRequest(_sn);\n\n        try this.tryHandleCallMessage(\n            req.from,\n            btpAddress,\n            req.rollback\n        ){\n        } catch {\n            //logging\n        }\n    }\n\n    /* Implementation-specific eventlog */\n    event CallMessageSent(\n        address indexed _from,\n        string indexed _to,\n        uint256 indexed _sn,\n        bytes _data\n    );\n\n    /* Implementation-specific eventlog */\n    event CallRequestCleared(\n        uint256 indexed _sn\n    );\n\n    /* ========== Interfaces with BMC ========== */\n    /**\n       @notice Handle BTP Message from other blockchain.\n       @dev Accept the message only from the BMC.\n       Every BSH must implement this function\n       @param _from    Network Address of source network\n       @param _svc     Name of the service\n       @param _sn      Serial number of the message\n       @param _msg     Serialized bytes of ServiceMessage\n   */\n    function handleBTPMessage(\n        string calldata _from,\n        string calldata _svc,\n        uint256 _sn,\n        bytes calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        Types.CSMessage memory csMsg = _msg.decodeCSMessage();\n        if (csMsg.msgType == Types.CS_REQUEST) {\n            handleRequest(_from, _sn, csMsg.payload);\n        } else if (csMsg.msgType == Types.CS_RESPONSE) {\n            handleResponse(csMsg.payload.decodeCSMessageResponse());\n        } else {\n            //TODO make revert message\n            string memory errMsg = string(\"UnknownMsgType(\")\n                .concat(uint(csMsg.msgType).toString())\n                .concat(string(\")\"));\n            revert(errMsg);\n        }\n    }\n\n    /**\n       @notice Handle the error on delivering the message.\n       @dev Accept the error only from the BMC.\n       Every BSH must implement this function\n       @param _src     BTP Address of BMC generates the error\n       @param _svc     Name of the service\n       @param _sn      Serial number of the original message\n       @param _code    Code of the error\n       @param _msg     Message of the error\n   */\n    function handleBTPError(\n        string calldata _src,\n        string calldata _svc,\n        uint256 _sn,\n        uint256 _code,\n        string calldata _msg\n    ) external override onlyBMC {\n        checkService(_svc);\n        string memory errMsg = string(\"BTPError{code=\")\n            .concat(uint(_code).toString())\n            .concat(string(\", msg=\"))\n            .concat(_msg)\n            .concat(string(\"}\"));\n        handleResponse(Types.CSMessageResponse(\n            _sn,\n            Types.CS_RESP_BTP_ERROR,\n            errMsg\n        ));\n    }\n    /* ========================================= */\n\n    function sendBTPMessage(\n        string memory netTo,\n        int msgType,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        bytes memory csMsg = Types.CSMessage(\n            msgType,\n            msgPayload\n        ).encodeCSMessage();\n        IBMC(bmc).sendMessage(\n            netTo,\n            SERVICE,\n            sn,\n            csMsg\n        );\n    }\n\n    function handleRequest(\n        string memory netFrom,\n        uint256 sn,\n        bytes memory msgPayload\n    ) internal {\n        Types.CSMessageRequest memory req = msgPayload.decodeCSMessageRequest();\n        //TODO make btpaddress\n        string memory from = string(\"btp://\")\n            .concat(netFrom)\n            .concat(string(\"/\"))\n            .concat(req.from);\n        uint256 reqId = getNextReqId();\n        proxyReqs[reqId] = Types.CSMessageRequest(\n            from,\n            req.to,\n            sn,\n            req.rollback,\n            req.data\n        );\n        emit CallMessage(from, req.to, sn, reqId, req.data);\n    }\n\n    function handleResponse(\n        Types.CSMessageResponse memory res\n    ) internal {\n        Types.CallRequest memory req = requests[res.sn];\n        if (!isNullCallRequest(req)) {\n            if (res.code == Types.CS_RESP_SUCCESS){\n                cleanupCallRequest(res.sn);\n            } else {\n                //emit rollback event\n                require(req.rollback.length > 0, \"NoRollbackData\");\n                req.enabled=true;\n                requests[res.sn]=req;\n                emit RollbackMessage(res.sn, req.rollback, res.msg);\n            }\n        }\n    }\n\n    function admin(\n    ) external view returns (address) {\n        if (adminAddress == address(0)) {\n            return owner;\n        }\n        return adminAddress;\n    }\n\n    function setAdmin(\n        address _address\n    ) external onlyOwner {\n        adminAddress = _address;\n    }\n\n    function getFeeConfig(\n        string memory net\n    ) internal view returns (Types.FeeConfig memory) {\n        Types.FeeConfig memory feeConfig = feeTable[net];\n        if (isNullFeeConfig(feeConfig)) {\n            feeConfig = feeTable[FEE_DEFAULT];\n        }\n        return feeConfig;\n    }\n\n    /**\n       @notice Gets the fixed fee for the given network address and type.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The fee amount in loop\n     */\n    function fixedFee(\n        string calldata _net,\n        string calldata _type\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        string memory feeType = _type.lower();\n        if (feeType.compareTo(Types.FEE_RELAY)) {\n            return feeConfig.relay;\n        } else if (feeType.compareTo(Types.FEE_PROTOCOL)) {\n            return feeConfig.protocol;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n       @notice Gets the total fixed fees for the given network address.\n       @dev If there is no mapping to the network address, `default` fee is returned.\n       @param _net The network address\n       @return The total fees amount in loop\n     */\n    function totalFixedFees(\n        string calldata _net\n    ) external view override returns (uint256) {\n        Types.FeeConfig memory feeConfig = getFeeConfig(_net);\n        return totalFee(feeConfig);\n    }\n\n    /**\n       @notice Sets the fixed fees for the given network address.\n       @dev Only the admin wallet can invoke this.\n       @param _net The destination network address\n       @param _relay The relay fee amount in loop\n       @param _protocol The protocol fee amount in loop\n     */\n    function setFixedFees(\n        string calldata _net,\n        uint256 _relay,\n        uint256 _protocol\n    ) external override onlyAdmin {\n        //TODO _net validation revert(\"InvalidNetworkAddress\")\n        feeTable[_net] = Types.FeeConfig(\n            _relay,\n            _protocol,\n            true\n        );\n        emit FixedFeesUpdated(_net, _relay, _protocol);\n    }\n\n    /**\n       @notice Gets the total accrued fees for the given type.\n       @param _type The fee type (\"relay\" or \"protocol\")\n       @return The total accrued fees in loop\n     */\n    function accruedFees(\n        string calldata _type\n    ) external view override returns (uint256) {\n        return accruedFeeTable[_type];\n    }\n\n}\n", "commit_id": "3747a9c81ff3f80171779cb88a49fd6fd2406eab"}}