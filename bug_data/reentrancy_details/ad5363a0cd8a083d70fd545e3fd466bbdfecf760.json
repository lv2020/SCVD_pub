{"filename": "contracts/MultiSigWallet.sol", "patch": "@@ -41,7 +41,15 @@ contract MultiSigWallet {\n         _;\n     }\n \n+    modifier txnExist(uint _txId) {\n+        require(_txId < transactions.length, \"transaction does not exist\");\n+        _;\n+    }\n+\n     constructor(address[] memory _owners, uint _approvalsRequired) payable {\n+        require(_owners.length > 0, \"MultiSigWallet must have at least 1 owner\");\n+        require(_approvalsRequired <= _owners.length, \"number of approvals must be less or equal to number of owners\");\n+\n         owners = _owners;\n \n         for(uint i; i < _owners.length; i++){\n@@ -51,7 +59,6 @@ contract MultiSigWallet {\n             isOwner[_owners[i]] = true;\n         }\n \n-        require(_approvalsRequired <= _owners.length, \"number of approvals required is too big\");\n \n         approvalsRequired = _approvalsRequired;\n     }\n@@ -69,7 +76,7 @@ contract MultiSigWallet {\n         emit Submit(msg.sender, txId, _to, _amount, _data);\n     }\n \n-    function approveTxn(uint _txId) public onlyOwner notExecuted(_txId) {\n+    function approveTxn(uint _txId) public onlyOwner notExecuted(_txId) txnExist(_txId) {\n         require(!approvals[_txId][msg.sender], \"already approved\");\n \n         approvals[_txId][msg.sender] = true;\n@@ -79,7 +86,7 @@ contract MultiSigWallet {\n         emit Approve(msg.sender, _txId);\n     }\n \n-    function revokeApproval(uint _txId) public onlyOwner notExecuted(_txId) {\n+    function revokeApproval(uint _txId) public onlyOwner notExecuted(_txId) txnExist(_txId) {\n         require(approvals[_txId][msg.sender], \"not yet approved\");\n \n         approvals[_txId][msg.sender] = false;\n@@ -89,22 +96,16 @@ contract MultiSigWallet {\n         emit Revoke(msg.sender, _txId);\n     }\n \n-    function getApprovalsCount(uint _txId) internal view returns(uint){\n-        return transactions[_txId].numOfApprovals;\n-    }\n-\n-    function executeTxn(uint _txId) public payable onlyOwner notExecuted(_txId) returns(bool success) {\n-        require(getApprovalsCount(_txId) >= approvalsRequired, \"not enough approvals\");\n-\n+    function executeTxn(uint _txId) public payable onlyOwner notExecuted(_txId) txnExist(_txId) returns(bool success) {\n         Transaction storage txn = transactions[_txId];\n+        require(txn.numOfApprovals >= approvalsRequired, \"not enough approvals\");\n \n         require(address(this).balance > txn.amount, \"not enough ETH\");\n \n+        txn.executed = true;\n         (success, ) = payable(txn.to).call{value: txn.amount}(txn.data);\n-        if(success){\n-            txn.executed = true;\n-            emit Execute(msg.sender, _txId);\n-        }\n+\n+        emit Execute(msg.sender, _txId);\n     }\n \n     function getBalance() public view returns (uint) {\n@@ -114,4 +115,5 @@ contract MultiSigWallet {\n     receive() external payable {\n         emit Deposit(msg.sender, msg.value, address(this).balance);\n     }\n-}\n\\ No newline at end of file\n+}\n+//[\"0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\",\"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\",\"0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db\"]\n\\ No newline at end of file", "project_link": "https://github.com/pstavola/MultiSigWallet/commit/ad5363a0cd8a083d70fd545e3fd466bbdfecf760", "bug_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint amount, uint balance);\n    event Approve(address indexed owner, uint indexed txId);\n    event Revoke(address indexed owner, uint indexed txId);\n    event Execute(address indexed owner, uint indexed txId);\n    event Submit(\n        address indexed owner,\n        uint indexed txIndex,\n        address indexed to,\n        uint value,\n        bytes data\n    );\n\n    address[] public owners;\n    mapping (address => bool) public isOwner;\n\n    struct Transaction {\n        address to;\n        bytes data;\n        uint amount;\n        bool executed;\n        uint numOfApprovals;\n    }\n\n    Transaction[] public transactions;\n\n    mapping(uint => mapping(address => bool)) public approvals;\n\n    uint public approvalsRequired;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not an owner\");\n        _;\n    }\n\n    modifier notExecuted(uint _txId) {\n        require(!transactions[_txId].executed, \"already executed\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _approvalsRequired) payable {\n        owners = _owners;\n\n        for(uint i; i < _owners.length; i++){\n            require(_owners[i] != address(0), \"owner cannot be address(0)\");\n            require(!isOwner[_owners[i]], \"duplicated owner\");\n\n            isOwner[_owners[i]] = true;\n        }\n\n        require(_approvalsRequired <= _owners.length, \"number of approvals required is too big\");\n\n        approvalsRequired = _approvalsRequired;\n    }\n\n    function submitTxn(\n        address _to,\n        bytes calldata _data,\n        uint _amount\n    ) public onlyOwner returns(uint txId) {\n\n        txId = transactions.length;\n        Transaction memory transaction = Transaction({to: _to, data: _data, amount: _amount, executed: false, numOfApprovals: 0});\n        transactions.push(transaction);\n\n        emit Submit(msg.sender, txId, _to, _amount, _data);\n    }\n\n    function approveTxn(uint _txId) public onlyOwner notExecuted(_txId) {\n        require(!approvals[_txId][msg.sender], \"already approved\");\n\n        approvals[_txId][msg.sender] = true;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals += 1;\n\n        emit Approve(msg.sender, _txId);\n    }\n\n    function revokeApproval(uint _txId) public onlyOwner notExecuted(_txId) {\n        require(approvals[_txId][msg.sender], \"not yet approved\");\n\n        approvals[_txId][msg.sender] = false;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals -= 1;\n\n        emit Revoke(msg.sender, _txId);\n    }\n\n    function getApprovalsCount(uint _txId) internal view returns(uint){\n        return transactions[_txId].numOfApprovals;\n    }\n\n    function executeTxn(uint _txId) public payable onlyOwner notExecuted(_txId) returns(bool success) {\n        require(getApprovalsCount(_txId) >= approvalsRequired, \"not enough approvals\");\n\n        Transaction storage txn = transactions[_txId];\n\n        require(address(this).balance > txn.amount, \"not enough ETH\");\n\n        (success, ) = payable(txn.to).call{value: txn.amount}(txn.data);\n        if(success){\n            txn.executed = true;\n            emit Execute(msg.sender, _txId);\n        }\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n}", "flattened_code": "//IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.15;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint amount, uint balance);\n    event Approve(address indexed owner, uint indexed txId);\n    event Revoke(address indexed owner, uint indexed txId);\n    event Execute(address indexed owner, uint indexed txId);\n    event Submit(\n        address indexed owner,\n        uint indexed txIndex,\n        address indexed to,\n        uint value,\n        bytes data\n    );\n\n    address[] public owners;\n    mapping (address => bool) public isOwner;\n\n    struct Transaction {\n        address to;\n        bytes data;\n        uint amount;\n        bool executed;\n        uint numOfApprovals;\n    }\n\n    Transaction[] public transactions;\n\n    mapping(uint => mapping(address => bool)) public approvals;\n\n    uint public approvalsRequired;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not an owner\");\n        _;\n    }\n\n    modifier notExecuted(uint _txId) {\n        require(!transactions[_txId].executed, \"already executed\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _approvalsRequired) payable {\n        owners = _owners;\n\n        for(uint i; i < _owners.length; i++){\n            require(_owners[i] != address(0), \"owner cannot be address(0)\");\n            require(!isOwner[_owners[i]], \"duplicated owner\");\n\n            isOwner[_owners[i]] = true;\n        }\n\n        require(_approvalsRequired <= _owners.length, \"number of approvals required is too big\");\n\n        approvalsRequired = _approvalsRequired;\n    }\n\n    function submitTxn(\n        address _to,\n        bytes calldata _data,\n        uint _amount\n    ) public onlyOwner returns(uint txId) {\n\n        txId = transactions.length;\n        Transaction memory transaction = Transaction({to: _to, data: _data, amount: _amount, executed: false, numOfApprovals: 0});\n        transactions.push(transaction);\n\n        emit Submit(msg.sender, txId, _to, _amount, _data);\n    }\n\n    function approveTxn(uint _txId) public onlyOwner notExecuted(_txId) {\n        require(!approvals[_txId][msg.sender], \"already approved\");\n\n        approvals[_txId][msg.sender] = true;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals += 1;\n\n        emit Approve(msg.sender, _txId);\n    }\n\n    function revokeApproval(uint _txId) public onlyOwner notExecuted(_txId) {\n        require(approvals[_txId][msg.sender], \"not yet approved\");\n\n        approvals[_txId][msg.sender] = false;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals -= 1;\n\n        emit Revoke(msg.sender, _txId);\n    }\n\n    function getApprovalsCount(uint _txId) internal view returns(uint){\n        return transactions[_txId].numOfApprovals;\n    }\n\n    function executeTxn(uint _txId) public payable onlyOwner notExecuted(_txId) returns(bool success) {\n        require(getApprovalsCount(_txId) >= approvalsRequired, \"not enough approvals\");\n\n        Transaction storage txn = transactions[_txId];\n\n        require(address(this).balance > txn.amount, \"not enough ETH\");\n\n        (success, ) = payable(txn.to).call{value: txn.amount}(txn.data);\n        if(success){\n            txn.executed = true;\n            emit Execute(msg.sender, _txId);\n        }\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n}\n", "commit_id": "1826435d399b3c9afbaf1d394d0fe003e624af49"}, "fixed_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint amount, uint balance);\n    event Approve(address indexed owner, uint indexed txId);\n    event Revoke(address indexed owner, uint indexed txId);\n    event Execute(address indexed owner, uint indexed txId);\n    event Submit(\n        address indexed owner,\n        uint indexed txIndex,\n        address indexed to,\n        uint value,\n        bytes data\n    );\n\n    address[] public owners;\n    mapping (address => bool) public isOwner;\n\n    struct Transaction {\n        address to;\n        bytes data;\n        uint amount;\n        bool executed;\n        uint numOfApprovals;\n    }\n\n    Transaction[] public transactions;\n\n    mapping(uint => mapping(address => bool)) public approvals;\n\n    uint public approvalsRequired;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not an owner\");\n        _;\n    }\n\n    modifier notExecuted(uint _txId) {\n        require(!transactions[_txId].executed, \"already executed\");\n        _;\n    }\n\n    modifier txnExist(uint _txId) {\n        require(_txId < transactions.length, \"transaction does not exist\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _approvalsRequired) payable {\n        require(_owners.length > 0, \"MultiSigWallet must have at least 1 owner\");\n        require(_approvalsRequired <= _owners.length, \"number of approvals must be less or equal to number of owners\");\n\n        owners = _owners;\n\n        for(uint i; i < _owners.length; i++){\n            require(_owners[i] != address(0), \"owner cannot be address(0)\");\n            require(!isOwner[_owners[i]], \"duplicated owner\");\n\n            isOwner[_owners[i]] = true;\n        }\n\n\n        approvalsRequired = _approvalsRequired;\n    }\n\n    function submitTxn(\n        address _to,\n        bytes calldata _data,\n        uint _amount\n    ) public onlyOwner returns(uint txId) {\n\n        txId = transactions.length;\n        Transaction memory transaction = Transaction({to: _to, data: _data, amount: _amount, executed: false, numOfApprovals: 0});\n        transactions.push(transaction);\n\n        emit Submit(msg.sender, txId, _to, _amount, _data);\n    }\n\n    function approveTxn(uint _txId) public onlyOwner notExecuted(_txId) txnExist(_txId) {\n        require(!approvals[_txId][msg.sender], \"already approved\");\n\n        approvals[_txId][msg.sender] = true;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals += 1;\n\n        emit Approve(msg.sender, _txId);\n    }\n\n    function revokeApproval(uint _txId) public onlyOwner notExecuted(_txId) txnExist(_txId) {\n        require(approvals[_txId][msg.sender], \"not yet approved\");\n\n        approvals[_txId][msg.sender] = false;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals -= 1;\n\n        emit Revoke(msg.sender, _txId);\n    }\n\n    function executeTxn(uint _txId) public payable onlyOwner notExecuted(_txId) txnExist(_txId) returns(bool success) {\n        Transaction storage txn = transactions[_txId];\n        require(txn.numOfApprovals >= approvalsRequired, \"not enough approvals\");\n\n        require(address(this).balance > txn.amount, \"not enough ETH\");\n\n        txn.executed = true;\n        (success, ) = payable(txn.to).call{value: txn.amount}(txn.data);\n\n        emit Execute(msg.sender, _txId);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n}\n//[\"0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\",\"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\",\"0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db\"]", "flattened_code": "//IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.15;\n\ncontract MultiSigWallet {\n    event Deposit(address indexed sender, uint amount, uint balance);\n    event Approve(address indexed owner, uint indexed txId);\n    event Revoke(address indexed owner, uint indexed txId);\n    event Execute(address indexed owner, uint indexed txId);\n    event Submit(\n        address indexed owner,\n        uint indexed txIndex,\n        address indexed to,\n        uint value,\n        bytes data\n    );\n\n    address[] public owners;\n    mapping (address => bool) public isOwner;\n\n    struct Transaction {\n        address to;\n        bytes data;\n        uint amount;\n        bool executed;\n        uint numOfApprovals;\n    }\n\n    Transaction[] public transactions;\n\n    mapping(uint => mapping(address => bool)) public approvals;\n\n    uint public approvalsRequired;\n\n    modifier onlyOwner() {\n        require(isOwner[msg.sender], \"not an owner\");\n        _;\n    }\n\n    modifier notExecuted(uint _txId) {\n        require(!transactions[_txId].executed, \"already executed\");\n        _;\n    }\n\n    modifier txnExist(uint _txId) {\n        require(_txId < transactions.length, \"transaction does not exist\");\n        _;\n    }\n\n    constructor(address[] memory _owners, uint _approvalsRequired) payable {\n        require(_owners.length > 0, \"MultiSigWallet must have at least 1 owner\");\n        require(_approvalsRequired <= _owners.length, \"number of approvals must be less or equal to number of owners\");\n\n        owners = _owners;\n\n        for(uint i; i < _owners.length; i++){\n            require(_owners[i] != address(0), \"owner cannot be address(0)\");\n            require(!isOwner[_owners[i]], \"duplicated owner\");\n\n            isOwner[_owners[i]] = true;\n        }\n\n\n        approvalsRequired = _approvalsRequired;\n    }\n\n    function submitTxn(\n        address _to,\n        bytes calldata _data,\n        uint _amount\n    ) public onlyOwner returns(uint txId) {\n\n        txId = transactions.length;\n        Transaction memory transaction = Transaction({to: _to, data: _data, amount: _amount, executed: false, numOfApprovals: 0});\n        transactions.push(transaction);\n\n        emit Submit(msg.sender, txId, _to, _amount, _data);\n    }\n\n    function approveTxn(uint _txId) public onlyOwner notExecuted(_txId) txnExist(_txId) {\n        require(!approvals[_txId][msg.sender], \"already approved\");\n\n        approvals[_txId][msg.sender] = true;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals += 1;\n\n        emit Approve(msg.sender, _txId);\n    }\n\n    function revokeApproval(uint _txId) public onlyOwner notExecuted(_txId) txnExist(_txId) {\n        require(approvals[_txId][msg.sender], \"not yet approved\");\n\n        approvals[_txId][msg.sender] = false;\n        Transaction storage txn = transactions[_txId];\n        txn.numOfApprovals -= 1;\n\n        emit Revoke(msg.sender, _txId);\n    }\n\n    function executeTxn(uint _txId) public payable onlyOwner notExecuted(_txId) txnExist(_txId) returns(bool success) {\n        Transaction storage txn = transactions[_txId];\n        require(txn.numOfApprovals >= approvalsRequired, \"not enough approvals\");\n\n        require(address(this).balance > txn.amount, \"not enough ETH\");\n\n        txn.executed = true;\n        (success, ) = payable(txn.to).call{value: txn.amount}(txn.data);\n\n        emit Execute(msg.sender, _txId);\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    receive() external payable {\n        emit Deposit(msg.sender, msg.value, address(this).balance);\n    }\n}\n//[\"0x5B38Da6a701c568545dCfcB03FcB875f56beddC4\",\"0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\",\"0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db\"]\n", "commit_id": "ad5363a0cd8a083d70fd545e3fd466bbdfecf760"}}