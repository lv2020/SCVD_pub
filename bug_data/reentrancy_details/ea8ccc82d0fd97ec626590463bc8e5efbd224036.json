{"filename": "contracts/Funds.sol", "patch": "@@ -201,8 +201,8 @@ contract Funds is DSMath {\n     function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n         require(msg.sender == own(fund));\n         require(bal(fund)  >= amt);\n-        require(funds[fund].tok.transfer(own(fund), amt));\n         funds[fund].bal = sub(funds[fund].bal, amt);\n+        require(funds[fund].tok.transfer(own(fund), amt));\n     }\n \n     function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest", "project_link": "https://github.com/AtomicLoans/atomicloans-eth-contracts/commit/ea8ccc82d0fd97ec626590463bc8e5efbd224036", "bug_version": {"raw_code": "import 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\n\nimport './Loans.sol';\nimport './Currency.sol';\nimport './Vars.sol';\nimport './DSMath.sol';\n\npragma solidity ^0.5.8;\n\ncontract Funds is DSMath {\n    Loans loans;\n\n    mapping (address => bytes32[]) public sechs;  // User secret hashes\n    mapping (address => uint256)   public sechi;  // User secret hash index\n\n    mapping (address => bytes)     public pubks;  // User A Coin PubKeys\n    \n    mapping (bytes32 => Fund)      public funds;  \n    uint256                        public fundi;\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    bool on; // Ensure that Loans contract is created\n\n    struct Fund {\n        address  own;   // Loan Fund Owner (Lender)\n        uint256  mila;  // Min Loan Amount\n        uint256  mala;  // Max Loan Amount\n        uint256  mild;  // Min Loan Duration\n        uint256  mald;  // Max Loan Duration\n        uint256  lint;  // Interest Rate in RAY\n        uint256  lpen;  // Liquidation Penalty Rate in RAY\n        uint256  lfee;  // Optional Automation Fee in RAY\n        uint256  rat;   // Liquidation Ratio in RAY\n        address  agent; // Optional Automator Agent\n        uint256  bal;   // Locked amount in fund (in TOK)\n        ERC20    tok;   // Debt Token\n        Currency cur;   // Currency info\n        Vars     vars;  // Variable contract\n    }\n\n    function setLoans(address loans_) public {\n        require(!on);\n        loans = Loans(loans_);\n        on = true;\n    }\n\n    function own(bytes32 fund)   public view returns (address) {\n        return funds[fund].own;\n    }\n\n    function mila(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mila;\n    }\n\n    function mala(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mala;\n    }\n\n    function mild(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mild;\n    }\n\n    function mald(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mald;\n    }\n\n    function lint(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lint;\n    }\n\n    function lpen(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lpen;\n    }\n\n    function lfee(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lfee;\n    }\n\n    function rat(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].rat;\n    }\n\n    function agent(bytes32 fund) public view returns (address) {\n        return funds[fund].agent;\n    }\n\n    function bal(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].bal;\n    }\n\n    function tok(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].tok);\n    }\n\n    function cur(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].cur);\n    }\n\n    function vars(bytes32 fund)  public view returns (address) {\n        return address(funds[fund].vars);\n    }\n\n    function open(\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  rat_,   // Liquidation Ratio\n        uint256  lint_,  // Interest Rate\n        uint256  lpen_,  // Liquidation Penalty Rate\n        uint256  lfee_,  // Optional Automation Fee Rate\n        address  agent_, // Optional Address Automated Agent\n        ERC20    tok_,   // Debt Token\n        Currency cur_,   // Currency contract\n        Vars     vars_   // Variable contract\n    ) public returns (bytes32 fund) {\n        fundi = add(fundi, 1);\n        fund = bytes32(fundi);\n        funds[fund].own   = msg.sender;\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].tok   = tok_;\n        funds[fund].cur   = cur_;\n        funds[fund].vars  = vars_;\n        funds[fund].agent = agent_;\n\n        if (tokas[address(tok_)] == false) {\n            require(tok_.approve(address(loans), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function push(bytes32 fund, uint256 amt) public { // Push funds to Loan Fund\n        // require(msg.sender == own(fund) || msg.sender == address(loans)); // NOTE: this require is not necessary. Anyone can fund someone elses loan fund\n        require(funds[fund].tok.transferFrom(msg.sender, address(this), amt));\n        funds[fund].bal = add(funds[fund].bal, amt);\n    }\n\n    function gen(bytes32[] memory sechs_) public { // Generate secret hashes for Loan Fund\n        for (uint i = 0; i < sechs_.length; i++) {\n            sechs[msg.sender].push(sechs_[i]);\n        }\n    }\n\n    function set(bytes memory pubk) public { // Set PubKey for Fund\n        pubks[msg.sender] = pubk;\n    }\n\n    function set(        // Set Loan Fund details\n        bytes32  fund,   // Loan Fund Index\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  lint_,  // Interest Rate in RAY\n        uint256  lpen_,  // Liquidation Penalty Rate in RAY\n        uint256  lfee_,  // Optional Automation Fee in RAY\n        uint256  rat_,   // Liquidation Ratio in RAY\n        address  agent_  // Optional Automator Agent)\n    ) public {\n        require(msg.sender == own(fund));\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].agent = agent_;\n    }\n\n    function req(                 // Request Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_,  // Loan Duration in seconds\n        bytes32[4] memory sechs_, // Secret Hash A1 & A2\n        bytes      memory pubk_   // Pubkey\n    ) public returns (bytes32 loani) {\n        require(msg.sender != own(fund));\n        require(amt_       <= bal(fund));\n        require(amt_       >= mila(fund));\n        require(amt_       <= mala(fund));\n        require(lodu_      >= mild(fund));\n        require(lodu_      <= mald(fund));\n\n        loani = lopen(fund, amt_, col_, lodu_);\n        lsech(fund, loani, sechs_, pubk_);\n        loans.push(loani);\n    }\n\n    function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n        require(msg.sender == own(fund));\n        require(bal(fund)  >= amt);\n        require(funds[fund].tok.transfer(own(fund), amt));\n        funds[fund].bal = sub(funds[fund].bal, amt);\n    }\n\n    function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest\n        return sub(rmul(amt, rpow(rate, lodu)), amt);\n    }\n\n    function lopen(               // Private Open Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_   // Loan Duration in seconds\n    ) private returns (bytes32 loani) {\n        loani = loans.open(\n            now + lodu_,\n            [ msg.sender, own(fund), funds[fund].agent],\n            [ amt_, calc(amt_, lint(fund), lodu_), calc(amt_, lpen(fund), lodu_), calc(amt_, lfee(fund), lodu_), col_, funds[fund].rat],\n            funds[fund].tok,\n            funds[fund].cur,\n            funds[fund].vars,\n            fund\n        );\n    }\n\n    function lsech(                // Loan Set Secret Hashes\n        bytes32 fund,              // Fund Index\n        bytes32 loan,              // Loan Index\n        bytes32[4] memory sechs_,  // 4 Secret Hashes\n        bytes memory pubk_         // Public Key\n    ) private { // Loan set Secret Hash and PubKey\n        loans.setSechs(\n            loan,\n            sechs_,\n            gsech(own(fund)),\n            gsech(agent(fund)),\n            pubk_,\n            pubks[own(fund)]\n        );\n    }\n\n    function gsech(address addr) private view returns (bytes32[4] memory) { // Get 4 secrethashes for loan\n        require((sechs[addr].length - sechi[addr]) >= 4);\n        return [ sechs[addr][add(sechi[addr], 0)], sechs[addr][add(sechi[addr], 1)], sechs[addr][add(sechi[addr], 2)], sechs[addr][add(sechi[addr], 3)] ];\n    }\n}\n", "flattened_code": "pragma solidity ^0.5.0;\n\npragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n\n\npragma solidity ^0.5.8;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant COL = 10 ** 8;\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function cmul(uint x, uint y) public pure returns (uint z) {\n        z = add(mul(x, y), COL / 2) / COL;\n    }\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\npragma solidity ^0.5.8;\n\ncontract Funds is DSMath {\n    Loans loans;\n\n    mapping (address => bytes32[]) public sechs;  // User secret hashes\n    mapping (address => uint256)   public sechi;  // User secret hash index\n\n    mapping (address => bytes)     public pubks;  // User A Coin PubKeys\n    \n    mapping (bytes32 => Fund)      public funds;  \n    uint256                        public fundi;\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    address own;\n\n    struct Fund {\n        address  lend;   // Loan Fund Owner (Lender)\n        uint256  mila;  // Min Loan Amount\n        uint256  mala;  // Max Loan Amount\n        uint256  mild;  // Min Loan Duration\n        uint256  mald;  // Max Loan Duration\n        uint256  lint;  // Interest Rate in RAY\n        uint256  lpen;  // Liquidation Penalty Rate in RAY\n        uint256  lfee;  // Optional Automation Fee in RAY\n        uint256  rat;   // Liquidation Ratio in RAY\n        address  agent; // Optional Automator Agent\n        uint256  bal;   // Locked amount in fund (in TOK)\n        ERC20    tok;   // Debt Token\n    }\n\n    constructor() public {\n        own = msg.sender;\n    }\n\n    function setLoans(address loans_) public {\n        require(msg.sender == own);\n        require(address(loans) == address(0));\n        loans = Loans(loans_);\n    }\n\n    function lend(bytes32 fund)   public view returns (address) {\n        return funds[fund].lend;\n    }\n\n    function mila(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mila;\n    }\n\n    function mala(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mala;\n    }\n\n    function mild(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mild;\n    }\n\n    function mald(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mald;\n    }\n\n    function lint(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lint;\n    }\n\n    function lpen(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lpen;\n    }\n\n    function lfee(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lfee;\n    }\n\n    function rat(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].rat;\n    }\n\n    function agent(bytes32 fund) public view returns (address) {\n        return funds[fund].agent;\n    }\n\n    function bal(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].bal;\n    }\n\n    function tok(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].tok);\n    }\n\n    function open(\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  rat_,   // Liquidation Ratio\n        uint256  lint_,  // Interest Rate\n        uint256  lpen_,  // Liquidation Penalty Rate\n        uint256  lfee_,  // Optional Automation Fee Rate\n        address  agent_, // Optional Address Automated Agent\n        ERC20    tok_   // Debt Token\n    ) public returns (bytes32 fund) {\n        fundi = add(fundi, 1);\n        fund = bytes32(fundi);\n        funds[fund].lend  = msg.sender;\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].tok   = tok_;\n        funds[fund].agent = agent_;\n\n        if (tokas[address(tok_)] == false) {\n            require(tok_.approve(address(loans), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function push(bytes32 fund, uint256 amt) public { // Push funds to Loan Fund\n        // require(msg.sender == lend(fund) || msg.sender == address(loans)); // NOTE: this require is not necessary. Anyone can fund someone elses loan fund\n        funds[fund].bal = add(funds[fund].bal, amt);\n        require(funds[fund].tok.transferFrom(msg.sender, address(this), amt));\n    }\n\n    function gen(bytes32[] memory sechs_) public { // Generate secret hashes for Loan Fund\n        for (uint i = 0; i < sechs_.length; i++) {\n            sechs[msg.sender].push(sechs_[i]);\n        }\n    }\n\n    function set(bytes memory pubk) public { // Set PubKey for Fund\n        pubks[msg.sender] = pubk;\n    }\n\n    function set(        // Set Loan Fund details\n        bytes32  fund,   // Loan Fund Index\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  lint_,  // Interest Rate in RAY\n        uint256  lpen_,  // Liquidation Penalty Rate in RAY\n        uint256  lfee_,  // Optional Automation Fee in RAY\n        uint256  rat_,   // Liquidation Ratio in RAY\n        address  agent_  // Optional Automator Agent)\n    ) public {\n        require(msg.sender == lend(fund));\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].agent = agent_;\n    }\n\n    function req(                 // Request Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_,  // Loan Duration in seconds\n        bytes32[4] memory sechs_, // Secret Hash A1 & A2\n        bytes      memory pubk_   // Pubkey\n    ) public returns (bytes32 loani) {\n        require(msg.sender != lend(fund));\n        require(amt_       <= bal(fund));\n        require(amt_       >= mila(fund));\n        require(amt_       <= mala(fund));\n        require(lodu_      >= mild(fund));\n        require(lodu_      <= mald(fund));\n\n        loani = lopen(fund, amt_, col_, lodu_);\n        lsech(fund, loani, sechs_, pubk_);\n        loans.push(loani);\n    }\n\n    function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n        require(msg.sender == lend(fund));\n        require(bal(fund)  >= amt);\n        funds[fund].bal = sub(funds[fund].bal, amt);\n        require(funds[fund].tok.transfer(lend(fund), amt));\n    }\n\n    function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest\n        return sub(rmul(amt, rpow(rate, lodu)), amt);\n    }\n\n    function lopen(               // Private Open Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_   // Loan Duration in seconds\n    ) private returns (bytes32 loani) {\n        loani = loans.open(\n            now + lodu_,\n            [ msg.sender, lend(fund), funds[fund].agent],\n            [ amt_, calc(amt_, lint(fund), lodu_), calc(amt_, lpen(fund), lodu_), calc(amt_, lfee(fund), lodu_), col_, funds[fund].rat],\n            funds[fund].tok,\n            fund\n        );\n    }\n\n    function lsech(                // Loan Set Secret Hashes\n        bytes32 fund,              // Fund Index\n        bytes32 loan,              // Loan Index\n        bytes32[4] memory sechs_,  // 4 Secret Hashes\n        bytes memory pubk_         // Public Key\n    ) private { // Loan set Secret Hash and PubKey\n        loans.setSechs(\n            loan,\n            sechs_,\n            gsech(lend(fund)),\n            gsech(agent(fund)),\n            pubk_,\n            pubks[lend(fund)]\n        );\n    }\n\n    function gsech(address addr) private returns (bytes32[4] memory) { // Get 4 secrethashes for loan\n        sechi[addr] = add(sechi[addr], 4);\n        return [ sechs[addr][sub(sechi[addr], 4)], sechs[addr][sub(sechi[addr], 3)], sechs[addr][sub(sechi[addr], 2)], sechs[addr][sub(sechi[addr], 1)] ];\n    }\n}\n\n\npragma solidity ^0.5.8;\n\ncontract Medianizer {\n    function peek() public returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke(bytes32 wut) public;\n    function void() public;\n    function push(uint256 amt, ERC20 tok) public;\n}\n\npragma solidity ^0.5.8;\n\ncontract Sales is DSMath { // Auctions\n\tLoans loans;\n\tMedianizer med;\n\n    uint256 public constant SALEX = 3600;                         // Sales Expiration\n    uint256 public constant SETEX = 14400;                        // Settlement Expiration\n    uint256 public constant MINBI = 1005000000000000000000000000; // Minimum Bid Increment in RAY\n\n\taddress public own; // Only the Loans contract can edit data\n\n\tmapping (bytes32 => Sale)       public sales; // Auctions\n\tmapping (bytes32 => ERC20)      public tokes; // Auction token\n\tmapping (bytes32 => Bsig)       public bsigs; // Borrower Signatures\n\tmapping (bytes32 => Lsig)       public lsigs; // Lender Signatures\n\tmapping (bytes32 => Asig)       public asigs; // Lender Signatures\n\tmapping (bytes32 => Sech)       public sechs; // Auction Secret Hashes\n    uint256                         public salei; // Auction Index\n\n    mapping (bytes32 => bytes32[])  public salel; // Loan Auctions (find by loani)\n\n    struct Sale {\n        bytes32    loani;  // Loan Index\n        uint256    bid;    // Current Bid\n        address    bidr;   // Bidder\n        address    bor;    // Borrower\n        address    lend;   // Lender\n        address    agent;  // Optional Automated Agent\n        uint256    salex;  // Auction Bidding Expiration\n        uint256    setex;  // Auction Settlement Expiration\n        bytes20    pbkh;   // Bidder PubKey Hash\n        bool       set;    // Sale at index opened\n        bool       taken;  // Winning bid accepted\n        bool       off;\n    }\n\n    struct Bsig {\n    \tbytes      rsig;  // Borrower Refundable Signature\n        bytes      ssig;  // Borrower Seizable Signature\n        bytes      rbsig; // Borrower Refundable Back Signature\n        bytes      sbsig; // Borrower Seizable Back Signature\n    }\n\n    struct Lsig {\n    \tbytes      rsig;  // Lender Refundable Signature\n        bytes      ssig;  // Lender Seizable Signature\n        bytes      rbsig; // Lender Refundable Back Signature\n        bytes      sbsig; // Lender Seizable Back Signature\n    }\n\n    struct Asig {\n    \tbytes      rsig;  // Agent Refundable Signature\n        bytes      ssig;  // Agent Seizable Signature\n        bytes      rbsig; // Agent Refundable Back Signature\n        bytes      sbsig; // Agent Seizable Back Signature\n    }\n\n    struct Sech {\n        bytes32    sechA; // Secret Hash A\n        bytes32    secA;  // Secret A\n        bytes32    sechB; // Secret Hash B\n        bytes32    secB;  // Secret B\n        bytes32    sechC; // Secret Hash C\n        bytes32    secC;  // Secret C\n        bytes32    sechD; // Secret Hash D\n        bytes32    secD;  // Secret D\n    }\n\n    function bid(bytes32 sale) public returns (uint256) {\n        return sales[sale].bid;\n    }\n\n    function bidr(bytes32 sale) public returns (address) {\n        return sales[sale].bidr;\n    }\n\n    function bor(bytes32 sale) public returns (address) {\n        return sales[sale].bor;\n    }\n\n    function lend(bytes32 sale) public returns (address) {\n        return sales[sale].lend;\n    }\n\n    function agent(bytes32 sale) public returns (address) {\n        return sales[sale].agent;\n    }\n\n    function salex(bytes32 sale) public returns (uint256) {\n        return sales[sale].salex;\n    }\n\n    function setex(bytes32 sale) public returns (uint256) {\n        return sales[sale].setex;\n    }\n\n    function pbkh(bytes32 sale) public returns (bytes20) {\n        return sales[sale].pbkh;\n    }\n\n    function taken(bytes32 sale) public returns (bool) {\n        return sales[sale].taken;\n    }\n\n    function off(bytes32 sale) public returns (bool) {\n        return sales[sale].off;\n    }\n\n    function sechA(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechA;\n    }\n\n    function secA(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secA;\n    }\n\n    function sechB(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechB;\n    }\n\n    function secB(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secB;\n    }\n\n    function sechC(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechC;\n    }\n\n    function secC(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secC;\n    }\n\n    function sechD(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechD;\n    }\n\n    function secD(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secD;\n    }\n\n    constructor (address loans_, address med_) public {\n    \town   = loans_;\n    \tloans = Loans(loans_);\n    \tmed   = Medianizer(med_);\n    }\n\n    function next(bytes32 loan) public view returns (uint256) {\n    \treturn salel[loan].length;\n    }\n\n    function open(\n    \tbytes32 loani, // Loan Index\n    \taddress bor,   // Address Borrower\n    \taddress lend,  // Address Lender\n        address agent, // Optional Address automated agent\n    \tbytes32 sechA, // Secret Hash A\n    \tbytes32 sechB, // Secret Hash B\n    \tbytes32 sechC, // Secret Hash C\n\tERC20   tok    // Debt Token\n\t) public returns(bytes32 sale) {\n    \trequire(msg.sender == own);\n    \tsalei = add(salei, 1);\n        sale = bytes32(salei);\n        sales[sale].loani = loani;\n        sales[sale].bor   = bor;\n        sales[sale].lend  = lend;\n        sales[sale].agent = agent;\n        sales[sale].salex = now + SALEX;\n        sales[sale].setex = now + SALEX + SETEX;\n        tokes[sale]       = tok;\n        sales[sale].set   = true;\n        sechs[sale].sechA = sechA;\n        sechs[sale].sechB = sechB;\n        sechs[sale].sechC = sechC;\n        salel[loani].push(sale);\n    }\n\n    function push(     // Bid on Collateral\n    \tbytes32 sale,  // Auction Index\n    \tuint256 amt,   // Bid Amount\n    \tbytes32 sech,  // Secret Hash\n    \tbytes20 pbkh   // PubKeyHash\n\t) public {\n        require(msg.sender != bor(sale) && msg.sender != lend(sale));\n\t\trequire(sales[sale].set);\n    \trequire(now < sales[sale].salex);\n    \trequire(amt > sales[sale].bid);\n    \trequire(tokes[sale].balanceOf(msg.sender) >= amt);\n    \tif (sales[sale].bid > 0) {\n\t\trequire(amt > rmul(sales[sale].bid, MINBI)); // Make sure next bid is at least 0.5% more than the last bid\n    \t}\n\n    \trequire(tokes[sale].transferFrom(msg.sender, address(this), amt));\n    \tif (sales[sale].bid > 0) {\n    \t\trequire(tokes[sale].transfer(sales[sale].bidr, sales[sale].bid));\n    \t}\n    \tsales[sale].bidr = msg.sender;\n    \tsales[sale].bid  = amt;\n    \tsechs[sale].sechD = sech;\n    \tsales[sale].pbkh = pbkh;\n\t}\n\n\tfunction sign(           // Provide Signature to move collateral to collateral swap\n\t\tbytes32      sale,   // Auction Index\n\t\tbytes memory rsig,   // Refundable Signature\n\t\tbytes memory ssig,   // Seizable Signature\n\t\tbytes memory rbsig,  // Refundable Back Signature\n\t\tbytes memory sbsig   // Seizable Back Signataure\n\t) public {\n\t\trequire(sales[sale].set);\n\t\trequire(now < sales[sale].setex);\n\t\tif (msg.sender == sales[sale].bor) {\n\t\t\tbsigs[sale].rsig  = rsig;\n\t\t\tbsigs[sale].ssig  = ssig;\n\t\t\tbsigs[sale].rbsig = rbsig;\n\t\t\tbsigs[sale].sbsig = sbsig;\n\t\t} else if (msg.sender == sales[sale].lend) {\n\t\t\tlsigs[sale].rsig  = rsig;\n\t\t\tlsigs[sale].ssig  = ssig;\n\t\t\tlsigs[sale].rbsig = rbsig;\n\t\t\tlsigs[sale].sbsig = sbsig;\n\t\t} else if (msg.sender == sales[sale].agent) {\n\t\t\tasigs[sale].rsig  = rsig;\n\t\t\tasigs[sale].ssig  = ssig;\n\t\t\tasigs[sale].rbsig = rbsig;\n\t\t\tasigs[sale].sbsig = sbsig;\n\t\t} else {\n\t\t\trevert();\n\t\t}\n\t}\n\n\tfunction sec(bytes32 sale, bytes32 sec_) public { // Provide Secret\n\t\trequire(sales[sale].set);\n\t\tif      (sha256(abi.encodePacked(sec_)) == sechs[sale].sechA) { sechs[sale].secA = sec_; }\n        else if (sha256(abi.encodePacked(sec_)) == sechs[sale].sechB) { sechs[sale].secB = sec_; }\n        else if (sha256(abi.encodePacked(sec_)) == sechs[sale].sechC) { sechs[sale].secC = sec_; }\n        else if (sha256(abi.encodePacked(sec_)) == sechs[sale].sechD) { sechs[sale].secD = sec_; }\n        else                                                          { revert(); }\n\t}\n\n\tfunction hasSecs(bytes32 sale) public view returns (bool) { // 2 of 3 secrets\n\t\tuint8 secs = 0;\n\t\tif (sha256(abi.encodePacked(sechs[sale].secA)) == sechs[sale].sechA) { secs = secs + 1; }\n\t\tif (sha256(abi.encodePacked(sechs[sale].secB)) == sechs[sale].sechB) { secs = secs + 1; }\n\t\tif (sha256(abi.encodePacked(sechs[sale].secC)) == sechs[sale].sechC) { secs = secs + 1; }\n\t\treturn (secs >= 2);\n\t}\n\n\tfunction take(bytes32 sale) public { // Withdraw Bid (Accept Bid and disperse funds to rightful parties)\n        require(!taken(sale));\n        require(!off(sale));\n\t\trequire(now > sales[sale].salex);\n\t\trequire(hasSecs(sale));\n\t\trequire(sha256(abi.encodePacked(sechs[sale].secD)) == sechs[sale].sechD);\n        sales[sale].taken = true;\n        if (sales[sale].bid > (loans.dedu(sales[sale].loani))) {\n            require(tokes[sale].transfer(sales[sale].lend, loans.lentb(sales[sale].loani)));\n            if (agent(sale) != address(0)) {\n                require(tokes[sale].transfer(sales[sale].agent, loans.lfee(sales[sale].loani)));\n            }\n            require(tokes[sale].approve(address(med), loans.lpen(sales[sale].loani)));\n            med.push(loans.lpen(sales[sale].loani), tokes[sale]);\n            require(tokes[sale].transfer(sales[sale].bor, add(sub(sales[sale].bid, loans.dedub(sales[sale].loani)), loans.back(sales[sale].loani))));\n        } else {\n            require(tokes[sale].transfer(sales[sale].lend, sales[sale].bid));\n        }\n\t}\n\n\tfunction unpush(bytes32 sale) public { // Refund Bid\n        require(!taken(sale));\n        require(!off(sale));\n\t\trequire(now > sales[sale].setex);\n\t\trequire(sales[sale].bid > 0);\n        sales[sale].off = true;\n\t\trequire(tokes[sale].transfer(sales[sale].bidr, sales[sale].bid));\n        if (next(sales[sale].loani) == 3) {\n            require(tokes[sale].transfer(sales[sale].bor, loans.back(sales[sale].loani)));\n        }\n\t}\n}\n\npragma solidity ^0.5.8;\n\ncontract Loans is DSMath {\n    Funds funds;\n    Medianizer med;\n    Sales sales;\n\n    uint256 public constant APEXT = 7200;         // approval expiration threshold\n    uint256 public constant ACEXT = 172800;       // acceptance expiration threshold\n    uint256 public constant BIEXT = 604800;       // bidding expirataion threshold\n\n    mapping (bytes32 => Loan)      public loans;\n    mapping (bytes32 => Sechs)     public sechs;  // Secret Hashes\n    mapping (bytes32 => Bools)     public bools;  // Boolean state of Loan\n    mapping (bytes32 => bytes32)   public fundi;  // Mapping of Loan Index to Fund Index\n    mapping (bytes32 => ERC20)     public tokes;  // Mapping of Loan index to Token contract\n    mapping (bytes32 => uint256)   public backs;  // Amount paid back in a Loan\n    mapping (bytes32 => uint256)   public asaex;  // All Auction expiration\n    uint256                        public loani;  // Current Loan Index\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    bool on; // Ensure that Sales contract is created\n\n    struct Loan {\n    \taddress bor;        // Address Borrower\n        address lend;       // Address Lender\n        address agent;      // Optional Address automated agent\n        uint256 born;       // Created At\n        uint256 loex;       // Loan Expiration\n        uint256 prin;       // Principal\n        uint256 lint;       // Interest\n        uint256 lpen;       // Liquidation Penalty\n        uint256 lfee;       // Optional fee paid to auto if address not 0x0\n        uint256 col;        // Collateral\n        uint256 rat;        // Liquidation Ratio\n        bytes   bpubk;      // Borrower PubKey\n        bytes   lpubk;      // Lender PubKey\n    }\n\n    struct Sechs {\n    \tbytes32    sechA1;  // Secret Hash A1\n    \tbytes32[3] sechAS;  // Secret Hashes A2, A3, A4\n    \tbytes32    sechB1;  // Secret Hash B1\n    \tbytes32[3] sechBS;  // Secret Hashes B2, B3, B4\n    \tbytes32    sechC1;  // Secret Hash C1\n    \tbytes32[3] sechCS;  // Secret Hashes C2, C3, C4\n    \tbool       set;     // Secret Hashes set\n    }\n\n    struct Bools {\n    \tbool pushed;        // Loan Funded\n    \tbool marked;        // Collateral Marked as Locked\n    \tbool taken;         // Loan Withdrawn\n    \tbool sale;          // Collateral Liquidation Started\n    \tbool paid;          // Loan Repaid\n    \tbool off;           // Loan Finished (Repayment accepted or cancelled)\n    }\n\n    function bor(bytes32 loan)    public view returns (address) {\n        return loans[loan].bor;\n    }\n\n    function lend(bytes32 loan)   public view returns (address) {\n        return loans[loan].lend;\n    }\n\n    function agent(bytes32 loan)  public view returns (address) {\n        return loans[loan].agent;\n    }\n\n    function apex(bytes32 loan)   public returns (uint256) { // Approval Expiration\n        return add(loans[loan].born, APEXT);\n    }\n\n    function acex(bytes32 loan)   public returns (uint256) { // Acceptance Expiration\n        return add(loans[loan].loex, ACEXT);\n    }\n\n    function biex(bytes32 loan)   public returns (uint256) { // Bidding Expiration\n        return add(loans[loan].loex, BIEXT);\n    }\n\n    function prin(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].prin;\n    }\n\n    function lint(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].lint;\n    }\n\n    function lfee(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].lfee;\n    }\n\n    function lpen(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].lpen;\n    }\n\n    function col(bytes32 loan)    public view returns (uint256) {\n        return loans[loan].col;\n    }\n\n    function back(bytes32 loan)   public view returns (uint256) { // Amount paid back for loan\n        return backs[loan];\n    }\n\n    function rat(bytes32 loan)    public view returns (uint256) {\n        return loans[loan].rat;\n    }\n\n    function lent(bytes32 loan)   public view returns (uint256) { // Amount lent by Lender\n        return add(prin(loan), lint(loan));\n    }\n\n    function lentb(bytes32 loan)  public view returns (uint256) { // Amount lent by lender minus amount paid back\n        return sub(lent(loan), back(loan));\n    }\n\n    function owed(bytes32 loan)   public view returns (uint256) { // Amount owed\n        return add(lent(loan), lfee(loan));\n    }\n\n    function owedb(bytes32 loan)  public view returns (uint256) { // Amount owed minus amount paid back\n        return sub(owed(loan), back(loan));\n    }\n\n    function dedu(bytes32 loan)   public view returns (uint256) { // Deductible amount from collateral\n        return add(owed(loan), lpen(loan));\n    }\n\n    function dedub(bytes32 loan)  public view returns (uint256) { // Deductible amount from collateral minus amount paid back\n        return sub(dedu(loan), back(loan));\n    }\n\n    function pushed(bytes32 loan) public view returns (bool) {\n        return bools[loan].pushed;\n    }\n\n    function marked(bytes32 loan) public view returns (bool) {\n        return bools[loan].marked;\n    }\n\n    function taken(bytes32 loan) public view returns (bool) {\n        return bools[loan].taken;\n    }\n\n    function sale(bytes32 loan) public view returns (bool) {\n        return bools[loan].sale;\n    }\n\n    function paid(bytes32 loan) public view returns (bool) {\n        return bools[loan].paid;\n    }\n\n    function off(bytes32 loan)    public view returns (bool) {\n        return bools[loan].off;\n    }\n\n    function colv(bytes32 loan) public returns (uint256) { // Current Collateral Value\n        uint256 val = uint(med.read());\n        return cmul(val, col(loan)); // Multiply value dependent on number of decimals with currency\n    }\n\n    function min(bytes32 loan) public view returns (uint256) {  // Minimum Collateral Value\n        return rmul(sub(prin(loan), back(loan)), rat(loan));\n    }\n\n    function safe(bytes32 loan) public returns (bool) { // Loan is safe from Liquidation\n        return colv(loan) >= min(loan);\n    }\n\n    constructor (address funds_, address med_) public {\n    \tfunds = Funds(funds_);\n    \tmed   = Medianizer(med_);\n    }\n\n    function setSales(address sales_) public {\n        require(!on);\n        sales = Sales(sales_);\n        on = true;\n    }\n    \n    function open(                  // Create new Loan\n        uint256            loex_,   // Loan Expiration\n        address[3] memory  usrs_,   // Borrower, Lender, Optional Automated Agent Addresses\n        uint256[6] memory  vals_,   // Principal, Interest, Liquidation Penalty, Optional Automation Fee, Collaateral Amount, Liquidation Ratio\n        ERC20              tok_,    // Token contract\n        bytes32            fundi_   // Optional Fund Index\n    ) public returns (bytes32 loan) {\n        loani = add(loani, 1);\n        loan = bytes32(loani);\n        loans[loan].born   = now;\n        loans[loan].loex   = loex_;\n        loans[loan].bor    = usrs_[0];\n        loans[loan].lend   = usrs_[1];\n        loans[loan].agent  = usrs_[2];\n        loans[loan].prin   = vals_[0];\n        loans[loan].lint   = vals_[1];\n        loans[loan].lpen   = vals_[2];\n        loans[loan].lfee   = vals_[3];\n        loans[loan].col    = vals_[4];\n        loans[loan].rat    = vals_[5];\n        tokes[loan]        = tok_;\n        fundi[loan]        = fundi_;\n        sechs[loan].set    = false;\n\n        if (fundi_ != bytes32(0) && tokas[address(tok_)] == false) {\n            require(tok_.approve(address(funds), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function setSechs(             // Set Secret Hashes for Loan\n    \tbytes32           loan,    // Loan index\n    \tbytes32[4] memory bsechs,  // Borrower Secret Hashes\n    \tbytes32[4] memory lsechs,  // Lender Secret Hashes\n    \tbytes32[4] memory asechs,  // Agent Secret Hashes\n\t\tbytes      memory bpubk_,  // Borrower Pubkey\n        bytes      memory lpubk_   // Lender Pubkey\n\t) public returns (bool) {\n\t\trequire(!sechs[loan].set);\n\t\trequire(msg.sender == loans[loan].bor || msg.sender == loans[loan].lend || msg.sender == address(funds));\n\t\tsechs[loan].sechA1 = bsechs[0];\n\t\tsechs[loan].sechAS = [ bsechs[1], bsechs[2], bsechs[3] ];\n\t\tsechs[loan].sechB1 = lsechs[0];\n\t\tsechs[loan].sechBS = [ lsechs[1], lsechs[2], lsechs[3] ];\n\t\tsechs[loan].sechC1 = asechs[0];\n\t\tsechs[loan].sechCS = [ asechs[1], asechs[2], asechs[3] ];\n\t\tloans[loan].bpubk  = bpubk_;\n\t\tloans[loan].lpubk  = lpubk_;\n        sechs[loan].set    = true;\n\t}\n\n\tfunction push(bytes32 loan) public { // Fund Loan\n\t\trequire(sechs[loan].set);\n    \trequire(bools[loan].pushed == false);\n    \trequire(tokes[loan].transferFrom(msg.sender, address(this), prin(loan)));\n    \tbools[loan].pushed = true;\n    }\n\n    function mark(bytes32 loan) public { // Mark Collateral as locked\n    \trequire(bools[loan].pushed == true);\n    \trequire(loans[loan].lend   == msg.sender);\n    \trequire(now                <= apex(loan));\n    \tbools[loan].marked = true;\n    }\n\n    function take(bytes32 loan, bytes32 secA1) public { // Withdraw\n    \trequire(!off(loan));\n    \trequire(bools[loan].pushed == true);\n    \trequire(bools[loan].marked == true);\n    \trequire(sha256(abi.encodePacked(secA1)) == sechs[loan].sechA1);\n    \trequire(tokes[loan].transfer(loans[loan].bor, prin(loan)));\n    \tbools[loan].taken = true;\n    }\n\n    function pay(bytes32 loan, uint256 amt) public { // Payback Loan\n        // require(msg.sender                == loans[loan].bor); // NOTE: this is not necessary. Anyone can pay off the loan\n    \trequire(!off(loan));\n        require(!sale(loan));\n    \trequire(bools[loan].taken         == true);\n    \trequire(now                       <= loans[loan].loex);\n    \trequire(add(amt, backs[loan])     <= owed(loan));\n\n    \trequire(tokes[loan].transferFrom(msg.sender, address(this), amt));\n    \tbacks[loan] = add(amt, backs[loan]);\n    \tif (backs[loan] == owed(loan)) {\n    \t\tbools[loan].paid = true;\n    \t}\n    }\n\n    function unpay(bytes32 loan) public { // Refund payback\n    \trequire(!off(loan));\n        require(!sale(loan));\n    \trequire(now              >  acex(loan));\n    \trequire(bools[loan].paid == true);\n    \trequire(msg.sender       == loans[loan].bor);\n        bools[loan].off = true;\n    \trequire(tokes[loan].transfer(loans[loan].bor, owed(loan)));\n    }\n\n    function pull(bytes32 loan, bytes32 sec) public {\n        pull(loan, sec, true); // Default to true for returning funds to Fund\n    }\n\n    function pull(bytes32 loan, bytes32 sec, bool fund) public { // Accept or Cancel // Bool fund set true if lender wants fund to return to fund\n        require(!off(loan));\n        require(bools[loan].taken == false || bools[loan].paid == true);\n        require(msg.sender == loans[loan].lend || msg.sender == loans[loan].agent);\n        require(sha256(abi.encodePacked(sec)) == sechs[loan].sechB1 || sha256(abi.encodePacked(sec)) == sechs[loan].sechC1);\n        require(now                             <= acex(loan));\n        require(bools[loan].sale                == false);\n        bools[loan].off = true;\n        if (bools[loan].taken == false) {\n            require(tokes[loan].transfer(loans[loan].lend, loans[loan].prin));\n        } else if (bools[loan].taken == true) {\n            if (fundi[loan] == bytes32(0) || !fund) {\n                require(tokes[loan].transfer(loans[loan].lend, lent(loan)));\n            } else {\n                funds.push(fundi[loan], lent(loan));\n            }\n            require(tokes[loan].transfer(loans[loan].agent, lfee(loan)));\n        }\n    }\n\n    function sechi(bytes32 loan, bytes32 usr) private view returns (bytes32 sech) { // Get Secret Hash for Sale Index\n    \tif      (usr == 'A') { sech = sechs[loan].sechAS[sales.next(loan)]; }\n    \telse if (usr == 'B') { sech = sechs[loan].sechBS[sales.next(loan)]; }\n    \telse if (usr == 'C') { sech = sechs[loan].sechCS[sales.next(loan)]; }\n    \telse revert();\n    }\n\n    function sell(bytes32 loan) public returns (bytes32 sale) { // Start Auction\n    \trequire(!off(loan));\n        require(bools[loan].taken  == true);\n    \tif (sales.next(loan) == 0) {\n    \t\tif (now > loans[loan].loex) {\n\t    \t\trequire(bools[loan].paid == false);\n\t\t\t} else {\n\t\t\t\trequire(!safe(loan));\n\t\t\t}\n\t\t} else {\n\t\t\trequire(sales.next(loan) < 3);\n\t\t\trequire(msg.sender == loans[loan].bor || msg.sender == loans[loan].lend);\n            require(now > sales.setex(sales.salel(loan, sales.next(loan) - 1))); // Can only start auction after settlement expiration of pervious auction\n            require(!sales.taken(sales.salel(loan, sales.next(loan) - 1))); // Can only start auction again if previous auction bid wasn't taken\n\t\t}\n\t\tsale = sales.open(loan, loans[loan].bor, loans[loan].lend, loans[loan].agent, sechi(loan, 'A'), sechi(loan, 'B'), sechi(loan, 'C'), tokes[loan]);\n        if (bools[loan].sale == false) { require(tokes[loan].transfer(address(sales), back(loan))); }\n\t\tbools[loan].sale = true;\n    }\n}\n\npragma solidity ^0.5.8;\n\ncontract Funds is DSMath {\n    Loans loans;\n\n    mapping (address => bytes32[]) public sechs;  // User secret hashes\n    mapping (address => uint256)   public sechi;  // User secret hash index\n\n    mapping (address => bytes)     public pubks;  // User A Coin PubKeys\n    \n    mapping (bytes32 => Fund)      public funds;  \n    uint256                        public fundi;\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    address own;\n\n    struct Fund {\n        address  lend;   // Loan Fund Owner (Lender)\n        uint256  mila;  // Min Loan Amount\n        uint256  mala;  // Max Loan Amount\n        uint256  mild;  // Min Loan Duration\n        uint256  mald;  // Max Loan Duration\n        uint256  lint;  // Interest Rate in RAY\n        uint256  lpen;  // Liquidation Penalty Rate in RAY\n        uint256  lfee;  // Optional Automation Fee in RAY\n        uint256  rat;   // Liquidation Ratio in RAY\n        address  agent; // Optional Automator Agent\n        uint256  bal;   // Locked amount in fund (in TOK)\n        ERC20    tok;   // Debt Token\n    }\n\n    constructor() public {\n        own = msg.sender;\n    }\n\n    function setLoans(address loans_) public {\n        require(msg.sender == own);\n        require(address(loans) == address(0));\n        loans = Loans(loans_);\n    }\n\n    function lend(bytes32 fund)   public view returns (address) {\n        return funds[fund].lend;\n    }\n\n    function mila(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mila;\n    }\n\n    function mala(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mala;\n    }\n\n    function mild(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mild;\n    }\n\n    function mald(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mald;\n    }\n\n    function lint(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lint;\n    }\n\n    function lpen(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lpen;\n    }\n\n    function lfee(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lfee;\n    }\n\n    function rat(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].rat;\n    }\n\n    function agent(bytes32 fund) public view returns (address) {\n        return funds[fund].agent;\n    }\n\n    function bal(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].bal;\n    }\n\n    function tok(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].tok);\n    }\n\n    function open(\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  rat_,   // Liquidation Ratio\n        uint256  lint_,  // Interest Rate\n        uint256  lpen_,  // Liquidation Penalty Rate\n        uint256  lfee_,  // Optional Automation Fee Rate\n        address  agent_, // Optional Address Automated Agent\n        ERC20    tok_   // Debt Token\n    ) public returns (bytes32 fund) {\n        fundi = add(fundi, 1);\n        fund = bytes32(fundi);\n        funds[fund].lend  = msg.sender;\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].tok   = tok_;\n        funds[fund].agent = agent_;\n\n        if (tokas[address(tok_)] == false) {\n            require(tok_.approve(address(loans), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function push(bytes32 fund, uint256 amt) public { // Push funds to Loan Fund\n        // require(msg.sender == lend(fund) || msg.sender == address(loans)); // NOTE: this require is not necessary. Anyone can fund someone elses loan fund\n        funds[fund].bal = add(funds[fund].bal, amt);\n        require(funds[fund].tok.transferFrom(msg.sender, address(this), amt));\n    }\n\n    function gen(bytes32[] memory sechs_) public { // Generate secret hashes for Loan Fund\n        for (uint i = 0; i < sechs_.length; i++) {\n            sechs[msg.sender].push(sechs_[i]);\n        }\n    }\n\n    function set(bytes memory pubk) public { // Set PubKey for Fund\n        pubks[msg.sender] = pubk;\n    }\n\n    function set(        // Set Loan Fund details\n        bytes32  fund,   // Loan Fund Index\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  lint_,  // Interest Rate in RAY\n        uint256  lpen_,  // Liquidation Penalty Rate in RAY\n        uint256  lfee_,  // Optional Automation Fee in RAY\n        uint256  rat_,   // Liquidation Ratio in RAY\n        address  agent_  // Optional Automator Agent)\n    ) public {\n        require(msg.sender == lend(fund));\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].agent = agent_;\n    }\n\n    function req(                 // Request Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_,  // Loan Duration in seconds\n        bytes32[4] memory sechs_, // Secret Hash A1 & A2\n        bytes      memory pubk_   // Pubkey\n    ) public returns (bytes32 loani) {\n        require(msg.sender != lend(fund));\n        require(amt_       <= bal(fund));\n        require(amt_       >= mila(fund));\n        require(amt_       <= mala(fund));\n        require(lodu_      >= mild(fund));\n        require(lodu_      <= mald(fund));\n\n        loani = lopen(fund, amt_, col_, lodu_);\n        lsech(fund, loani, sechs_, pubk_);\n        loans.push(loani);\n    }\n\n    function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n        require(msg.sender == lend(fund));\n        require(bal(fund)  >= amt);\n        funds[fund].bal = sub(funds[fund].bal, amt);\n        require(funds[fund].tok.transfer(lend(fund), amt));\n    }\n\n    function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest\n        return sub(rmul(amt, rpow(rate, lodu)), amt);\n    }\n\n    function lopen(               // Private Open Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_   // Loan Duration in seconds\n    ) private returns (bytes32 loani) {\n        loani = loans.open(\n            now + lodu_,\n            [ msg.sender, lend(fund), funds[fund].agent],\n            [ amt_, calc(amt_, lint(fund), lodu_), calc(amt_, lpen(fund), lodu_), calc(amt_, lfee(fund), lodu_), col_, funds[fund].rat],\n            funds[fund].tok,\n            fund\n        );\n    }\n\n    function lsech(                // Loan Set Secret Hashes\n        bytes32 fund,              // Fund Index\n        bytes32 loan,              // Loan Index\n        bytes32[4] memory sechs_,  // 4 Secret Hashes\n        bytes memory pubk_         // Public Key\n    ) private { // Loan set Secret Hash and PubKey\n        loans.setSechs(\n            loan,\n            sechs_,\n            gsech(lend(fund)),\n            gsech(agent(fund)),\n            pubk_,\n            pubks[lend(fund)]\n        );\n    }\n\n    function gsech(address addr) private returns (bytes32[4] memory) { // Get 4 secrethashes for loan\n        sechi[addr] = add(sechi[addr], 4);\n        return [ sechs[addr][sub(sechi[addr], 4)], sechs[addr][sub(sechi[addr], 3)], sechs[addr][sub(sechi[addr], 2)], sechs[addr][sub(sechi[addr], 1)] ];\n    }\n}\n", "commit_id": "17ea184ff67d07957d9cb37d1c016fa766456873"}, "fixed_version": {"raw_code": "import 'openzeppelin-solidity/contracts/token/ERC20/ERC20.sol';\nimport 'openzeppelin-solidity/contracts/math/SafeMath.sol';\n\nimport './Loans.sol';\nimport './Currency.sol';\nimport './Vars.sol';\nimport './DSMath.sol';\n\npragma solidity ^0.5.8;\n\ncontract Funds is DSMath {\n    Loans loans;\n\n    mapping (address => bytes32[]) public sechs;  // User secret hashes\n    mapping (address => uint256)   public sechi;  // User secret hash index\n\n    mapping (address => bytes)     public pubks;  // User A Coin PubKeys\n    \n    mapping (bytes32 => Fund)      public funds;  \n    uint256                        public fundi;\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    bool on; // Ensure that Loans contract is created\n\n    struct Fund {\n        address  own;   // Loan Fund Owner (Lender)\n        uint256  mila;  // Min Loan Amount\n        uint256  mala;  // Max Loan Amount\n        uint256  mild;  // Min Loan Duration\n        uint256  mald;  // Max Loan Duration\n        uint256  lint;  // Interest Rate in RAY\n        uint256  lpen;  // Liquidation Penalty Rate in RAY\n        uint256  lfee;  // Optional Automation Fee in RAY\n        uint256  rat;   // Liquidation Ratio in RAY\n        address  agent; // Optional Automator Agent\n        uint256  bal;   // Locked amount in fund (in TOK)\n        ERC20    tok;   // Debt Token\n        Currency cur;   // Currency info\n        Vars     vars;  // Variable contract\n    }\n\n    function setLoans(address loans_) public {\n        require(!on);\n        loans = Loans(loans_);\n        on = true;\n    }\n\n    function own(bytes32 fund)   public view returns (address) {\n        return funds[fund].own;\n    }\n\n    function mila(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mila;\n    }\n\n    function mala(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mala;\n    }\n\n    function mild(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mild;\n    }\n\n    function mald(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mald;\n    }\n\n    function lint(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lint;\n    }\n\n    function lpen(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lpen;\n    }\n\n    function lfee(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lfee;\n    }\n\n    function rat(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].rat;\n    }\n\n    function agent(bytes32 fund) public view returns (address) {\n        return funds[fund].agent;\n    }\n\n    function bal(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].bal;\n    }\n\n    function tok(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].tok);\n    }\n\n    function cur(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].cur);\n    }\n\n    function vars(bytes32 fund)  public view returns (address) {\n        return address(funds[fund].vars);\n    }\n\n    function open(\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  rat_,   // Liquidation Ratio\n        uint256  lint_,  // Interest Rate\n        uint256  lpen_,  // Liquidation Penalty Rate\n        uint256  lfee_,  // Optional Automation Fee Rate\n        address  agent_, // Optional Address Automated Agent\n        ERC20    tok_,   // Debt Token\n        Currency cur_,   // Currency contract\n        Vars     vars_   // Variable contract\n    ) public returns (bytes32 fund) {\n        fundi = add(fundi, 1);\n        fund = bytes32(fundi);\n        funds[fund].own   = msg.sender;\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].tok   = tok_;\n        funds[fund].cur   = cur_;\n        funds[fund].vars  = vars_;\n        funds[fund].agent = agent_;\n\n        if (tokas[address(tok_)] == false) {\n            require(tok_.approve(address(loans), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function push(bytes32 fund, uint256 amt) public { // Push funds to Loan Fund\n        // require(msg.sender == own(fund) || msg.sender == address(loans)); // NOTE: this require is not necessary. Anyone can fund someone elses loan fund\n        require(funds[fund].tok.transferFrom(msg.sender, address(this), amt));\n        funds[fund].bal = add(funds[fund].bal, amt);\n    }\n\n    function gen(bytes32[] memory sechs_) public { // Generate secret hashes for Loan Fund\n        for (uint i = 0; i < sechs_.length; i++) {\n            sechs[msg.sender].push(sechs_[i]);\n        }\n    }\n\n    function set(bytes memory pubk) public { // Set PubKey for Fund\n        pubks[msg.sender] = pubk;\n    }\n\n    function set(        // Set Loan Fund details\n        bytes32  fund,   // Loan Fund Index\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  lint_,  // Interest Rate in RAY\n        uint256  lpen_,  // Liquidation Penalty Rate in RAY\n        uint256  lfee_,  // Optional Automation Fee in RAY\n        uint256  rat_,   // Liquidation Ratio in RAY\n        address  agent_  // Optional Automator Agent)\n    ) public {\n        require(msg.sender == own(fund));\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].agent = agent_;\n    }\n\n    function req(                 // Request Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_,  // Loan Duration in seconds\n        bytes32[4] memory sechs_, // Secret Hash A1 & A2\n        bytes      memory pubk_   // Pubkey\n    ) public returns (bytes32 loani) {\n        require(msg.sender != own(fund));\n        require(amt_       <= bal(fund));\n        require(amt_       >= mila(fund));\n        require(amt_       <= mala(fund));\n        require(lodu_      >= mild(fund));\n        require(lodu_      <= mald(fund));\n\n        loani = lopen(fund, amt_, col_, lodu_);\n        lsech(fund, loani, sechs_, pubk_);\n        loans.push(loani);\n    }\n\n    function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n        require(msg.sender == own(fund));\n        require(bal(fund)  >= amt);\n        funds[fund].bal = sub(funds[fund].bal, amt);\n        require(funds[fund].tok.transfer(own(fund), amt));\n    }\n\n    function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest\n        return sub(rmul(amt, rpow(rate, lodu)), amt);\n    }\n\n    function lopen(               // Private Open Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_   // Loan Duration in seconds\n    ) private returns (bytes32 loani) {\n        loani = loans.open(\n            now + lodu_,\n            [ msg.sender, own(fund), funds[fund].agent],\n            [ amt_, calc(amt_, lint(fund), lodu_), calc(amt_, lpen(fund), lodu_), calc(amt_, lfee(fund), lodu_), col_, funds[fund].rat],\n            funds[fund].tok,\n            funds[fund].cur,\n            funds[fund].vars,\n            fund\n        );\n    }\n\n    function lsech(                // Loan Set Secret Hashes\n        bytes32 fund,              // Fund Index\n        bytes32 loan,              // Loan Index\n        bytes32[4] memory sechs_,  // 4 Secret Hashes\n        bytes memory pubk_         // Public Key\n    ) private { // Loan set Secret Hash and PubKey\n        loans.setSechs(\n            loan,\n            sechs_,\n            gsech(own(fund)),\n            gsech(agent(fund)),\n            pubk_,\n            pubks[own(fund)]\n        );\n    }\n\n    function gsech(address addr) private view returns (bytes32[4] memory) { // Get 4 secrethashes for loan\n        require((sechs[addr].length - sechi[addr]) >= 4);\n        return [ sechs[addr][add(sechi[addr], 0)], sechs[addr][add(sechi[addr], 1)], sechs[addr][add(sechi[addr], 2)], sechs[addr][add(sechi[addr], 3)] ];\n    }\n}\n", "flattened_code": "pragma solidity ^0.5.0;\n\npragma solidity ^0.5.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n    // solhint-disable-previous-line no-empty-blocks\n\n    function _msgSender() internal view returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n}\n\n\n\npragma solidity ^0.5.8;\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n\n    function min(uint x, uint y) internal pure returns (uint z) {\n        return x <= y ? x : y;\n    }\n    function max(uint x, uint y) internal pure returns (uint z) {\n        return x >= y ? x : y;\n    }\n    function imin(int x, int y) internal pure returns (int z) {\n        return x <= y ? x : y;\n    }\n    function imax(int x, int y) internal pure returns (int z) {\n        return x >= y ? x : y;\n    }\n\n    uint constant COL = 10 ** 8;\n    uint constant WAD = 10 ** 18;\n    uint constant RAY = 10 ** 27;\n\n    function cmul(uint x, uint y) public pure returns (uint z) {\n        z = add(mul(x, y), COL / 2) / COL;\n    }\n    function wmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n    function rmul(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint x, uint n) internal pure returns (uint z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n\npragma solidity ^0.5.8;\n\ncontract Funds is DSMath {\n    Loans loans;\n\n    mapping (address => bytes32[]) public sechs;  // User secret hashes\n    mapping (address => uint256)   public sechi;  // User secret hash index\n\n    mapping (address => bytes)     public pubks;  // User A Coin PubKeys\n    \n    mapping (bytes32 => Fund)      public funds;  \n    uint256                        public fundi;\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    address own;\n\n    struct Fund {\n        address  lend;   // Loan Fund Owner (Lender)\n        uint256  mila;  // Min Loan Amount\n        uint256  mala;  // Max Loan Amount\n        uint256  mild;  // Min Loan Duration\n        uint256  mald;  // Max Loan Duration\n        uint256  lint;  // Interest Rate in RAY\n        uint256  lpen;  // Liquidation Penalty Rate in RAY\n        uint256  lfee;  // Optional Automation Fee in RAY\n        uint256  rat;   // Liquidation Ratio in RAY\n        address  agent; // Optional Automator Agent\n        uint256  bal;   // Locked amount in fund (in TOK)\n        ERC20    tok;   // Debt Token\n    }\n\n    constructor() public {\n        own = msg.sender;\n    }\n\n    function setLoans(address loans_) public {\n        require(msg.sender == own);\n        require(address(loans) == address(0));\n        loans = Loans(loans_);\n    }\n\n    function lend(bytes32 fund)   public view returns (address) {\n        return funds[fund].lend;\n    }\n\n    function mila(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mila;\n    }\n\n    function mala(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mala;\n    }\n\n    function mild(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mild;\n    }\n\n    function mald(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mald;\n    }\n\n    function lint(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lint;\n    }\n\n    function lpen(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lpen;\n    }\n\n    function lfee(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lfee;\n    }\n\n    function rat(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].rat;\n    }\n\n    function agent(bytes32 fund) public view returns (address) {\n        return funds[fund].agent;\n    }\n\n    function bal(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].bal;\n    }\n\n    function tok(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].tok);\n    }\n\n    function open(\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  rat_,   // Liquidation Ratio\n        uint256  lint_,  // Interest Rate\n        uint256  lpen_,  // Liquidation Penalty Rate\n        uint256  lfee_,  // Optional Automation Fee Rate\n        address  agent_, // Optional Address Automated Agent\n        ERC20    tok_   // Debt Token\n    ) public returns (bytes32 fund) {\n        fundi = add(fundi, 1);\n        fund = bytes32(fundi);\n        funds[fund].lend  = msg.sender;\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].tok   = tok_;\n        funds[fund].agent = agent_;\n\n        if (tokas[address(tok_)] == false) {\n            require(tok_.approve(address(loans), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function push(bytes32 fund, uint256 amt) public { // Push funds to Loan Fund\n        // require(msg.sender == lend(fund) || msg.sender == address(loans)); // NOTE: this require is not necessary. Anyone can fund someone elses loan fund\n        funds[fund].bal = add(funds[fund].bal, amt);\n        require(funds[fund].tok.transferFrom(msg.sender, address(this), amt));\n    }\n\n    function gen(bytes32[] memory sechs_) public { // Generate secret hashes for Loan Fund\n        for (uint i = 0; i < sechs_.length; i++) {\n            sechs[msg.sender].push(sechs_[i]);\n        }\n    }\n\n    function set(bytes memory pubk) public { // Set PubKey for Fund\n        pubks[msg.sender] = pubk;\n    }\n\n    function set(        // Set Loan Fund details\n        bytes32  fund,   // Loan Fund Index\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  lint_,  // Interest Rate in RAY\n        uint256  lpen_,  // Liquidation Penalty Rate in RAY\n        uint256  lfee_,  // Optional Automation Fee in RAY\n        uint256  rat_,   // Liquidation Ratio in RAY\n        address  agent_  // Optional Automator Agent)\n    ) public {\n        require(msg.sender == lend(fund));\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].agent = agent_;\n    }\n\n    function req(                 // Request Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_,  // Loan Duration in seconds\n        bytes32[4] memory sechs_, // Secret Hash A1 & A2\n        bytes      memory pubk_   // Pubkey\n    ) public returns (bytes32 loani) {\n        require(msg.sender != lend(fund));\n        require(amt_       <= bal(fund));\n        require(amt_       >= mila(fund));\n        require(amt_       <= mala(fund));\n        require(lodu_      >= mild(fund));\n        require(lodu_      <= mald(fund));\n\n        loani = lopen(fund, amt_, col_, lodu_);\n        lsech(fund, loani, sechs_, pubk_);\n        loans.push(loani);\n    }\n\n    function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n        require(msg.sender == lend(fund));\n        require(bal(fund)  >= amt);\n        funds[fund].bal = sub(funds[fund].bal, amt);\n        require(funds[fund].tok.transfer(lend(fund), amt));\n    }\n\n    function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest\n        return sub(rmul(amt, rpow(rate, lodu)), amt);\n    }\n\n    function lopen(               // Private Open Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_   // Loan Duration in seconds\n    ) private returns (bytes32 loani) {\n        loani = loans.open(\n            now + lodu_,\n            [ msg.sender, lend(fund), funds[fund].agent],\n            [ amt_, calc(amt_, lint(fund), lodu_), calc(amt_, lpen(fund), lodu_), calc(amt_, lfee(fund), lodu_), col_, funds[fund].rat],\n            funds[fund].tok,\n            fund\n        );\n    }\n\n    function lsech(                // Loan Set Secret Hashes\n        bytes32 fund,              // Fund Index\n        bytes32 loan,              // Loan Index\n        bytes32[4] memory sechs_,  // 4 Secret Hashes\n        bytes memory pubk_         // Public Key\n    ) private { // Loan set Secret Hash and PubKey\n        loans.setSechs(\n            loan,\n            sechs_,\n            gsech(lend(fund)),\n            gsech(agent(fund)),\n            pubk_,\n            pubks[lend(fund)]\n        );\n    }\n\n    function gsech(address addr) private returns (bytes32[4] memory) { // Get 4 secrethashes for loan\n        sechi[addr] = add(sechi[addr], 4);\n        return [ sechs[addr][sub(sechi[addr], 4)], sechs[addr][sub(sechi[addr], 3)], sechs[addr][sub(sechi[addr], 2)], sechs[addr][sub(sechi[addr], 1)] ];\n    }\n}\n\n\npragma solidity ^0.5.8;\n\ncontract Medianizer {\n    function peek() public returns (bytes32, bool);\n    function read() public returns (bytes32);\n    function poke(bytes32 wut) public;\n    function void() public;\n    function push(uint256 amt, ERC20 tok) public;\n}\n\npragma solidity ^0.5.8;\n\ncontract Sales is DSMath { // Auctions\n\tLoans loans;\n\tMedianizer med;\n\n    uint256 public constant SALEX = 3600;                         // Sales Expiration\n    uint256 public constant SETEX = 14400;                        // Settlement Expiration\n    uint256 public constant MINBI = 1005000000000000000000000000; // Minimum Bid Increment in RAY\n\n\taddress public own; // Only the Loans contract can edit data\n\n\tmapping (bytes32 => Sale)       public sales; // Auctions\n\tmapping (bytes32 => ERC20)      public tokes; // Auction token\n\tmapping (bytes32 => Bsig)       public bsigs; // Borrower Signatures\n\tmapping (bytes32 => Lsig)       public lsigs; // Lender Signatures\n\tmapping (bytes32 => Asig)       public asigs; // Lender Signatures\n\tmapping (bytes32 => Sech)       public sechs; // Auction Secret Hashes\n    uint256                         public salei; // Auction Index\n\n    mapping (bytes32 => bytes32[])  public salel; // Loan Auctions (find by loani)\n\n    struct Sale {\n        bytes32    loani;  // Loan Index\n        uint256    bid;    // Current Bid\n        address    bidr;   // Bidder\n        address    bor;    // Borrower\n        address    lend;   // Lender\n        address    agent;  // Optional Automated Agent\n        uint256    salex;  // Auction Bidding Expiration\n        uint256    setex;  // Auction Settlement Expiration\n        bytes20    pbkh;   // Bidder PubKey Hash\n        bool       set;    // Sale at index opened\n        bool       taken;  // Winning bid accepted\n        bool       off;\n    }\n\n    struct Bsig {\n    \tbytes      rsig;  // Borrower Refundable Signature\n        bytes      ssig;  // Borrower Seizable Signature\n        bytes      rbsig; // Borrower Refundable Back Signature\n        bytes      sbsig; // Borrower Seizable Back Signature\n    }\n\n    struct Lsig {\n    \tbytes      rsig;  // Lender Refundable Signature\n        bytes      ssig;  // Lender Seizable Signature\n        bytes      rbsig; // Lender Refundable Back Signature\n        bytes      sbsig; // Lender Seizable Back Signature\n    }\n\n    struct Asig {\n    \tbytes      rsig;  // Agent Refundable Signature\n        bytes      ssig;  // Agent Seizable Signature\n        bytes      rbsig; // Agent Refundable Back Signature\n        bytes      sbsig; // Agent Seizable Back Signature\n    }\n\n    struct Sech {\n        bytes32    sechA; // Secret Hash A\n        bytes32    secA;  // Secret A\n        bytes32    sechB; // Secret Hash B\n        bytes32    secB;  // Secret B\n        bytes32    sechC; // Secret Hash C\n        bytes32    secC;  // Secret C\n        bytes32    sechD; // Secret Hash D\n        bytes32    secD;  // Secret D\n    }\n\n    function bid(bytes32 sale) public returns (uint256) {\n        return sales[sale].bid;\n    }\n\n    function bidr(bytes32 sale) public returns (address) {\n        return sales[sale].bidr;\n    }\n\n    function bor(bytes32 sale) public returns (address) {\n        return sales[sale].bor;\n    }\n\n    function lend(bytes32 sale) public returns (address) {\n        return sales[sale].lend;\n    }\n\n    function agent(bytes32 sale) public returns (address) {\n        return sales[sale].agent;\n    }\n\n    function salex(bytes32 sale) public returns (uint256) {\n        return sales[sale].salex;\n    }\n\n    function setex(bytes32 sale) public returns (uint256) {\n        return sales[sale].setex;\n    }\n\n    function pbkh(bytes32 sale) public returns (bytes20) {\n        return sales[sale].pbkh;\n    }\n\n    function taken(bytes32 sale) public returns (bool) {\n        return sales[sale].taken;\n    }\n\n    function off(bytes32 sale) public returns (bool) {\n        return sales[sale].off;\n    }\n\n    function sechA(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechA;\n    }\n\n    function secA(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secA;\n    }\n\n    function sechB(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechB;\n    }\n\n    function secB(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secB;\n    }\n\n    function sechC(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechC;\n    }\n\n    function secC(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secC;\n    }\n\n    function sechD(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].sechD;\n    }\n\n    function secD(bytes32 sale) public returns (bytes32) {\n        return sechs[sale].secD;\n    }\n\n    constructor (address loans_, address med_) public {\n    \town   = loans_;\n    \tloans = Loans(loans_);\n    \tmed   = Medianizer(med_);\n    }\n\n    function next(bytes32 loan) public view returns (uint256) {\n    \treturn salel[loan].length;\n    }\n\n    function open(\n    \tbytes32 loani, // Loan Index\n    \taddress bor,   // Address Borrower\n    \taddress lend,  // Address Lender\n        address agent, // Optional Address automated agent\n    \tbytes32 sechA, // Secret Hash A\n    \tbytes32 sechB, // Secret Hash B\n    \tbytes32 sechC, // Secret Hash C\n\tERC20   tok    // Debt Token\n\t) public returns(bytes32 sale) {\n    \trequire(msg.sender == own);\n    \tsalei = add(salei, 1);\n        sale = bytes32(salei);\n        sales[sale].loani = loani;\n        sales[sale].bor   = bor;\n        sales[sale].lend  = lend;\n        sales[sale].agent = agent;\n        sales[sale].salex = now + SALEX;\n        sales[sale].setex = now + SALEX + SETEX;\n        tokes[sale]       = tok;\n        sales[sale].set   = true;\n        sechs[sale].sechA = sechA;\n        sechs[sale].sechB = sechB;\n        sechs[sale].sechC = sechC;\n        salel[loani].push(sale);\n    }\n\n    function push(     // Bid on Collateral\n    \tbytes32 sale,  // Auction Index\n    \tuint256 amt,   // Bid Amount\n    \tbytes32 sech,  // Secret Hash\n    \tbytes20 pbkh   // PubKeyHash\n\t) public {\n        require(msg.sender != bor(sale) && msg.sender != lend(sale));\n\t\trequire(sales[sale].set);\n    \trequire(now < sales[sale].salex);\n    \trequire(amt > sales[sale].bid);\n    \trequire(tokes[sale].balanceOf(msg.sender) >= amt);\n    \tif (sales[sale].bid > 0) {\n\t\trequire(amt > rmul(sales[sale].bid, MINBI)); // Make sure next bid is at least 0.5% more than the last bid\n    \t}\n\n    \trequire(tokes[sale].transferFrom(msg.sender, address(this), amt));\n    \tif (sales[sale].bid > 0) {\n    \t\trequire(tokes[sale].transfer(sales[sale].bidr, sales[sale].bid));\n    \t}\n    \tsales[sale].bidr = msg.sender;\n    \tsales[sale].bid  = amt;\n    \tsechs[sale].sechD = sech;\n    \tsales[sale].pbkh = pbkh;\n\t}\n\n\tfunction sign(           // Provide Signature to move collateral to collateral swap\n\t\tbytes32      sale,   // Auction Index\n\t\tbytes memory rsig,   // Refundable Signature\n\t\tbytes memory ssig,   // Seizable Signature\n\t\tbytes memory rbsig,  // Refundable Back Signature\n\t\tbytes memory sbsig   // Seizable Back Signataure\n\t) public {\n\t\trequire(sales[sale].set);\n\t\trequire(now < sales[sale].setex);\n\t\tif (msg.sender == sales[sale].bor) {\n\t\t\tbsigs[sale].rsig  = rsig;\n\t\t\tbsigs[sale].ssig  = ssig;\n\t\t\tbsigs[sale].rbsig = rbsig;\n\t\t\tbsigs[sale].sbsig = sbsig;\n\t\t} else if (msg.sender == sales[sale].lend) {\n\t\t\tlsigs[sale].rsig  = rsig;\n\t\t\tlsigs[sale].ssig  = ssig;\n\t\t\tlsigs[sale].rbsig = rbsig;\n\t\t\tlsigs[sale].sbsig = sbsig;\n\t\t} else if (msg.sender == sales[sale].agent) {\n\t\t\tasigs[sale].rsig  = rsig;\n\t\t\tasigs[sale].ssig  = ssig;\n\t\t\tasigs[sale].rbsig = rbsig;\n\t\t\tasigs[sale].sbsig = sbsig;\n\t\t} else {\n\t\t\trevert();\n\t\t}\n\t}\n\n\tfunction sec(bytes32 sale, bytes32 sec_) public { // Provide Secret\n\t\trequire(sales[sale].set);\n\t\tif      (sha256(abi.encodePacked(sec_)) == sechs[sale].sechA) { sechs[sale].secA = sec_; }\n        else if (sha256(abi.encodePacked(sec_)) == sechs[sale].sechB) { sechs[sale].secB = sec_; }\n        else if (sha256(abi.encodePacked(sec_)) == sechs[sale].sechC) { sechs[sale].secC = sec_; }\n        else if (sha256(abi.encodePacked(sec_)) == sechs[sale].sechD) { sechs[sale].secD = sec_; }\n        else                                                          { revert(); }\n\t}\n\n\tfunction hasSecs(bytes32 sale) public view returns (bool) { // 2 of 3 secrets\n\t\tuint8 secs = 0;\n\t\tif (sha256(abi.encodePacked(sechs[sale].secA)) == sechs[sale].sechA) { secs = secs + 1; }\n\t\tif (sha256(abi.encodePacked(sechs[sale].secB)) == sechs[sale].sechB) { secs = secs + 1; }\n\t\tif (sha256(abi.encodePacked(sechs[sale].secC)) == sechs[sale].sechC) { secs = secs + 1; }\n\t\treturn (secs >= 2);\n\t}\n\n\tfunction take(bytes32 sale) public { // Withdraw Bid (Accept Bid and disperse funds to rightful parties)\n        require(!taken(sale));\n        require(!off(sale));\n\t\trequire(now > sales[sale].salex);\n\t\trequire(hasSecs(sale));\n\t\trequire(sha256(abi.encodePacked(sechs[sale].secD)) == sechs[sale].sechD);\n        sales[sale].taken = true;\n        if (sales[sale].bid > (loans.dedu(sales[sale].loani))) {\n            require(tokes[sale].transfer(sales[sale].lend, loans.lentb(sales[sale].loani)));\n            if (agent(sale) != address(0)) {\n                require(tokes[sale].transfer(sales[sale].agent, loans.lfee(sales[sale].loani)));\n            }\n            require(tokes[sale].approve(address(med), loans.lpen(sales[sale].loani)));\n            med.push(loans.lpen(sales[sale].loani), tokes[sale]);\n            require(tokes[sale].transfer(sales[sale].bor, add(sub(sales[sale].bid, loans.dedub(sales[sale].loani)), loans.back(sales[sale].loani))));\n        } else {\n            require(tokes[sale].transfer(sales[sale].lend, sales[sale].bid));\n        }\n\t}\n\n\tfunction unpush(bytes32 sale) public { // Refund Bid\n        require(!taken(sale));\n        require(!off(sale));\n\t\trequire(now > sales[sale].setex);\n\t\trequire(sales[sale].bid > 0);\n        sales[sale].off = true;\n\t\trequire(tokes[sale].transfer(sales[sale].bidr, sales[sale].bid));\n        if (next(sales[sale].loani) == 3) {\n            require(tokes[sale].transfer(sales[sale].bor, loans.back(sales[sale].loani)));\n        }\n\t}\n}\n\npragma solidity ^0.5.8;\n\ncontract Loans is DSMath {\n    Funds funds;\n    Medianizer med;\n    Sales sales;\n\n    uint256 public constant APEXT = 7200;         // approval expiration threshold\n    uint256 public constant ACEXT = 172800;       // acceptance expiration threshold\n    uint256 public constant BIEXT = 604800;       // bidding expirataion threshold\n\n    mapping (bytes32 => Loan)      public loans;\n    mapping (bytes32 => Sechs)     public sechs;  // Secret Hashes\n    mapping (bytes32 => Bools)     public bools;  // Boolean state of Loan\n    mapping (bytes32 => bytes32)   public fundi;  // Mapping of Loan Index to Fund Index\n    mapping (bytes32 => ERC20)     public tokes;  // Mapping of Loan index to Token contract\n    mapping (bytes32 => uint256)   public backs;  // Amount paid back in a Loan\n    mapping (bytes32 => uint256)   public asaex;  // All Auction expiration\n    uint256                        public loani;  // Current Loan Index\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    bool on; // Ensure that Sales contract is created\n\n    struct Loan {\n    \taddress bor;        // Address Borrower\n        address lend;       // Address Lender\n        address agent;      // Optional Address automated agent\n        uint256 born;       // Created At\n        uint256 loex;       // Loan Expiration\n        uint256 prin;       // Principal\n        uint256 lint;       // Interest\n        uint256 lpen;       // Liquidation Penalty\n        uint256 lfee;       // Optional fee paid to auto if address not 0x0\n        uint256 col;        // Collateral\n        uint256 rat;        // Liquidation Ratio\n        bytes   bpubk;      // Borrower PubKey\n        bytes   lpubk;      // Lender PubKey\n    }\n\n    struct Sechs {\n    \tbytes32    sechA1;  // Secret Hash A1\n    \tbytes32[3] sechAS;  // Secret Hashes A2, A3, A4\n    \tbytes32    sechB1;  // Secret Hash B1\n    \tbytes32[3] sechBS;  // Secret Hashes B2, B3, B4\n    \tbytes32    sechC1;  // Secret Hash C1\n    \tbytes32[3] sechCS;  // Secret Hashes C2, C3, C4\n    \tbool       set;     // Secret Hashes set\n    }\n\n    struct Bools {\n    \tbool pushed;        // Loan Funded\n    \tbool marked;        // Collateral Marked as Locked\n    \tbool taken;         // Loan Withdrawn\n    \tbool sale;          // Collateral Liquidation Started\n    \tbool paid;          // Loan Repaid\n    \tbool off;           // Loan Finished (Repayment accepted or cancelled)\n    }\n\n    function bor(bytes32 loan)    public view returns (address) {\n        return loans[loan].bor;\n    }\n\n    function lend(bytes32 loan)   public view returns (address) {\n        return loans[loan].lend;\n    }\n\n    function agent(bytes32 loan)  public view returns (address) {\n        return loans[loan].agent;\n    }\n\n    function apex(bytes32 loan)   public returns (uint256) { // Approval Expiration\n        return add(loans[loan].born, APEXT);\n    }\n\n    function acex(bytes32 loan)   public returns (uint256) { // Acceptance Expiration\n        return add(loans[loan].loex, ACEXT);\n    }\n\n    function biex(bytes32 loan)   public returns (uint256) { // Bidding Expiration\n        return add(loans[loan].loex, BIEXT);\n    }\n\n    function prin(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].prin;\n    }\n\n    function lint(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].lint;\n    }\n\n    function lfee(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].lfee;\n    }\n\n    function lpen(bytes32 loan)   public view returns (uint256) {\n        return loans[loan].lpen;\n    }\n\n    function col(bytes32 loan)    public view returns (uint256) {\n        return loans[loan].col;\n    }\n\n    function back(bytes32 loan)   public view returns (uint256) { // Amount paid back for loan\n        return backs[loan];\n    }\n\n    function rat(bytes32 loan)    public view returns (uint256) {\n        return loans[loan].rat;\n    }\n\n    function lent(bytes32 loan)   public view returns (uint256) { // Amount lent by Lender\n        return add(prin(loan), lint(loan));\n    }\n\n    function lentb(bytes32 loan)  public view returns (uint256) { // Amount lent by lender minus amount paid back\n        return sub(lent(loan), back(loan));\n    }\n\n    function owed(bytes32 loan)   public view returns (uint256) { // Amount owed\n        return add(lent(loan), lfee(loan));\n    }\n\n    function owedb(bytes32 loan)  public view returns (uint256) { // Amount owed minus amount paid back\n        return sub(owed(loan), back(loan));\n    }\n\n    function dedu(bytes32 loan)   public view returns (uint256) { // Deductible amount from collateral\n        return add(owed(loan), lpen(loan));\n    }\n\n    function dedub(bytes32 loan)  public view returns (uint256) { // Deductible amount from collateral minus amount paid back\n        return sub(dedu(loan), back(loan));\n    }\n\n    function pushed(bytes32 loan) public view returns (bool) {\n        return bools[loan].pushed;\n    }\n\n    function marked(bytes32 loan) public view returns (bool) {\n        return bools[loan].marked;\n    }\n\n    function taken(bytes32 loan) public view returns (bool) {\n        return bools[loan].taken;\n    }\n\n    function sale(bytes32 loan) public view returns (bool) {\n        return bools[loan].sale;\n    }\n\n    function paid(bytes32 loan) public view returns (bool) {\n        return bools[loan].paid;\n    }\n\n    function off(bytes32 loan)    public view returns (bool) {\n        return bools[loan].off;\n    }\n\n    function colv(bytes32 loan) public returns (uint256) { // Current Collateral Value\n        uint256 val = uint(med.read());\n        return cmul(val, col(loan)); // Multiply value dependent on number of decimals with currency\n    }\n\n    function min(bytes32 loan) public view returns (uint256) {  // Minimum Collateral Value\n        return rmul(sub(prin(loan), back(loan)), rat(loan));\n    }\n\n    function safe(bytes32 loan) public returns (bool) { // Loan is safe from Liquidation\n        return colv(loan) >= min(loan);\n    }\n\n    constructor (address funds_, address med_) public {\n    \tfunds = Funds(funds_);\n    \tmed   = Medianizer(med_);\n    }\n\n    function setSales(address sales_) public {\n        require(!on);\n        sales = Sales(sales_);\n        on = true;\n    }\n    \n    function open(                  // Create new Loan\n        uint256            loex_,   // Loan Expiration\n        address[3] memory  usrs_,   // Borrower, Lender, Optional Automated Agent Addresses\n        uint256[6] memory  vals_,   // Principal, Interest, Liquidation Penalty, Optional Automation Fee, Collaateral Amount, Liquidation Ratio\n        ERC20              tok_,    // Token contract\n        bytes32            fundi_   // Optional Fund Index\n    ) public returns (bytes32 loan) {\n        loani = add(loani, 1);\n        loan = bytes32(loani);\n        loans[loan].born   = now;\n        loans[loan].loex   = loex_;\n        loans[loan].bor    = usrs_[0];\n        loans[loan].lend   = usrs_[1];\n        loans[loan].agent  = usrs_[2];\n        loans[loan].prin   = vals_[0];\n        loans[loan].lint   = vals_[1];\n        loans[loan].lpen   = vals_[2];\n        loans[loan].lfee   = vals_[3];\n        loans[loan].col    = vals_[4];\n        loans[loan].rat    = vals_[5];\n        tokes[loan]        = tok_;\n        fundi[loan]        = fundi_;\n        sechs[loan].set    = false;\n\n        if (fundi_ != bytes32(0) && tokas[address(tok_)] == false) {\n            require(tok_.approve(address(funds), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function setSechs(             // Set Secret Hashes for Loan\n    \tbytes32           loan,    // Loan index\n    \tbytes32[4] memory bsechs,  // Borrower Secret Hashes\n    \tbytes32[4] memory lsechs,  // Lender Secret Hashes\n    \tbytes32[4] memory asechs,  // Agent Secret Hashes\n\t\tbytes      memory bpubk_,  // Borrower Pubkey\n        bytes      memory lpubk_   // Lender Pubkey\n\t) public returns (bool) {\n\t\trequire(!sechs[loan].set);\n\t\trequire(msg.sender == loans[loan].bor || msg.sender == loans[loan].lend || msg.sender == address(funds));\n\t\tsechs[loan].sechA1 = bsechs[0];\n\t\tsechs[loan].sechAS = [ bsechs[1], bsechs[2], bsechs[3] ];\n\t\tsechs[loan].sechB1 = lsechs[0];\n\t\tsechs[loan].sechBS = [ lsechs[1], lsechs[2], lsechs[3] ];\n\t\tsechs[loan].sechC1 = asechs[0];\n\t\tsechs[loan].sechCS = [ asechs[1], asechs[2], asechs[3] ];\n\t\tloans[loan].bpubk  = bpubk_;\n\t\tloans[loan].lpubk  = lpubk_;\n        sechs[loan].set    = true;\n\t}\n\n\tfunction push(bytes32 loan) public { // Fund Loan\n\t\trequire(sechs[loan].set);\n    \trequire(bools[loan].pushed == false);\n    \trequire(tokes[loan].transferFrom(msg.sender, address(this), prin(loan)));\n    \tbools[loan].pushed = true;\n    }\n\n    function mark(bytes32 loan) public { // Mark Collateral as locked\n    \trequire(bools[loan].pushed == true);\n    \trequire(loans[loan].lend   == msg.sender);\n    \trequire(now                <= apex(loan));\n    \tbools[loan].marked = true;\n    }\n\n    function take(bytes32 loan, bytes32 secA1) public { // Withdraw\n    \trequire(!off(loan));\n    \trequire(bools[loan].pushed == true);\n    \trequire(bools[loan].marked == true);\n    \trequire(sha256(abi.encodePacked(secA1)) == sechs[loan].sechA1);\n    \trequire(tokes[loan].transfer(loans[loan].bor, prin(loan)));\n    \tbools[loan].taken = true;\n    }\n\n    function pay(bytes32 loan, uint256 amt) public { // Payback Loan\n        // require(msg.sender                == loans[loan].bor); // NOTE: this is not necessary. Anyone can pay off the loan\n    \trequire(!off(loan));\n        require(!sale(loan));\n    \trequire(bools[loan].taken         == true);\n    \trequire(now                       <= loans[loan].loex);\n    \trequire(add(amt, backs[loan])     <= owed(loan));\n\n    \trequire(tokes[loan].transferFrom(msg.sender, address(this), amt));\n    \tbacks[loan] = add(amt, backs[loan]);\n    \tif (backs[loan] == owed(loan)) {\n    \t\tbools[loan].paid = true;\n    \t}\n    }\n\n    function unpay(bytes32 loan) public { // Refund payback\n    \trequire(!off(loan));\n        require(!sale(loan));\n    \trequire(now              >  acex(loan));\n    \trequire(bools[loan].paid == true);\n    \trequire(msg.sender       == loans[loan].bor);\n        bools[loan].off = true;\n    \trequire(tokes[loan].transfer(loans[loan].bor, owed(loan)));\n    }\n\n    function pull(bytes32 loan, bytes32 sec) public {\n        pull(loan, sec, true); // Default to true for returning funds to Fund\n    }\n\n    function pull(bytes32 loan, bytes32 sec, bool fund) public { // Accept or Cancel // Bool fund set true if lender wants fund to return to fund\n        require(!off(loan));\n        require(bools[loan].taken == false || bools[loan].paid == true);\n        require(msg.sender == loans[loan].lend || msg.sender == loans[loan].agent);\n        require(sha256(abi.encodePacked(sec)) == sechs[loan].sechB1 || sha256(abi.encodePacked(sec)) == sechs[loan].sechC1);\n        require(now                             <= acex(loan));\n        require(bools[loan].sale                == false);\n        bools[loan].off = true;\n        if (bools[loan].taken == false) {\n            require(tokes[loan].transfer(loans[loan].lend, loans[loan].prin));\n        } else if (bools[loan].taken == true) {\n            if (fundi[loan] == bytes32(0) || !fund) {\n                require(tokes[loan].transfer(loans[loan].lend, lent(loan)));\n            } else {\n                funds.push(fundi[loan], lent(loan));\n            }\n            require(tokes[loan].transfer(loans[loan].agent, lfee(loan)));\n        }\n    }\n\n    function sechi(bytes32 loan, bytes32 usr) private view returns (bytes32 sech) { // Get Secret Hash for Sale Index\n    \tif      (usr == 'A') { sech = sechs[loan].sechAS[sales.next(loan)]; }\n    \telse if (usr == 'B') { sech = sechs[loan].sechBS[sales.next(loan)]; }\n    \telse if (usr == 'C') { sech = sechs[loan].sechCS[sales.next(loan)]; }\n    \telse revert();\n    }\n\n    function sell(bytes32 loan) public returns (bytes32 sale) { // Start Auction\n    \trequire(!off(loan));\n        require(bools[loan].taken  == true);\n    \tif (sales.next(loan) == 0) {\n    \t\tif (now > loans[loan].loex) {\n\t    \t\trequire(bools[loan].paid == false);\n\t\t\t} else {\n\t\t\t\trequire(!safe(loan));\n\t\t\t}\n\t\t} else {\n\t\t\trequire(sales.next(loan) < 3);\n\t\t\trequire(msg.sender == loans[loan].bor || msg.sender == loans[loan].lend);\n            require(now > sales.setex(sales.salel(loan, sales.next(loan) - 1))); // Can only start auction after settlement expiration of pervious auction\n            require(!sales.taken(sales.salel(loan, sales.next(loan) - 1))); // Can only start auction again if previous auction bid wasn't taken\n\t\t}\n\t\tsale = sales.open(loan, loans[loan].bor, loans[loan].lend, loans[loan].agent, sechi(loan, 'A'), sechi(loan, 'B'), sechi(loan, 'C'), tokes[loan]);\n        if (bools[loan].sale == false) { require(tokes[loan].transfer(address(sales), back(loan))); }\n\t\tbools[loan].sale = true;\n    }\n}\n\npragma solidity ^0.5.8;\n\ncontract Funds is DSMath {\n    Loans loans;\n\n    mapping (address => bytes32[]) public sechs;  // User secret hashes\n    mapping (address => uint256)   public sechi;  // User secret hash index\n\n    mapping (address => bytes)     public pubks;  // User A Coin PubKeys\n    \n    mapping (bytes32 => Fund)      public funds;  \n    uint256                        public fundi;\n\n    mapping (address => bool)      public tokas;  // Is ERC20 Token Approved\n\n    address own;\n\n    struct Fund {\n        address  lend;   // Loan Fund Owner (Lender)\n        uint256  mila;  // Min Loan Amount\n        uint256  mala;  // Max Loan Amount\n        uint256  mild;  // Min Loan Duration\n        uint256  mald;  // Max Loan Duration\n        uint256  lint;  // Interest Rate in RAY\n        uint256  lpen;  // Liquidation Penalty Rate in RAY\n        uint256  lfee;  // Optional Automation Fee in RAY\n        uint256  rat;   // Liquidation Ratio in RAY\n        address  agent; // Optional Automator Agent\n        uint256  bal;   // Locked amount in fund (in TOK)\n        ERC20    tok;   // Debt Token\n    }\n\n    constructor() public {\n        own = msg.sender;\n    }\n\n    function setLoans(address loans_) public {\n        require(msg.sender == own);\n        require(address(loans) == address(0));\n        loans = Loans(loans_);\n    }\n\n    function lend(bytes32 fund)   public view returns (address) {\n        return funds[fund].lend;\n    }\n\n    function mila(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mila;\n    }\n\n    function mala(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mala;\n    }\n\n    function mild(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mild;\n    }\n\n    function mald(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].mald;\n    }\n\n    function lint(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lint;\n    }\n\n    function lpen(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lpen;\n    }\n\n    function lfee(bytes32 fund)  public view returns (uint256) {\n        return funds[fund].lfee;\n    }\n\n    function rat(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].rat;\n    }\n\n    function agent(bytes32 fund) public view returns (address) {\n        return funds[fund].agent;\n    }\n\n    function bal(bytes32 fund)   public view returns (uint256) {\n        return funds[fund].bal;\n    }\n\n    function tok(bytes32 fund)   public view returns (address) {\n        return address(funds[fund].tok);\n    }\n\n    function open(\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  rat_,   // Liquidation Ratio\n        uint256  lint_,  // Interest Rate\n        uint256  lpen_,  // Liquidation Penalty Rate\n        uint256  lfee_,  // Optional Automation Fee Rate\n        address  agent_, // Optional Address Automated Agent\n        ERC20    tok_   // Debt Token\n    ) public returns (bytes32 fund) {\n        fundi = add(fundi, 1);\n        fund = bytes32(fundi);\n        funds[fund].lend  = msg.sender;\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].tok   = tok_;\n        funds[fund].agent = agent_;\n\n        if (tokas[address(tok_)] == false) {\n            require(tok_.approve(address(loans), 2**256-1));\n            tokas[address(tok_)] = true;\n        }\n    }\n\n    function push(bytes32 fund, uint256 amt) public { // Push funds to Loan Fund\n        // require(msg.sender == lend(fund) || msg.sender == address(loans)); // NOTE: this require is not necessary. Anyone can fund someone elses loan fund\n        funds[fund].bal = add(funds[fund].bal, amt);\n        require(funds[fund].tok.transferFrom(msg.sender, address(this), amt));\n    }\n\n    function gen(bytes32[] memory sechs_) public { // Generate secret hashes for Loan Fund\n        for (uint i = 0; i < sechs_.length; i++) {\n            sechs[msg.sender].push(sechs_[i]);\n        }\n    }\n\n    function set(bytes memory pubk) public { // Set PubKey for Fund\n        pubks[msg.sender] = pubk;\n    }\n\n    function set(        // Set Loan Fund details\n        bytes32  fund,   // Loan Fund Index\n        uint256  mila_,  // Min Loan Amount\n        uint256  mala_,  // Max Loan Amount\n        uint256  mild_,  // Min Loan Duration\n        uint256  mald_,  // Max Loan Duration\n        uint256  lint_,  // Interest Rate in RAY\n        uint256  lpen_,  // Liquidation Penalty Rate in RAY\n        uint256  lfee_,  // Optional Automation Fee in RAY\n        uint256  rat_,   // Liquidation Ratio in RAY\n        address  agent_  // Optional Automator Agent)\n    ) public {\n        require(msg.sender == lend(fund));\n        funds[fund].mila  = mila_;\n        funds[fund].mala  = mala_;\n        funds[fund].mild  = mild_;\n        funds[fund].mald  = mald_;\n        funds[fund].lint  = lint_;\n        funds[fund].lpen  = lpen_;\n        funds[fund].lfee  = lfee_;\n        funds[fund].rat   = rat_;\n        funds[fund].agent = agent_;\n    }\n\n    function req(                 // Request Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_,  // Loan Duration in seconds\n        bytes32[4] memory sechs_, // Secret Hash A1 & A2\n        bytes      memory pubk_   // Pubkey\n    ) public returns (bytes32 loani) {\n        require(msg.sender != lend(fund));\n        require(amt_       <= bal(fund));\n        require(amt_       >= mila(fund));\n        require(amt_       <= mala(fund));\n        require(lodu_      >= mild(fund));\n        require(lodu_      <= mald(fund));\n\n        loani = lopen(fund, amt_, col_, lodu_);\n        lsech(fund, loani, sechs_, pubk_);\n        loans.push(loani);\n    }\n\n    function pull(bytes32 fund, uint256 amt) public { // Pull funds from Loan Fund\n        require(msg.sender == lend(fund));\n        require(bal(fund)  >= amt);\n        funds[fund].bal = sub(funds[fund].bal, amt);\n        require(funds[fund].tok.transfer(lend(fund), amt));\n    }\n\n    function calc(uint256 amt, uint256 rate, uint256 lodu) public pure returns (uint256) { // Calculate interest\n        return sub(rmul(amt, rpow(rate, lodu)), amt);\n    }\n\n    function lopen(               // Private Open Loan\n        bytes32           fund,   // Fund Index\n        uint256           amt_,   // Loan Amount\n        uint256           col_,   // Collateral Amount in satoshis\n        uint256           lodu_   // Loan Duration in seconds\n    ) private returns (bytes32 loani) {\n        loani = loans.open(\n            now + lodu_,\n            [ msg.sender, lend(fund), funds[fund].agent],\n            [ amt_, calc(amt_, lint(fund), lodu_), calc(amt_, lpen(fund), lodu_), calc(amt_, lfee(fund), lodu_), col_, funds[fund].rat],\n            funds[fund].tok,\n            fund\n        );\n    }\n\n    function lsech(                // Loan Set Secret Hashes\n        bytes32 fund,              // Fund Index\n        bytes32 loan,              // Loan Index\n        bytes32[4] memory sechs_,  // 4 Secret Hashes\n        bytes memory pubk_         // Public Key\n    ) private { // Loan set Secret Hash and PubKey\n        loans.setSechs(\n            loan,\n            sechs_,\n            gsech(lend(fund)),\n            gsech(agent(fund)),\n            pubk_,\n            pubks[lend(fund)]\n        );\n    }\n\n    function gsech(address addr) private returns (bytes32[4] memory) { // Get 4 secrethashes for loan\n        sechi[addr] = add(sechi[addr], 4);\n        return [ sechs[addr][sub(sechi[addr], 4)], sechs[addr][sub(sechi[addr], 3)], sechs[addr][sub(sechi[addr], 2)], sechs[addr][sub(sechi[addr], 1)] ];\n    }\n}\n", "commit_id": "ea8ccc82d0fd97ec626590463bc8e5efbd224036"}}