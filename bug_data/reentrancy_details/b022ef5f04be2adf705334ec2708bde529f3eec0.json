{"filename": "packages/contracts/contracts/Purchase.sol", "patch": "@@ -93,10 +93,12 @@ contract Purchase {\n   isSeller\n   atStage(Stages.SELLER_PENDING)\n   {\n+    stage = Stages.COMPLETE;\n+\n     // Send contract funds to seller (ie owner of Listing)\n+    // Transfering money always needs to be the last thing we do, do avoid\n+    // rentrancy bugs. (Though here the seller would just be getting their own money)\n     listingContract.owner().transfer(this.balance);\n-\n-      stage = Stages.COMPLETE;\n   }\n \n ", "project_link": "https://github.com/tyleryasaka/platform/commit/b022ef5f04be2adf705334ec2708bde529f3eec0", "bug_version": {"raw_code": "pragma solidity ^0.4.11;\n\n/// @title Purchase\n/// @dev An purchase Origin Listing representing a purchase/booking\nimport \"./Listing.sol\";\n\ncontract Purchase {\n\n  enum Stages {\n    AWAITING_PAYMENT, // Buyer hasn't paid full amount yet\n    BUYER_PENDING, // Waiting for buyer to confirm receipt\n    SELLER_PENDING, // Waiting for seller to confirm all is good\n    IN_DISPUTE, // We are in a dispute\n    REVIEW_PERIOD, // Time for reviews (only when transaction did not go through)\n    COMPLETE // It's all over\n  }\n\n  /*\n  * Storage\n  */\n\n  Stages public stage = Stages.AWAITING_PAYMENT;\n\n  Listing listingContract; // listing that is being purchased\n  address public buyer; // User who is buying. Seller is derived from listing\n  uint created;\n\n  /*\n  * Modifiers\n  */\n\n  modifier isSeller() {\n    require (msg.sender == listingContract.owner());\n    _;\n  }\n\n  modifier isBuyer() {\n    require (msg.sender == buyer);\n    _;\n  }\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage);\n    _;\n  }\n\n  /*\n  * Public functions\n  */\n\n  function Purchase(\n    address _listingContractAddress,\n    address _buyer\n  )\n  public\n  {\n    buyer = _buyer;\n    listingContract = Listing(_listingContractAddress);\n    created = now;\n  }\n\n  // Pay for listing\n  // We used to limit this to buyer, but that prevents Listing contract from\n  // paying\n  function pay()\n  public\n  payable\n  atStage(Stages.AWAITING_PAYMENT)\n  {\n    if (this.balance >= listingContract.price()) {\n      // Buyer (or their proxy) has paid enough to cover purchase\n      stage = Stages.BUYER_PENDING;\n\n      // Mark item as no longer available for sale in Listing\n      // TODO: presumably we call function on Listing(), proving that we have\n      // the funds to cover purchase.\n    }\n    // Possible that nothing happens, and contract just accumulates sent value\n  }\n\n\n  function buyerConfirmReceipt()\n  isBuyer\n  public\n  atStage(Stages.BUYER_PENDING)\n  {\n      stage = Stages.SELLER_PENDING;\n  }\n\n\n  function sellerGetPayout()\n  public\n  isSeller\n  atStage(Stages.SELLER_PENDING)\n  {\n    // Send contract funds to seller (ie owner of Listing)\n    listingContract.owner().transfer(this.balance);\n\n      stage = Stages.COMPLETE;\n  }\n\n\n  function openDispute()\n  public\n  {\n    // Must be buyer or seller\n    require (\n      (msg.sender == buyer) ||\n      (msg.sender == listingContract.owner())\n    );\n\n    // Must be in a valid stage\n    require(\n      (stage == Stages.BUYER_PENDING) ||\n      (stage == Stages.SELLER_PENDING)\n    );\n\n    stage = Stages.IN_DISPUTE;\n\n    // TODO: Create a dispute contract?\n    // Right now there's no way to exit this state.\n  }\n}\n\n", "flattened_code": "pragma solidity ^0.4.11;\n\n/// @title Purchase\n/// @dev An purchase Origin Listing representing a purchase/booking\npragma solidity ^0.4.11;\n\n/// @title Listing\n/// @dev An indiviual Origin Listing representing an offer for booking/purchase\n\npragma solidity ^0.4.11;\n\n/// @title Purchase\n/// @dev An purchase Origin Listing representing a purchase/booking\n\ncontract Purchase {\n\n  enum Stages {\n    AWAITING_PAYMENT, // Buyer hasn't paid full amount yet\n    BUYER_PENDING, // Waiting for buyer to confirm receipt\n    SELLER_PENDING, // Waiting for seller to confirm all is good\n    IN_DISPUTE, // We are in a dispute\n    REVIEW_PERIOD, // Time for reviews (only when transaction did not go through)\n    COMPLETE // It's all over\n  }\n\n  /*\n  * Storage\n  */\n\n  Stages public stage = Stages.AWAITING_PAYMENT;\n\n  Listing listingContract; // listing that is being purchased\n  address public buyer; // User who is buying. Seller is derived from listing\n  uint created;\n\n  /*\n  * Modifiers\n  */\n\n  modifier isSeller() {\n    require (msg.sender == listingContract.owner());\n    _;\n  }\n\n  modifier isBuyer() {\n    require (msg.sender == buyer);\n    _;\n  }\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage);\n    _;\n  }\n\n  /*\n  * Public functions\n  */\n\n  function Purchase(\n    address _listingContractAddress,\n    address _buyer\n  )\n  public\n  {\n    buyer = _buyer;\n    listingContract = Listing(_listingContractAddress);\n    created = now;\n  }\n\n  // Pay for listing\n  // We used to limit this to buyer, but that prevents Listing contract from\n  // paying\n  function pay()\n  public\n  payable\n  atStage(Stages.AWAITING_PAYMENT)\n  {\n    if (this.balance >= listingContract.price()) {\n      // Buyer (or their proxy) has paid enough to cover purchase\n      stage = Stages.BUYER_PENDING;\n\n      // Mark item as no longer available for sale in Listing\n      // TODO: presumably we call function on Listing(), proving that we have\n      // the funds to cover purchase.\n    }\n    // Possible that nothing happens, and contract just accumulates sent value\n  }\n\n\n  function buyerConfirmReceipt()\n  isBuyer\n  public\n  atStage(Stages.BUYER_PENDING)\n  {\n      stage = Stages.SELLER_PENDING;\n  }\n\n\n  function sellerGetPayout()\n  public\n  isSeller\n  atStage(Stages.SELLER_PENDING)\n  {\n    // Send contract funds to seller (ie owner of Listing)\n    listingContract.owner().transfer(this.balance);\n\n      stage = Stages.COMPLETE;\n  }\n\n\n  function openDispute()\n  public\n  {\n    // Must be buyer or seller\n    require (\n      (msg.sender == buyer) ||\n      (msg.sender == listingContract.owner())\n    );\n\n    // Must be in a valid stage\n    require(\n      (stage == Stages.BUYER_PENDING) ||\n      (stage == Stages.SELLER_PENDING)\n    );\n\n    stage = Stages.IN_DISPUTE;\n\n    // TODO: Create a dispute contract?\n    // Right now there's no way to exit this state.\n  }\n}\n\n\ncontract Listing {\n\n  /*\n   * Events\n   */\n\n  event ListingPurchased(Purchase _purchaseContract);\n\n    /*\n    * Storage\n    */\n\n    address public owner;\n    address public listingRegistry; // TODO: Define interface for real ListingRegistry ?\n    // Assume IPFS defaults for hash: function:0x12=sha2, size:0x20=256 bits\n    // See: https://ethereum.stackexchange.com/a/17112/20332\n    // This assumption may have to change in future, but saves space now\n    bytes32 public ipfsHash;\n    uint public price;\n    uint public unitsAvailable;\n\n\n    function Listing (\n      address _owner,\n      bytes32 _ipfsHash,\n      uint _price,\n      uint _unitsAvailable\n    )\n    public\n    {\n      owner = _owner;\n      listingRegistry = msg.sender; // ListingRegistry(msg.sender);\n      ipfsHash = _ipfsHash;\n      price = _price;\n      unitsAvailable = _unitsAvailable;\n    }\n\n\n  /// @dev buyListing(): Buy a listing\n  /// @param _unitsToBuy Number of units to buy\n  function buyListing(uint _unitsToBuy)\n    public\n    payable\n  {\n    // TODO: Handle units. For now we just do one at a time\n    require (_unitsToBuy == 1); // HACK\n\n    // Create purchase contract\n    Purchase purchaseContract = new Purchase(this, msg.sender);\n\n    // Count units as sold\n    unitsAvailable -= _unitsToBuy;\n\n    // TODO STAN: How to call function *AND* transfer value??\n    purchaseContract.pay.value(msg.value)();\n\n    ListingPurchased(purchaseContract);\n  }\n\n}\n\ncontract Purchase {\n\n  enum Stages {\n    AWAITING_PAYMENT, // Buyer hasn't paid full amount yet\n    BUYER_PENDING, // Waiting for buyer to confirm receipt\n    SELLER_PENDING, // Waiting for seller to confirm all is good\n    IN_DISPUTE, // We are in a dispute\n    REVIEW_PERIOD, // Time for reviews (only when transaction did not go through)\n    COMPLETE // It's all over\n  }\n\n  /*\n  * Storage\n  */\n\n  Stages public stage = Stages.AWAITING_PAYMENT;\n\n  Listing listingContract; // listing that is being purchased\n  address public buyer; // User who is buying. Seller is derived from listing\n  uint created;\n\n  /*\n  * Modifiers\n  */\n\n  modifier isSeller() {\n    require (msg.sender == listingContract.owner());\n    _;\n  }\n\n  modifier isBuyer() {\n    require (msg.sender == buyer);\n    _;\n  }\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage);\n    _;\n  }\n\n  /*\n  * Public functions\n  */\n\n  function Purchase(\n    address _listingContractAddress,\n    address _buyer\n  )\n  public\n  {\n    buyer = _buyer;\n    listingContract = Listing(_listingContractAddress);\n    created = now;\n  }\n\n  // Pay for listing\n  // We used to limit this to buyer, but that prevents Listing contract from\n  // paying\n  function pay()\n  public\n  payable\n  atStage(Stages.AWAITING_PAYMENT)\n  {\n    if (this.balance >= listingContract.price()) {\n      // Buyer (or their proxy) has paid enough to cover purchase\n      stage = Stages.BUYER_PENDING;\n\n      // Mark item as no longer available for sale in Listing\n      // TODO: presumably we call function on Listing(), proving that we have\n      // the funds to cover purchase.\n    }\n    // Possible that nothing happens, and contract just accumulates sent value\n  }\n\n\n  function buyerConfirmReceipt()\n  isBuyer\n  public\n  atStage(Stages.BUYER_PENDING)\n  {\n      stage = Stages.SELLER_PENDING;\n  }\n\n\n  function sellerGetPayout()\n  public\n  isSeller\n  atStage(Stages.SELLER_PENDING)\n  {\n    // Send contract funds to seller (ie owner of Listing)\n    listingContract.owner().transfer(this.balance);\n\n      stage = Stages.COMPLETE;\n  }\n\n\n  function openDispute()\n  public\n  {\n    // Must be buyer or seller\n    require (\n      (msg.sender == buyer) ||\n      (msg.sender == listingContract.owner())\n    );\n\n    // Must be in a valid stage\n    require(\n      (stage == Stages.BUYER_PENDING) ||\n      (stage == Stages.SELLER_PENDING)\n    );\n\n    stage = Stages.IN_DISPUTE;\n\n    // TODO: Create a dispute contract?\n    // Right now there's no way to exit this state.\n  }\n}\n\n", "commit_id": "e4c55c32f7021401788baedcfbece160431bf4f7"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.11;\n\n/// @title Purchase\n/// @dev An purchase Origin Listing representing a purchase/booking\nimport \"./Listing.sol\";\n\ncontract Purchase {\n\n  enum Stages {\n    AWAITING_PAYMENT, // Buyer hasn't paid full amount yet\n    BUYER_PENDING, // Waiting for buyer to confirm receipt\n    SELLER_PENDING, // Waiting for seller to confirm all is good\n    IN_DISPUTE, // We are in a dispute\n    REVIEW_PERIOD, // Time for reviews (only when transaction did not go through)\n    COMPLETE // It's all over\n  }\n\n  /*\n  * Storage\n  */\n\n  Stages public stage = Stages.AWAITING_PAYMENT;\n\n  Listing listingContract; // listing that is being purchased\n  address public buyer; // User who is buying. Seller is derived from listing\n  uint created;\n\n  /*\n  * Modifiers\n  */\n\n  modifier isSeller() {\n    require (msg.sender == listingContract.owner());\n    _;\n  }\n\n  modifier isBuyer() {\n    require (msg.sender == buyer);\n    _;\n  }\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage);\n    _;\n  }\n\n  /*\n  * Public functions\n  */\n\n  function Purchase(\n    address _listingContractAddress,\n    address _buyer\n  )\n  public\n  {\n    buyer = _buyer;\n    listingContract = Listing(_listingContractAddress);\n    created = now;\n  }\n\n  // Pay for listing\n  // We used to limit this to buyer, but that prevents Listing contract from\n  // paying\n  function pay()\n  public\n  payable\n  atStage(Stages.AWAITING_PAYMENT)\n  {\n    if (this.balance >= listingContract.price()) {\n      // Buyer (or their proxy) has paid enough to cover purchase\n      stage = Stages.BUYER_PENDING;\n\n      // Mark item as no longer available for sale in Listing\n      // TODO: presumably we call function on Listing(), proving that we have\n      // the funds to cover purchase.\n    }\n    // Possible that nothing happens, and contract just accumulates sent value\n  }\n\n\n  function buyerConfirmReceipt()\n  isBuyer\n  public\n  atStage(Stages.BUYER_PENDING)\n  {\n      stage = Stages.SELLER_PENDING;\n  }\n\n\n  function sellerGetPayout()\n  public\n  isSeller\n  atStage(Stages.SELLER_PENDING)\n  {\n    stage = Stages.COMPLETE;\n\n    // Send contract funds to seller (ie owner of Listing)\n    // Transfering money always needs to be the last thing we do, do avoid\n    // rentrancy bugs. (Though here the seller would just be getting their own money)\n    listingContract.owner().transfer(this.balance);\n  }\n\n\n  function openDispute()\n  public\n  {\n    // Must be buyer or seller\n    require (\n      (msg.sender == buyer) ||\n      (msg.sender == listingContract.owner())\n    );\n\n    // Must be in a valid stage\n    require(\n      (stage == Stages.BUYER_PENDING) ||\n      (stage == Stages.SELLER_PENDING)\n    );\n\n    stage = Stages.IN_DISPUTE;\n\n    // TODO: Create a dispute contract?\n    // Right now there's no way to exit this state.\n  }\n}\n\n", "flattened_code": "pragma solidity ^0.4.11;\n\n/// @title Purchase\n/// @dev An purchase Origin Listing representing a purchase/booking\npragma solidity ^0.4.11;\n\n/// @title Listing\n/// @dev An indiviual Origin Listing representing an offer for booking/purchase\n\npragma solidity ^0.4.11;\n\n/// @title Purchase\n/// @dev An purchase Origin Listing representing a purchase/booking\n\ncontract Purchase {\n\n  enum Stages {\n    AWAITING_PAYMENT, // Buyer hasn't paid full amount yet\n    BUYER_PENDING, // Waiting for buyer to confirm receipt\n    SELLER_PENDING, // Waiting for seller to confirm all is good\n    IN_DISPUTE, // We are in a dispute\n    REVIEW_PERIOD, // Time for reviews (only when transaction did not go through)\n    COMPLETE // It's all over\n  }\n\n  /*\n  * Storage\n  */\n\n  Stages public stage = Stages.AWAITING_PAYMENT;\n\n  Listing listingContract; // listing that is being purchased\n  address public buyer; // User who is buying. Seller is derived from listing\n  uint created;\n\n  /*\n  * Modifiers\n  */\n\n  modifier isSeller() {\n    require (msg.sender == listingContract.owner());\n    _;\n  }\n\n  modifier isBuyer() {\n    require (msg.sender == buyer);\n    _;\n  }\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage);\n    _;\n  }\n\n  /*\n  * Public functions\n  */\n\n  function Purchase(\n    address _listingContractAddress,\n    address _buyer\n  )\n  public\n  {\n    buyer = _buyer;\n    listingContract = Listing(_listingContractAddress);\n    created = now;\n  }\n\n  // Pay for listing\n  // We used to limit this to buyer, but that prevents Listing contract from\n  // paying\n  function pay()\n  public\n  payable\n  atStage(Stages.AWAITING_PAYMENT)\n  {\n    if (this.balance >= listingContract.price()) {\n      // Buyer (or their proxy) has paid enough to cover purchase\n      stage = Stages.BUYER_PENDING;\n\n      // Mark item as no longer available for sale in Listing\n      // TODO: presumably we call function on Listing(), proving that we have\n      // the funds to cover purchase.\n    }\n    // Possible that nothing happens, and contract just accumulates sent value\n  }\n\n\n  function buyerConfirmReceipt()\n  isBuyer\n  public\n  atStage(Stages.BUYER_PENDING)\n  {\n      stage = Stages.SELLER_PENDING;\n  }\n\n\n  function sellerGetPayout()\n  public\n  isSeller\n  atStage(Stages.SELLER_PENDING)\n  {\n    stage = Stages.COMPLETE;\n\n    // Send contract funds to seller (ie owner of Listing)\n    // Transfering money always needs to be the last thing we do, do avoid\n    // rentrancy bugs. (Though here the seller would just be getting their own money)\n    listingContract.owner().transfer(this.balance);\n  }\n\n\n  function openDispute()\n  public\n  {\n    // Must be buyer or seller\n    require (\n      (msg.sender == buyer) ||\n      (msg.sender == listingContract.owner())\n    );\n\n    // Must be in a valid stage\n    require(\n      (stage == Stages.BUYER_PENDING) ||\n      (stage == Stages.SELLER_PENDING)\n    );\n\n    stage = Stages.IN_DISPUTE;\n\n    // TODO: Create a dispute contract?\n    // Right now there's no way to exit this state.\n  }\n}\n\n\ncontract Listing {\n\n  /*\n   * Events\n   */\n\n  event ListingPurchased(Purchase _purchaseContract);\n\n    /*\n    * Storage\n    */\n\n    address public owner;\n    address public listingRegistry; // TODO: Define interface for real ListingRegistry ?\n    // Assume IPFS defaults for hash: function:0x12=sha2, size:0x20=256 bits\n    // See: https://ethereum.stackexchange.com/a/17112/20332\n    // This assumption may have to change in future, but saves space now\n    bytes32 public ipfsHash;\n    uint public price;\n    uint public unitsAvailable;\n\n\n    function Listing (\n      address _owner,\n      bytes32 _ipfsHash,\n      uint _price,\n      uint _unitsAvailable\n    )\n    public\n    {\n      owner = _owner;\n      listingRegistry = msg.sender; // ListingRegistry(msg.sender);\n      ipfsHash = _ipfsHash;\n      price = _price;\n      unitsAvailable = _unitsAvailable;\n    }\n\n\n  /// @dev buyListing(): Buy a listing\n  /// @param _unitsToBuy Number of units to buy\n  function buyListing(uint _unitsToBuy)\n    public\n    payable\n  {\n    // TODO: Handle units. For now we just do one at a time\n    require (_unitsToBuy == 1); // HACK\n\n    // Create purchase contract\n    Purchase purchaseContract = new Purchase(this, msg.sender);\n\n    // Count units as sold\n    unitsAvailable -= _unitsToBuy;\n\n    // TODO STAN: How to call function *AND* transfer value??\n    purchaseContract.pay.value(msg.value)();\n\n    ListingPurchased(purchaseContract);\n  }\n\n}\n\ncontract Purchase {\n\n  enum Stages {\n    AWAITING_PAYMENT, // Buyer hasn't paid full amount yet\n    BUYER_PENDING, // Waiting for buyer to confirm receipt\n    SELLER_PENDING, // Waiting for seller to confirm all is good\n    IN_DISPUTE, // We are in a dispute\n    REVIEW_PERIOD, // Time for reviews (only when transaction did not go through)\n    COMPLETE // It's all over\n  }\n\n  /*\n  * Storage\n  */\n\n  Stages public stage = Stages.AWAITING_PAYMENT;\n\n  Listing listingContract; // listing that is being purchased\n  address public buyer; // User who is buying. Seller is derived from listing\n  uint created;\n\n  /*\n  * Modifiers\n  */\n\n  modifier isSeller() {\n    require (msg.sender == listingContract.owner());\n    _;\n  }\n\n  modifier isBuyer() {\n    require (msg.sender == buyer);\n    _;\n  }\n\n  modifier atStage(Stages _stage) {\n    require(stage == _stage);\n    _;\n  }\n\n  /*\n  * Public functions\n  */\n\n  function Purchase(\n    address _listingContractAddress,\n    address _buyer\n  )\n  public\n  {\n    buyer = _buyer;\n    listingContract = Listing(_listingContractAddress);\n    created = now;\n  }\n\n  // Pay for listing\n  // We used to limit this to buyer, but that prevents Listing contract from\n  // paying\n  function pay()\n  public\n  payable\n  atStage(Stages.AWAITING_PAYMENT)\n  {\n    if (this.balance >= listingContract.price()) {\n      // Buyer (or their proxy) has paid enough to cover purchase\n      stage = Stages.BUYER_PENDING;\n\n      // Mark item as no longer available for sale in Listing\n      // TODO: presumably we call function on Listing(), proving that we have\n      // the funds to cover purchase.\n    }\n    // Possible that nothing happens, and contract just accumulates sent value\n  }\n\n\n  function buyerConfirmReceipt()\n  isBuyer\n  public\n  atStage(Stages.BUYER_PENDING)\n  {\n      stage = Stages.SELLER_PENDING;\n  }\n\n\n  function sellerGetPayout()\n  public\n  isSeller\n  atStage(Stages.SELLER_PENDING)\n  {\n    stage = Stages.COMPLETE;\n\n    // Send contract funds to seller (ie owner of Listing)\n    // Transfering money always needs to be the last thing we do, do avoid\n    // rentrancy bugs. (Though here the seller would just be getting their own money)\n    listingContract.owner().transfer(this.balance);\n  }\n\n\n  function openDispute()\n  public\n  {\n    // Must be buyer or seller\n    require (\n      (msg.sender == buyer) ||\n      (msg.sender == listingContract.owner())\n    );\n\n    // Must be in a valid stage\n    require(\n      (stage == Stages.BUYER_PENDING) ||\n      (stage == Stages.SELLER_PENDING)\n    );\n\n    stage = Stages.IN_DISPUTE;\n\n    // TODO: Create a dispute contract?\n    // Right now there's no way to exit this state.\n  }\n}\n\n", "commit_id": "b022ef5f04be2adf705334ec2708bde529f3eec0"}}