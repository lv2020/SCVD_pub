{"filename": "contracts/abstracts/LendingContract.sol", "patch": "@@ -256,10 +256,10 @@ abstract contract LendingContract is LendingSetter {\n                 );\n         }\n \n-        doTransferOut(user, vars.withdrawAmount, method);\n-\n         _lToken.burn(user, vars.withdrawTokens);\n \n+        doTransferOut(user, vars.withdrawAmount, method);\n+\n         emit Withdraw(user, vars.withdrawAmount, vars.withdrawTokens);\n \n         return uint256(Error.NO_ERROR);\n@@ -361,12 +361,12 @@ abstract contract LendingContract is LendingSetter {\n                 );\n         }\n \n-        doTransferOut(borrower, borrowAmount, method);\n-\n         accountBorrows[borrower].principal = vars.accountBorrowsNew;\n         accountBorrows[borrower].interestIndex = borrowIndex;\n         totalBorrows = vars.totalBorrowsNew;\n \n+        doTransferOut(borrower, borrowAmount, method);\n+\n         emit Borrow(\n             borrower,\n             borrowAmount,", "project_link": "https://github.com/Finstable/yuemmai-contract/commit/37b3d41aa783c3aa5fb6149d8355e0ff66f4f7be", "bug_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../LToken.sol\";\nimport \"./LendingSetter.sol\";\nimport \"../interfaces/IYESVault.sol\";\nimport \"../modules/kyc/KYCHandler.sol\";\nimport \"../modules/kyc/interfaces/IKYCBitkubChain.sol\";\nimport \"../modules/committee/Committee.sol\";\n\nabstract contract LendingContract is LendingSetter {\n    constructor(ConstructorArgs memory args)\n        SuperAdmin(args.superAdmin)\n        BKNextCallHelper(args.callHelper)\n    {\n        require(args.initialExchangeRateMantissa > 0, \"Invalid exchange rate\");\n        initialExchangeRateMantissa = args.initialExchangeRateMantissa;\n\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        uint256 err1 = _setControllerFresh(args.controller);\n        require(err1 == uint256(Error.NO_ERROR), \"Controller failed\");\n\n        uint256 err2 = _setInterestRateModelFresh(args.interestRateModel);\n        require(err2 == uint256(Error.NO_ERROR), \"Interest model failed\");\n\n        uint256 err3 = _setBeneficiaryFresh(args.beneficiary);\n        require(err3 == uint256(Error.NO_ERROR), \"Beneficiary failed\");\n\n        uint256 err4 = _setReservePoolFresh(args.poolReserve);\n        require(err4 == uint256(Error.NO_ERROR), \"Reserve pool failed\");\n\n        _transferRouter = INextTransferRouter(args.transferRouter);\n\n        underlyingToken = args.underlyingToken;\n        committee = args.committee;\n        IKAP20(underlyingToken).totalSupply();\n\n        _lToken = new LToken(\n            args.lTokenName,\n            args.lTokenSymbol,\n            args.lTokenDecimals,\n            args.kyc,\n            args.adminRouter,\n            args.committee,\n            args.transferRouter,\n            args.acceptedKYCLevel\n        );\n    }\n\n    function depositInternal(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(Error(error), FailureInfo.DEPOSIT_ACCRUE_INTEREST_FAILED),\n                0\n            );\n        }\n        return depositFresh(user, depositAmount, method);\n    }\n\n    struct DepositLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualDepositAmount;\n    }\n\n    function depositFresh(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.depositAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.DEPOSIT_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.DEPOSIT_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        DepositLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.DEPOSIT_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        vars.actualDepositAmount = doTransferIn(user, depositAmount, method);\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualDepositAmount,\n            Exp({mantissa: vars.exchangeRateMantissa})\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Exchange calculate failed\"\n        );\n\n        _lToken.mint(user, vars.mintTokens);\n\n        emit Deposit(user, vars.actualDepositAmount, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualDepositAmount);\n    }\n\n    function withdrawInternal(\n        address payable user,\n        uint256 withdrawTokens,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, withdrawTokens, 0, method);\n    }\n\n    function withdrawUnderlyingInternal(\n        address payable user,\n        uint256 withdrawAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, 0, withdrawAmount, method);\n    }\n\n    struct WithdrawLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 withdrawTokens;\n        uint256 withdrawAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    function withdrawFresh(\n        address payable user,\n        uint256 withdrawTokensIn,\n        uint256 withdrawAmountIn,\n        TransferMethod method\n    ) internal returns (uint256) {\n        require(\n            withdrawTokensIn == 0 || withdrawAmountIn == 0,\n            \"Must have a zero input\"\n        );\n\n        WithdrawLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.WITHDRAW_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        if (withdrawTokensIn > 0) {\n            vars.withdrawTokens = withdrawTokensIn;\n\n            (vars.mathErr, vars.withdrawAmount) = mulScalarTruncate(\n                Exp({mantissa: vars.exchangeRateMantissa}),\n                withdrawTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            (vars.mathErr, vars.withdrawTokens) = divScalarByExpTruncate(\n                withdrawAmountIn,\n                Exp({mantissa: vars.exchangeRateMantissa})\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.withdrawAmount = withdrawAmountIn;\n        }\n\n        uint256 allowed = _controller.withdrawAllowed(address(this), user);\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.WITHDRAW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < vars.withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n                );\n        }\n\n        doTransferOut(user, vars.withdrawAmount, method);\n\n        _lToken.burn(user, vars.withdrawTokens);\n\n        emit Withdraw(user, vars.withdrawAmount, vars.withdrawTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function borrowInternal(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        return borrowFresh(borrower, borrowAmount, method);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    function borrowFresh(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal returns (uint256) {\n        uint256 allowed = _controller.borrowAllowed(\n            address(this),\n            borrower,\n            borrowAmount\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.BORROW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.BORROW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < borrowAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.BORROW_CASH_NOT_AVAILABLE\n                );\n        }\n\n        BorrowLocalVars memory vars;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\n            vars.accountBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\n            totalBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        doTransferOut(borrower, borrowAmount, method);\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        emit Borrow(\n            borrower,\n            borrowAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function repayBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(borrower, borrower, repayAmount, method);\n    }\n\n    function repayBorrowBehalfInternal(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(payer, borrower, repayAmount, method);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.repayBorrowAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.REPAY_BORROW_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REPAY_BORROW_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > vars.accountBorrows) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > totalBorrows) {\n            vars.repayAmount = totalBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        if (payer != address(this)) {\n            vars.actualRepayAmount = doTransferIn(\n                payer,\n                vars.repayAmount,\n                method\n            );\n        } else {\n            vars.actualRepayAmount = vars.repayAmount;\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\n            vars.accountBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Account borrow update failed\"\n        );\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\n            totalBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Total borrow update failed\"\n        );\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        emit RepayBorrow(\n            payer,\n            borrower,\n            vars.actualRepayAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    function liquidateBorrowInternal(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        return\n            liquidateBorrowFresh(\n                liquidator,\n                borrower,\n                input,\n                minReward,\n                deadline,\n                method\n            );\n    }\n\n    struct LiquidateBorrowLocalVars {\n        MathError mErr;\n        uint256 err;\n        uint256 allowed;\n        uint256 borrowBalance;\n        uint256 seizeTokens;\n        uint256 sellOutput;\n        uint256 actualInput;\n        uint256 actualRepayAmount;\n        uint256 transferOutput;\n        uint256 reward;\n    }\n\n    function liquidateBorrowFresh(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        LiquidateBorrowLocalVars memory vars;\n        vars.allowed = _controller.liquidateBorrowAllowed(\n            address(this),\n            borrower\n        );\n        if (vars.allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_CONTROLLER_REJECTION,\n                    vars.allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        if (borrower == liquidator) {\n            return (\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\n                ),\n                0\n            );\n        }\n\n        (vars.mErr, vars.borrowBalance) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (\n                fail(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_BORROW_BALANCE_ERROR\n                ),\n                0\n            );\n        }\n\n        (vars.err, vars.seizeTokens) = _controller\n            .liquidateCalculateSeizeTokens(address(this), vars.borrowBalance);\n\n        require(\n            vars.err == uint256(Error.NO_ERROR),\n            \"Calculate seize amount failed\"\n        );\n\n        IYESVault yesVault = IYESVault(_controller.yesVault());\n        vars.sellOutput = yesVault.sellMarket(\n            borrower,\n            vars.seizeTokens,\n            deadline\n        );\n        vars.actualInput = doTransferIn(liquidator, input, method);\n\n        (vars.err, vars.actualRepayAmount) = repayBorrowFresh(\n            address(this),\n            borrower,\n            vars.borrowBalance,\n            TransferMethod.METAMASK\n        );\n\n        if (vars.err != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(vars.err),\n                    FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n                ),\n                0\n            );\n        }\n\n        vars.transferOutput =\n            (vars.sellOutput + vars.actualInput) -\n            vars.actualRepayAmount;\n        vars.reward = vars.transferOutput - vars.actualInput;\n        require(vars.reward >= minReward, \"Too low reward\");\n\n        doTransferOut(liquidator, vars.transferOutput, method);\n\n        emit LiquidateBorrow(\n            liquidator,\n            borrower,\n            vars.actualRepayAmount,\n            vars.seizeTokens\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /*** Fresh getters ***/\n\n    function exchangeRateCurrent()\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return exchangeRateStored();\n    }\n\n    function borrowBalanceCurrent(address account)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return borrowBalanceStored(account);\n    }\n\n    function totalBorrowsCurrent()\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return totalBorrows;\n    }\n\n    function balanceOfUnderlying(address owner)\n        external\n        override\n        returns (uint256)\n    {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint256 balance) = mulScalarTruncate(\n            exchangeRate,\n            _lToken.balanceOf(owner)\n        );\n        require(mErr == MathError.NO_ERROR, \"Math error\");\n        return balance;\n    }\n\n    /*** Protocol functions ***/\n\n    function _claimPlatformReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == beneficiary, \"Only beneficiary\");\n        uint256 platformReservesNew;\n\n        if (beneficiary == address(0)) {\n            return\n                fail(\n                    Error.INVALID_BENEFICIARY,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_INVALID_BENEFICIARY\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > platformReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_VALIDATION\n                );\n        }\n\n        platformReservesNew = platformReserves - claimedAmount;\n        require(platformReservesNew <= platformReserves, \"Overflow\");\n\n        platformReserves = platformReservesNew;\n\n        doTransferOut(beneficiary, claimedAmount, TransferMethod.METAMASK);\n\n        emit PlatformReservesClaimed(\n            beneficiary,\n            claimedAmount,\n            platformReservesNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _claimPoolReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == reservePool, \"Only reserve pool\");\n        uint256 poolReservesNew;\n\n        if (reservePool == address(0)) {\n            return\n                fail(\n                    Error.INVALID_RESERVE_POOL,\n                    FailureInfo.CLAIM_POOL_RESERVES_INVALID_RESERVE_POOL\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_POOL_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > poolReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_POOL_RESERVES_VALIDATION\n                );\n        }\n\n        poolReservesNew = poolReserves - claimedAmount;\n        require(poolReservesNew <= poolReserves, \"Overflow\");\n\n        poolReserves = poolReservesNew;\n\n        doTransferOut(reservePool, claimedAmount, TransferMethod.METAMASK);\n\n        emit PoolReservesClaimed(reservePool, claimedAmount, poolReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** BK Next helpers ***/\n    function requireKYC(address sender) internal view {\n        IKYCBitkubChain kyc = _lToken.kyc();\n        require(\n            kyc.kycsLevel(sender) >= _lToken.acceptedKYCLevel(),\n            \"only Bitkub Next user\"\n        );\n    }\n\n    /*** Token functions ***/\n    function doTransferIn(\n        address from,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual returns (uint256);\n\n    function doTransferOut(\n        address payable to,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual;\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IKAP20 {\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function adminApprove(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function adminTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IKToken {\n    function internalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function externalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Pausable {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool public paused;\n\n    constructor() {\n        paused = false;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Pausable: paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused, \"Pausable: not paused\");\n        _;\n    }\n\n    function _pause() internal virtual whenNotPaused {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function _unpause() internal virtual whenPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IAdminProjectRouter {\n    function isSuperAdmin(address _addr, string calldata _project) external view returns (bool);\n\n    function isAdmin(address _addr, string calldata _project) external view returns (bool);\n}\n\nabstract contract Authorization {\n    IAdminProjectRouter public adminProjectRouter;\n    string public PROJECT;\n\n    event AdminProjectRouterSet(address indexed oldAdmin, address indexed newAdmin, address indexed caller);\n\n    modifier onlySuperAdmin() {\n        require(adminProjectRouter.isSuperAdmin(msg.sender, PROJECT), \"Authorization: restricted only super admin\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(adminProjectRouter.isAdmin(msg.sender, PROJECT), \"Authorization: restricted only admin\");\n        _;\n    }\n\n    modifier onlySuperAdminOrAdmin() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) || adminProjectRouter.isAdmin(msg.sender, PROJECT),\n            \"Authorization: restricted only super admin or admin\"\n        );\n        _;\n    }\n\n    function setAdminProjectRouter(address _adminProjectRouter) public virtual onlySuperAdmin {\n        require(_adminProjectRouter != address(0), \"Authorization: new admin project router is the zero address\");\n        emit AdminProjectRouterSet(address(adminProjectRouter), _adminProjectRouter, msg.sender);\n        adminProjectRouter = IAdminProjectRouter(_adminProjectRouter);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IKYCBitkubChain {\n    function kycsLevel(address _addr) external view returns (uint256);\n}\n\nabstract contract KYCHandler {\n    IKYCBitkubChain public kyc;\n\n    uint256 public acceptedKYCLevel;\n    bool public isActivatedOnlyKYCAddress;\n\n    function _activateOnlyKYCAddress() internal virtual {\n        isActivatedOnlyKYCAddress = true;\n    }\n\n    function _setKYC(address _kyc) internal virtual {\n        kyc = IKYCBitkubChain(_kyc);\n    }\n\n    function _setAcceptedKYCLevel(uint256 _kycLevel) internal virtual {\n        acceptedKYCLevel = _kycLevel;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity 0.8.11;\n\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\npragma solidity 0.8.11;\n\nabstract contract Committee {\n    address public committee;\n\n    event CommitteeSet(\n        address indexed oldCommittee,\n        address indexed newCommittee,\n        address indexed caller\n    );\n\n    modifier onlyCommittee() {\n        require(\n            msg.sender == committee,\n            \"Committee: restricted only committee\"\n        );\n        _;\n    }\n\n    function setCommittee(address _committee) public virtual onlyCommittee {\n        emit CommitteeSet(committee, _committee, msg.sender);\n        committee = _committee;\n    }\n}\n\nabstract contract AccessController is\n    Authorization,\n    KYCHandler,\n    Ownable,\n    Committee\n{\n    event TransferRouterSet(\n        address indexed oldTransferRouter,\n        address indexed newTransferRouter,\n        address indexed caller\n    );\n\n    address public transferRouter;\n\n    modifier onlyOwnerOrCommittee() {\n        require(\n            msg.sender == owner() || msg.sender == committee,\n            \"AccessController: restricted only owner or committee\"\n        );\n        _;\n    }\n\n    modifier onlySuperAdminOrTransferRouter() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) ||\n                msg.sender == transferRouter,\n            \"AccessController: restricted only super admin or transfer router\"\n        );\n        _;\n    }\n\n    modifier onlySuperAdminOrCommittee() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) ||\n                msg.sender == committee,\n            \"AccessController: restricted only super admin or committee\"\n        );\n        _;\n    }\n\n    modifier onlySuperAdminOrOwner() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) ||\n                msg.sender == owner(),\n            \"AccessController: restricted only super admin or owner\"\n        );\n        _;\n    }\n\n    function activateOnlyKYCAddress() external onlyCommittee {\n        _activateOnlyKYCAddress();\n    }\n\n    function setKYC(address _kyc) external onlyCommittee {\n        _setKYC(_kyc);\n    }\n\n    function setAcceptedKYCLevel(uint256 _kycLevel) external onlyCommittee {\n        _setAcceptedKYCLevel(_kycLevel);\n    }\n\n    function setTransferRouter(address _transferRouter)\n        external\n        onlyOwnerOrCommittee\n    {\n        emit TransferRouterSet(transferRouter, _transferRouter, msg.sender);\n        transferRouter = _transferRouter;\n    }\n\n    function setAdminProjectRouter(address _adminProjectRouter)\n        public\n        override\n        onlyOwnerOrCommittee\n    {\n        require(\n            _adminProjectRouter != address(0),\n            \"Authorization: new admin project router is the zero address\"\n        );\n        emit AdminProjectRouterSet(\n            address(adminProjectRouter),\n            _adminProjectRouter,\n            msg.sender\n        );\n        adminProjectRouter = IAdminProjectRouter(_adminProjectRouter);\n    }\n}\n\ncontract KAP20 is IKAP20, IKToken, Pausable, AccessController {\n    mapping(address => uint256) _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 public override totalSupply;\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _projectName,\n        uint8 _decimals,\n        address _kyc,\n        address _adminProjectRouter,\n        address _committee,\n        address _transferRouter,\n        uint256 _acceptedKYCLevel\n    ) {\n        name = _name;\n        symbol = _symbol;\n        PROJECT = _projectName;\n        decimals = _decimals;\n        kyc = IKYCBitkubChain(_kyc);\n        adminProjectRouter = IAdminProjectRouter(_adminProjectRouter);\n        committee = _committee;\n        transferRouter = _transferRouter;\n        acceptedKYCLevel = _acceptedKYCLevel;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function adminApprove(\n        address owner,\n        address spender,\n        uint256 amount\n    )\n        public\n        virtual\n        override\n        whenNotPaused\n        onlySuperAdminOrAdmin\n        returns (bool)\n    {\n        require(\n            kyc.kycsLevel(owner) >= acceptedKYCLevel &&\n                kyc.kycsLevel(spender) >= acceptedKYCLevel,\n            \"KAP20: owner or spender address is not a KYC user\"\n        );\n\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override whenNotPaused returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"KAP20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"KAP20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"KAP20: transfer from the zero address\");\n        require(recipient != address(0), \"KAP20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"KAP20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"KAP20: mint to the zero address\");\n\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"KAP20: burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"KAP20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"KAP20: approve from the zero address\");\n        require(spender != address(0), \"KAP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function adminTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override onlyCommittee returns (bool) {\n        if (isActivatedOnlyKYCAddress) {\n            require(\n                kyc.kycsLevel(sender) > 0 && kyc.kycsLevel(recipient) > 0,\n                \"KAP721: only internal purpose\"\n            );\n        }\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"KAP20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    function internalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        override\n        whenNotPaused\n        onlySuperAdminOrTransferRouter\n        returns (bool)\n    {\n        require(\n            kyc.kycsLevel(sender) >= acceptedKYCLevel &&\n                kyc.kycsLevel(recipient) >= acceptedKYCLevel,\n            \"KAP20: only internal purpose\"\n        );\n\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function externalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        override\n        whenNotPaused\n        onlySuperAdminOrTransferRouter\n        returns (bool)\n    {\n        require(\n            kyc.kycsLevel(sender) >= acceptedKYCLevel,\n            \"KAP20: only internal purpose\"\n        );\n\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n}\n\ncontract LToken is KAP20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _kyc,\n        address _adminProjectRouter,\n        address _committee,\n        address _transferRouter,\n        uint256 _acceptedKYCLevel\n    )\n        KAP20(\n            _name,\n            _symbol,\n            \"bitkub-next-yuemmai\",\n            _decimals,\n            _kyc,\n            _adminProjectRouter,\n            _committee,\n            _transferRouter,\n            _acceptedKYCLevel\n        )\n    {}\n\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ILending {\n    /*** Market Events ***/\n\n    event AccrueInterest(\n        uint256 cashPrior,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 totalBorrows\n    );\n    event Deposit(address user, uint256 depositAmount, uint256 mintTokens);\n    event Withdraw(\n        address user,\n        uint256 withdrawAmount,\n        uint256 withdrawTokens\n    );\n    event Borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    event NewController(address oldController, address newController);\n    event NewMarketInterestRateModel(\n        address oldInterestRateModel,\n        address newInterestRateModel\n    );\n    event NewPlatformReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n    event NewPoolReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n    event PlatformReservesClaimed(\n        address beneficiary,\n        uint256 reduceAmount,\n        uint256 newTotalReserves\n    );\n    event PoolReservesClaimed(\n        address reservePool,\n        uint256 claimedAmount,\n        uint256 poolReservesNew\n    );\n    event NewBeneficiary(\n        address payable oldBeneficiary,\n        address payable newBeneficiary\n    );\n    event NewReservePool(\n        address payable oldReservePool,\n        address payable newReservePool\n    );\n    event NewSlippageTolerrance(\n        uint256 oldSlippageTolerrance,\n        uint256 newSlippageTolerrance\n    );\n\n    // /*** User Interface ***/\n\n    function isLContract() external returns (bool);\n\n    function PROJECT() external returns (string memory);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function lToken() external view returns (address);\n\n    function underlyingToken() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function interestRateModel() external view returns (address);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function poolReserveFactorMantissa() external view returns (uint256);\n\n    function platformReserveFactorMantissa() external view returns (uint256);\n\n    function accrualBlockNumber() external view returns (uint256);\n\n    function borrowIndex() external view returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function platformReserves() external view returns (uint256);\n\n    function poolReserves() external view returns (uint256);\n\n    function totalReserves() external view returns (uint256);\n\n    function protocolSeizeShareMantissa() external view returns (uint256);\n\n    function beneficiary() external view returns (address payable);\n\n    function reservePool() external view returns (address payable);\n\n    function transferRouter() external view returns (address);\n\n    /*** Admin Functions ***/\n\n    function _setController(address newController) external returns (uint256);\n\n    function _setPlatformReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        returns (uint256);\n\n    function _setPoolReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        returns (uint256);\n\n    function _setInterestRateModel(address newInterestRateModel)\n        external\n        returns (uint256);\n\n    function _setBeneficiary(address payable newBeneficiary)\n        external\n        returns (uint256);\n\n    function _setReservePool(address payable newReservePool)\n        external\n        returns (uint256);\n\n    function setTransferRouter(address newTransferRouter)\n        external\n        returns (uint256);\n\n    function pause() external returns (uint256);\n\n    function unpause() external returns (uint256);\n\n    /*** Protocol Functions ***/\n    function _claimPoolReserves(uint256 claimedAmount)\n        external\n        returns (uint256);\n\n    function _claimPlatformReserves(uint256 claimedAmount)\n        external\n        returns (uint256);\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IYESController {\n    struct Market {\n        bool isListed;\n        mapping(address => bool) accountMembership;\n    }\n\n    event MarketListed(address lToken);\n    event MarketEntered(address lToken, address account);\n    event MarketExited(address lToken, address account);\n    event NewCollateralFactor(\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n    event NewYESVault(address oldYESVault, address newYESVault);\n    event ActionPaused(string action, bool state);\n    event LendingActionPaused(address lToken, string action, bool state);\n\n    function isController() external returns (bool);\n\n    function enterMarkets(address[] calldata lTokens)\n        external\n        returns (uint256[] memory);\n\n    function exitMarket(address lToken) external returns (uint256);\n\n    function depositAllowed(address lToken) external view returns (uint256);\n\n    function withdrawAllowed(address lToken, address withdrawer)\n        external\n        view\n        returns (uint256);\n\n    function borrowAllowed(\n        address lToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowAllowed(address lToken, address borrower)\n        external\n        view\n        returns (uint256);\n\n    function seizeAllowed(address lToken) external view returns (uint256);\n\n    function repayBorrowAllowed(address lToken) external view returns (uint256);\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function liquidateCalculateSeizeTokens(\n        address lToken,\n        uint256 borrowBalance\n    ) external view returns (uint256, uint256);\n\n    function yesVault() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function collateralFactorMantissa() external view returns (uint256);\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function markets(address lToken, address account)\n        external\n        view\n        returns (bool, bool);\n\n    function accountAssets(address account)\n        external\n        view\n        returns (address[] memory);\n\n    function depositGuardianPaused(address account)\n        external\n        view\n        returns (bool);\n\n    function borrowGuardianPaused(address account) external view returns (bool);\n\n    function seizeGuardianPaused() external view returns (bool);\n\n    function borrowLimitOf(address account) external view returns (uint256);\n\n    function setBorrowPaused(address lContractAddress, bool state)\n        external\n        returns (bool);\n\n    function setDepositPaused(address lContractAddress, bool state)\n        external\n        returns (bool);\n\n    function setSeizePaused(bool state) external returns (bool);\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ninterface IInterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    function isInterestRateModel() external view returns (bool);\n\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    // /**\n    //   * @notice Calculates the current supply interest rate per block\n    //   * @param cash The total amount of cash the market has\n    //   * @param borrows The total amount of borrows the market has outstanding\n    //   * @param reserves The total amount of reserves the market has\n    //   * @param reserveFactorMantissa The current reserve factor the market has\n    //   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n    //   */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ncontract YESControllerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        CONTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INSUFFICIENT_BORROW_LIMIT,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        SET_BYES_TOKEN_CHECK\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), 0);\n\n        return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), opaqueError);\n\n        return uint256(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        CONTROLLER_REJECTION,\n        CONTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        INVALID_BENEFICIARY,\n        INVALID_RESERVE_POOL,\n        INVALID_MARKET,\n        INVALID_MARKET_IMPL,\n        INVALID_VAULT,\n        INVALID_YES_TOKEN\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_PLATFORM_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_POOL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_CONTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_CONTROLLER_REJECTION,\n        LIQUIDATE_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_CONTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        DEPOSIT_ACCRUE_INTEREST_FAILED,\n        DEPOSIT_CONTROLLER_REJECTION,\n        DEPOSIT_EXCHANGE_CALCULATION_FAILED,\n        DEPOSIT_EXCHANGE_RATE_READ_FAILED,\n        DEPOSIT_FRESHNESS_CHECK,\n        DEPOSIT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        DEPOSIT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        DEPOSIT_TRANSFER_IN_FAILED,\n        DEPOSIT_TRANSFER_IN_NOT_POSSIBLE,\n        WITHDRAW_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_CONTROLLER_REJECTION,\n        WITHDRAW_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        WITHDRAW_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        WITHDRAW_EXCHANGE_RATE_READ_FAILED,\n        WITHDRAW_FRESHNESS_CHECK,\n        WITHDRAW_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE,\n        CLAIM_PLATFORM_RESERVES_ACCRUE_INTEREST_FAILED,\n        CLAIM_POOL_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_POOL_RESERVES_ACCRUE_INTEREST_FAILED,\n        CLAIM_PLATFORM_RESERVES_ADMIN_CHECK,\n        REDUCE_POOL_RESERVES_ADMIN_CHECK,\n        CLAIM_PLATFORM_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_POOL_RESERVES_CASH_NOT_AVAILABLE,\n        CLAIM_PLATFORM_RESERVES_FRESH_CHECK,\n        REDUCE_POOL_RESERVES_FRESH_CHECK,\n        CLAIM_PLATFORM_RESERVES_VALIDATION,\n        REDUCE_POOL_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_CONTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_CONTROLLER_OWNER_CHECK,\n        SET_CONTROLLER_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PLATFORM_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_POOL_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_PLATFORM_RESERVE_FACTOR_FRESH_CHECK,\n        SET_POOL_RESERVE_FACTOR_FRESH_CHECK,\n        SET_PLATFORM_RESERVE_FACTOR_BOUNDS_CHECK,\n        SET_POOL_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_CONTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_PLATFORM_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_POOL_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_PLATFORM_RESERVES_FRESH_CHECK,\n        ADD_POOL_RESERVES_FRESH_CHECK,\n        ADD_PLATFORM_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        ADD_POOL_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        CLAIM_PLATFORM_RESERVES_INVALID_BENEFICIARY,\n        CLAIM_POOL_RESERVES_INVALID_RESERVE_POOL,\n        CLAIM_POOL_RESERVES_VALIDATION,\n        SET_BENEFICIARY_ACCRUE_INTEREST_FAILED,\n        SET_BENEFICIARY_FRESH_CHECK,\n        SET_RESERVE_POOL_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_POOL_FRESH_CHECK,\n        SET_SLIPPAGE_TOLERRANCE_ACCRUE_INTEREST_FAILED,\n        SET_SLIPPAGE_TOLERRANCE_FRESH_CHECK,\n        LIQUIDATE_BORROW_BALANCE_ERROR,\n        PAUSE_ACCRUE_INTEREST_FAILED,\n        UNPAUSE_ACCRUE_INTEREST_FAILED\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), 0);\n\n        return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), opaqueError);\n\n        return uint256(err);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint256 c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        uint256 c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (MathError, uint256) {\n        (MathError err0, uint256 sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint256 constant expScale = 1e18;\n    uint256 constant doubleScale = 1e36;\n    uint256 constant halfExpScale = expScale / 2;\n    uint256 constant mantissaOne = expScale;\n\n    struct Exp {\n        uint256 mantissa;\n    }\n\n    struct Double {\n        uint256 mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint256) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (uint256)\n    {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (uint256) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint224)\n    {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return\n            Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint256 a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint256 num, uint256 denom)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (MathError, uint256) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 descaledMantissa) = divUInt(\n            a.mantissa,\n            scalar\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(\n            a.mantissa,\n            b.mantissa\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(\n            halfExpScale,\n            doubleScaledProduct\n        );\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint256 product) = divUInt(\n            doubleScaledProductWithHalfScale,\n            expScale\n        );\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(\n        Exp memory a,\n        Exp memory b,\n        Exp memory c\n    ) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface INextTransferRouter {\n  function transferFrom(\n    string memory _project,\n    address _token,\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity 0.8.11;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISuperAdmin {\n    event NewPendingSuperAdmin(address pendingSuperAdmin);\n    event NewSuperAdmin(address superAdmin);\n\n    function superAdmin() external view returns (address);\n\n    function pendingSuperAdmin() external view returns (address);\n\n    function setPendingSuperAdmin(address _pendingSuperAdmin) external;\n\n    function acceptSuperAdmin() external;\n}\n\ncontract SuperAdmin is ISuperAdmin {\n    address public override superAdmin;\n    address public override pendingSuperAdmin;\n\n    modifier onlySuperAdmin() {\n        require(msg.sender == superAdmin, \"Only Super Admin\");\n        _;\n    }\n\n    modifier onlyPendingSuperAdmin() {\n        require(msg.sender == pendingSuperAdmin, \"Only Pending Super Admin\");\n        _;\n    }\n\n    constructor(address superAdmin_) {\n        superAdmin = superAdmin_;\n    }\n\n    function setPendingSuperAdmin(address _pendingSuperAdmin)\n        public\n        onlySuperAdmin\n    {\n        pendingSuperAdmin = _pendingSuperAdmin;\n\n        emit NewPendingSuperAdmin(pendingSuperAdmin);\n    }\n\n    function acceptSuperAdmin() public onlyPendingSuperAdmin {\n        superAdmin = msg.sender;\n        pendingSuperAdmin = address(0);\n\n        emit NewSuperAdmin(superAdmin);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IBKNextCallHelper {\n    event CallHelperSet(address oldCallHelper, address newCallHelper);\n\n    function callHelper() external returns (address);\n\n    function setCallHelper(address _addr) external;\n}\n\ncontract BKNextCallHelper is IBKNextCallHelper {\n    address public override callHelper;\n\n    modifier onlyCallHelper() {\n        require(msg.sender == callHelper, \"Only Callhelper\");\n        _;\n    }\n\n    constructor(address callHelper_) {\n        callHelper = callHelper_;\n    }\n\n    function setCallHelper(address _addr) external override onlyCallHelper {\n        address oldCallHelper = callHelper;\n        callHelper = _addr;\n        emit CallHelperSet(oldCallHelper, callHelper);\n    }\n}\n\nabstract contract LendingStorage is\n    ILending,\n    TokenErrorReporter,\n    Exponential,\n    ReentrancyGuard,\n    SuperAdmin,\n    BKNextCallHelper,\n    Committee\n{\n    string public constant override PROJECT = \"bitkub-next-yuemmai\";\n    bool public constant override isLContract = true;\n\n    address public override underlyingToken;\n\n    uint256 public override poolReserveFactorMantissa = 0.1e18; // 10%\n    uint256 public override platformReserveFactorMantissa = 0.1e18; // 10%\n    uint256 public override accrualBlockNumber;\n    uint256 public override borrowIndex;\n    uint256 public override totalBorrows;\n    uint256 public override poolReserves;\n    uint256 public override platformReserves;\n\n    address payable public override beneficiary;\n    address payable public override reservePool;\n\n    uint256 public constant override protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n    uint256 internal initialExchangeRateMantissa;\n    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n    uint256 internal constant reserveFactorMaxMantissa = 1e18;\n\n    LToken internal _lToken;\n    IYESController internal _controller;\n    IInterestRateModel internal _interestRateModel;\n    INextTransferRouter internal _transferRouter;\n\n    struct ConstructorArgs {\n        address underlyingToken;\n        address controller;\n        address interestRateModel;\n        uint256 initialExchangeRateMantissa;\n        address payable beneficiary;\n        address payable poolReserve;\n        string lTokenName;\n        string lTokenSymbol;\n        uint8 lTokenDecimals;\n        address superAdmin;\n        address callHelper;\n        address committee;\n        address adminRouter;\n        address transferRouter;\n        address kyc;\n        uint256 acceptedKYCLevel;\n    }\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    enum TransferMethod {\n        METAMASK,\n        BK_NEXT\n    }\n}\n\nabstract contract LendingGetter is LendingStorage {\n    function exchangeRateStored() public view override returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"Math error\");\n        return result;\n    }\n\n    function exchangeRateStoredInternal()\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        uint256 _totalSupply = _lToken.totalSupply();\n        if (_totalSupply == 0) {\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n                totalCash,\n                totalBorrows,\n                totalReserves()\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(\n                cashPlusBorrowsMinusReserves,\n                _totalSupply\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    function borrowBalanceStored(address account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"Math error\");\n        return result;\n    }\n\n    function borrowBalanceStoredInternal(address account)\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        (mathErr, principalTimesIndex) = mulUInt(\n            borrowSnapshot.principal,\n            borrowIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(\n            principalTimesIndex,\n            borrowSnapshot.interestIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 lTokenBalance = _lToken.balanceOf(account);\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (\n            uint256(Error.NO_ERROR),\n            lTokenBalance,\n            borrowBalance,\n            exchangeRateMantissa\n        );\n    }\n\n    function borrowRatePerBlock() external view override returns (uint256) {\n        return\n            _interestRateModel.getBorrowRate(\n                getCashPrior(),\n                totalBorrows,\n                totalReserves()\n            );\n    }\n\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return\n            _interestRateModel.getSupplyRate(\n                getCashPrior(),\n                totalBorrows,\n                totalReserves(),\n                reserveFactorMantissa()\n            );\n    }\n\n    function reserveFactorMantissa() public view override returns (uint256) {\n        uint256 sumReserveFactorMantissa = platformReserveFactorMantissa +\n            poolReserveFactorMantissa;\n        require(\n            sumReserveFactorMantissa >= platformReserveFactorMantissa,\n            \"Overflow\"\n        );\n        return sumReserveFactorMantissa;\n    }\n\n    function totalReserves() public view override returns (uint256) {\n        uint256 sumReserves = platformReserves + poolReserves;\n        require(sumReserves >= platformReserves, \"Overflow\");\n        return sumReserves;\n    }\n\n    function controller() external view override returns (address) {\n        return address(_controller);\n    }\n\n    function lToken() external view override returns (address) {\n        return address(_lToken);\n    }\n\n    function transferRouter() external view override returns (address) {\n        return address(_transferRouter);\n    }\n\n    function interestRateModel() external view override returns (address) {\n        return address(_interestRateModel);\n    }\n\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    function getCash() external view override returns (uint256) {\n        return getCashPrior();\n    }\n\n    function getCashPrior() internal view virtual returns (uint256);\n}\n\nabstract contract LendingInterest is LendingGetter {\n    struct AccrueInterestLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 currentBlockNumber;\n        uint256 accrualBlockNumberPrior;\n        uint256 cashPrior;\n        uint256 borrowsPrior;\n        uint256 poolReservesPrior;\n        uint256 platformReservesPrior;\n        uint256 totalReservesPrior;\n        uint256 borrowIndexPrior;\n        uint256 borrowRateMantissa;\n        uint256 blockDelta;\n    }\n\n    function accrueInterest() public override returns (uint256) {\n        AccrueInterestLocalVars memory vars;\n\n        vars.currentBlockNumber = getBlockNumber();\n        vars.accrualBlockNumberPrior = accrualBlockNumber;\n\n        if (vars.accrualBlockNumberPrior == vars.currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        vars.cashPrior = getCashPrior();\n        vars.borrowsPrior = totalBorrows;\n        vars.poolReservesPrior = poolReserves;\n        vars.platformReservesPrior = platformReserves;\n        vars.borrowIndexPrior = borrowIndex;\n\n        vars.borrowRateMantissa = _interestRateModel.getBorrowRate(\n            vars.cashPrior,\n            vars.borrowsPrior,\n            totalReserves()\n        );\n\n        require(\n            vars.borrowRateMantissa <= borrowRateMaxMantissa,\n            \"Too high borrow rate\"\n        );\n\n        (vars.mathErr, vars.blockDelta) = subUInt(\n            vars.currentBlockNumber,\n            vars.accrualBlockNumberPrior\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Calculate block delta failed\"\n        );\n\n        Exp memory simpleInterestFactor;\n        uint256 interestAccumulated;\n        uint256 totalBorrowsNew;\n        uint256 platformReservesNew;\n        uint256 poolReservesNew;\n        uint256 borrowIndexNew;\n\n        (vars.mathErr, simpleInterestFactor) = mulScalar(\n            Exp({mantissa: vars.borrowRateMantissa}),\n            vars.blockDelta\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, interestAccumulated) = mulScalarTruncate(\n            simpleInterestFactor,\n            vars.borrowsPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, totalBorrowsNew) = addUInt(\n            interestAccumulated,\n            vars.borrowsPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, platformReservesNew) = mulScalarTruncateAddUInt(\n            Exp({mantissa: platformReserveFactorMantissa}),\n            interestAccumulated,\n            vars.platformReservesPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_PLATFORM_RESERVES_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, poolReservesNew) = mulScalarTruncateAddUInt(\n            Exp({mantissa: poolReserveFactorMantissa}),\n            interestAccumulated,\n            vars.poolReservesPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_PLATFORM_RESERVES_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(\n            simpleInterestFactor,\n            vars.borrowIndexPrior,\n            vars.borrowIndexPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        platformReserves = platformReservesNew;\n        poolReserves = poolReservesNew;\n\n        emit AccrueInterest(\n            vars.cashPrior,\n            interestAccumulated,\n            borrowIndexNew,\n            totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n}\n\nabstract contract LendingSetter is LendingInterest {\n    function _setController(address newController)\n        public\n        override\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_CONTROLLER_RATE_MODEL_ACCRUE_INTEREST_FAILED\n                );\n        }\n\n        return _setControllerFresh(newController);\n    }\n\n    function _setControllerFresh(address newController)\n        internal\n        returns (uint256)\n    {\n        IYESController oldController = _controller;\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\n                );\n        }\n\n        _controller = IYESController(newController);\n\n        require(_controller.isController(), \"Controller error\");\n\n        emit NewController(address(oldController), newController);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setInterestRateModel(address newInterestRateModel)\n        public\n        override\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function _setInterestRateModelFresh(address newInterestRateModel)\n        internal\n        returns (uint256)\n    {\n        IInterestRateModel oldInterestRateModel;\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\n                );\n        }\n\n        oldInterestRateModel = _interestRateModel;\n        _interestRateModel = IInterestRateModel(newInterestRateModel);\n\n        require(\n            _interestRateModel.isInterestRateModel(),\n            \"Interest model error\"\n        );\n\n        emit NewMarketInterestRateModel(\n            address(oldInterestRateModel),\n            newInterestRateModel\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setPlatformReserveFactor(uint256 newPlatformReserveFactorMantissa)\n        external\n        override\n        nonReentrant\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo\n                        .SET_PLATFORM_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setPlatformReserveFactorFresh(newPlatformReserveFactorMantissa);\n    }\n\n    function _setPlatformReserveFactorFresh(\n        uint256 newPlatformReserveFactorMantissa\n    ) internal returns (uint256) {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_PLATFORM_RESERVE_FACTOR_FRESH_CHECK\n                );\n        }\n\n        uint256 newTotalReserveFactorMantissa = newPlatformReserveFactorMantissa +\n                poolReserveFactorMantissa;\n\n        if (newTotalReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.SET_PLATFORM_RESERVE_FACTOR_BOUNDS_CHECK\n                );\n        }\n\n        uint256 oldPlatformReserveFactorMantissa = platformReserveFactorMantissa;\n        platformReserveFactorMantissa = newPlatformReserveFactorMantissa;\n\n        emit NewPlatformReserveFactor(\n            oldPlatformReserveFactorMantissa,\n            newPlatformReserveFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setPoolReserveFactor(uint256 newPoolReserveFactorMantissa)\n        external\n        override\n        nonReentrant\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_POOL_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setPoolReserveFactorFresh(newPoolReserveFactorMantissa);\n    }\n\n    function _setPoolReserveFactorFresh(uint256 newPoolReserveFactorMantissa)\n        internal\n        returns (uint256)\n    {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_POOL_RESERVE_FACTOR_FRESH_CHECK\n                );\n        }\n\n        uint256 newTotalReserveFactorMantissa = platformReserveFactorMantissa +\n            newPoolReserveFactorMantissa;\n        if (newTotalReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.SET_POOL_RESERVE_FACTOR_BOUNDS_CHECK\n                );\n        }\n\n        uint256 oldPoolReserveFactorMantissa = poolReserveFactorMantissa;\n        poolReserveFactorMantissa = newPoolReserveFactorMantissa;\n\n        emit NewPoolReserveFactor(\n            oldPoolReserveFactorMantissa,\n            newPoolReserveFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setBeneficiary(address payable newBeneficiary)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(msg.sender == beneficiary, \"Only beneficiary\");\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_BENEFICIARY_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setBeneficiaryFresh(newBeneficiary);\n    }\n\n    function _setBeneficiaryFresh(address payable newBeneficiary)\n        internal\n        returns (uint256)\n    {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_BENEFICIARY_FRESH_CHECK\n                );\n        }\n\n        address payable oldBeneficiary = beneficiary;\n        beneficiary = newBeneficiary;\n\n        emit NewBeneficiary(oldBeneficiary, newBeneficiary);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setReservePool(address payable newReservePool)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(msg.sender == reservePool, \"Only reserve pool\");\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_RESERVE_POOL_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setReservePoolFresh(newReservePool);\n    }\n\n    function setTransferRouter(address newTransferRouter)\n        external\n        override\n        onlyCommittee\n        returns (uint256)\n    {\n        _transferRouter = INextTransferRouter(newTransferRouter);\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setReservePoolFresh(address payable newReservePool)\n        internal\n        returns (uint256)\n    {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_RESERVE_POOL_FRESH_CHECK\n                );\n        }\n\n        address payable oldReservePool = reservePool;\n        reservePool = newReservePool;\n\n        emit NewReservePool(oldReservePool, newReservePool);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function pause() external override onlySuperAdmin returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return fail(Error(error), FailureInfo.PAUSE_ACCRUE_INTEREST_FAILED);\n        }\n        _lToken.pause();\n        return uint256(Error.NO_ERROR);\n    }\n\n    function unpause() external override onlySuperAdmin returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.UNPAUSE_ACCRUE_INTEREST_FAILED);\n        }\n        _lToken.unpause();\n        return uint256(Error.NO_ERROR);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IYESVault {\n    event Airdrop(address beneficiary, uint256 amount);\n    event BorrowLimitUpdated(\n        address account,\n        uint256 oldAmount,\n        uint256 newAmount\n    );\n    event Deposit(address sender, uint256 amount);\n    event Withdraw(address sender, uint256 amount);\n\n    function PROJECT() external view returns (string memory);\n\n    function borrowLimitOf(address account) external view returns (uint256);\n\n    function tokensOf(address account) external view returns (uint256);\n\n    function releasedTo(address account) external view returns (uint256);\n\n    function controller() external view returns (address);\n\n    function yesToken() external view returns (address);\n\n    function marketImpl() external view returns (address);\n\n    function market() external view returns (address);\n\n    function totalAllocated() external view returns (uint256);\n\n    function admin() external view returns (address);\n\n    function transferRouter() external view returns (address);\n\n    function airdrop(address beneficiary, uint256 amount) external;\n\n    function setBorrowLimit(address account, uint256 newAmount) external;\n\n    function deposit(uint256 amount, address sender) external;\n\n    function withdraw(uint256 amount, address sender) external;\n\n    function sellMarket(\n        address borrower,\n        uint256 amount,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /*** Admin Events ***/\n\n    event NewController(address oldController, address newController);\n    event NewYESToken(address oldYESToken, address newYESToken);\n    event NewMarketImpl(address oldMarketImpl, address newMarketImpl);\n    event NewMarket(address oldMarket, address newMarket);\n    event NewSlippageTolerrance(uint256 oldTolerrance, uint256 newTolerrance);\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /*** Admin Functions ***/\n\n    function setController(address newController) external;\n\n    function setMarketImpl(address newMarketImpl) external;\n\n    function setMarket(address newMarket) external;\n\n    function setTransferRouter(address newTransferRouter) external;\n\n    function setAdmin(address newAdmin) external;\n}\n\nabstract contract LendingContract is LendingSetter {\n    constructor(ConstructorArgs memory args)\n        SuperAdmin(args.superAdmin)\n        BKNextCallHelper(args.callHelper)\n    {\n        require(args.initialExchangeRateMantissa > 0, \"Invalid exchange rate\");\n        initialExchangeRateMantissa = args.initialExchangeRateMantissa;\n\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        uint256 err1 = _setControllerFresh(args.controller);\n        require(err1 == uint256(Error.NO_ERROR), \"Controller failed\");\n\n        uint256 err2 = _setInterestRateModelFresh(args.interestRateModel);\n        require(err2 == uint256(Error.NO_ERROR), \"Interest model failed\");\n\n        uint256 err3 = _setBeneficiaryFresh(args.beneficiary);\n        require(err3 == uint256(Error.NO_ERROR), \"Beneficiary failed\");\n\n        uint256 err4 = _setReservePoolFresh(args.poolReserve);\n        require(err4 == uint256(Error.NO_ERROR), \"Reserve pool failed\");\n\n        _transferRouter = INextTransferRouter(args.transferRouter);\n\n        underlyingToken = args.underlyingToken;\n        committee = args.committee;\n        IKAP20(underlyingToken).totalSupply();\n\n        _lToken = new LToken(\n            args.lTokenName,\n            args.lTokenSymbol,\n            args.lTokenDecimals,\n            args.kyc,\n            args.adminRouter,\n            args.committee,\n            args.transferRouter,\n            args.acceptedKYCLevel\n        );\n    }\n\n    function depositInternal(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(Error(error), FailureInfo.DEPOSIT_ACCRUE_INTEREST_FAILED),\n                0\n            );\n        }\n        return depositFresh(user, depositAmount, method);\n    }\n\n    struct DepositLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualDepositAmount;\n    }\n\n    function depositFresh(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.depositAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.DEPOSIT_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.DEPOSIT_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        DepositLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.DEPOSIT_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        vars.actualDepositAmount = doTransferIn(user, depositAmount, method);\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualDepositAmount,\n            Exp({mantissa: vars.exchangeRateMantissa})\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Exchange calculate failed\"\n        );\n\n        _lToken.mint(user, vars.mintTokens);\n\n        emit Deposit(user, vars.actualDepositAmount, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualDepositAmount);\n    }\n\n    function withdrawInternal(\n        address payable user,\n        uint256 withdrawTokens,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, withdrawTokens, 0, method);\n    }\n\n    function withdrawUnderlyingInternal(\n        address payable user,\n        uint256 withdrawAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, 0, withdrawAmount, method);\n    }\n\n    struct WithdrawLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 withdrawTokens;\n        uint256 withdrawAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    function withdrawFresh(\n        address payable user,\n        uint256 withdrawTokensIn,\n        uint256 withdrawAmountIn,\n        TransferMethod method\n    ) internal returns (uint256) {\n        require(\n            withdrawTokensIn == 0 || withdrawAmountIn == 0,\n            \"Must have a zero input\"\n        );\n\n        WithdrawLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.WITHDRAW_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        if (withdrawTokensIn > 0) {\n            vars.withdrawTokens = withdrawTokensIn;\n\n            (vars.mathErr, vars.withdrawAmount) = mulScalarTruncate(\n                Exp({mantissa: vars.exchangeRateMantissa}),\n                withdrawTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            (vars.mathErr, vars.withdrawTokens) = divScalarByExpTruncate(\n                withdrawAmountIn,\n                Exp({mantissa: vars.exchangeRateMantissa})\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.withdrawAmount = withdrawAmountIn;\n        }\n\n        uint256 allowed = _controller.withdrawAllowed(address(this), user);\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.WITHDRAW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < vars.withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n                );\n        }\n\n        doTransferOut(user, vars.withdrawAmount, method);\n\n        _lToken.burn(user, vars.withdrawTokens);\n\n        emit Withdraw(user, vars.withdrawAmount, vars.withdrawTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function borrowInternal(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        return borrowFresh(borrower, borrowAmount, method);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    function borrowFresh(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal returns (uint256) {\n        uint256 allowed = _controller.borrowAllowed(\n            address(this),\n            borrower,\n            borrowAmount\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.BORROW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.BORROW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < borrowAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.BORROW_CASH_NOT_AVAILABLE\n                );\n        }\n\n        BorrowLocalVars memory vars;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\n            vars.accountBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\n            totalBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        doTransferOut(borrower, borrowAmount, method);\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        emit Borrow(\n            borrower,\n            borrowAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function repayBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(borrower, borrower, repayAmount, method);\n    }\n\n    function repayBorrowBehalfInternal(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(payer, borrower, repayAmount, method);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.repayBorrowAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.REPAY_BORROW_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REPAY_BORROW_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > vars.accountBorrows) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > totalBorrows) {\n            vars.repayAmount = totalBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        if (payer != address(this)) {\n            vars.actualRepayAmount = doTransferIn(\n                payer,\n                vars.repayAmount,\n                method\n            );\n        } else {\n            vars.actualRepayAmount = vars.repayAmount;\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\n            vars.accountBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Account borrow update failed\"\n        );\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\n            totalBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Total borrow update failed\"\n        );\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        emit RepayBorrow(\n            payer,\n            borrower,\n            vars.actualRepayAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    function liquidateBorrowInternal(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        return\n            liquidateBorrowFresh(\n                liquidator,\n                borrower,\n                input,\n                minReward,\n                deadline,\n                method\n            );\n    }\n\n    struct LiquidateBorrowLocalVars {\n        MathError mErr;\n        uint256 err;\n        uint256 allowed;\n        uint256 borrowBalance;\n        uint256 seizeTokens;\n        uint256 sellOutput;\n        uint256 actualInput;\n        uint256 actualRepayAmount;\n        uint256 transferOutput;\n        uint256 reward;\n    }\n\n    function liquidateBorrowFresh(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        LiquidateBorrowLocalVars memory vars;\n        vars.allowed = _controller.liquidateBorrowAllowed(\n            address(this),\n            borrower\n        );\n        if (vars.allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_CONTROLLER_REJECTION,\n                    vars.allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        if (borrower == liquidator) {\n            return (\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\n                ),\n                0\n            );\n        }\n\n        (vars.mErr, vars.borrowBalance) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (\n                fail(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_BORROW_BALANCE_ERROR\n                ),\n                0\n            );\n        }\n\n        (vars.err, vars.seizeTokens) = _controller\n            .liquidateCalculateSeizeTokens(address(this), vars.borrowBalance);\n\n        require(\n            vars.err == uint256(Error.NO_ERROR),\n            \"Calculate seize amount failed\"\n        );\n\n        IYESVault yesVault = IYESVault(_controller.yesVault());\n        vars.sellOutput = yesVault.sellMarket(\n            borrower,\n            vars.seizeTokens,\n            deadline\n        );\n        vars.actualInput = doTransferIn(liquidator, input, method);\n\n        (vars.err, vars.actualRepayAmount) = repayBorrowFresh(\n            address(this),\n            borrower,\n            vars.borrowBalance,\n            TransferMethod.METAMASK\n        );\n\n        if (vars.err != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(vars.err),\n                    FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n                ),\n                0\n            );\n        }\n\n        vars.transferOutput =\n            (vars.sellOutput + vars.actualInput) -\n            vars.actualRepayAmount;\n        vars.reward = vars.transferOutput - vars.actualInput;\n        require(vars.reward >= minReward, \"Too low reward\");\n\n        doTransferOut(liquidator, vars.transferOutput, method);\n\n        emit LiquidateBorrow(\n            liquidator,\n            borrower,\n            vars.actualRepayAmount,\n            vars.seizeTokens\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /*** Fresh getters ***/\n\n    function exchangeRateCurrent()\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return exchangeRateStored();\n    }\n\n    function borrowBalanceCurrent(address account)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return borrowBalanceStored(account);\n    }\n\n    function totalBorrowsCurrent()\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return totalBorrows;\n    }\n\n    function balanceOfUnderlying(address owner)\n        external\n        override\n        returns (uint256)\n    {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint256 balance) = mulScalarTruncate(\n            exchangeRate,\n            _lToken.balanceOf(owner)\n        );\n        require(mErr == MathError.NO_ERROR, \"Math error\");\n        return balance;\n    }\n\n    /*** Protocol functions ***/\n\n    function _claimPlatformReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == beneficiary, \"Only beneficiary\");\n        uint256 platformReservesNew;\n\n        if (beneficiary == address(0)) {\n            return\n                fail(\n                    Error.INVALID_BENEFICIARY,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_INVALID_BENEFICIARY\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > platformReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_VALIDATION\n                );\n        }\n\n        platformReservesNew = platformReserves - claimedAmount;\n        require(platformReservesNew <= platformReserves, \"Overflow\");\n\n        platformReserves = platformReservesNew;\n\n        doTransferOut(beneficiary, claimedAmount, TransferMethod.METAMASK);\n\n        emit PlatformReservesClaimed(\n            beneficiary,\n            claimedAmount,\n            platformReservesNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _claimPoolReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == reservePool, \"Only reserve pool\");\n        uint256 poolReservesNew;\n\n        if (reservePool == address(0)) {\n            return\n                fail(\n                    Error.INVALID_RESERVE_POOL,\n                    FailureInfo.CLAIM_POOL_RESERVES_INVALID_RESERVE_POOL\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_POOL_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > poolReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_POOL_RESERVES_VALIDATION\n                );\n        }\n\n        poolReservesNew = poolReserves - claimedAmount;\n        require(poolReservesNew <= poolReserves, \"Overflow\");\n\n        poolReserves = poolReservesNew;\n\n        doTransferOut(reservePool, claimedAmount, TransferMethod.METAMASK);\n\n        emit PoolReservesClaimed(reservePool, claimedAmount, poolReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** BK Next helpers ***/\n    function requireKYC(address sender) internal view {\n        IKYCBitkubChain kyc = _lToken.kyc();\n        require(\n            kyc.kycsLevel(sender) >= _lToken.acceptedKYCLevel(),\n            \"only Bitkub Next user\"\n        );\n    }\n\n    /*** Token functions ***/\n    function doTransferIn(\n        address from,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual returns (uint256);\n\n    function doTransferOut(\n        address payable to,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual;\n}\n", "commit_id": "08bd113e762b17d8501f9b371518c7aa01f48afc"}, "fixed_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"../LToken.sol\";\nimport \"./LendingSetter.sol\";\nimport \"../interfaces/IYESVault.sol\";\nimport \"../modules/kyc/KYCHandler.sol\";\nimport \"../modules/kyc/interfaces/IKYCBitkubChain.sol\";\nimport \"../modules/committee/Committee.sol\";\n\nabstract contract LendingContract is LendingSetter {\n    constructor(ConstructorArgs memory args)\n        SuperAdmin(args.superAdmin)\n        BKNextCallHelper(args.callHelper)\n    {\n        require(args.initialExchangeRateMantissa > 0, \"Invalid exchange rate\");\n        initialExchangeRateMantissa = args.initialExchangeRateMantissa;\n\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        uint256 err1 = _setControllerFresh(args.controller);\n        require(err1 == uint256(Error.NO_ERROR), \"Controller failed\");\n\n        uint256 err2 = _setInterestRateModelFresh(args.interestRateModel);\n        require(err2 == uint256(Error.NO_ERROR), \"Interest model failed\");\n\n        uint256 err3 = _setBeneficiaryFresh(args.beneficiary);\n        require(err3 == uint256(Error.NO_ERROR), \"Beneficiary failed\");\n\n        uint256 err4 = _setReservePoolFresh(args.poolReserve);\n        require(err4 == uint256(Error.NO_ERROR), \"Reserve pool failed\");\n\n        _transferRouter = INextTransferRouter(args.transferRouter);\n\n        underlyingToken = args.underlyingToken;\n        committee = args.committee;\n        IKAP20(underlyingToken).totalSupply();\n\n        _lToken = new LToken(\n            args.lTokenName,\n            args.lTokenSymbol,\n            args.lTokenDecimals,\n            args.kyc,\n            args.adminRouter,\n            args.committee,\n            args.transferRouter,\n            args.acceptedKYCLevel\n        );\n    }\n\n    function depositInternal(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(Error(error), FailureInfo.DEPOSIT_ACCRUE_INTEREST_FAILED),\n                0\n            );\n        }\n        return depositFresh(user, depositAmount, method);\n    }\n\n    struct DepositLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualDepositAmount;\n    }\n\n    function depositFresh(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.depositAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.DEPOSIT_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.DEPOSIT_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        DepositLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.DEPOSIT_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        vars.actualDepositAmount = doTransferIn(user, depositAmount, method);\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualDepositAmount,\n            Exp({mantissa: vars.exchangeRateMantissa})\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Exchange calculate failed\"\n        );\n\n        _lToken.mint(user, vars.mintTokens);\n\n        emit Deposit(user, vars.actualDepositAmount, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualDepositAmount);\n    }\n\n    function withdrawInternal(\n        address payable user,\n        uint256 withdrawTokens,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, withdrawTokens, 0, method);\n    }\n\n    function withdrawUnderlyingInternal(\n        address payable user,\n        uint256 withdrawAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, 0, withdrawAmount, method);\n    }\n\n    struct WithdrawLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 withdrawTokens;\n        uint256 withdrawAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    function withdrawFresh(\n        address payable user,\n        uint256 withdrawTokensIn,\n        uint256 withdrawAmountIn,\n        TransferMethod method\n    ) internal returns (uint256) {\n        require(\n            withdrawTokensIn == 0 || withdrawAmountIn == 0,\n            \"Must have a zero input\"\n        );\n\n        WithdrawLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.WITHDRAW_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        if (withdrawTokensIn > 0) {\n            vars.withdrawTokens = withdrawTokensIn;\n\n            (vars.mathErr, vars.withdrawAmount) = mulScalarTruncate(\n                Exp({mantissa: vars.exchangeRateMantissa}),\n                withdrawTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            (vars.mathErr, vars.withdrawTokens) = divScalarByExpTruncate(\n                withdrawAmountIn,\n                Exp({mantissa: vars.exchangeRateMantissa})\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.withdrawAmount = withdrawAmountIn;\n        }\n\n        uint256 allowed = _controller.withdrawAllowed(address(this), user);\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.WITHDRAW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < vars.withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n                );\n        }\n\n        _lToken.burn(user, vars.withdrawTokens);\n\n        doTransferOut(user, vars.withdrawAmount, method);\n\n        emit Withdraw(user, vars.withdrawAmount, vars.withdrawTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function borrowInternal(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        return borrowFresh(borrower, borrowAmount, method);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    function borrowFresh(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal returns (uint256) {\n        uint256 allowed = _controller.borrowAllowed(\n            address(this),\n            borrower,\n            borrowAmount\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.BORROW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.BORROW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < borrowAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.BORROW_CASH_NOT_AVAILABLE\n                );\n        }\n\n        BorrowLocalVars memory vars;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\n            vars.accountBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\n            totalBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        doTransferOut(borrower, borrowAmount, method);\n\n        emit Borrow(\n            borrower,\n            borrowAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function repayBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(borrower, borrower, repayAmount, method);\n    }\n\n    function repayBorrowBehalfInternal(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(payer, borrower, repayAmount, method);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.repayBorrowAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.REPAY_BORROW_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REPAY_BORROW_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > vars.accountBorrows) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > totalBorrows) {\n            vars.repayAmount = totalBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        if (payer != address(this)) {\n            vars.actualRepayAmount = doTransferIn(\n                payer,\n                vars.repayAmount,\n                method\n            );\n        } else {\n            vars.actualRepayAmount = vars.repayAmount;\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\n            vars.accountBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Account borrow update failed\"\n        );\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\n            totalBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Total borrow update failed\"\n        );\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        emit RepayBorrow(\n            payer,\n            borrower,\n            vars.actualRepayAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    function liquidateBorrowInternal(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        return\n            liquidateBorrowFresh(\n                liquidator,\n                borrower,\n                input,\n                minReward,\n                deadline,\n                method\n            );\n    }\n\n    struct LiquidateBorrowLocalVars {\n        MathError mErr;\n        uint256 err;\n        uint256 allowed;\n        uint256 borrowBalance;\n        uint256 seizeTokens;\n        uint256 sellOutput;\n        uint256 actualInput;\n        uint256 actualRepayAmount;\n        uint256 transferOutput;\n        uint256 reward;\n    }\n\n    function liquidateBorrowFresh(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        LiquidateBorrowLocalVars memory vars;\n        vars.allowed = _controller.liquidateBorrowAllowed(\n            address(this),\n            borrower\n        );\n        if (vars.allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_CONTROLLER_REJECTION,\n                    vars.allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        if (borrower == liquidator) {\n            return (\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\n                ),\n                0\n            );\n        }\n\n        (vars.mErr, vars.borrowBalance) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (\n                fail(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_BORROW_BALANCE_ERROR\n                ),\n                0\n            );\n        }\n\n        (vars.err, vars.seizeTokens) = _controller\n            .liquidateCalculateSeizeTokens(address(this), vars.borrowBalance);\n\n        require(\n            vars.err == uint256(Error.NO_ERROR),\n            \"Calculate seize amount failed\"\n        );\n\n        IYESVault yesVault = IYESVault(_controller.yesVault());\n        vars.sellOutput = yesVault.sellMarket(\n            borrower,\n            vars.seizeTokens,\n            deadline\n        );\n        vars.actualInput = doTransferIn(liquidator, input, method);\n\n        (vars.err, vars.actualRepayAmount) = repayBorrowFresh(\n            address(this),\n            borrower,\n            vars.borrowBalance,\n            TransferMethod.METAMASK\n        );\n\n        if (vars.err != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(vars.err),\n                    FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n                ),\n                0\n            );\n        }\n\n        vars.transferOutput =\n            (vars.sellOutput + vars.actualInput) -\n            vars.actualRepayAmount;\n        vars.reward = vars.transferOutput - vars.actualInput;\n        require(vars.reward >= minReward, \"Too low reward\");\n\n        doTransferOut(liquidator, vars.transferOutput, method);\n\n        emit LiquidateBorrow(\n            liquidator,\n            borrower,\n            vars.actualRepayAmount,\n            vars.seizeTokens\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /*** Fresh getters ***/\n\n    function exchangeRateCurrent()\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return exchangeRateStored();\n    }\n\n    function borrowBalanceCurrent(address account)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return borrowBalanceStored(account);\n    }\n\n    function totalBorrowsCurrent()\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return totalBorrows;\n    }\n\n    function balanceOfUnderlying(address owner)\n        external\n        override\n        returns (uint256)\n    {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint256 balance) = mulScalarTruncate(\n            exchangeRate,\n            _lToken.balanceOf(owner)\n        );\n        require(mErr == MathError.NO_ERROR, \"Math error\");\n        return balance;\n    }\n\n    /*** Protocol functions ***/\n\n    function _claimPlatformReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == beneficiary, \"Only beneficiary\");\n        uint256 platformReservesNew;\n\n        if (beneficiary == address(0)) {\n            return\n                fail(\n                    Error.INVALID_BENEFICIARY,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_INVALID_BENEFICIARY\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > platformReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_VALIDATION\n                );\n        }\n\n        platformReservesNew = platformReserves - claimedAmount;\n        require(platformReservesNew <= platformReserves, \"Overflow\");\n\n        platformReserves = platformReservesNew;\n\n        doTransferOut(beneficiary, claimedAmount, TransferMethod.METAMASK);\n\n        emit PlatformReservesClaimed(\n            beneficiary,\n            claimedAmount,\n            platformReservesNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _claimPoolReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == reservePool, \"Only reserve pool\");\n        uint256 poolReservesNew;\n\n        if (reservePool == address(0)) {\n            return\n                fail(\n                    Error.INVALID_RESERVE_POOL,\n                    FailureInfo.CLAIM_POOL_RESERVES_INVALID_RESERVE_POOL\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_POOL_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > poolReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_POOL_RESERVES_VALIDATION\n                );\n        }\n\n        poolReservesNew = poolReserves - claimedAmount;\n        require(poolReservesNew <= poolReserves, \"Overflow\");\n\n        poolReserves = poolReservesNew;\n\n        doTransferOut(reservePool, claimedAmount, TransferMethod.METAMASK);\n\n        emit PoolReservesClaimed(reservePool, claimedAmount, poolReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** BK Next helpers ***/\n    function requireKYC(address sender) internal view {\n        IKYCBitkubChain kyc = _lToken.kyc();\n        require(\n            kyc.kycsLevel(sender) >= _lToken.acceptedKYCLevel(),\n            \"only Bitkub Next user\"\n        );\n    }\n\n    /*** Token functions ***/\n    function doTransferIn(\n        address from,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual returns (uint256);\n\n    function doTransferOut(\n        address payable to,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual;\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IKAP20 {\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function adminApprove(\n        address owner,\n        address spender,\n        uint256 amount\n    ) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function adminTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IKToken {\n    function internalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function externalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\nabstract contract Pausable {\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool public paused;\n\n    constructor() {\n        paused = false;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"Pausable: paused\");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused, \"Pausable: not paused\");\n        _;\n    }\n\n    function _pause() internal virtual whenNotPaused {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function _unpause() internal virtual whenPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\n\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IAdminProjectRouter {\n    function isSuperAdmin(address _addr, string calldata _project) external view returns (bool);\n\n    function isAdmin(address _addr, string calldata _project) external view returns (bool);\n}\n\nabstract contract Authorization {\n    IAdminProjectRouter public adminProjectRouter;\n    string public PROJECT;\n\n    event AdminProjectRouterSet(address indexed oldAdmin, address indexed newAdmin, address indexed caller);\n\n    modifier onlySuperAdmin() {\n        require(adminProjectRouter.isSuperAdmin(msg.sender, PROJECT), \"Authorization: restricted only super admin\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(adminProjectRouter.isAdmin(msg.sender, PROJECT), \"Authorization: restricted only admin\");\n        _;\n    }\n\n    modifier onlySuperAdminOrAdmin() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) || adminProjectRouter.isAdmin(msg.sender, PROJECT),\n            \"Authorization: restricted only super admin or admin\"\n        );\n        _;\n    }\n\n    function setAdminProjectRouter(address _adminProjectRouter) public virtual onlySuperAdmin {\n        require(_adminProjectRouter != address(0), \"Authorization: new admin project router is the zero address\");\n        emit AdminProjectRouterSet(address(adminProjectRouter), _adminProjectRouter, msg.sender);\n        adminProjectRouter = IAdminProjectRouter(_adminProjectRouter);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\ninterface IKYCBitkubChain {\n    function kycsLevel(address _addr) external view returns (uint256);\n}\n\nabstract contract KYCHandler {\n    IKYCBitkubChain public kyc;\n\n    uint256 public acceptedKYCLevel;\n    bool public isActivatedOnlyKYCAddress;\n\n    function _activateOnlyKYCAddress() internal virtual {\n        isActivatedOnlyKYCAddress = true;\n    }\n\n    function _setKYC(address _kyc) internal virtual {\n        kyc = IKYCBitkubChain(_kyc);\n    }\n\n    function _setAcceptedKYCLevel(uint256 _kycLevel) internal virtual {\n        acceptedKYCLevel = _kycLevel;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\n\npragma solidity 0.8.11;\n\n\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\npragma solidity 0.8.11;\n\nabstract contract Committee {\n    address public committee;\n\n    event CommitteeSet(\n        address indexed oldCommittee,\n        address indexed newCommittee,\n        address indexed caller\n    );\n\n    modifier onlyCommittee() {\n        require(\n            msg.sender == committee,\n            \"Committee: restricted only committee\"\n        );\n        _;\n    }\n\n    function setCommittee(address _committee) public virtual onlyCommittee {\n        emit CommitteeSet(committee, _committee, msg.sender);\n        committee = _committee;\n    }\n}\n\nabstract contract AccessController is\n    Authorization,\n    KYCHandler,\n    Ownable,\n    Committee\n{\n    event TransferRouterSet(\n        address indexed oldTransferRouter,\n        address indexed newTransferRouter,\n        address indexed caller\n    );\n\n    address public transferRouter;\n\n    modifier onlyOwnerOrCommittee() {\n        require(\n            msg.sender == owner() || msg.sender == committee,\n            \"AccessController: restricted only owner or committee\"\n        );\n        _;\n    }\n\n    modifier onlySuperAdminOrTransferRouter() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) ||\n                msg.sender == transferRouter,\n            \"AccessController: restricted only super admin or transfer router\"\n        );\n        _;\n    }\n\n    modifier onlySuperAdminOrCommittee() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) ||\n                msg.sender == committee,\n            \"AccessController: restricted only super admin or committee\"\n        );\n        _;\n    }\n\n    modifier onlySuperAdminOrOwner() {\n        require(\n            adminProjectRouter.isSuperAdmin(msg.sender, PROJECT) ||\n                msg.sender == owner(),\n            \"AccessController: restricted only super admin or owner\"\n        );\n        _;\n    }\n\n    function activateOnlyKYCAddress() external onlyCommittee {\n        _activateOnlyKYCAddress();\n    }\n\n    function setKYC(address _kyc) external onlyCommittee {\n        _setKYC(_kyc);\n    }\n\n    function setAcceptedKYCLevel(uint256 _kycLevel) external onlyCommittee {\n        _setAcceptedKYCLevel(_kycLevel);\n    }\n\n    function setTransferRouter(address _transferRouter)\n        external\n        onlyOwnerOrCommittee\n    {\n        emit TransferRouterSet(transferRouter, _transferRouter, msg.sender);\n        transferRouter = _transferRouter;\n    }\n\n    function setAdminProjectRouter(address _adminProjectRouter)\n        public\n        override\n        onlyOwnerOrCommittee\n    {\n        require(\n            _adminProjectRouter != address(0),\n            \"Authorization: new admin project router is the zero address\"\n        );\n        emit AdminProjectRouterSet(\n            address(adminProjectRouter),\n            _adminProjectRouter,\n            msg.sender\n        );\n        adminProjectRouter = IAdminProjectRouter(_adminProjectRouter);\n    }\n}\n\ncontract KAP20 is IKAP20, IKToken, Pausable, AccessController {\n    mapping(address => uint256) _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 public override totalSupply;\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _projectName,\n        uint8 _decimals,\n        address _kyc,\n        address _adminProjectRouter,\n        address _committee,\n        address _transferRouter,\n        uint256 _acceptedKYCLevel\n    ) {\n        name = _name;\n        symbol = _symbol;\n        PROJECT = _projectName;\n        decimals = _decimals;\n        kyc = IKYCBitkubChain(_kyc);\n        adminProjectRouter = IAdminProjectRouter(_adminProjectRouter);\n        committee = _committee;\n        transferRouter = _transferRouter;\n        acceptedKYCLevel = _acceptedKYCLevel;\n    }\n\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        whenNotPaused\n        returns (bool)\n    {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function adminApprove(\n        address owner,\n        address spender,\n        uint256 amount\n    )\n        public\n        virtual\n        override\n        whenNotPaused\n        onlySuperAdminOrAdmin\n        returns (bool)\n    {\n        require(\n            kyc.kycsLevel(owner) >= acceptedKYCLevel &&\n                kyc.kycsLevel(spender) >= acceptedKYCLevel,\n            \"KAP20: owner or spender address is not a KYC user\"\n        );\n\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override whenNotPaused returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(\n            currentAllowance >= amount,\n            \"KAP20: transfer amount exceeds allowance\"\n        );\n        unchecked {\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender] + addedValue\n        );\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(\n            currentAllowance >= subtractedValue,\n            \"KAP20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(msg.sender, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"KAP20: transfer from the zero address\");\n        require(recipient != address(0), \"KAP20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"KAP20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"KAP20: mint to the zero address\");\n\n        totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"KAP20: burn from the zero address\");\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"KAP20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"KAP20: approve from the zero address\");\n        require(spender != address(0), \"KAP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function adminTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override onlyCommittee returns (bool) {\n        if (isActivatedOnlyKYCAddress) {\n            require(\n                kyc.kycsLevel(sender) > 0 && kyc.kycsLevel(recipient) > 0,\n                \"KAP721: only internal purpose\"\n            );\n        }\n        uint256 senderBalance = _balances[sender];\n        require(\n            senderBalance >= amount,\n            \"KAP20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        return true;\n    }\n\n    function internalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        override\n        whenNotPaused\n        onlySuperAdminOrTransferRouter\n        returns (bool)\n    {\n        require(\n            kyc.kycsLevel(sender) >= acceptedKYCLevel &&\n                kyc.kycsLevel(recipient) >= acceptedKYCLevel,\n            \"KAP20: only internal purpose\"\n        );\n\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function externalTransfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    )\n        external\n        override\n        whenNotPaused\n        onlySuperAdminOrTransferRouter\n        returns (bool)\n    {\n        require(\n            kyc.kycsLevel(sender) >= acceptedKYCLevel,\n            \"KAP20: only internal purpose\"\n        );\n\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n}\n\ncontract LToken is KAP20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _kyc,\n        address _adminProjectRouter,\n        address _committee,\n        address _transferRouter,\n        uint256 _acceptedKYCLevel\n    )\n        KAP20(\n            _name,\n            _symbol,\n            \"bitkub-next-yuemmai\",\n            _decimals,\n            _kyc,\n            _adminProjectRouter,\n            _committee,\n            _transferRouter,\n            _acceptedKYCLevel\n        )\n    {}\n\n    function mint(address _to, uint256 _amount) external onlyOwner {\n        _mint(_to, _amount);\n    }\n\n    function burn(address _from, uint256 _amount) external onlyOwner {\n        _burn(_from, _amount);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ILending {\n    /*** Market Events ***/\n\n    event AccrueInterest(\n        uint256 cashPrior,\n        uint256 interestAccumulated,\n        uint256 borrowIndex,\n        uint256 totalBorrows\n    );\n    event Deposit(address user, uint256 depositAmount, uint256 mintTokens);\n    event Withdraw(\n        address user,\n        uint256 withdrawAmount,\n        uint256 withdrawTokens\n    );\n    event Borrow(\n        address borrower,\n        uint256 borrowAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n    event RepayBorrow(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        uint256 accountBorrows,\n        uint256 totalBorrows\n    );\n    event LiquidateBorrow(\n        address liquidator,\n        address borrower,\n        uint256 repayAmount,\n        uint256 seizeTokens\n    );\n\n    /*** Admin Events ***/\n\n    event NewController(address oldController, address newController);\n    event NewMarketInterestRateModel(\n        address oldInterestRateModel,\n        address newInterestRateModel\n    );\n    event NewPlatformReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n    event NewPoolReserveFactor(\n        uint256 oldReserveFactorMantissa,\n        uint256 newReserveFactorMantissa\n    );\n    event PlatformReservesClaimed(\n        address beneficiary,\n        uint256 reduceAmount,\n        uint256 newTotalReserves\n    );\n    event PoolReservesClaimed(\n        address reservePool,\n        uint256 claimedAmount,\n        uint256 poolReservesNew\n    );\n    event NewBeneficiary(\n        address payable oldBeneficiary,\n        address payable newBeneficiary\n    );\n    event NewReservePool(\n        address payable oldReservePool,\n        address payable newReservePool\n    );\n    event NewSlippageTolerrance(\n        uint256 oldSlippageTolerrance,\n        uint256 newSlippageTolerrance\n    );\n\n    // /*** User Interface ***/\n\n    function isLContract() external returns (bool);\n\n    function PROJECT() external returns (string memory);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function borrowRatePerBlock() external view returns (uint256);\n\n    function supplyRatePerBlock() external view returns (uint256);\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function getCash() external view returns (uint256);\n\n    function accrueInterest() external returns (uint256);\n\n    function lToken() external view returns (address);\n\n    function underlyingToken() external view returns (address);\n\n    function controller() external view returns (address);\n\n    function interestRateModel() external view returns (address);\n\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function poolReserveFactorMantissa() external view returns (uint256);\n\n    function platformReserveFactorMantissa() external view returns (uint256);\n\n    function accrualBlockNumber() external view returns (uint256);\n\n    function borrowIndex() external view returns (uint256);\n\n    function totalBorrows() external view returns (uint256);\n\n    function platformReserves() external view returns (uint256);\n\n    function poolReserves() external view returns (uint256);\n\n    function totalReserves() external view returns (uint256);\n\n    function protocolSeizeShareMantissa() external view returns (uint256);\n\n    function beneficiary() external view returns (address payable);\n\n    function reservePool() external view returns (address payable);\n\n    function transferRouter() external view returns (address);\n\n    /*** Admin Functions ***/\n\n    function _setController(address newController) external returns (uint256);\n\n    function _setPlatformReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        returns (uint256);\n\n    function _setPoolReserveFactor(uint256 newReserveFactorMantissa)\n        external\n        returns (uint256);\n\n    function _setInterestRateModel(address newInterestRateModel)\n        external\n        returns (uint256);\n\n    function _setBeneficiary(address payable newBeneficiary)\n        external\n        returns (uint256);\n\n    function _setReservePool(address payable newReservePool)\n        external\n        returns (uint256);\n\n    function setTransferRouter(address newTransferRouter)\n        external\n        returns (uint256);\n\n    function pause() external returns (uint256);\n\n    function unpause() external returns (uint256);\n\n    /*** Protocol Functions ***/\n    function _claimPoolReserves(uint256 claimedAmount)\n        external\n        returns (uint256);\n\n    function _claimPlatformReserves(uint256 claimedAmount)\n        external\n        returns (uint256);\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IYESController {\n    struct Market {\n        bool isListed;\n        mapping(address => bool) accountMembership;\n    }\n\n    event MarketListed(address lToken);\n    event MarketEntered(address lToken, address account);\n    event MarketExited(address lToken, address account);\n    event NewCollateralFactor(\n        uint256 oldCollateralFactorMantissa,\n        uint256 newCollateralFactorMantissa\n    );\n    event NewLiquidationIncentive(\n        uint256 oldLiquidationIncentiveMantissa,\n        uint256 newLiquidationIncentiveMantissa\n    );\n    event NewPriceOracle(address oldPriceOracle, address newPriceOracle);\n    event NewYESVault(address oldYESVault, address newYESVault);\n    event ActionPaused(string action, bool state);\n    event LendingActionPaused(address lToken, string action, bool state);\n\n    function isController() external returns (bool);\n\n    function enterMarkets(address[] calldata lTokens)\n        external\n        returns (uint256[] memory);\n\n    function exitMarket(address lToken) external returns (uint256);\n\n    function depositAllowed(address lToken) external view returns (uint256);\n\n    function withdrawAllowed(address lToken, address withdrawer)\n        external\n        view\n        returns (uint256);\n\n    function borrowAllowed(\n        address lToken,\n        address borrower,\n        uint256 borrowAmount\n    ) external returns (uint256);\n\n    function liquidateBorrowAllowed(address lToken, address borrower)\n        external\n        view\n        returns (uint256);\n\n    function seizeAllowed(address lToken) external view returns (uint256);\n\n    function repayBorrowAllowed(address lToken) external view returns (uint256);\n\n    function getAccountLiquidity(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function liquidateCalculateSeizeTokens(\n        address lToken,\n        uint256 borrowBalance\n    ) external view returns (uint256, uint256);\n\n    function yesVault() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function allMarkets() external view returns (address[] memory);\n\n    function collateralFactorMantissa() external view returns (uint256);\n\n    function liquidationIncentiveMantissa() external view returns (uint256);\n\n    function markets(address lToken, address account)\n        external\n        view\n        returns (bool, bool);\n\n    function accountAssets(address account)\n        external\n        view\n        returns (address[] memory);\n\n    function depositGuardianPaused(address account)\n        external\n        view\n        returns (bool);\n\n    function borrowGuardianPaused(address account) external view returns (bool);\n\n    function seizeGuardianPaused() external view returns (bool);\n\n    function borrowLimitOf(address account) external view returns (uint256);\n\n    function setBorrowPaused(address lContractAddress, bool state)\n        external\n        returns (bool);\n\n    function setDepositPaused(address lContractAddress, bool state)\n        external\n        returns (bool);\n\n    function setSeizePaused(bool state) external returns (bool);\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\ninterface IInterestRateModel {\n    /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n    function isInterestRateModel() external view returns (bool);\n\n    /**\n     * @notice Calculates the current borrow interest rate per block\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves\n    ) external view returns (uint256);\n\n    // /**\n    //   * @notice Calculates the current supply interest rate per block\n    //   * @param cash The total amount of cash the market has\n    //   * @param borrows The total amount of borrows the market has outstanding\n    //   * @param reserves The total amount of reserves the market has\n    //   * @param reserveFactorMantissa The current reserve factor the market has\n    //   * @return The supply rate per block (as a percentage, and scaled by 1e18)\n    //   */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa\n    ) external view returns (uint256);\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ncontract YESControllerErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        CONTROLLER_MISMATCH,\n        INSUFFICIENT_SHORTFALL,\n        INSUFFICIENT_LIQUIDITY,\n        INSUFFICIENT_BORROW_LIMIT,\n        INVALID_CLOSE_FACTOR,\n        INVALID_COLLATERAL_FACTOR,\n        INVALID_LIQUIDATION_INCENTIVE,\n        MARKET_NOT_ENTERED, // no longer possible\n        MARKET_NOT_LISTED,\n        MARKET_ALREADY_LISTED,\n        MATH_ERROR,\n        NONZERO_BORROW_BALANCE,\n        PRICE_ERROR,\n        REJECTION,\n        SNAPSHOT_ERROR,\n        TOO_MANY_ASSETS,\n        TOO_MUCH_REPAY\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n        EXIT_MARKET_BALANCE_OWED,\n        EXIT_MARKET_REJECTION,\n        SET_CLOSE_FACTOR_OWNER_CHECK,\n        SET_CLOSE_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_NO_EXISTS,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n        SET_IMPLEMENTATION_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n        SET_LIQUIDATION_INCENTIVE_VALIDATION,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n        SET_PRICE_ORACLE_OWNER_CHECK,\n        SUPPORT_MARKET_EXISTS,\n        SUPPORT_MARKET_OWNER_CHECK,\n        SET_PAUSE_GUARDIAN_OWNER_CHECK,\n        SET_BYES_TOKEN_CHECK\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), 0);\n\n        return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), opaqueError);\n\n        return uint256(err);\n    }\n}\n\ncontract TokenErrorReporter {\n    enum Error {\n        NO_ERROR,\n        UNAUTHORIZED,\n        BAD_INPUT,\n        CONTROLLER_REJECTION,\n        CONTROLLER_CALCULATION_ERROR,\n        INTEREST_RATE_MODEL_ERROR,\n        INVALID_ACCOUNT_PAIR,\n        INVALID_CLOSE_AMOUNT_REQUESTED,\n        INVALID_COLLATERAL_FACTOR,\n        MATH_ERROR,\n        MARKET_NOT_FRESH,\n        MARKET_NOT_LISTED,\n        TOKEN_INSUFFICIENT_ALLOWANCE,\n        TOKEN_INSUFFICIENT_BALANCE,\n        TOKEN_INSUFFICIENT_CASH,\n        TOKEN_TRANSFER_IN_FAILED,\n        TOKEN_TRANSFER_OUT_FAILED,\n        INVALID_BENEFICIARY,\n        INVALID_RESERVE_POOL,\n        INVALID_MARKET,\n        INVALID_MARKET_IMPL,\n        INVALID_VAULT,\n        INVALID_YES_TOKEN\n    }\n\n    enum FailureInfo {\n        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n        ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n        ACCRUE_INTEREST_BORROW_RATE_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_PLATFORM_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_NEW_POOL_RESERVES_CALCULATION_FAILED,\n        ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        BORROW_ACCRUE_INTEREST_FAILED,\n        BORROW_CASH_NOT_AVAILABLE,\n        BORROW_FRESHNESS_CHECK,\n        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        BORROW_MARKET_NOT_LISTED,\n        BORROW_CONTROLLER_REJECTION,\n        LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED,\n        LIQUIDATE_ACCRUE_COLLATERAL_INTEREST_FAILED,\n        LIQUIDATE_COLLATERAL_FRESHNESS_CHECK,\n        LIQUIDATE_CONTROLLER_REJECTION,\n        LIQUIDATE_CONTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED,\n        LIQUIDATE_CLOSE_AMOUNT_IS_UINT_MAX,\n        LIQUIDATE_CLOSE_AMOUNT_IS_ZERO,\n        LIQUIDATE_FRESHNESS_CHECK,\n        LIQUIDATE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_REPAY_BORROW_FRESH_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_INCREMENT_FAILED,\n        LIQUIDATE_SEIZE_BALANCE_DECREMENT_FAILED,\n        LIQUIDATE_SEIZE_CONTROLLER_REJECTION,\n        LIQUIDATE_SEIZE_LIQUIDATOR_IS_BORROWER,\n        LIQUIDATE_SEIZE_TOO_MUCH,\n        DEPOSIT_ACCRUE_INTEREST_FAILED,\n        DEPOSIT_CONTROLLER_REJECTION,\n        DEPOSIT_EXCHANGE_CALCULATION_FAILED,\n        DEPOSIT_EXCHANGE_RATE_READ_FAILED,\n        DEPOSIT_FRESHNESS_CHECK,\n        DEPOSIT_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        DEPOSIT_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        DEPOSIT_TRANSFER_IN_FAILED,\n        DEPOSIT_TRANSFER_IN_NOT_POSSIBLE,\n        WITHDRAW_ACCRUE_INTEREST_FAILED,\n        WITHDRAW_CONTROLLER_REJECTION,\n        WITHDRAW_EXCHANGE_TOKENS_CALCULATION_FAILED,\n        WITHDRAW_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n        WITHDRAW_EXCHANGE_RATE_READ_FAILED,\n        WITHDRAW_FRESHNESS_CHECK,\n        WITHDRAW_NEW_ACCOUNT_BALANCE_CALCULATION_FAILED,\n        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE,\n        CLAIM_PLATFORM_RESERVES_ACCRUE_INTEREST_FAILED,\n        CLAIM_POOL_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_POOL_RESERVES_ACCRUE_INTEREST_FAILED,\n        CLAIM_PLATFORM_RESERVES_ADMIN_CHECK,\n        REDUCE_POOL_RESERVES_ADMIN_CHECK,\n        CLAIM_PLATFORM_RESERVES_CASH_NOT_AVAILABLE,\n        REDUCE_POOL_RESERVES_CASH_NOT_AVAILABLE,\n        CLAIM_PLATFORM_RESERVES_FRESH_CHECK,\n        REDUCE_POOL_RESERVES_FRESH_CHECK,\n        CLAIM_PLATFORM_RESERVES_VALIDATION,\n        REDUCE_POOL_RESERVES_VALIDATION,\n        REPAY_BEHALF_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCRUE_INTEREST_FAILED,\n        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_CONTROLLER_REJECTION,\n        REPAY_BORROW_FRESHNESS_CHECK,\n        REPAY_BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n        SET_COLLATERAL_FACTOR_OWNER_CHECK,\n        SET_COLLATERAL_FACTOR_VALIDATION,\n        SET_CONTROLLER_OWNER_CHECK,\n        SET_CONTROLLER_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED,\n        SET_INTEREST_RATE_MODEL_FRESH_CHECK,\n        SET_INTEREST_RATE_MODEL_OWNER_CHECK,\n        SET_MAX_ASSETS_OWNER_CHECK,\n        SET_ORACLE_MARKET_NOT_LISTED,\n        SET_PENDING_ADMIN_OWNER_CHECK,\n        SET_PLATFORM_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_POOL_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_FACTOR_ADMIN_CHECK,\n        SET_PLATFORM_RESERVE_FACTOR_FRESH_CHECK,\n        SET_POOL_RESERVE_FACTOR_FRESH_CHECK,\n        SET_PLATFORM_RESERVE_FACTOR_BOUNDS_CHECK,\n        SET_POOL_RESERVE_FACTOR_BOUNDS_CHECK,\n        TRANSFER_CONTROLLER_REJECTION,\n        TRANSFER_NOT_ALLOWED,\n        TRANSFER_NOT_ENOUGH,\n        TRANSFER_TOO_MUCH,\n        ADD_PLATFORM_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_POOL_RESERVES_ACCRUE_INTEREST_FAILED,\n        ADD_PLATFORM_RESERVES_FRESH_CHECK,\n        ADD_POOL_RESERVES_FRESH_CHECK,\n        ADD_PLATFORM_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        ADD_POOL_RESERVES_TRANSFER_IN_NOT_POSSIBLE,\n        CLAIM_PLATFORM_RESERVES_INVALID_BENEFICIARY,\n        CLAIM_POOL_RESERVES_INVALID_RESERVE_POOL,\n        CLAIM_POOL_RESERVES_VALIDATION,\n        SET_BENEFICIARY_ACCRUE_INTEREST_FAILED,\n        SET_BENEFICIARY_FRESH_CHECK,\n        SET_RESERVE_POOL_ACCRUE_INTEREST_FAILED,\n        SET_RESERVE_POOL_FRESH_CHECK,\n        SET_SLIPPAGE_TOLERRANCE_ACCRUE_INTEREST_FAILED,\n        SET_SLIPPAGE_TOLERRANCE_FRESH_CHECK,\n        LIQUIDATE_BORROW_BALANCE_ERROR,\n        PAUSE_ACCRUE_INTEREST_FAILED,\n        UNPAUSE_ACCRUE_INTEREST_FAILED\n    }\n\n    /**\n     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n     **/\n    event Failure(uint256 error, uint256 info, uint256 detail);\n\n    /**\n     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n     */\n    function fail(Error err, FailureInfo info) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), 0);\n\n        return uint256(err);\n    }\n\n    /**\n     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n     */\n    function failOpaque(\n        Error err,\n        FailureInfo info,\n        uint256 opaqueError\n    ) internal returns (uint256) {\n        emit Failure(uint256(err), uint256(info), opaqueError);\n\n        return uint256(err);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title Careful Math\n * @author Compound\n * @notice Derived from OpenZeppelin's SafeMath library\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n */\ncontract CarefulMath {\n    /**\n     * @dev Possible error codes that we can return\n     */\n    enum MathError {\n        NO_ERROR,\n        DIVISION_BY_ZERO,\n        INTEGER_OVERFLOW,\n        INTEGER_UNDERFLOW\n    }\n\n    /**\n     * @dev Multiplies two numbers, returns an error on overflow.\n     */\n    function mulUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (a == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        uint256 c = a * b;\n\n        if (c / a != b) {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        } else {\n            return (MathError.NO_ERROR, c);\n        }\n    }\n\n    /**\n     * @dev Integer division of two numbers, truncating the quotient.\n     */\n    function divUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b == 0) {\n            return (MathError.DIVISION_BY_ZERO, 0);\n        }\n\n        return (MathError.NO_ERROR, a / b);\n    }\n\n    /**\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function subUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        if (b <= a) {\n            return (MathError.NO_ERROR, a - b);\n        } else {\n            return (MathError.INTEGER_UNDERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev Adds two numbers, returns an error on overflow.\n     */\n    function addUInt(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        uint256 c = a + b;\n\n        if (c >= a) {\n            return (MathError.NO_ERROR, c);\n        } else {\n            return (MathError.INTEGER_OVERFLOW, 0);\n        }\n    }\n\n    /**\n     * @dev add a and b and then subtract c\n     */\n    function addThenSubUInt(\n        uint256 a,\n        uint256 b,\n        uint256 c\n    ) internal pure returns (MathError, uint256) {\n        (MathError err0, uint256 sum) = addUInt(a, b);\n\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, 0);\n        }\n\n        return subUInt(sum, c);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n    uint256 constant expScale = 1e18;\n    uint256 constant doubleScale = 1e36;\n    uint256 constant halfExpScale = expScale / 2;\n    uint256 constant mantissaOne = expScale;\n\n    struct Exp {\n        uint256 mantissa;\n    }\n\n    struct Double {\n        uint256 mantissa;\n    }\n\n    /**\n     * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n    function truncate(Exp memory exp) internal pure returns (uint256) {\n        // Note: We are not using careful math here as we're performing a division that cannot fail\n        return exp.mantissa / expScale;\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (uint256)\n    {\n        Exp memory product = mul_(a, scalar);\n        return truncate(product);\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mul_ScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (uint256) {\n        Exp memory product = mul_(a, scalar);\n        return add_(truncate(product), addend);\n    }\n\n    /**\n     * @dev Checks if first Exp is less than second Exp.\n     */\n    function lessThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa < right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp <= right Exp.\n     */\n    function lessThanOrEqualExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa <= right.mantissa;\n    }\n\n    /**\n     * @dev Checks if left Exp > right Exp.\n     */\n    function greaterThanExp(Exp memory left, Exp memory right)\n        internal\n        pure\n        returns (bool)\n    {\n        return left.mantissa > right.mantissa;\n    }\n\n    /**\n     * @dev returns true if Exp is exactly zero\n     */\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\n        return value.mantissa == 0;\n    }\n\n    function safe224(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint224)\n    {\n        require(n < 2**224, errorMessage);\n        return uint224(n);\n    }\n\n    function safe32(uint256 n, string memory errorMessage)\n        internal\n        pure\n        returns (uint32)\n    {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function add_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\n    }\n\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return add_(a, b, \"addition overflow\");\n    }\n\n    function add_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\n    }\n\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub_(a, b, \"subtraction underflow\");\n    }\n\n    function sub_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function mul_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\n    }\n\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / expScale;\n    }\n\n    function mul_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\n    }\n\n    function mul_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: mul_(a.mantissa, b)});\n    }\n\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return mul_(a, b.mantissa) / doubleScale;\n    }\n\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mul_(a, b, \"multiplication overflow\");\n    }\n\n    function mul_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        if (a == 0 || b == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, errorMessage);\n        return c;\n    }\n\n    function div_(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (Exp memory)\n    {\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\n    }\n\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\n        return Exp({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\n        return div_(mul_(a, expScale), b.mantissa);\n    }\n\n    function div_(Double memory a, Double memory b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return\n            Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n    }\n\n    function div_(Double memory a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(a.mantissa, b)});\n    }\n\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\n        return div_(mul_(a, doubleScale), b.mantissa);\n    }\n\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div_(a, b, \"divide by zero\");\n    }\n\n    function div_(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    function fraction(uint256 a, uint256 b)\n        internal\n        pure\n        returns (Double memory)\n    {\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\n    }\n}\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract Exponential is CarefulMath, ExponentialNoError {\n    /**\n     * @dev Creates an exponential from numerator and denominator values.\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n     *            or if `denom` is zero.\n     */\n    function getExp(uint256 num, uint256 denom)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n    }\n\n    /**\n     * @dev Adds two exponentials, returning a new exponential.\n     */\n    function addExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Subtracts two exponentials, returning a new exponential.\n     */\n    function subExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\n\n        return (error, Exp({mantissa: result}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\n     */\n    function mulScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n    function mulScalarTruncate(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(product));\n    }\n\n    /**\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n    function mulScalarTruncateAddUInt(\n        Exp memory a,\n        uint256 scalar,\n        uint256 addend\n    ) internal pure returns (MathError, uint256) {\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return addUInt(truncate(product), addend);\n    }\n\n    /**\n     * @dev Divide an Exp by a scalar, returning a new Exp.\n     */\n    function divScalar(Exp memory a, uint256 scalar)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 descaledMantissa) = divUInt(\n            a.mantissa,\n            scalar\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, returning a new Exp.\n     */\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        /*\n          We are doing this as:\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n          How it works:\n          Exp = a / b;\n          Scalar = s;\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n        */\n        (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n        return getExp(numerator, divisor.mantissa);\n    }\n\n    /**\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n     */\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\n        internal\n        pure\n        returns (MathError, uint256)\n    {\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n        if (err != MathError.NO_ERROR) {\n            return (err, 0);\n        }\n\n        return (MathError.NO_ERROR, truncate(fraction));\n    }\n\n    /**\n     * @dev Multiplies two exponentials, returning a new exponential.\n     */\n    function mulExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(\n            a.mantissa,\n            b.mantissa\n        );\n        if (err0 != MathError.NO_ERROR) {\n            return (err0, Exp({mantissa: 0}));\n        }\n\n        // We add half the scale before dividing so that we get rounding instead of truncation.\n        //  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) = addUInt(\n            halfExpScale,\n            doubleScaledProduct\n        );\n        if (err1 != MathError.NO_ERROR) {\n            return (err1, Exp({mantissa: 0}));\n        }\n\n        (MathError err2, uint256 product) = divUInt(\n            doubleScaledProductWithHalfScale,\n            expScale\n        );\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n        assert(err2 == MathError.NO_ERROR);\n\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\n    }\n\n    /**\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n     */\n    function mulExp(uint256 a, uint256 b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n    }\n\n    /**\n     * @dev Multiplies three exponentials, returning a new exponential.\n     */\n    function mulExp3(\n        Exp memory a,\n        Exp memory b,\n        Exp memory c\n    ) internal pure returns (MathError, Exp memory) {\n        (MathError err, Exp memory ab) = mulExp(a, b);\n        if (err != MathError.NO_ERROR) {\n            return (err, ab);\n        }\n        return mulExp(ab, c);\n    }\n\n    /**\n     * @dev Divides two exponentials, returning a new exponential.\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n     */\n    function divExp(Exp memory a, Exp memory b)\n        internal\n        pure\n        returns (MathError, Exp memory)\n    {\n        return getExp(a.mantissa, b.mantissa);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface INextTransferRouter {\n  function transferFrom(\n    string memory _project,\n    address _token,\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.0 (security/ReentrancyGuard.sol)\n\npragma solidity 0.8.11;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface ISuperAdmin {\n    event NewPendingSuperAdmin(address pendingSuperAdmin);\n    event NewSuperAdmin(address superAdmin);\n\n    function superAdmin() external view returns (address);\n\n    function pendingSuperAdmin() external view returns (address);\n\n    function setPendingSuperAdmin(address _pendingSuperAdmin) external;\n\n    function acceptSuperAdmin() external;\n}\n\ncontract SuperAdmin is ISuperAdmin {\n    address public override superAdmin;\n    address public override pendingSuperAdmin;\n\n    modifier onlySuperAdmin() {\n        require(msg.sender == superAdmin, \"Only Super Admin\");\n        _;\n    }\n\n    modifier onlyPendingSuperAdmin() {\n        require(msg.sender == pendingSuperAdmin, \"Only Pending Super Admin\");\n        _;\n    }\n\n    constructor(address superAdmin_) {\n        superAdmin = superAdmin_;\n    }\n\n    function setPendingSuperAdmin(address _pendingSuperAdmin)\n        public\n        onlySuperAdmin\n    {\n        pendingSuperAdmin = _pendingSuperAdmin;\n\n        emit NewPendingSuperAdmin(pendingSuperAdmin);\n    }\n\n    function acceptSuperAdmin() public onlyPendingSuperAdmin {\n        superAdmin = msg.sender;\n        pendingSuperAdmin = address(0);\n\n        emit NewSuperAdmin(superAdmin);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity 0.8.11;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IBKNextCallHelper {\n    event CallHelperSet(address oldCallHelper, address newCallHelper);\n\n    function callHelper() external returns (address);\n\n    function setCallHelper(address _addr) external;\n}\n\ncontract BKNextCallHelper is IBKNextCallHelper {\n    address public override callHelper;\n\n    modifier onlyCallHelper() {\n        require(msg.sender == callHelper, \"Only Callhelper\");\n        _;\n    }\n\n    constructor(address callHelper_) {\n        callHelper = callHelper_;\n    }\n\n    function setCallHelper(address _addr) external override onlyCallHelper {\n        address oldCallHelper = callHelper;\n        callHelper = _addr;\n        emit CallHelperSet(oldCallHelper, callHelper);\n    }\n}\n\nabstract contract LendingStorage is\n    ILending,\n    TokenErrorReporter,\n    Exponential,\n    ReentrancyGuard,\n    SuperAdmin,\n    BKNextCallHelper,\n    Committee\n{\n    string public constant override PROJECT = \"bitkub-next-yuemmai\";\n    bool public constant override isLContract = true;\n\n    address public override underlyingToken;\n\n    uint256 public override poolReserveFactorMantissa = 0.1e18; // 10%\n    uint256 public override platformReserveFactorMantissa = 0.1e18; // 10%\n    uint256 public override accrualBlockNumber;\n    uint256 public override borrowIndex;\n    uint256 public override totalBorrows;\n    uint256 public override poolReserves;\n    uint256 public override platformReserves;\n\n    address payable public override beneficiary;\n    address payable public override reservePool;\n\n    uint256 public constant override protocolSeizeShareMantissa = 2.8e16; //2.8%\n\n    uint256 internal initialExchangeRateMantissa;\n    uint256 internal constant borrowRateMaxMantissa = 0.0005e16;\n    uint256 internal constant reserveFactorMaxMantissa = 1e18;\n\n    LToken internal _lToken;\n    IYESController internal _controller;\n    IInterestRateModel internal _interestRateModel;\n    INextTransferRouter internal _transferRouter;\n\n    struct ConstructorArgs {\n        address underlyingToken;\n        address controller;\n        address interestRateModel;\n        uint256 initialExchangeRateMantissa;\n        address payable beneficiary;\n        address payable poolReserve;\n        string lTokenName;\n        string lTokenSymbol;\n        uint8 lTokenDecimals;\n        address superAdmin;\n        address callHelper;\n        address committee;\n        address adminRouter;\n        address transferRouter;\n        address kyc;\n        uint256 acceptedKYCLevel;\n    }\n\n    struct BorrowSnapshot {\n        uint256 principal;\n        uint256 interestIndex;\n    }\n\n    mapping(address => BorrowSnapshot) internal accountBorrows;\n\n    enum TransferMethod {\n        METAMASK,\n        BK_NEXT\n    }\n}\n\nabstract contract LendingGetter is LendingStorage {\n    function exchangeRateStored() public view override returns (uint256) {\n        (MathError err, uint256 result) = exchangeRateStoredInternal();\n        require(err == MathError.NO_ERROR, \"Math error\");\n        return result;\n    }\n\n    function exchangeRateStoredInternal()\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        uint256 _totalSupply = _lToken.totalSupply();\n        if (_totalSupply == 0) {\n            return (MathError.NO_ERROR, initialExchangeRateMantissa);\n        } else {\n            uint256 totalCash = getCashPrior();\n            uint256 cashPlusBorrowsMinusReserves;\n            Exp memory exchangeRate;\n            MathError mathErr;\n\n            (mathErr, cashPlusBorrowsMinusReserves) = addThenSubUInt(\n                totalCash,\n                totalBorrows,\n                totalReserves()\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            (mathErr, exchangeRate) = getExp(\n                cashPlusBorrowsMinusReserves,\n                _totalSupply\n            );\n            if (mathErr != MathError.NO_ERROR) {\n                return (mathErr, 0);\n            }\n\n            return (MathError.NO_ERROR, exchangeRate.mantissa);\n        }\n    }\n\n    function borrowBalanceStored(address account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        (MathError err, uint256 result) = borrowBalanceStoredInternal(account);\n        require(err == MathError.NO_ERROR, \"Math error\");\n        return result;\n    }\n\n    function borrowBalanceStoredInternal(address account)\n        internal\n        view\n        returns (MathError, uint256)\n    {\n        MathError mathErr;\n        uint256 principalTimesIndex;\n        uint256 result;\n\n        BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n        if (borrowSnapshot.principal == 0) {\n            return (MathError.NO_ERROR, 0);\n        }\n\n        (mathErr, principalTimesIndex) = mulUInt(\n            borrowSnapshot.principal,\n            borrowIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        (mathErr, result) = divUInt(\n            principalTimesIndex,\n            borrowSnapshot.interestIndex\n        );\n        if (mathErr != MathError.NO_ERROR) {\n            return (mathErr, 0);\n        }\n\n        return (MathError.NO_ERROR, result);\n    }\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 lTokenBalance = _lToken.balanceOf(account);\n        uint256 borrowBalance;\n        uint256 exchangeRateMantissa;\n\n        MathError mErr;\n\n        (mErr, borrowBalance) = borrowBalanceStoredInternal(account);\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        (mErr, exchangeRateMantissa) = exchangeRateStoredInternal();\n        if (mErr != MathError.NO_ERROR) {\n            return (uint256(Error.MATH_ERROR), 0, 0, 0);\n        }\n\n        return (\n            uint256(Error.NO_ERROR),\n            lTokenBalance,\n            borrowBalance,\n            exchangeRateMantissa\n        );\n    }\n\n    function borrowRatePerBlock() external view override returns (uint256) {\n        return\n            _interestRateModel.getBorrowRate(\n                getCashPrior(),\n                totalBorrows,\n                totalReserves()\n            );\n    }\n\n    function supplyRatePerBlock() external view override returns (uint256) {\n        return\n            _interestRateModel.getSupplyRate(\n                getCashPrior(),\n                totalBorrows,\n                totalReserves(),\n                reserveFactorMantissa()\n            );\n    }\n\n    function reserveFactorMantissa() public view override returns (uint256) {\n        uint256 sumReserveFactorMantissa = platformReserveFactorMantissa +\n            poolReserveFactorMantissa;\n        require(\n            sumReserveFactorMantissa >= platformReserveFactorMantissa,\n            \"Overflow\"\n        );\n        return sumReserveFactorMantissa;\n    }\n\n    function totalReserves() public view override returns (uint256) {\n        uint256 sumReserves = platformReserves + poolReserves;\n        require(sumReserves >= platformReserves, \"Overflow\");\n        return sumReserves;\n    }\n\n    function controller() external view override returns (address) {\n        return address(_controller);\n    }\n\n    function lToken() external view override returns (address) {\n        return address(_lToken);\n    }\n\n    function transferRouter() external view override returns (address) {\n        return address(_transferRouter);\n    }\n\n    function interestRateModel() external view override returns (address) {\n        return address(_interestRateModel);\n    }\n\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    function getCash() external view override returns (uint256) {\n        return getCashPrior();\n    }\n\n    function getCashPrior() internal view virtual returns (uint256);\n}\n\nabstract contract LendingInterest is LendingGetter {\n    struct AccrueInterestLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 currentBlockNumber;\n        uint256 accrualBlockNumberPrior;\n        uint256 cashPrior;\n        uint256 borrowsPrior;\n        uint256 poolReservesPrior;\n        uint256 platformReservesPrior;\n        uint256 totalReservesPrior;\n        uint256 borrowIndexPrior;\n        uint256 borrowRateMantissa;\n        uint256 blockDelta;\n    }\n\n    function accrueInterest() public override returns (uint256) {\n        AccrueInterestLocalVars memory vars;\n\n        vars.currentBlockNumber = getBlockNumber();\n        vars.accrualBlockNumberPrior = accrualBlockNumber;\n\n        if (vars.accrualBlockNumberPrior == vars.currentBlockNumber) {\n            return uint256(Error.NO_ERROR);\n        }\n\n        vars.cashPrior = getCashPrior();\n        vars.borrowsPrior = totalBorrows;\n        vars.poolReservesPrior = poolReserves;\n        vars.platformReservesPrior = platformReserves;\n        vars.borrowIndexPrior = borrowIndex;\n\n        vars.borrowRateMantissa = _interestRateModel.getBorrowRate(\n            vars.cashPrior,\n            vars.borrowsPrior,\n            totalReserves()\n        );\n\n        require(\n            vars.borrowRateMantissa <= borrowRateMaxMantissa,\n            \"Too high borrow rate\"\n        );\n\n        (vars.mathErr, vars.blockDelta) = subUInt(\n            vars.currentBlockNumber,\n            vars.accrualBlockNumberPrior\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Calculate block delta failed\"\n        );\n\n        Exp memory simpleInterestFactor;\n        uint256 interestAccumulated;\n        uint256 totalBorrowsNew;\n        uint256 platformReservesNew;\n        uint256 poolReservesNew;\n        uint256 borrowIndexNew;\n\n        (vars.mathErr, simpleInterestFactor) = mulScalar(\n            Exp({mantissa: vars.borrowRateMantissa}),\n            vars.blockDelta\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_SIMPLE_INTEREST_FACTOR_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, interestAccumulated) = mulScalarTruncate(\n            simpleInterestFactor,\n            vars.borrowsPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_ACCUMULATED_INTEREST_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, totalBorrowsNew) = addUInt(\n            interestAccumulated,\n            vars.borrowsPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_TOTAL_BORROWS_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, platformReservesNew) = mulScalarTruncateAddUInt(\n            Exp({mantissa: platformReserveFactorMantissa}),\n            interestAccumulated,\n            vars.platformReservesPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_PLATFORM_RESERVES_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, poolReservesNew) = mulScalarTruncateAddUInt(\n            Exp({mantissa: poolReserveFactorMantissa}),\n            interestAccumulated,\n            vars.poolReservesPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_PLATFORM_RESERVES_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, borrowIndexNew) = mulScalarTruncateAddUInt(\n            simpleInterestFactor,\n            vars.borrowIndexPrior,\n            vars.borrowIndexPrior\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .ACCRUE_INTEREST_NEW_BORROW_INDEX_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        accrualBlockNumber = vars.currentBlockNumber;\n        borrowIndex = borrowIndexNew;\n        totalBorrows = totalBorrowsNew;\n        platformReserves = platformReservesNew;\n        poolReserves = poolReservesNew;\n\n        emit AccrueInterest(\n            vars.cashPrior,\n            interestAccumulated,\n            borrowIndexNew,\n            totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n}\n\nabstract contract LendingSetter is LendingInterest {\n    function _setController(address newController)\n        public\n        override\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_CONTROLLER_RATE_MODEL_ACCRUE_INTEREST_FAILED\n                );\n        }\n\n        return _setControllerFresh(newController);\n    }\n\n    function _setControllerFresh(address newController)\n        internal\n        returns (uint256)\n    {\n        IYESController oldController = _controller;\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\n                );\n        }\n\n        _controller = IYESController(newController);\n\n        require(_controller.isController(), \"Controller error\");\n\n        emit NewController(address(oldController), newController);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setInterestRateModel(address newInterestRateModel)\n        public\n        override\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_INTEREST_RATE_MODEL_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setInterestRateModelFresh(newInterestRateModel);\n    }\n\n    function _setInterestRateModelFresh(address newInterestRateModel)\n        internal\n        returns (uint256)\n    {\n        IInterestRateModel oldInterestRateModel;\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_INTEREST_RATE_MODEL_FRESH_CHECK\n                );\n        }\n\n        oldInterestRateModel = _interestRateModel;\n        _interestRateModel = IInterestRateModel(newInterestRateModel);\n\n        require(\n            _interestRateModel.isInterestRateModel(),\n            \"Interest model error\"\n        );\n\n        emit NewMarketInterestRateModel(\n            address(oldInterestRateModel),\n            newInterestRateModel\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setPlatformReserveFactor(uint256 newPlatformReserveFactorMantissa)\n        external\n        override\n        nonReentrant\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo\n                        .SET_PLATFORM_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setPlatformReserveFactorFresh(newPlatformReserveFactorMantissa);\n    }\n\n    function _setPlatformReserveFactorFresh(\n        uint256 newPlatformReserveFactorMantissa\n    ) internal returns (uint256) {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_PLATFORM_RESERVE_FACTOR_FRESH_CHECK\n                );\n        }\n\n        uint256 newTotalReserveFactorMantissa = newPlatformReserveFactorMantissa +\n                poolReserveFactorMantissa;\n\n        if (newTotalReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.SET_PLATFORM_RESERVE_FACTOR_BOUNDS_CHECK\n                );\n        }\n\n        uint256 oldPlatformReserveFactorMantissa = platformReserveFactorMantissa;\n        platformReserveFactorMantissa = newPlatformReserveFactorMantissa;\n\n        emit NewPlatformReserveFactor(\n            oldPlatformReserveFactorMantissa,\n            newPlatformReserveFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setPoolReserveFactor(uint256 newPoolReserveFactorMantissa)\n        external\n        override\n        nonReentrant\n        onlySuperAdmin\n        returns (uint256)\n    {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_POOL_RESERVE_FACTOR_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setPoolReserveFactorFresh(newPoolReserveFactorMantissa);\n    }\n\n    function _setPoolReserveFactorFresh(uint256 newPoolReserveFactorMantissa)\n        internal\n        returns (uint256)\n    {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_POOL_RESERVE_FACTOR_FRESH_CHECK\n                );\n        }\n\n        uint256 newTotalReserveFactorMantissa = platformReserveFactorMantissa +\n            newPoolReserveFactorMantissa;\n        if (newTotalReserveFactorMantissa > reserveFactorMaxMantissa) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.SET_POOL_RESERVE_FACTOR_BOUNDS_CHECK\n                );\n        }\n\n        uint256 oldPoolReserveFactorMantissa = poolReserveFactorMantissa;\n        poolReserveFactorMantissa = newPoolReserveFactorMantissa;\n\n        emit NewPoolReserveFactor(\n            oldPoolReserveFactorMantissa,\n            newPoolReserveFactorMantissa\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setBeneficiary(address payable newBeneficiary)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(msg.sender == beneficiary, \"Only beneficiary\");\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_BENEFICIARY_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setBeneficiaryFresh(newBeneficiary);\n    }\n\n    function _setBeneficiaryFresh(address payable newBeneficiary)\n        internal\n        returns (uint256)\n    {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_BENEFICIARY_FRESH_CHECK\n                );\n        }\n\n        address payable oldBeneficiary = beneficiary;\n        beneficiary = newBeneficiary;\n\n        emit NewBeneficiary(oldBeneficiary, newBeneficiary);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setReservePool(address payable newReservePool)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(msg.sender == reservePool, \"Only reserve pool\");\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(\n                    Error(error),\n                    FailureInfo.SET_RESERVE_POOL_ACCRUE_INTEREST_FAILED\n                );\n        }\n        return _setReservePoolFresh(newReservePool);\n    }\n\n    function setTransferRouter(address newTransferRouter)\n        external\n        override\n        onlyCommittee\n        returns (uint256)\n    {\n        _transferRouter = INextTransferRouter(newTransferRouter);\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _setReservePoolFresh(address payable newReservePool)\n        internal\n        returns (uint256)\n    {\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.SET_RESERVE_POOL_FRESH_CHECK\n                );\n        }\n\n        address payable oldReservePool = reservePool;\n        reservePool = newReservePool;\n\n        emit NewReservePool(oldReservePool, newReservePool);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function pause() external override onlySuperAdmin returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return fail(Error(error), FailureInfo.PAUSE_ACCRUE_INTEREST_FAILED);\n        }\n        _lToken.pause();\n        return uint256(Error.NO_ERROR);\n    }\n\n    function unpause() external override onlySuperAdmin returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.UNPAUSE_ACCRUE_INTEREST_FAILED);\n        }\n        _lToken.unpause();\n        return uint256(Error.NO_ERROR);\n    }\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IYESVault {\n    event Airdrop(address beneficiary, uint256 amount);\n    event BorrowLimitUpdated(\n        address account,\n        uint256 oldAmount,\n        uint256 newAmount\n    );\n    event Deposit(address sender, uint256 amount);\n    event Withdraw(address sender, uint256 amount);\n\n    function PROJECT() external view returns (string memory);\n\n    function borrowLimitOf(address account) external view returns (uint256);\n\n    function tokensOf(address account) external view returns (uint256);\n\n    function releasedTo(address account) external view returns (uint256);\n\n    function controller() external view returns (address);\n\n    function yesToken() external view returns (address);\n\n    function marketImpl() external view returns (address);\n\n    function market() external view returns (address);\n\n    function totalAllocated() external view returns (uint256);\n\n    function admin() external view returns (address);\n\n    function transferRouter() external view returns (address);\n\n    function airdrop(address beneficiary, uint256 amount) external;\n\n    function setBorrowLimit(address account, uint256 newAmount) external;\n\n    function deposit(uint256 amount, address sender) external;\n\n    function withdraw(uint256 amount, address sender) external;\n\n    function sellMarket(\n        address borrower,\n        uint256 amount,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /*** Admin Events ***/\n\n    event NewController(address oldController, address newController);\n    event NewYESToken(address oldYESToken, address newYESToken);\n    event NewMarketImpl(address oldMarketImpl, address newMarketImpl);\n    event NewMarket(address oldMarket, address newMarket);\n    event NewSlippageTolerrance(uint256 oldTolerrance, uint256 newTolerrance);\n    event NewAdmin(address oldAdmin, address newAdmin);\n\n    /*** Admin Functions ***/\n\n    function setController(address newController) external;\n\n    function setMarketImpl(address newMarketImpl) external;\n\n    function setMarket(address newMarket) external;\n\n    function setTransferRouter(address newTransferRouter) external;\n\n    function setAdmin(address newAdmin) external;\n}\n\nabstract contract LendingContract is LendingSetter {\n    constructor(ConstructorArgs memory args)\n        SuperAdmin(args.superAdmin)\n        BKNextCallHelper(args.callHelper)\n    {\n        require(args.initialExchangeRateMantissa > 0, \"Invalid exchange rate\");\n        initialExchangeRateMantissa = args.initialExchangeRateMantissa;\n\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        uint256 err1 = _setControllerFresh(args.controller);\n        require(err1 == uint256(Error.NO_ERROR), \"Controller failed\");\n\n        uint256 err2 = _setInterestRateModelFresh(args.interestRateModel);\n        require(err2 == uint256(Error.NO_ERROR), \"Interest model failed\");\n\n        uint256 err3 = _setBeneficiaryFresh(args.beneficiary);\n        require(err3 == uint256(Error.NO_ERROR), \"Beneficiary failed\");\n\n        uint256 err4 = _setReservePoolFresh(args.poolReserve);\n        require(err4 == uint256(Error.NO_ERROR), \"Reserve pool failed\");\n\n        _transferRouter = INextTransferRouter(args.transferRouter);\n\n        underlyingToken = args.underlyingToken;\n        committee = args.committee;\n        IKAP20(underlyingToken).totalSupply();\n\n        _lToken = new LToken(\n            args.lTokenName,\n            args.lTokenSymbol,\n            args.lTokenDecimals,\n            args.kyc,\n            args.adminRouter,\n            args.committee,\n            args.transferRouter,\n            args.acceptedKYCLevel\n        );\n    }\n\n    function depositInternal(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(Error(error), FailureInfo.DEPOSIT_ACCRUE_INTEREST_FAILED),\n                0\n            );\n        }\n        return depositFresh(user, depositAmount, method);\n    }\n\n    struct DepositLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 mintTokens;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n        uint256 actualDepositAmount;\n    }\n\n    function depositFresh(\n        address user,\n        uint256 depositAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.depositAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.DEPOSIT_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.DEPOSIT_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        DepositLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.DEPOSIT_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        vars.actualDepositAmount = doTransferIn(user, depositAmount, method);\n\n        (vars.mathErr, vars.mintTokens) = divScalarByExpTruncate(\n            vars.actualDepositAmount,\n            Exp({mantissa: vars.exchangeRateMantissa})\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Exchange calculate failed\"\n        );\n\n        _lToken.mint(user, vars.mintTokens);\n\n        emit Deposit(user, vars.actualDepositAmount, vars.mintTokens);\n\n        return (uint256(Error.NO_ERROR), vars.actualDepositAmount);\n    }\n\n    function withdrawInternal(\n        address payable user,\n        uint256 withdrawTokens,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, withdrawTokens, 0, method);\n    }\n\n    function withdrawUnderlyingInternal(\n        address payable user,\n        uint256 withdrawAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.WITHDRAW_ACCRUE_INTEREST_FAILED);\n        }\n        return withdrawFresh(user, 0, withdrawAmount, method);\n    }\n\n    struct WithdrawLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 exchangeRateMantissa;\n        uint256 withdrawTokens;\n        uint256 withdrawAmount;\n        uint256 totalSupplyNew;\n        uint256 accountTokensNew;\n    }\n\n    function withdrawFresh(\n        address payable user,\n        uint256 withdrawTokensIn,\n        uint256 withdrawAmountIn,\n        TransferMethod method\n    ) internal returns (uint256) {\n        require(\n            withdrawTokensIn == 0 || withdrawAmountIn == 0,\n            \"Must have a zero input\"\n        );\n\n        WithdrawLocalVars memory vars;\n\n        (\n            vars.mathErr,\n            vars.exchangeRateMantissa\n        ) = exchangeRateStoredInternal();\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.WITHDRAW_EXCHANGE_RATE_READ_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        if (withdrawTokensIn > 0) {\n            vars.withdrawTokens = withdrawTokensIn;\n\n            (vars.mathErr, vars.withdrawAmount) = mulScalarTruncate(\n                Exp({mantissa: vars.exchangeRateMantissa}),\n                withdrawTokensIn\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_TOKENS_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n        } else {\n            (vars.mathErr, vars.withdrawTokens) = divScalarByExpTruncate(\n                withdrawAmountIn,\n                Exp({mantissa: vars.exchangeRateMantissa})\n            );\n            if (vars.mathErr != MathError.NO_ERROR) {\n                return\n                    failOpaque(\n                        Error.MATH_ERROR,\n                        FailureInfo.WITHDRAW_EXCHANGE_AMOUNT_CALCULATION_FAILED,\n                        uint256(vars.mathErr)\n                    );\n            }\n\n            vars.withdrawAmount = withdrawAmountIn;\n        }\n\n        uint256 allowed = _controller.withdrawAllowed(address(this), user);\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.WITHDRAW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.WITHDRAW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < vars.withdrawAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n                );\n        }\n\n        _lToken.burn(user, vars.withdrawTokens);\n\n        doTransferOut(user, vars.withdrawAmount, method);\n\n        emit Withdraw(user, vars.withdrawAmount, vars.withdrawTokens);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function borrowInternal(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return\n                fail(Error(error), FailureInfo.BORROW_ACCRUE_INTEREST_FAILED);\n        }\n        return borrowFresh(borrower, borrowAmount, method);\n    }\n\n    struct BorrowLocalVars {\n        MathError mathErr;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n    }\n\n    function borrowFresh(\n        address payable borrower,\n        uint256 borrowAmount,\n        TransferMethod method\n    ) internal returns (uint256) {\n        uint256 allowed = _controller.borrowAllowed(\n            address(this),\n            borrower,\n            borrowAmount\n        );\n        if (allowed != 0) {\n            return\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.BORROW_CONTROLLER_REJECTION,\n                    allowed\n                );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.BORROW_FRESHNESS_CHECK\n                );\n        }\n\n        if (getCashPrior() < borrowAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.BORROW_CASH_NOT_AVAILABLE\n                );\n        }\n\n        BorrowLocalVars memory vars;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = addUInt(\n            vars.accountBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .BORROW_NEW_ACCOUNT_BORROW_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        (vars.mathErr, vars.totalBorrowsNew) = addUInt(\n            totalBorrows,\n            borrowAmount\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                );\n        }\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        doTransferOut(borrower, borrowAmount, method);\n\n        emit Borrow(\n            borrower,\n            borrowAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function repayBorrowInternal(\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(borrower, borrower, repayAmount, method);\n    }\n\n    function repayBorrowBehalfInternal(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.REPAY_BEHALF_ACCRUE_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n        return repayBorrowFresh(payer, borrower, repayAmount, method);\n    }\n\n    struct RepayBorrowLocalVars {\n        Error err;\n        MathError mathErr;\n        uint256 repayAmount;\n        uint256 borrowerIndex;\n        uint256 accountBorrows;\n        uint256 accountBorrowsNew;\n        uint256 totalBorrowsNew;\n        uint256 actualRepayAmount;\n    }\n\n    function repayBorrowFresh(\n        address payer,\n        address borrower,\n        uint256 repayAmount,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        uint256 allowed = _controller.repayBorrowAllowed(address(this));\n        if (allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.REPAY_BORROW_CONTROLLER_REJECTION,\n                    allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.REPAY_BORROW_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        RepayBorrowLocalVars memory vars;\n\n        vars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n        (vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(\n            borrower\n        );\n        if (vars.mathErr != MathError.NO_ERROR) {\n            return (\n                failOpaque(\n                    Error.MATH_ERROR,\n                    FailureInfo\n                        .REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n                    uint256(vars.mathErr)\n                ),\n                0\n            );\n        }\n\n        if (repayAmount == type(uint256).max) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > vars.accountBorrows) {\n            vars.repayAmount = vars.accountBorrows;\n        } else if (repayAmount > totalBorrows) {\n            vars.repayAmount = totalBorrows;\n        } else {\n            vars.repayAmount = repayAmount;\n        }\n\n        if (payer != address(this)) {\n            vars.actualRepayAmount = doTransferIn(\n                payer,\n                vars.repayAmount,\n                method\n            );\n        } else {\n            vars.actualRepayAmount = vars.repayAmount;\n        }\n\n        (vars.mathErr, vars.accountBorrowsNew) = subUInt(\n            vars.accountBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Account borrow update failed\"\n        );\n\n        (vars.mathErr, vars.totalBorrowsNew) = subUInt(\n            totalBorrows,\n            vars.actualRepayAmount\n        );\n        require(\n            vars.mathErr == MathError.NO_ERROR,\n            \"Total borrow update failed\"\n        );\n\n        accountBorrows[borrower].principal = vars.accountBorrowsNew;\n        accountBorrows[borrower].interestIndex = borrowIndex;\n        totalBorrows = vars.totalBorrowsNew;\n\n        emit RepayBorrow(\n            payer,\n            borrower,\n            vars.actualRepayAmount,\n            vars.accountBorrowsNew,\n            vars.totalBorrowsNew\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    function liquidateBorrowInternal(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal nonReentrant returns (uint256, uint256) {\n        uint256 error = accrueInterest();\n        if (error != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(error),\n                    FailureInfo.LIQUIDATE_ACCRUE_BORROW_INTEREST_FAILED\n                ),\n                0\n            );\n        }\n\n        return\n            liquidateBorrowFresh(\n                liquidator,\n                borrower,\n                input,\n                minReward,\n                deadline,\n                method\n            );\n    }\n\n    struct LiquidateBorrowLocalVars {\n        MathError mErr;\n        uint256 err;\n        uint256 allowed;\n        uint256 borrowBalance;\n        uint256 seizeTokens;\n        uint256 sellOutput;\n        uint256 actualInput;\n        uint256 actualRepayAmount;\n        uint256 transferOutput;\n        uint256 reward;\n    }\n\n    function liquidateBorrowFresh(\n        address payable liquidator,\n        address borrower,\n        uint256 input,\n        uint256 minReward,\n        uint256 deadline,\n        TransferMethod method\n    ) internal returns (uint256, uint256) {\n        LiquidateBorrowLocalVars memory vars;\n        vars.allowed = _controller.liquidateBorrowAllowed(\n            address(this),\n            borrower\n        );\n        if (vars.allowed != 0) {\n            return (\n                failOpaque(\n                    Error.CONTROLLER_REJECTION,\n                    FailureInfo.LIQUIDATE_CONTROLLER_REJECTION,\n                    vars.allowed\n                ),\n                0\n            );\n        }\n\n        if (accrualBlockNumber != getBlockNumber()) {\n            return (\n                fail(\n                    Error.MARKET_NOT_FRESH,\n                    FailureInfo.LIQUIDATE_FRESHNESS_CHECK\n                ),\n                0\n            );\n        }\n\n        if (borrower == liquidator) {\n            return (\n                fail(\n                    Error.INVALID_ACCOUNT_PAIR,\n                    FailureInfo.LIQUIDATE_LIQUIDATOR_IS_BORROWER\n                ),\n                0\n            );\n        }\n\n        (vars.mErr, vars.borrowBalance) = borrowBalanceStoredInternal(borrower);\n\n        if (vars.mErr != MathError.NO_ERROR) {\n            return (\n                fail(\n                    Error.MATH_ERROR,\n                    FailureInfo.LIQUIDATE_BORROW_BALANCE_ERROR\n                ),\n                0\n            );\n        }\n\n        (vars.err, vars.seizeTokens) = _controller\n            .liquidateCalculateSeizeTokens(address(this), vars.borrowBalance);\n\n        require(\n            vars.err == uint256(Error.NO_ERROR),\n            \"Calculate seize amount failed\"\n        );\n\n        IYESVault yesVault = IYESVault(_controller.yesVault());\n        vars.sellOutput = yesVault.sellMarket(\n            borrower,\n            vars.seizeTokens,\n            deadline\n        );\n        vars.actualInput = doTransferIn(liquidator, input, method);\n\n        (vars.err, vars.actualRepayAmount) = repayBorrowFresh(\n            address(this),\n            borrower,\n            vars.borrowBalance,\n            TransferMethod.METAMASK\n        );\n\n        if (vars.err != uint256(Error.NO_ERROR)) {\n            return (\n                fail(\n                    Error(vars.err),\n                    FailureInfo.LIQUIDATE_REPAY_BORROW_FRESH_FAILED\n                ),\n                0\n            );\n        }\n\n        vars.transferOutput =\n            (vars.sellOutput + vars.actualInput) -\n            vars.actualRepayAmount;\n        vars.reward = vars.transferOutput - vars.actualInput;\n        require(vars.reward >= minReward, \"Too low reward\");\n\n        doTransferOut(liquidator, vars.transferOutput, method);\n\n        emit LiquidateBorrow(\n            liquidator,\n            borrower,\n            vars.actualRepayAmount,\n            vars.seizeTokens\n        );\n\n        return (uint256(Error.NO_ERROR), vars.actualRepayAmount);\n    }\n\n    /*** Fresh getters ***/\n\n    function exchangeRateCurrent()\n        public\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return exchangeRateStored();\n    }\n\n    function borrowBalanceCurrent(address account)\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return borrowBalanceStored(account);\n    }\n\n    function totalBorrowsCurrent()\n        external\n        override\n        nonReentrant\n        returns (uint256)\n    {\n        require(\n            accrueInterest() == uint256(Error.NO_ERROR),\n            \"Accrue interest failed\"\n        );\n        return totalBorrows;\n    }\n\n    function balanceOfUnderlying(address owner)\n        external\n        override\n        returns (uint256)\n    {\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\n        (MathError mErr, uint256 balance) = mulScalarTruncate(\n            exchangeRate,\n            _lToken.balanceOf(owner)\n        );\n        require(mErr == MathError.NO_ERROR, \"Math error\");\n        return balance;\n    }\n\n    /*** Protocol functions ***/\n\n    function _claimPlatformReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == beneficiary, \"Only beneficiary\");\n        uint256 platformReservesNew;\n\n        if (beneficiary == address(0)) {\n            return\n                fail(\n                    Error.INVALID_BENEFICIARY,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_INVALID_BENEFICIARY\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > platformReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_PLATFORM_RESERVES_VALIDATION\n                );\n        }\n\n        platformReservesNew = platformReserves - claimedAmount;\n        require(platformReservesNew <= platformReserves, \"Overflow\");\n\n        platformReserves = platformReservesNew;\n\n        doTransferOut(beneficiary, claimedAmount, TransferMethod.METAMASK);\n\n        emit PlatformReservesClaimed(\n            beneficiary,\n            claimedAmount,\n            platformReservesNew\n        );\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    function _claimPoolReserves(uint256 claimedAmount)\n        external\n        override\n        returns (uint256)\n    {\n        require(msg.sender == reservePool, \"Only reserve pool\");\n        uint256 poolReservesNew;\n\n        if (reservePool == address(0)) {\n            return\n                fail(\n                    Error.INVALID_RESERVE_POOL,\n                    FailureInfo.CLAIM_POOL_RESERVES_INVALID_RESERVE_POOL\n                );\n        }\n\n        if (getCashPrior() < claimedAmount) {\n            return\n                fail(\n                    Error.TOKEN_INSUFFICIENT_CASH,\n                    FailureInfo.CLAIM_POOL_RESERVES_CASH_NOT_AVAILABLE\n                );\n        }\n\n        if (claimedAmount > poolReserves) {\n            return\n                fail(\n                    Error.BAD_INPUT,\n                    FailureInfo.CLAIM_POOL_RESERVES_VALIDATION\n                );\n        }\n\n        poolReservesNew = poolReserves - claimedAmount;\n        require(poolReservesNew <= poolReserves, \"Overflow\");\n\n        poolReserves = poolReservesNew;\n\n        doTransferOut(reservePool, claimedAmount, TransferMethod.METAMASK);\n\n        emit PoolReservesClaimed(reservePool, claimedAmount, poolReservesNew);\n\n        return uint256(Error.NO_ERROR);\n    }\n\n    /*** BK Next helpers ***/\n    function requireKYC(address sender) internal view {\n        IKYCBitkubChain kyc = _lToken.kyc();\n        require(\n            kyc.kycsLevel(sender) >= _lToken.acceptedKYCLevel(),\n            \"only Bitkub Next user\"\n        );\n    }\n\n    /*** Token functions ***/\n    function doTransferIn(\n        address from,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual returns (uint256);\n\n    function doTransferOut(\n        address payable to,\n        uint256 amount,\n        TransferMethod method\n    ) internal virtual;\n}\n", "commit_id": "37b3d41aa783c3aa5fb6149d8355e0ff66f4f7be"}}