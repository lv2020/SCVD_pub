{"filename": "contracts/Presale.sol", "patch": "@@ -6,11 +6,12 @@ import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n+import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n import \"./NICEToken.sol\";\n // TEST\n import \"./TestStaking2.sol\";\n \n-contract Presale is Ownable {\n+contract Presale is Ownable, ReentrancyGuard {\n \n   using SafeMath for uint;\n   using SafeERC20 for ERC20;\n@@ -30,7 +31,6 @@ contract Presale is Ownable {\n   ERC721 public immutable crushGod;\n   NICEToken public niceToken;\n   ERC20 public immutable busd;\n-  uint public constant saleDuration = 12 hours; // Duration in Blocks ( 3 blocks per second ) 12 hours\n   uint public totalSale = 26595745 ether;\n   uint public constant vesting = 2500;\n   uint public priceDec = 10000;\n@@ -41,7 +41,7 @@ contract Presale is Ownable {\n   address public immutable devAddress;\n \n   mapping(address => uint) public whitelist;\n-  mapping(uint => address) public usedTokens;\n+  mapping(uint => address) public nftUsed;\n   mapping(address => Buy) public userBought;\n \n   // EVENTS\n@@ -60,7 +60,7 @@ contract Presale is Ownable {\n   /// @notice qualify only checks quantity\n   /// @dev qualify is an overlook of the amount of CrushGod NFTs held and tokens staked\n   function qualify() public view returns(bool _isQualified){\n-      (uint staked,,,,) = staking.stakings(msg.sender);\n+      (,uint staked,,,,,,,) = staking.stakings(msg.sender);\n       uint nfts = crushGod.balanceOf(msg.sender);\n       _isQualified = nfts > 0 && staked >= 10000 ether;\n   }\n@@ -71,9 +71,10 @@ contract Presale is Ownable {\n     bool isQualified = qualify();\n     require(isQualified, \"Unqualified\");\n     require(whitelist[msg.sender] == 0, \"Already whitelisted\");\n-    require(usedTokens[tokenId] == address(0), \"Token already used\");\n+    require(nftUsed[tokenId] == address(0), \"Token already used\");\n     require(crushGod.ownerOf(tokenId) == msg.sender, \"Illegal owner\");\n     whitelist[msg.sender] = tokenId;\n+    nftUsed[tokenId] = msg.sender;\n   }\n \n   function setNiceToken(address _tokenAddress) onlyOwner external {\n@@ -84,7 +85,7 @@ contract Presale is Ownable {\n   /// @param _amount Amount of BUSD to lock NICE amount\n   /// @dev minimum of $100 BUSD, max of $5K BUSD\n   /// @dev if maxRaise is exceeded we will allocate just a portion of that amount.\n-  function buyNice(uint _amount) external{\n+  function buyNice(uint _amount) external nonReentrant{\n     require(_amount.mod(1 ether) == 0, \"Exact amounts only\");\n     require(whitelist[msg.sender]  > 0, \"Whitelist only\");\n     require(block.timestamp < saleEnd, \"SaleEnded\");\n@@ -112,7 +113,7 @@ contract Presale is Ownable {\n   }\n   /// @notice function that gets available tokens to the user.\n   /// @dev transfers NICE to the user directly by minting straight to their wallets\n-  function claimTokens() external{\n+  function claimTokens() external nonReentrant{\n     Buy storage userInfo = userBought[msg.sender];\n     require(saleEnd > 0 && block.timestamp > saleEnd.add(vestingDuration), \"Claim Unavailable\");\n     require( address(niceToken) != address(0), \"Token Not added\");", "project_link": "https://github.com/Bitcrush-Arcade/crush_contracts/commit/e2983ee54f443ed8502076c4775c43a39c8aafd5", "solc_version": "0.8.0", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "d91f25fa989964e5d6715eb6b5316d6b440388cd"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "e2983ee54f443ed8502076c4775c43a39c8aafd5"}}