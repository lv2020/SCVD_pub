{"filename": "contracts/Auction.sol", "patch": "@@ -95,10 +95,13 @@ contract Auction {\n \n   function refund() public {\n     require(msg.sender != winner, \"winner cannot refund\");\n+    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n \n-    msg.sender.send( bids[msg.sender] );\n-    emit Refund(msg.sender, bids[msg.sender], now);\n-    bids[msg.sender] = 0;\n+    uint refundValue = bids[msg.sender];\n+    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n+    msg.sender.transfer(refundValue);\n+    \n+    emit Refund(msg.sender, refundValue, now);\n   }\n \n }", "project_link": "https://github.com/astralship/eos/commit/ea415ec328778cbe5d2788b317b576986728d78b", "bug_version": {"raw_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n\n    msg.sender.send( bids[msg.sender] );\n    emit Refund(msg.sender, bids[msg.sender], now);\n    bids[msg.sender] = 0;\n  }\n\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n\n    msg.sender.send( bids[msg.sender] );\n    emit Refund(msg.sender, bids[msg.sender], now);\n    bids[msg.sender] = 0;\n  }\n\n}\n", "commit_id": "1359e14e0319c6019eb9c7e57348b95c722e3dd6"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n\n    uint refundValue = bids[msg.sender];\n    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n    msg.sender.transfer(refundValue);\n    \n    emit Refund(msg.sender, refundValue, now);\n  }\n\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\ncontract Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n    require(bids[msg.sender] > 0, \"refunds only allowed if you sent something\");\n\n    uint refundValue = bids[msg.sender];\n    bids[msg.sender] = 0; // reentrancy fix, setting to zero first\n    msg.sender.transfer(refundValue);\n    \n    emit Refund(msg.sender, refundValue, now);\n  }\n\n}\n", "commit_id": "ea415ec328778cbe5d2788b317b576986728d78b"}}