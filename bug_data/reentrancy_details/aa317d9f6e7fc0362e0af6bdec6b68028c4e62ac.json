{"filename": "contracts/identity/Identity.sol", "patch": "@@ -14,12 +14,13 @@ contract Identity is ERC725, ERC735 {\n     mapping (bytes32 => uint256) indexes;\n     mapping (uint => Transaction) txx;\n     mapping (uint256 => uint256) minimumApprovalsByKeyPurpose;\n-    bytes32[] pendingTransactions;\n+    \n     uint nonce = 0;\n     address recoveryContract;\n     address recoveryManager;\n \n     struct Transaction {\n+        bool valid;\n         address to;\n         uint value;\n         bytes data;\n@@ -455,6 +456,7 @@ contract Identity is ERC725, ERC735 {\n         executionId = nonce;\n         nonce++;\n         txx[executionId] = Transaction({\n+            valid: true,\n             to: _to,\n             value: _value,\n             data: _data,\n@@ -473,29 +475,30 @@ contract Identity is ERC725, ERC735 {\n         returns(bool success) //(?) should return approved instead of success?\n     {\n         \n-        Transaction storage trx = txx[_id];\n+        Transaction memory trx = txx[_id];\n+        require(trx.valid);\n+        uint256 requiredKeyPurpose = trx.to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n+        require(isKeyPurpose(_key, requiredKeyPurpose));\n+        bytes32 keyHash = keccak256(_key, requiredKeyPurpose);\n+        require(txx[_id].approvals[keyHash] != _approval);\n         \n-        uint256 approvalCount;\n-        uint256 requiredKeyPurpose;\n-\n-        if (trx.to == address(this)) {\n-            require(isKeyPurpose(_key, MANAGEMENT_KEY));\n-            bytes32 managerKeyHash = keccak256(_key, MANAGEMENT_KEY);\n-            requiredKeyPurpose = MANAGEMENT_KEY;\n-            approvalCount = _calculateApprovals(managerKeyHash, _approval, trx);\n+        if (_approval) {\n+            trx.approverCount++;\n         } else {\n-            require(isKeyPurpose(_key, ACTION_KEY));\n-            bytes32 actorKeyHash = keccak256(_key, ACTION_KEY);\n-            requiredKeyPurpose = ACTION_KEY;\n-            approvalCount = _calculateApprovals(actorKeyHash, _approval, trx);\n+            trx.approverCount--;\n         }\n-\n+    \n         emit Approved(_id, _approval);\n \n-        if (approvalCount >= minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n+        if (trx.approverCount < minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n+            txx[_id].approvals[keyHash] = _approval;\n+            txx[_id] = trx;\n+        } else {\n+            delete txx[_id];\n             //(?) success should be included in event?\n-            success = trx.to.call.value(trx.value)(trx.data);\n+            success = address(trx.to).call.value(trx.value)(trx.data);\n             emit Executed(_id, trx.to, trx.value, trx.data);\n+            \n         }\n     }\n \n@@ -541,31 +544,10 @@ contract Identity is ERC725, ERC735 {\n \n         delete indexes[keyHash];\n         delete keys[keyHash];\n-        \n-        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n-    }\n-\n-    function _calculateApprovals(\n-        bytes32 _keyHash,\n-        bool _approval,\n-        Transaction storage trx\n-    )\n-        private \n-        returns (uint256 approvalCount) \n-    {\n-        require(trx.approvals[_keyHash] != _approval);\n \n-        trx.approvals[_keyHash] = _approval;\n-        if (_approval) {\n-            trx.approverCount++;\n-        } else {\n-            trx.approverCount--;\n-        }\n-        \n-        return trx.approverCount;\n+        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n     }\n \n-    \n     function _includeClaim(\n         bytes32 _claimHash,\n         uint256 _claimType,", "project_link": "https://github.com/status-im/contracts/commit/8752bd114f51ea24047fd4c131c9fc6629f10953", "solc_version": "0.8.0", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "aa317d9f6e7fc0362e0af6bdec6b68028c4e62ac"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "8752bd114f51ea24047fd4c131c9fc6629f10953"}}