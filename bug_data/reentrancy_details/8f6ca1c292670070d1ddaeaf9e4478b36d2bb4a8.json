{"filename": "contracts/2key/acquisition-campaign-contracts/TwoKeyPurchasesHandler.sol", "patch": "@@ -197,9 +197,6 @@ contract TwoKeyPurchasesHandler is UpgradeableCampaign {\n         //Only converter of maintainer can call this function\n         require(msg.sender == p.converter || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender) == true);\n         require(p.isPortionWithdrawn[portion] == false && block.timestamp > portionToUnlockingDate[portion]);\n-        //Transfer tokens\n-        require(IERC20(assetContractERC20).transfer(p.converter, p.portionAmounts[portion]));\n-        p.isPortionWithdrawn[portion] = true;\n \n         emit TokensWithdrawn (\n             block.timestamp,\n@@ -208,6 +205,10 @@ contract TwoKeyPurchasesHandler is UpgradeableCampaign {\n             portion,\n             p.portionAmounts[portion]\n         );\n+\n+        p.isPortionWithdrawn[portion] = true;\n+        //Transfer tokens\n+        require(IERC20(assetContractERC20).transfer(p.converter, p.portionAmounts[portion]));\n     }\n \n     function getPurchaseInformation(", "project_link": "https://github.com/2key/contracts/commit/4b884f1bd46dc4e6e1d7d9b44f08ee6a097b8bf5", "bug_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport \"../interfaces/ITwoKeyEventSource.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../upgradable-pattern-campaigns/UpgradeableCampaign.sol\";\n\n/**\n * @author Nikola Madjarevic\n */\ncontract TwoKeyPurchasesHandler is UpgradeableCampaign {\n\n    enum VestingAmount {BONUS, BASE_AND_BONUS}\n    VestingAmount vestingAmount;\n\n    bool initialized;\n    bool isDistributionDateChanged;\n\n    address proxyConversionHandler;\n    address public assetContractERC20;\n    address converter;\n    address contractor;\n    address twoKeyEventSource;\n\n    mapping(uint => uint) public portionToUnlockingDate;\n\n    uint numberOfPurchases;\n    uint bonusTokensVestingStartShiftInDaysFromDistributionDate;\n    uint tokenDistributionDate; // Start of token distribution\n    uint numberOfVestingPortions; // For example 6\n    uint numberOfDaysBetweenPortions; // For example 30 days\n    uint maxDistributionDateShiftInDays;\n\n    mapping(uint => Purchase) conversionIdToPurchase;\n\n    event TokensWithdrawn(\n        uint timestamp,\n        address methodCaller,\n        address tokensReceiver,\n        uint portionId,\n        uint portionAmount\n    );\n\n    struct Purchase {\n        address converter;\n        uint baseTokens;\n        uint bonusTokens;\n        uint [] portionAmounts;\n        bool [] isPortionWithdrawn;\n    }\n\n    function setInitialParamsPurchasesHandler(\n        uint[] values,\n        address _contractor,\n        address _assetContractERC20,\n        address _twoKeyEventSource,\n        address _proxyConversionHandler\n    )\n    public\n    {\n        require(initialized == false);\n        require(values[4] <= 100);\n        tokenDistributionDate = values[2];\n        maxDistributionDateShiftInDays = values[3];\n        numberOfVestingPortions = values[4];\n        numberOfDaysBetweenPortions = values[5];\n        bonusTokensVestingStartShiftInDaysFromDistributionDate = values[6];\n        vestingAmount = VestingAmount(values[7]);\n        contractor = _contractor;\n        assetContractERC20 = _assetContractERC20;\n        twoKeyEventSource = _twoKeyEventSource;\n        proxyConversionHandler = _proxyConversionHandler;\n\n        uint bonusVestingStartDate;\n        // In case vested amounts are both bonus and base, bonusTokensVestingStartShiftInDaysFromDistributionDate is ignored\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            bonusVestingStartDate = tokenDistributionDate + numberOfDaysBetweenPortions * (1 days);\n        } else {\n            bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        }\n\n\n        portionToUnlockingDate[0] = tokenDistributionDate;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionToUnlockingDate[i] = bonusVestingStartDate + (i-1) * (numberOfDaysBetweenPortions * (1 days));\n        }\n\n        initialized = true;\n    }\n\n\n    function startVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    public\n    {\n        require(msg.sender == proxyConversionHandler);\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            baseAndBonusVesting(_baseTokens, _bonusTokens, _conversionId, _converter);\n        } else {\n            bonusVestingOnly(_baseTokens, _bonusTokens, _conversionId, _converter);\n        }\n        numberOfPurchases++;\n    }\n\n    function bonusVestingOnly(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions+1);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions+1);\n        portionAmounts[0] = _baseTokens;\n\n        uint bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        uint bonusPortionAmount = _bonusTokens / numberOfVestingPortions;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionAmounts[i] = bonusPortionAmount;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n    function baseAndBonusVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions);\n\n        uint totalAmount = _baseTokens + _bonusTokens;\n        uint portion = totalAmount / numberOfVestingPortions;\n\n        for(uint i=0; i<numberOfVestingPortions; i++) {\n            portionAmounts[i] = portion;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n\n    function changeDistributionDate(\n        uint _newDate\n    )\n    public\n    {\n        require(msg.sender == contractor);\n        require(isDistributionDateChanged == false);\n        require(_newDate - (maxDistributionDateShiftInDays * (1 days)) <= tokenDistributionDate);\n        require(now < tokenDistributionDate);\n\n        uint shift = tokenDistributionDate - _newDate;\n        // If the date is changed shifting all tokens unlocking dates for the difference\n        for(uint i=0; i<numberOfVestingPortions+1;i++) {\n            portionToUnlockingDate[i] = portionToUnlockingDate[i] + shift;\n        }\n\n        isDistributionDateChanged = true;\n        tokenDistributionDate = _newDate;\n    }\n\n\n    function withdrawTokens(\n        uint conversionId,\n        uint portion\n    )\n    public\n    {\n        Purchase p = conversionIdToPurchase[conversionId];\n        //Only converter of maintainer can call this function\n        require(msg.sender == p.converter || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender) == true);\n        require(p.isPortionWithdrawn[portion] == false && block.timestamp > portionToUnlockingDate[portion]);\n        //Transfer tokens\n        require(IERC20(assetContractERC20).transfer(p.converter, p.portionAmounts[portion]));\n        p.isPortionWithdrawn[portion] = true;\n\n        emit TokensWithdrawn (\n            block.timestamp,\n            msg.sender,\n            converter,\n            portion,\n            p.portionAmounts[portion]\n        );\n    }\n\n    function getPurchaseInformation(\n        uint _conversionId\n    )\n    public\n    view\n    returns (address, uint, uint, uint[], bool[], uint[])\n    {\n        Purchase memory p = conversionIdToPurchase[_conversionId];\n        uint [] memory unlockingDates = getPortionsUnlockingDates();\n        return (\n            p.converter,\n            p.baseTokens,\n            p.bonusTokens,\n            p.portionAmounts,\n            p.isPortionWithdrawn,\n            unlockingDates\n        );\n    }\n\n    function getStaticInfo()\n    public\n    view\n    returns (uint,uint,uint,uint,uint,uint)\n    {\n        return (\n            bonusTokensVestingStartShiftInDaysFromDistributionDate,\n            tokenDistributionDate,\n            numberOfVestingPortions,\n            numberOfDaysBetweenPortions,\n            maxDistributionDateShiftInDays,\n            uint(vestingAmount)\n        );\n    }\n\n    function getPortionsUnlockingDates()\n    public\n    view\n    returns (uint[])\n    {\n        uint [] memory dates = new uint[](numberOfVestingPortions+1);\n        for(uint i=0; i< numberOfVestingPortions+1; i++) {\n            dates[i] = portionToUnlockingDate[i];\n        }\n        return dates;\n    }\n\n\n\n}\n", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\ncontract ITwoKeyEventSource {\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external view;\n    function rejected(address _campaign, address _converter) external view;\n\n    function convertedAcquisitionV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external\n    view;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonationV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external\n    view;\n\n    function executedV1(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external\n    view;\n\n}\npragma solidity ^0.4.24;\n\n/// Interface of ERC20 contract we need in order to invoke balanceOf method from another contracts\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n/**\n * @title IRegistry\n * @dev This contract represents the interface of a registry contract\n */\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    */\n    event VersionAdded(string version, address implementation);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract UpgradeabilityCampaignStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    address internal twoKeyFactory;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract UpgradeableCampaign is UpgradeabilityCampaignStorage {\n\n}\n\n/**\n * @author Nikola Madjarevic\n */\ncontract TwoKeyPurchasesHandler is UpgradeableCampaign {\n\n    enum VestingAmount {BONUS, BASE_AND_BONUS}\n    VestingAmount vestingAmount;\n\n    bool initialized;\n    bool isDistributionDateChanged;\n\n    address proxyConversionHandler;\n    address public assetContractERC20;\n    address converter;\n    address contractor;\n    address twoKeyEventSource;\n\n    mapping(uint => uint) public portionToUnlockingDate;\n\n    uint numberOfPurchases;\n    uint bonusTokensVestingStartShiftInDaysFromDistributionDate;\n    uint tokenDistributionDate; // Start of token distribution\n    uint numberOfVestingPortions; // For example 6\n    uint numberOfDaysBetweenPortions; // For example 30 days\n    uint maxDistributionDateShiftInDays;\n\n    mapping(uint => Purchase) conversionIdToPurchase;\n\n    event TokensWithdrawn(\n        uint timestamp,\n        address methodCaller,\n        address tokensReceiver,\n        uint portionId,\n        uint portionAmount\n    );\n\n    struct Purchase {\n        address converter;\n        uint baseTokens;\n        uint bonusTokens;\n        uint [] portionAmounts;\n        bool [] isPortionWithdrawn;\n    }\n\n    function setInitialParamsPurchasesHandler(\n        uint[] values,\n        address _contractor,\n        address _assetContractERC20,\n        address _twoKeyEventSource,\n        address _proxyConversionHandler\n    )\n    public\n    {\n        require(initialized == false);\n        require(values[4] <= 100);\n        tokenDistributionDate = values[2];\n        maxDistributionDateShiftInDays = values[3];\n        numberOfVestingPortions = values[4];\n        numberOfDaysBetweenPortions = values[5];\n        bonusTokensVestingStartShiftInDaysFromDistributionDate = values[6];\n        vestingAmount = VestingAmount(values[7]);\n        contractor = _contractor;\n        assetContractERC20 = _assetContractERC20;\n        twoKeyEventSource = _twoKeyEventSource;\n        proxyConversionHandler = _proxyConversionHandler;\n\n        uint bonusVestingStartDate;\n        // In case vested amounts are both bonus and base, bonusTokensVestingStartShiftInDaysFromDistributionDate is ignored\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            bonusVestingStartDate = tokenDistributionDate + numberOfDaysBetweenPortions * (1 days);\n        } else {\n            bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        }\n\n\n        portionToUnlockingDate[0] = tokenDistributionDate;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionToUnlockingDate[i] = bonusVestingStartDate + (i-1) * (numberOfDaysBetweenPortions * (1 days));\n        }\n\n        initialized = true;\n    }\n\n\n    function startVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    public\n    {\n        require(msg.sender == proxyConversionHandler);\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            baseAndBonusVesting(_baseTokens, _bonusTokens, _conversionId, _converter);\n        } else {\n            bonusVestingOnly(_baseTokens, _bonusTokens, _conversionId, _converter);\n        }\n        numberOfPurchases++;\n    }\n\n    function bonusVestingOnly(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions+1);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions+1);\n        portionAmounts[0] = _baseTokens;\n\n        uint bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        uint bonusPortionAmount = _bonusTokens / numberOfVestingPortions;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionAmounts[i] = bonusPortionAmount;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n    function baseAndBonusVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions);\n\n        uint totalAmount = _baseTokens + _bonusTokens;\n        uint portion = totalAmount / numberOfVestingPortions;\n\n        for(uint i=0; i<numberOfVestingPortions; i++) {\n            portionAmounts[i] = portion;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n\n    function changeDistributionDate(\n        uint _newDate\n    )\n    public\n    {\n        require(msg.sender == contractor);\n        require(isDistributionDateChanged == false);\n        require(_newDate - (maxDistributionDateShiftInDays * (1 days)) <= tokenDistributionDate);\n        require(now < tokenDistributionDate);\n\n        uint shift = tokenDistributionDate - _newDate;\n        // If the date is changed shifting all tokens unlocking dates for the difference\n        for(uint i=0; i<numberOfVestingPortions+1;i++) {\n            portionToUnlockingDate[i] = portionToUnlockingDate[i] + shift;\n        }\n\n        isDistributionDateChanged = true;\n        tokenDistributionDate = _newDate;\n    }\n\n\n    function withdrawTokens(\n        uint conversionId,\n        uint portion\n    )\n    public\n    {\n        Purchase p = conversionIdToPurchase[conversionId];\n        //Only converter of maintainer can call this function\n        require(msg.sender == p.converter || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender) == true);\n        require(p.isPortionWithdrawn[portion] == false && block.timestamp > portionToUnlockingDate[portion]);\n        //Transfer tokens\n        require(IERC20(assetContractERC20).transfer(p.converter, p.portionAmounts[portion]));\n        p.isPortionWithdrawn[portion] = true;\n\n        emit TokensWithdrawn (\n            block.timestamp,\n            msg.sender,\n            converter,\n            portion,\n            p.portionAmounts[portion]\n        );\n    }\n\n    function getPurchaseInformation(\n        uint _conversionId\n    )\n    public\n    view\n    returns (address, uint, uint, uint[], bool[], uint[])\n    {\n        Purchase memory p = conversionIdToPurchase[_conversionId];\n        uint [] memory unlockingDates = getPortionsUnlockingDates();\n        return (\n            p.converter,\n            p.baseTokens,\n            p.bonusTokens,\n            p.portionAmounts,\n            p.isPortionWithdrawn,\n            unlockingDates\n        );\n    }\n\n    function getStaticInfo()\n    public\n    view\n    returns (uint,uint,uint,uint,uint,uint)\n    {\n        return (\n            bonusTokensVestingStartShiftInDaysFromDistributionDate,\n            tokenDistributionDate,\n            numberOfVestingPortions,\n            numberOfDaysBetweenPortions,\n            maxDistributionDateShiftInDays,\n            uint(vestingAmount)\n        );\n    }\n\n    function getPortionsUnlockingDates()\n    public\n    view\n    returns (uint[])\n    {\n        uint [] memory dates = new uint[](numberOfVestingPortions+1);\n        for(uint i=0; i< numberOfVestingPortions+1; i++) {\n            dates[i] = portionToUnlockingDate[i];\n        }\n        return dates;\n    }\n\n\n\n}\n", "commit_id": "8f6ca1c292670070d1ddaeaf9e4478b36d2bb4a8"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport \"../interfaces/ITwoKeyEventSource.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../upgradable-pattern-campaigns/UpgradeableCampaign.sol\";\n\n/**\n * @author Nikola Madjarevic\n */\ncontract TwoKeyPurchasesHandler is UpgradeableCampaign {\n\n    enum VestingAmount {BONUS, BASE_AND_BONUS}\n    VestingAmount vestingAmount;\n\n    bool initialized;\n    bool isDistributionDateChanged;\n\n    address proxyConversionHandler;\n    address public assetContractERC20;\n    address converter;\n    address contractor;\n    address twoKeyEventSource;\n\n    mapping(uint => uint) public portionToUnlockingDate;\n\n    uint numberOfPurchases;\n    uint bonusTokensVestingStartShiftInDaysFromDistributionDate;\n    uint tokenDistributionDate; // Start of token distribution\n    uint numberOfVestingPortions; // For example 6\n    uint numberOfDaysBetweenPortions; // For example 30 days\n    uint maxDistributionDateShiftInDays;\n\n    mapping(uint => Purchase) conversionIdToPurchase;\n\n    event TokensWithdrawn(\n        uint timestamp,\n        address methodCaller,\n        address tokensReceiver,\n        uint portionId,\n        uint portionAmount\n    );\n\n    struct Purchase {\n        address converter;\n        uint baseTokens;\n        uint bonusTokens;\n        uint [] portionAmounts;\n        bool [] isPortionWithdrawn;\n    }\n\n    function setInitialParamsPurchasesHandler(\n        uint[] values,\n        address _contractor,\n        address _assetContractERC20,\n        address _twoKeyEventSource,\n        address _proxyConversionHandler\n    )\n    public\n    {\n        require(initialized == false);\n        require(values[4] <= 100);\n        tokenDistributionDate = values[2];\n        maxDistributionDateShiftInDays = values[3];\n        numberOfVestingPortions = values[4];\n        numberOfDaysBetweenPortions = values[5];\n        bonusTokensVestingStartShiftInDaysFromDistributionDate = values[6];\n        vestingAmount = VestingAmount(values[7]);\n        contractor = _contractor;\n        assetContractERC20 = _assetContractERC20;\n        twoKeyEventSource = _twoKeyEventSource;\n        proxyConversionHandler = _proxyConversionHandler;\n\n        uint bonusVestingStartDate;\n        // In case vested amounts are both bonus and base, bonusTokensVestingStartShiftInDaysFromDistributionDate is ignored\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            bonusVestingStartDate = tokenDistributionDate + numberOfDaysBetweenPortions * (1 days);\n        } else {\n            bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        }\n\n\n        portionToUnlockingDate[0] = tokenDistributionDate;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionToUnlockingDate[i] = bonusVestingStartDate + (i-1) * (numberOfDaysBetweenPortions * (1 days));\n        }\n\n        initialized = true;\n    }\n\n\n    function startVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    public\n    {\n        require(msg.sender == proxyConversionHandler);\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            baseAndBonusVesting(_baseTokens, _bonusTokens, _conversionId, _converter);\n        } else {\n            bonusVestingOnly(_baseTokens, _bonusTokens, _conversionId, _converter);\n        }\n        numberOfPurchases++;\n    }\n\n    function bonusVestingOnly(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions+1);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions+1);\n        portionAmounts[0] = _baseTokens;\n\n        uint bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        uint bonusPortionAmount = _bonusTokens / numberOfVestingPortions;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionAmounts[i] = bonusPortionAmount;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n    function baseAndBonusVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions);\n\n        uint totalAmount = _baseTokens + _bonusTokens;\n        uint portion = totalAmount / numberOfVestingPortions;\n\n        for(uint i=0; i<numberOfVestingPortions; i++) {\n            portionAmounts[i] = portion;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n\n    function changeDistributionDate(\n        uint _newDate\n    )\n    public\n    {\n        require(msg.sender == contractor);\n        require(isDistributionDateChanged == false);\n        require(_newDate - (maxDistributionDateShiftInDays * (1 days)) <= tokenDistributionDate);\n        require(now < tokenDistributionDate);\n\n        uint shift = tokenDistributionDate - _newDate;\n        // If the date is changed shifting all tokens unlocking dates for the difference\n        for(uint i=0; i<numberOfVestingPortions+1;i++) {\n            portionToUnlockingDate[i] = portionToUnlockingDate[i] + shift;\n        }\n\n        isDistributionDateChanged = true;\n        tokenDistributionDate = _newDate;\n    }\n\n\n    function withdrawTokens(\n        uint conversionId,\n        uint portion\n    )\n    public\n    {\n        Purchase p = conversionIdToPurchase[conversionId];\n        //Only converter of maintainer can call this function\n        require(msg.sender == p.converter || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender) == true);\n        require(p.isPortionWithdrawn[portion] == false && block.timestamp > portionToUnlockingDate[portion]);\n\n        emit TokensWithdrawn (\n            block.timestamp,\n            msg.sender,\n            converter,\n            portion,\n            p.portionAmounts[portion]\n        );\n\n        p.isPortionWithdrawn[portion] = true;\n        //Transfer tokens\n        require(IERC20(assetContractERC20).transfer(p.converter, p.portionAmounts[portion]));\n    }\n\n    function getPurchaseInformation(\n        uint _conversionId\n    )\n    public\n    view\n    returns (address, uint, uint, uint[], bool[], uint[])\n    {\n        Purchase memory p = conversionIdToPurchase[_conversionId];\n        uint [] memory unlockingDates = getPortionsUnlockingDates();\n        return (\n            p.converter,\n            p.baseTokens,\n            p.bonusTokens,\n            p.portionAmounts,\n            p.isPortionWithdrawn,\n            unlockingDates\n        );\n    }\n\n    function getStaticInfo()\n    public\n    view\n    returns (uint,uint,uint,uint,uint,uint)\n    {\n        return (\n            bonusTokensVestingStartShiftInDaysFromDistributionDate,\n            tokenDistributionDate,\n            numberOfVestingPortions,\n            numberOfDaysBetweenPortions,\n            maxDistributionDateShiftInDays,\n            uint(vestingAmount)\n        );\n    }\n\n    function getPortionsUnlockingDates()\n    public\n    view\n    returns (uint[])\n    {\n        uint [] memory dates = new uint[](numberOfVestingPortions+1);\n        for(uint i=0; i< numberOfVestingPortions+1; i++) {\n            dates[i] = portionToUnlockingDate[i];\n        }\n        return dates;\n    }\n\n\n\n}\n", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\ncontract ITwoKeyEventSource {\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external view;\n    function rejected(address _campaign, address _converter) external view;\n\n    function convertedAcquisitionV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external\n    view;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonationV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external\n    view;\n\n    function executedV1(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external\n    view;\n\n}\npragma solidity ^0.4.24;\n\n/// Interface of ERC20 contract we need in order to invoke balanceOf method from another contracts\ncontract IERC20 {\n    function balanceOf(\n        address whom\n    )\n    external\n    view\n    returns (uint);\n\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    external\n    returns (bool);\n\n\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n    public\n    returns (bool);\n\n\n\n    function decimals()\n    external\n    view\n    returns (uint);\n\n\n    function symbol()\n    external\n    view\n    returns (string);\n\n\n    function name()\n    external\n    view\n    returns (string);\n\n\n    function freezeTransfers()\n    external;\n\n\n    function unfreezeTransfers()\n    external;\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n/**\n * @title IRegistry\n * @dev This contract represents the interface of a registry contract\n */\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    */\n    event VersionAdded(string version, address implementation);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract UpgradeabilityCampaignStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    address internal twoKeyFactory;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract UpgradeableCampaign is UpgradeabilityCampaignStorage {\n\n}\n\n/**\n * @author Nikola Madjarevic\n */\ncontract TwoKeyPurchasesHandler is UpgradeableCampaign {\n\n    enum VestingAmount {BONUS, BASE_AND_BONUS}\n    VestingAmount vestingAmount;\n\n    bool initialized;\n    bool isDistributionDateChanged;\n\n    address proxyConversionHandler;\n    address public assetContractERC20;\n    address converter;\n    address contractor;\n    address twoKeyEventSource;\n\n    mapping(uint => uint) public portionToUnlockingDate;\n\n    uint numberOfPurchases;\n    uint bonusTokensVestingStartShiftInDaysFromDistributionDate;\n    uint tokenDistributionDate; // Start of token distribution\n    uint numberOfVestingPortions; // For example 6\n    uint numberOfDaysBetweenPortions; // For example 30 days\n    uint maxDistributionDateShiftInDays;\n\n    mapping(uint => Purchase) conversionIdToPurchase;\n\n    event TokensWithdrawn(\n        uint timestamp,\n        address methodCaller,\n        address tokensReceiver,\n        uint portionId,\n        uint portionAmount\n    );\n\n    struct Purchase {\n        address converter;\n        uint baseTokens;\n        uint bonusTokens;\n        uint [] portionAmounts;\n        bool [] isPortionWithdrawn;\n    }\n\n    function setInitialParamsPurchasesHandler(\n        uint[] values,\n        address _contractor,\n        address _assetContractERC20,\n        address _twoKeyEventSource,\n        address _proxyConversionHandler\n    )\n    public\n    {\n        require(initialized == false);\n        require(values[4] <= 100);\n        tokenDistributionDate = values[2];\n        maxDistributionDateShiftInDays = values[3];\n        numberOfVestingPortions = values[4];\n        numberOfDaysBetweenPortions = values[5];\n        bonusTokensVestingStartShiftInDaysFromDistributionDate = values[6];\n        vestingAmount = VestingAmount(values[7]);\n        contractor = _contractor;\n        assetContractERC20 = _assetContractERC20;\n        twoKeyEventSource = _twoKeyEventSource;\n        proxyConversionHandler = _proxyConversionHandler;\n\n        uint bonusVestingStartDate;\n        // In case vested amounts are both bonus and base, bonusTokensVestingStartShiftInDaysFromDistributionDate is ignored\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            bonusVestingStartDate = tokenDistributionDate + numberOfDaysBetweenPortions * (1 days);\n        } else {\n            bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        }\n\n\n        portionToUnlockingDate[0] = tokenDistributionDate;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionToUnlockingDate[i] = bonusVestingStartDate + (i-1) * (numberOfDaysBetweenPortions * (1 days));\n        }\n\n        initialized = true;\n    }\n\n\n    function startVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    public\n    {\n        require(msg.sender == proxyConversionHandler);\n        if(vestingAmount == VestingAmount.BASE_AND_BONUS) {\n            baseAndBonusVesting(_baseTokens, _bonusTokens, _conversionId, _converter);\n        } else {\n            bonusVestingOnly(_baseTokens, _bonusTokens, _conversionId, _converter);\n        }\n        numberOfPurchases++;\n    }\n\n    function bonusVestingOnly(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions+1);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions+1);\n        portionAmounts[0] = _baseTokens;\n\n        uint bonusVestingStartDate = tokenDistributionDate + bonusTokensVestingStartShiftInDaysFromDistributionDate * (1 days);\n        uint bonusPortionAmount = _bonusTokens / numberOfVestingPortions;\n\n        for(uint i=1; i<numberOfVestingPortions + 1; i++) {\n            portionAmounts[i] = bonusPortionAmount;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n    function baseAndBonusVesting(\n        uint _baseTokens,\n        uint _bonusTokens,\n        uint _conversionId,\n        address _converter\n    )\n    internal\n    {\n        uint [] memory portionAmounts = new uint[](numberOfVestingPortions);\n        bool [] memory isPortionWithdrawn = new bool[](numberOfVestingPortions);\n\n        uint totalAmount = _baseTokens + _bonusTokens;\n        uint portion = totalAmount / numberOfVestingPortions;\n\n        for(uint i=0; i<numberOfVestingPortions; i++) {\n            portionAmounts[i] = portion;\n        }\n\n        Purchase memory purchase = Purchase(\n            _converter,\n            _baseTokens,\n            _bonusTokens,\n            portionAmounts,\n            isPortionWithdrawn\n        );\n\n        conversionIdToPurchase[_conversionId] = purchase;\n    }\n\n\n    function changeDistributionDate(\n        uint _newDate\n    )\n    public\n    {\n        require(msg.sender == contractor);\n        require(isDistributionDateChanged == false);\n        require(_newDate - (maxDistributionDateShiftInDays * (1 days)) <= tokenDistributionDate);\n        require(now < tokenDistributionDate);\n\n        uint shift = tokenDistributionDate - _newDate;\n        // If the date is changed shifting all tokens unlocking dates for the difference\n        for(uint i=0; i<numberOfVestingPortions+1;i++) {\n            portionToUnlockingDate[i] = portionToUnlockingDate[i] + shift;\n        }\n\n        isDistributionDateChanged = true;\n        tokenDistributionDate = _newDate;\n    }\n\n\n    function withdrawTokens(\n        uint conversionId,\n        uint portion\n    )\n    public\n    {\n        Purchase p = conversionIdToPurchase[conversionId];\n        //Only converter of maintainer can call this function\n        require(msg.sender == p.converter || ITwoKeyEventSource(twoKeyEventSource).isAddressMaintainer(msg.sender) == true);\n        require(p.isPortionWithdrawn[portion] == false && block.timestamp > portionToUnlockingDate[portion]);\n\n        emit TokensWithdrawn (\n            block.timestamp,\n            msg.sender,\n            converter,\n            portion,\n            p.portionAmounts[portion]\n        );\n\n        p.isPortionWithdrawn[portion] = true;\n        //Transfer tokens\n        require(IERC20(assetContractERC20).transfer(p.converter, p.portionAmounts[portion]));\n    }\n\n    function getPurchaseInformation(\n        uint _conversionId\n    )\n    public\n    view\n    returns (address, uint, uint, uint[], bool[], uint[])\n    {\n        Purchase memory p = conversionIdToPurchase[_conversionId];\n        uint [] memory unlockingDates = getPortionsUnlockingDates();\n        return (\n            p.converter,\n            p.baseTokens,\n            p.bonusTokens,\n            p.portionAmounts,\n            p.isPortionWithdrawn,\n            unlockingDates\n        );\n    }\n\n    function getStaticInfo()\n    public\n    view\n    returns (uint,uint,uint,uint,uint,uint)\n    {\n        return (\n            bonusTokensVestingStartShiftInDaysFromDistributionDate,\n            tokenDistributionDate,\n            numberOfVestingPortions,\n            numberOfDaysBetweenPortions,\n            maxDistributionDateShiftInDays,\n            uint(vestingAmount)\n        );\n    }\n\n    function getPortionsUnlockingDates()\n    public\n    view\n    returns (uint[])\n    {\n        uint [] memory dates = new uint[](numberOfVestingPortions+1);\n        for(uint i=0; i< numberOfVestingPortions+1; i++) {\n            dates[i] = portionToUnlockingDate[i];\n        }\n        return dates;\n    }\n\n\n\n}\n", "commit_id": "4b884f1bd46dc4e6e1d7d9b44f08ee6a097b8bf5"}}