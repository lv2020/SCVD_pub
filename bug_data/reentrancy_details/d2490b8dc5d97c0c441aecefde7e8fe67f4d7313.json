{"filename": "contracts/ERC20/ERC20Tradable.sol", "patch": "@@ -95,16 +95,16 @@ contract ERC20Tradable is ITradable, ERC20 {\n         uint256 freeTokenAmount = balanceOf(addr) - _token1;\n         require(freeAmount > 0 || freeTokenAmount > 0, \"nothing to transfer\");\n \n+        if (freeTokenAmount > 0) {\n+            _transfer(addr, recipient, freeTokenAmount);\n+        }\n+\n         if (freeAmount > 0) {\n             // solhint-disable-next-line avoid-low-level-calls\n             (bool success, ) = recipient.call{value: freeAmount}(\"\");\n             require(success, \"transfer failed\");\n         }\n \n-        if (freeTokenAmount > 0) {\n-            _transfer(addr, recipient, freeTokenAmount);\n-        }\n-\n         return true;\n     }\n ", "project_link": "https://github.com/gymnasy55/redduck-milestone1/commit/be04f2ea5a73e6f14e3d820a6113e17b3a26bc81", "bug_version": {"raw_code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/ITradable.sol\";\n\ncontract ERC20Tradable is ITradable, ERC20 {\n    uint256 public immutable divider;\n\n    uint256 internal _token0;\n    uint256 internal _token1;\n    uint256 internal _price;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 price_\n    ) ERC20(name_, symbol_, decimals_) {\n        divider = 10**decimals_;\n        _price = price_;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function price() public view virtual returns (uint256) {\n        return _price * divider;\n    }\n\n    function liquidity()\n        public\n        view\n        returns (uint256 amount, uint256 tokenAmount)\n    {\n        (amount, tokenAmount) = (_token0, _token1);\n    }\n\n    function addLiquidity(uint256 tokenAmount) external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n\n        _changeLiquidity(amount, tokenAmount, _add, _add);\n\n        transferFrom(msg.sender, address(this), tokenAmount);\n\n        return true;\n    }\n\n    function buy() external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        uint256 tokenAmount = amount / (price() / divider);\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        require(\n            int256(_token1) - int256(tokenAmount) > 0,\n            \"not enough liquidity\"\n        );\n\n        _changeLiquidity(amount, tokenAmount, _add, _sub);\n\n        address sender = msg.sender;\n        _transfer(address(this), sender, tokenAmount);\n\n        emit Buy(sender, tokenAmount, amount);\n\n        return true;\n    }\n\n    function sell(uint256 tokenAmount) external returns (bool) {\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        uint256 amount = (tokenAmount * price()) / divider;\n        require(amount > 0, \"amount must be positive\");\n        require(int256(_token0) - int256(amount) > 0, \"not enough liquidity\");\n\n        _changeLiquidity(amount, tokenAmount, _sub, _add);\n\n        address sender = msg.sender;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = sender.call{value: amount}(\"\");\n        require(success, \"transfer failed\");\n\n        transferFrom(sender, address(this), tokenAmount);\n\n        emit Sell(sender, amount, tokenAmount);\n\n        return true;\n    }\n\n    function release(address recipient) external returns (bool) {\n        require(recipient != address(0), \"recipient is zero address\");\n        address addr = address(this);\n        uint256 freeAmount = addr.balance - _token0;\n        uint256 freeTokenAmount = balanceOf(addr) - _token1;\n        require(freeAmount > 0 || freeTokenAmount > 0, \"nothing to transfer\");\n\n        if (freeAmount > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = recipient.call{value: freeAmount}(\"\");\n            require(success, \"transfer failed\");\n        }\n\n        if (freeTokenAmount > 0) {\n            _transfer(addr, recipient, freeTokenAmount);\n        }\n\n        return true;\n    }\n\n    function _changeLiquidity(\n        uint256 amount,\n        uint256 tokenAmount,\n        function(uint256, uint256) pure returns (uint256) op0,\n        function(uint256, uint256) pure returns (uint256) op1\n    ) internal {\n        _token0 = op0(_token0, amount);\n        _token1 = op1(_token1, tokenAmount);\n\n        emit LiquidityChanged(msg.sender, _token1, _token0);\n    }\n\n    function _add(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first + second;\n    }\n\n    function _sub(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first - second;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        (_name, _symbol, _decimals) = (name_, symbol_, decimals_);\n    }\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 currentAllowance = allowance(from, to);\n        require(currentAllowance >= amount, \"transfer exceeds allowance\");\n\n        _approve(from, to, currentAllowance - amount);\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"owner is zero address\");\n        require(spender != address(0), \"spender is zero address\");\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"transfer from zero address\");\n        require(to != address(0), \"transfer to zero address\");\n        uint256 balanceFrom = _balances[from];\n        require(balanceFrom >= amount, \"transfer amount exceeds balance\");\n\n        _balances[from] = balanceFrom - amount;\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\ninterface ITradable {\n    event Buy(address indexed account, uint256 tokenAmount, uint256 amount);\n    event Sell(address indexed account, uint256 amount, uint256 tokenAmount);\n    event LiquidityChanged(\n        address indexed account,\n        uint256 tokenAmount,\n        uint256 amount\n    );\n\n    function price() external view returns (uint256);\n\n    function liquidity()\n        external\n        view\n        returns (uint256 amount, uint256 tokenAmount);\n\n    function addLiquidity(uint256 tokenAmount) external payable returns (bool);\n\n    function buy() external payable returns (bool);\n\n    function sell(uint256 tokenAmount) external returns (bool);\n\n    /**\n     * @dev send surplus of token and eth to recipient\n     */\n    function release(address recipient) external returns (bool);\n}\n\ncontract ERC20Tradable is ITradable, ERC20 {\n    uint256 public immutable divider;\n\n    uint256 internal _token0;\n    uint256 internal _token1;\n    uint256 internal _price;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 price_\n    ) ERC20(name_, symbol_, decimals_) {\n        divider = 10**decimals_;\n        _price = price_;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function price() public view virtual returns (uint256) {\n        return _price * divider;\n    }\n\n    function liquidity()\n        public\n        view\n        returns (uint256 amount, uint256 tokenAmount)\n    {\n        (amount, tokenAmount) = (_token0, _token1);\n    }\n\n    function addLiquidity(uint256 tokenAmount) external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n\n        _changeLiquidity(amount, tokenAmount, _add, _add);\n\n        transferFrom(msg.sender, address(this), tokenAmount);\n\n        return true;\n    }\n\n    function buy() external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        uint256 tokenAmount = amount / (price() / divider);\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        require(\n            int256(_token1) - int256(tokenAmount) > 0,\n            \"not enough liquidity\"\n        );\n\n        _changeLiquidity(amount, tokenAmount, _add, _sub);\n\n        address sender = msg.sender;\n        _transfer(address(this), sender, tokenAmount);\n\n        emit Buy(sender, tokenAmount, amount);\n\n        return true;\n    }\n\n    function sell(uint256 tokenAmount) external returns (bool) {\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        uint256 amount = (tokenAmount * price()) / divider;\n        require(amount > 0, \"amount must be positive\");\n        require(int256(_token0) - int256(amount) > 0, \"not enough liquidity\");\n\n        _changeLiquidity(amount, tokenAmount, _sub, _add);\n\n        address sender = msg.sender;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = sender.call{value: amount}(\"\");\n        require(success, \"transfer failed\");\n\n        transferFrom(sender, address(this), tokenAmount);\n\n        emit Sell(sender, amount, tokenAmount);\n\n        return true;\n    }\n\n    function release(address recipient) external returns (bool) {\n        require(recipient != address(0), \"recipient is zero address\");\n        address addr = address(this);\n        uint256 freeAmount = addr.balance - _token0;\n        uint256 freeTokenAmount = balanceOf(addr) - _token1;\n        require(freeAmount > 0 || freeTokenAmount > 0, \"nothing to transfer\");\n\n        if (freeAmount > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = recipient.call{value: freeAmount}(\"\");\n            require(success, \"transfer failed\");\n        }\n\n        if (freeTokenAmount > 0) {\n            _transfer(addr, recipient, freeTokenAmount);\n        }\n\n        return true;\n    }\n\n    function _changeLiquidity(\n        uint256 amount,\n        uint256 tokenAmount,\n        function(uint256, uint256) pure returns (uint256) op0,\n        function(uint256, uint256) pure returns (uint256) op1\n    ) internal {\n        _token0 = op0(_token0, amount);\n        _token1 = op1(_token1, tokenAmount);\n\n        emit LiquidityChanged(msg.sender, _token1, _token0);\n    }\n\n    function _add(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first + second;\n    }\n\n    function _sub(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first - second;\n    }\n}\n", "commit_id": "d2490b8dc5d97c0c441aecefde7e8fe67f4d7313"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"./ERC20.sol\";\nimport \"../interfaces/ITradable.sol\";\n\ncontract ERC20Tradable is ITradable, ERC20 {\n    uint256 public immutable divider;\n\n    uint256 internal _token0;\n    uint256 internal _token1;\n    uint256 internal _price;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 price_\n    ) ERC20(name_, symbol_, decimals_) {\n        divider = 10**decimals_;\n        _price = price_;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function price() public view virtual returns (uint256) {\n        return _price * divider;\n    }\n\n    function liquidity()\n        public\n        view\n        returns (uint256 amount, uint256 tokenAmount)\n    {\n        (amount, tokenAmount) = (_token0, _token1);\n    }\n\n    function addLiquidity(uint256 tokenAmount) external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n\n        _changeLiquidity(amount, tokenAmount, _add, _add);\n\n        transferFrom(msg.sender, address(this), tokenAmount);\n\n        return true;\n    }\n\n    function buy() external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        uint256 tokenAmount = amount / (price() / divider);\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        require(\n            int256(_token1) - int256(tokenAmount) > 0,\n            \"not enough liquidity\"\n        );\n\n        _changeLiquidity(amount, tokenAmount, _add, _sub);\n\n        address sender = msg.sender;\n        _transfer(address(this), sender, tokenAmount);\n\n        emit Buy(sender, tokenAmount, amount);\n\n        return true;\n    }\n\n    function sell(uint256 tokenAmount) external returns (bool) {\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        uint256 amount = (tokenAmount * price()) / divider;\n        require(amount > 0, \"amount must be positive\");\n        require(int256(_token0) - int256(amount) > 0, \"not enough liquidity\");\n\n        _changeLiquidity(amount, tokenAmount, _sub, _add);\n\n        address sender = msg.sender;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = sender.call{value: amount}(\"\");\n        require(success, \"transfer failed\");\n\n        transferFrom(sender, address(this), tokenAmount);\n\n        emit Sell(sender, amount, tokenAmount);\n\n        return true;\n    }\n\n    function release(address recipient) external returns (bool) {\n        require(recipient != address(0), \"recipient is zero address\");\n        address addr = address(this);\n        uint256 freeAmount = addr.balance - _token0;\n        uint256 freeTokenAmount = balanceOf(addr) - _token1;\n        require(freeAmount > 0 || freeTokenAmount > 0, \"nothing to transfer\");\n\n        if (freeTokenAmount > 0) {\n            _transfer(addr, recipient, freeTokenAmount);\n        }\n\n        if (freeAmount > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = recipient.call{value: freeAmount}(\"\");\n            require(success, \"transfer failed\");\n        }\n\n        return true;\n    }\n\n    function _changeLiquidity(\n        uint256 amount,\n        uint256 tokenAmount,\n        function(uint256, uint256) pure returns (uint256) op0,\n        function(uint256, uint256) pure returns (uint256) op1\n    ) internal {\n        _token0 = op0(_token0, amount);\n        _token1 = op1(_token1, tokenAmount);\n\n        emit LiquidityChanged(msg.sender, _token1, _token0);\n    }\n\n    function _add(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first + second;\n    }\n\n    function _sub(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first - second;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ncontract ERC20 is IERC20, IERC20Metadata {\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n    string internal _symbol;\n    uint8 internal _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        (_name, _symbol, _decimals) = (name_, symbol_, decimals_);\n    }\n\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address to, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function allowance(address owner, address spender)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        _approve(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override returns (bool) {\n        uint256 currentAllowance = allowance(from, to);\n        require(currentAllowance >= amount, \"transfer exceeds allowance\");\n\n        _approve(from, to, currentAllowance - amount);\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        require(owner != address(0), \"owner is zero address\");\n        require(spender != address(0), \"spender is zero address\");\n\n        _allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        require(from != address(0), \"transfer from zero address\");\n        require(to != address(0), \"transfer to zero address\");\n        uint256 balanceFrom = _balances[from];\n        require(balanceFrom >= amount, \"transfer amount exceeds balance\");\n\n        _balances[from] = balanceFrom - amount;\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\ninterface ITradable {\n    event Buy(address indexed account, uint256 tokenAmount, uint256 amount);\n    event Sell(address indexed account, uint256 amount, uint256 tokenAmount);\n    event LiquidityChanged(\n        address indexed account,\n        uint256 tokenAmount,\n        uint256 amount\n    );\n\n    function price() external view returns (uint256);\n\n    function liquidity()\n        external\n        view\n        returns (uint256 amount, uint256 tokenAmount);\n\n    function addLiquidity(uint256 tokenAmount) external payable returns (bool);\n\n    function buy() external payable returns (bool);\n\n    function sell(uint256 tokenAmount) external returns (bool);\n\n    /**\n     * @dev send surplus of token and eth to recipient\n     */\n    function release(address recipient) external returns (bool);\n}\n\ncontract ERC20Tradable is ITradable, ERC20 {\n    uint256 public immutable divider;\n\n    uint256 internal _token0;\n    uint256 internal _token1;\n    uint256 internal _price;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        uint256 price_\n    ) ERC20(name_, symbol_, decimals_) {\n        divider = 10**decimals_;\n        _price = price_;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function price() public view virtual returns (uint256) {\n        return _price * divider;\n    }\n\n    function liquidity()\n        public\n        view\n        returns (uint256 amount, uint256 tokenAmount)\n    {\n        (amount, tokenAmount) = (_token0, _token1);\n    }\n\n    function addLiquidity(uint256 tokenAmount) external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n\n        _changeLiquidity(amount, tokenAmount, _add, _add);\n\n        transferFrom(msg.sender, address(this), tokenAmount);\n\n        return true;\n    }\n\n    function buy() external payable returns (bool) {\n        uint256 amount = msg.value;\n        require(amount > 0, \"amount must be positive\");\n        uint256 tokenAmount = amount / (price() / divider);\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        require(\n            int256(_token1) - int256(tokenAmount) > 0,\n            \"not enough liquidity\"\n        );\n\n        _changeLiquidity(amount, tokenAmount, _add, _sub);\n\n        address sender = msg.sender;\n        _transfer(address(this), sender, tokenAmount);\n\n        emit Buy(sender, tokenAmount, amount);\n\n        return true;\n    }\n\n    function sell(uint256 tokenAmount) external returns (bool) {\n        require(tokenAmount > 0, \"tokenAmount must be positive\");\n        uint256 amount = (tokenAmount * price()) / divider;\n        require(amount > 0, \"amount must be positive\");\n        require(int256(_token0) - int256(amount) > 0, \"not enough liquidity\");\n\n        _changeLiquidity(amount, tokenAmount, _sub, _add);\n\n        address sender = msg.sender;\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = sender.call{value: amount}(\"\");\n        require(success, \"transfer failed\");\n\n        transferFrom(sender, address(this), tokenAmount);\n\n        emit Sell(sender, amount, tokenAmount);\n\n        return true;\n    }\n\n    function release(address recipient) external returns (bool) {\n        require(recipient != address(0), \"recipient is zero address\");\n        address addr = address(this);\n        uint256 freeAmount = addr.balance - _token0;\n        uint256 freeTokenAmount = balanceOf(addr) - _token1;\n        require(freeAmount > 0 || freeTokenAmount > 0, \"nothing to transfer\");\n\n        if (freeTokenAmount > 0) {\n            _transfer(addr, recipient, freeTokenAmount);\n        }\n\n        if (freeAmount > 0) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = recipient.call{value: freeAmount}(\"\");\n            require(success, \"transfer failed\");\n        }\n\n        return true;\n    }\n\n    function _changeLiquidity(\n        uint256 amount,\n        uint256 tokenAmount,\n        function(uint256, uint256) pure returns (uint256) op0,\n        function(uint256, uint256) pure returns (uint256) op1\n    ) internal {\n        _token0 = op0(_token0, amount);\n        _token1 = op1(_token1, tokenAmount);\n\n        emit LiquidityChanged(msg.sender, _token1, _token0);\n    }\n\n    function _add(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first + second;\n    }\n\n    function _sub(uint256 first, uint256 second)\n        private\n        pure\n        returns (uint256)\n    {\n        return first - second;\n    }\n}\n", "commit_id": "be04f2ea5a73e6f14e3d820a6113e17b3a26bc81"}}