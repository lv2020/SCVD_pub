{"filename": "contracts/managers/SherlockClaimManager.sol", "patch": "@@ -540,7 +540,7 @@ contract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager\n   // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n   // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n   // Then, the next callback in the process, disputePriceFor(), gets called by the UMA's contract.\n-  // @note reentrancy is allowed for this call\n+  // @note Does not have reentrancy protection because it is called by the OO contract which is non-reentrant.\n   function priceProposed(\n     bytes32 identifier,\n     uint32 timestamp,\n@@ -563,7 +563,7 @@ contract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager\n   // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n   // We change the claim's state from UmaDisputeProposed to UmaPending\n   // Then, the next callback in the process, priceSettled(), gets called by the UMA's contract.\n-  // @note reentrancy is allowed for this call\n+  // @note Does not have reentrancy protection because it is called by the OO contract which is non-reentrant.\n   function priceDisputed(\n     bytes32 identifier,\n     uint32 timestamp,", "project_link": "https://github.com/sherlock-protocol/sherlock-v2-core/commit/aace01f52c94cb0f54006ca449bfe94528a80229", "bug_version": {"raw_code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// This contract contains the logic for handling claims\n// The idea is that the first level of handling a claim is the Sherlock Protocol Claims Committee (SPCC)(a multisig)\n// If a protocol agent doesn't like that result, they can escalate the claim to UMA's Optimistic Oracle (OO), who will be the final decision\n// We also build in a multisig (controlled by UMA) to give the final approve to pay out after the OO approves a claim\n\nimport './Manager.sol';\nimport '../interfaces/managers/ISherlockClaimManager.sol';\nimport '../interfaces/managers/ISherlockProtocolManager.sol';\nimport '../interfaces/UMAprotocol/SkinnyOptimisticOracleInterface.sol';\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\n/// @dev expects 6 decimals input tokens\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 22k cost of escalating\n  /// @dev usdcFee = https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  /// @dev price = (BOND * 2) + (usdcFee * 2)\n  /// @dev this is because the price is proposed and disputed in the same transaction\n\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then, the next callback in the process, disputePriceFor(), gets called by the UMA's contract.\n  // @note reentrancy is allowed for this call\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then, the next callback in the process, priceSettled(), gets called by the UMA's contract.\n  // @note reentrancy is allowed for this call\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// This contract contains the logic for handling claims\n// The idea is that the first level of handling a claim is the Sherlock Protocol Claims Committee (SPCC)(a multisig)\n// If a protocol agent doesn't like that result, they can escalate the claim to UMA's Optimistic Oracle (OO), who will be the final decision\n// We also build in a multisig (controlled by UMA) to give the final approve to pay out after the OO approves a claim\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\ninterface ISherlockStake {\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) external view returns (uint256);\n\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) external view returns (uint256);\n\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) external view returns (uint256);\n\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() external view returns (uint256);\n\n  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external returns (uint256 _id, uint256 _sher);\n\n  /// @notice Redeem NFT `_id` and receive `_amount` of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of `_id` will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup `_period` has ended\n  function redeemNFT(uint256 _id) external returns (uint256 _amount);\n\n  /// @notice Owner restakes position with ID: `_id` for `_period` seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends\n  /// @dev Only the owner of `_id` will be able to restake their position using this call\n  /// @dev `_period` needs to be whitelisted\n  /// @dev Can only be called after lockup `_period` has ended\n  function ownerRestake(uint256 _id, uint256 _period) external returns (uint256 _sher);\n\n  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id) external returns (uint256 _sher, uint256 _arbReward);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\ninterface ISherDistributionManager is IManager {\n  // anyone can just send token to this contract to fund rewards\n\n  event Initialized(uint256 maxRewardsEndTVL, uint256 zeroRewardsStartTVL, uint256 maxRewardRate);\n\n  /// @notice Caller will receive `_sher` SHER tokens based on `_amount` and `_period`\n  /// @param _amount Amount of tokens (in USDC) staked\n  /// @param _period Period of time for stake, in seconds\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens sent to Sherlock core contract\n  /// @dev Calling contract will depend on before + after balance diff and return value\n  /// @dev INCLUDES stake in calculation, function expects the `_amount` to be deposited already\n  /// @dev If tvl=50 and amount=50, this means it is calculating SHER rewards for the first 50 tokens going in\n  function pullReward(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) external returns (uint256 _sher);\n\n  /// @notice Calculates how many `_sher` SHER tokens are owed to a stake position based on `_amount` and `_period`\n  /// @param _tvl TVL to use for reward calculation (pre-stake TVL)\n  /// @param _amount Amount of tokens (USDC) staked\n  /// @param _period Stake period (in seconds)\n  /// @return _sher Amount of SHER tokens owed to this stake position\n  /// @dev EXCLUDES `_amount` of stake, this will be added on top of TVL (_tvl is excluding _amount)\n  /// @dev If tvl=0 and amount=50, it would calculate for the first 50 tokens going in (different from pullReward())\n  function calcReward(\n    uint256 _tvl,\n    uint256 _amount,\n    uint256 _period\n  ) external view returns (uint256 _sher);\n\n  /// @notice Function used to check if this is the current active distribution manager\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\ninterface ISherlockProtocolManager is IManager {\n  // msg.sender is not authorized to call this function\n  error Unauthorized();\n\n  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n  error ProtocolNotExists(bytes32 protocol);\n\n  // When comparing two arrays and the lengths are not equal (but are supposed to be equal)\n  error UnequalArrayLength();\n\n  // If there is not enough balance in the contract for the amount requested (after any requirements are met), this is returned\n  error InsufficientBalance(bytes32 protocol);\n\n  event MinBalance(uint256 previous, uint256 current);\n\n  event AccountingError(bytes32 indexed protocol, uint256 amount, uint256 insufficientTokens);\n\n  event ProtocolAdded(bytes32 indexed protocol);\n\n  event ProtocolRemovedByArb(bytes32 indexed protocol, address arb, uint256 profit);\n\n  event ProtocolRemoved(bytes32 indexed protocol);\n\n  event ProtocolUpdated(\n    bytes32 indexed protocol,\n    bytes32 coverage,\n    uint256 nonStakers,\n    uint256 coverageAmount\n  );\n\n  event ProtocolAgentTransfer(bytes32 indexed protocol, address from, address to);\n\n  event ProtocolBalanceDeposited(bytes32 indexed protocol, uint256 amount);\n\n  event ProtocolBalanceWithdrawn(bytes32 indexed protocol, uint256 amount);\n\n  event ProtocolPremiumChanged(bytes32 indexed protocol, uint256 oldPremium, uint256 newPremium);\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() external view returns (uint256);\n\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external;\n\n  /// @notice View current protocolAgent of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view returns (address);\n\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium `_protocol` pays per second\n  function premium(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance\n  /// @param _protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point\n  /// @dev `_nonStakers` is scaled by 10**18\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external;\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external;\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external;\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  function forceRemoveByActiveBalance(bytes32 _protocol) external;\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external;\n\n  /// @notice View minimal balance needed before liquidation can start\n  /// @return Minimal balance needed\n  function minActiveBalance() external view returns (uint256);\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external;\n\n  /// @notice Set premium of `_protocol` to `_premium`\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium `_protocol` pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external;\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium) external;\n\n  /// @notice Deposits `_amount` of token to the active balance of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount) external;\n\n  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount) external;\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent) external;\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  function nonStakersClaimable(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external;\n\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    returns (uint256 current, uint256 previous);\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\ninterface ISherlockClaimManagerCallbackReceiver {\n  /// @notice Calls this function on approved contracts and passes args\n  /// @param _protocol The protocol that is receiving the payout\n  /// @param _claimID The claim ID that is receiving the payout\n  /// @param _amount The amount of USDC being paid out for this claim\n  function PreCorePayoutCallback(\n    bytes32 _protocol,\n    uint256 _claimID,\n    uint256 _amount\n  ) external;\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleInterface {\n  // Struct representing the state of a price request.\n  enum State {\n    Invalid, // Never requested.\n    Requested, // Requested, no other actions taken.\n    Proposed, // Proposed, but not expired or disputed yet.\n    Expired, // Proposed, not disputed, past liveness.\n    Disputed, // Disputed, but no DVM price returned yet.\n    Resolved, // Disputed and DVM price is available.\n    Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n  }\n\n  // Struct representing a price request.\n  struct Request {\n    address proposer; // Address of the proposer.\n    address disputer; // Address of the disputer.\n    IERC20 currency; // ERC20 token used to pay rewards and fees.\n    bool settled; // True if the request is settled.\n    bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n    int256 proposedPrice; // Price that the proposer submitted.\n    int256 resolvedPrice; // Price resolved once the request is settled.\n    uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n    uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n    uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n    uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n    uint256 customLiveness; // Custom liveness value set by the requester.\n  }\n\n  // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n  // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n  // to accept a price request made with ancillary data length over a certain size.\n  uint256 public constant ancillaryBytesLimit = 8192;\n\n  /**\n   * @notice Requests a new price.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data representing additional args being passed with the price request.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n   * This can be changed with a subsequent call to setBond().\n   */\n  function requestPrice(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Set the proposal bond associated with a price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param bond custom bond amount to set.\n   * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n   * changed again with a subsequent call to setBond().\n   */\n  function setBond(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    uint256 bond\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n   * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n   * bond, so there is still profit to be made even if the reward is refunded.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   */\n  function setRefundOnDispute(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual;\n\n  /**\n   * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n   * being auto-resolved.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param customLiveness new custom liveness.\n   */\n  function setCustomLiveness(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    uint256 customLiveness\n  ) external virtual;\n\n  /**\n   * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n   * from this proposal. However, any bonds are pulled from the caller.\n   * @param proposer address to set as the proposer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePriceFor(\n    address proposer,\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    int256 proposedPrice\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value for an existing price request.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePrice(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n   * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n   * @param disputer address to set as the disputer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was value (the proposal was incorrect).\n   */\n  function disputePriceFor(\n    address disputer,\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price value for an existing price request with an active proposal.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePrice(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n   * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n   * hasn't been settled.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return resolved price.\n   */\n  function settleAndGetPrice(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual returns (int256);\n\n  /**\n   * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n   * the returned bonds as well as additional rewards.\n   */\n  function settle(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual returns (uint256 payout);\n\n  /**\n   * @notice Gets the current data structure containing all information about a price request.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return the Request data structure.\n   */\n  function getRequest(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public view virtual returns (Request memory);\n\n  /**\n   * @notice Returns the state of a price request.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return the State enum value.\n   */\n  function getState(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public view virtual returns (State);\n\n  /**\n   * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return true if price has resolved or settled, false otherwise.\n   */\n  function hasPrice(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public view virtual returns (bool);\n\n  function stampAncillaryData(bytes memory ancillaryData, address requester)\n    public\n    view\n    virtual\n    returns (bytes memory);\n}\n\n/**\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\n * @notice Differences from normal OptimisticOracle:\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\n *   set in `requestPrice`, which has an expanded input set.\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\n *   can be fetched via the `Settle` event or the return value of `settle`.\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\n *   full request struct.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract SkinnyOptimisticOracleInterface {\n  event RequestPrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event ProposePrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event DisputePrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event Settle(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\n  // in that refundOnDispute is removed.\n  struct Request {\n    address proposer; // Address of the proposer.\n    address disputer; // Address of the disputer.\n    IERC20 currency; // ERC20 token used to pay rewards and fees.\n    bool settled; // True if the request is settled.\n    int256 proposedPrice; // Price that the proposer submitted.\n    int256 resolvedPrice; // Price resolved once the request is settled.\n    uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n    uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n    uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n    uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n    uint256 customLiveness; // Custom liveness value set by the requester.\n  }\n\n  // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n  // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n  // to accept a price request made with ancillary data length over a certain size.\n  uint256 public constant ancillaryBytesLimit = 8192;\n\n  /**\n   * @notice Requests a new price.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data representing additional args being passed with the price request.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n   * @param customLiveness custom proposal liveness to set for request.\n   * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n   */\n  function requestPrice(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward,\n    uint256 bond,\n    uint256 customLiveness\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n   * from this proposal. However, any bonds are pulled from the caller.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * propose a price for.\n   * @param proposer address to set as the proposer.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePriceFor(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    address proposer,\n    int256 proposedPrice\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value where caller is the proposer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * propose a price for.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n   * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n   * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n   * @dev The caller is the requester, but the proposer can be customized.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n   * @param customLiveness custom proposal liveness to set for request.\n   * @param proposer address to set as the proposer.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function requestAndProposePriceFor(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward,\n    uint256 bond,\n    uint256 customLiveness,\n    address proposer,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n   * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * dispute.\n   * @param disputer address to set as the disputer.\n   * @param requester sender of the initial price request.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePriceFor(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    address disputer,\n    address requester\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal where caller is the disputer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * dispute.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * settle.\n   * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n   * the returned bonds as well as additional rewards.\n   * @return resolvedPrice the price that the request settled to.\n   */\n  function settle(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (uint256 payout, int256 resolvedPrice);\n\n  /**\n   * @notice Computes the current state of a price request. See the State enum for more details.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters.\n   * @return the State.\n   */\n  function getState(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (OptimisticOracleInterface.State);\n\n  /**\n   * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters. The hash of these parameters must match with the request hash that is\n   * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n   * will revert.\n   * @return boolean indicating true if price exists and false if not.\n   */\n  function hasPrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) public virtual returns (bool);\n\n  /**\n   * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param requester sender of the initial price request.\n   * @return the stamped ancillary bytes.\n   */\n  function stampAncillaryData(bytes memory ancillaryData, address requester)\n    public\n    pure\n    virtual\n    returns (bytes memory);\n}\n\n/**\n * @title Optimistic Requester.\n * @notice Optional interface that requesters can implement to receive callbacks.\n * @dev This contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\n * money themselves).\n */\ninterface OptimisticRequester {\n  /**\n   * @notice Callback for proposals.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request request params after proposal.\n   */\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external;\n\n  /**\n   * @notice Callback for disputes.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request request params after dispute.\n   */\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external;\n\n  /**\n   * @notice Callback for settlement.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request request params after settlement.\n   */\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external;\n}\n\ninterface ISherlockClaimManager is IManager, OptimisticRequester {\n  // Doesn't allow a new claim to be submitted by a protocol agent if a claim is already active for that protocol\n  error ClaimActive();\n\n  // If the current state of a claim does not match the expected state, this error is thrown\n  error InvalidState();\n\n  event ClaimCreated(\n    uint256 claimID,\n    bytes32 indexed protocol,\n    uint256 amount,\n    address receiver,\n    bool previousCoverageUsed\n  );\n\n  event CallbackAdded(ISherlockClaimManagerCallbackReceiver callback);\n\n  event CallbackRemoved(ISherlockClaimManagerCallbackReceiver callback);\n\n  event ClaimStatusChanged(uint256 indexed claimID, State previousState, State currentState);\n\n  event ClaimPayout(uint256 claimID, address receiver, uint256 amount);\n\n  event ClaimHalted(uint256 claimID);\n\n  event UMAHORenounced();\n\n  enum State {\n    NonExistent, // Claim doesn't exist (this is the default state on creation)\n    SpccPending, // Claim is created, SPCC is able to set state to valid\n    SpccApproved, // Final state, claim is valid\n    SpccDenied, // Claim denied by SPCC, claim can be escalated within 4 weeks\n    UmaPriceProposed, // Price is proposed but not escalated\n    ReadyToProposeUmaDispute, // Price is proposed, callback received, ready to submit dispute\n    UmaDisputeProposed, // Escalation is done, waiting for confirmation\n    UmaPending, // Claim is escalated, in case Spcc denied or didn't act within 7 days.\n    UmaApproved, // Final state, claim is valid, claim can be enacted after 1 day, umaHaltOperator has 1 day to change to denied\n    UmaDenied, // Final state, claim is invalid\n    Halted, // UMAHO can halt claim if state is UmaApproved\n    Cleaned // Claim is removed by protocol agent\n  }\n\n  struct Claim {\n    uint256 created;\n    uint256 updated;\n    address initiator;\n    bytes32 protocol;\n    uint256 amount;\n    address receiver;\n    uint32 timestamp;\n    State state;\n    bytes ancillaryData;\n  }\n\n  // requestAndProposePriceFor() --> proposer = protocolAgent\n  // disputePriceFor() --> disputor = sherlock.strategyManager() (current active one)\n  // priceSettled will be the the callback that contains the main data\n\n  // user has to pay 7.5k to dispute a claim, we will execute a safeTransferFrom(user, address(this), 7.5k)\n  // we need to approve the contract 7.5k as it will be transferred from address(this)  // + 2x final fee\n  // the bond will be 5k on requestAndProposePriceFor()                                 // + 1x final fee\n  // the bond will be 2.5k on disputePriceFor()                                         // + 1x final fee\n  // on settle eiter strategy gets 7.5k. or the proposer get their bond back.           // + 1x final fee\n\n  // lastClaimID <-- starts with 0, so initial id = 1\n  // have claim counter, easy to identify certain claims by their number\n  // but use hash(callback.request.propose + callback.timestamp) as the internal UUID to handle the callbacks\n\n  // So SPCC and UMAHO are hardcoded (UMAHO can be renounced)\n  // In case these need to be updated, deploy different contract and upgrade it on the sherlock gov side.\n\n  // On price proposed callback --> call disputePriceFor with callbackdata + sherlock.strategyManager() and address(this)\n\n  /// @notice `SHERLOCK_CLAIM` in utf8\n  function UMA_IDENTIFIER() external view returns (bytes32);\n\n  function sherlockProtocolClaimsCommittee() external view returns (address);\n\n  /// @notice operator is able to deny approved UMA claims\n  function umaHaltOperator() external view returns (address);\n\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external;\n\n  function claim(uint256 _claimID) external view returns (Claim memory);\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external;\n\n  function spccApprove(uint256 _claimID) external;\n\n  function spccRefuse(uint256 _claimID) external;\n\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev proposedPrice = _amount\n  function escalate(uint256 _claimID, uint256 _amount) external;\n\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  function payoutClaim(uint256 _claimID) external;\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  function executeHalt(uint256 _claimID) external;\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n\ninterface IStrategyManager is IManager {\n  /// @return Returns the token type being deposited into a strategy\n  function want() external view returns (IERC20);\n\n  /// @notice Withdraws all USDC from the strategy back into the Sherlock core contract\n  /// @dev Only callable by the Sherlock core contract\n  /// @return The final amount withdrawn\n  function withdrawAll() external returns (uint256);\n\n  /// @notice Withdraws a specific amount of USDC from the strategy back into the Sherlock core contract\n  /// @param _amount Amount of USDC to withdraw\n  function withdraw(uint256 _amount) external;\n\n  /// @notice Deposits all USDC held in this contract into the strategy\n  function deposit() external;\n\n  /// @return Returns the USDC balance in this contract\n  function balanceOf() external view returns (uint256);\n}\n\n/// @title Sherlock core interface for governance\n/// @author Evert Kors\ninterface ISherlockGov {\n  event ClaimPayout(address receiver, uint256 amount);\n  event YieldStrategyUpdateWithdrawAllError(bytes error);\n  event YieldStrategyUpdated(IStrategyManager previous, IStrategyManager current);\n  event ProtocolManagerUpdated(ISherlockProtocolManager previous, ISherlockProtocolManager current);\n  event ClaimManagerUpdated(ISherlockClaimManager previous, ISherlockClaimManager current);\n  event NonStakerAddressUpdated(address previous, address current);\n  event SherDistributionManagerUpdated(\n    ISherDistributionManager previous,\n    ISherDistributionManager current\n  );\n\n  event StakingPeriodEnabled(uint256 period);\n\n  event StakingPeriodDisabled(uint256 period);\n\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) external;\n\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external;\n\n  /// @notice View if `_period` is a valid period\n  /// @return Boolean indicating if period is valid\n  function stakingPeriods(uint256 _period) external view returns (bool);\n\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external;\n\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external;\n\n  /// @notice Read SHER distribution manager\n  /// @return Address of current SHER distribution manager\n  function sherDistributionManager() external view returns (ISherDistributionManager);\n\n  /// @notice Update address eligible for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligible for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external;\n\n  /// @notice View current non stakers address\n  /// @return Current non staker address\n  /// @dev Is able to pull funds out of the contract\n  function nonStakersAddress() external view returns (address);\n\n  /// @notice View current address able to manage protocols\n  /// @return Protocol manager implemenation\n  function sherlockProtocolManager() external view returns (ISherlockProtocolManager);\n\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager) external;\n\n  /// @notice View current address able to pull payouts\n  /// @return Address able to pull payouts\n  function sherlockClaimManager() external view returns (ISherlockClaimManager);\n\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager) external;\n\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy New address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external;\n\n  /// @notice Update yield strategy ignoring current state\n  /// @param _yieldStrategy New address of the strategy\n  /// @dev tries a yieldStrategyWithdrawAll() on old strategy, ignore failure\n  function updateYieldStrategyForce(IStrategyManager _yieldStrategy) external;\n\n  /// @notice Read current strategy\n  /// @return Address of current strategy\n  /// @dev can never be address(0)\n  function yieldStrategy() external view returns (IStrategyManager);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n/// @title Sherlock interface for payout manager\n/// @author Evert Kors\ninterface ISherlockPayout {\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external;\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n/// @title Sherlock core interface for yield strategy\n/// @author Evert Kors\ninterface ISherlockStrategy {\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external;\n\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external;\n\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external;\n}\n\ninterface ISherlock is ISherlockStake, ISherlockGov, ISherlockPayout, ISherlockStrategy, IERC721 {\n  // msg.sender is not authorized to call this function\n  error Unauthorized();\n\n  // An address or other value passed in is equal to zero (and shouldn't be)\n  error ZeroArgument();\n\n  // Occurs when a value already holds the desired property, or is not whitelisted\n  error InvalidArgument();\n\n  // Required conditions are not true/met\n  error InvalidConditions();\n\n  // If the SHER tokens held in a contract are not the value they are supposed to be\n  error InvalidSherAmount(uint256 expected, uint256 actual);\n\n  // Checks the ERC-721 functions _exists() to see if an NFT ID actually exists and errors if not\n  error NonExistent();\n\n  event ArbRestaked(uint256 indexed tokenID, uint256 reward);\n\n  event Restaked(uint256 indexed tokenID);\n}\n\n\ninterface IManager {\n  // An address or other value passed in is equal to zero (and shouldn't be)\n  error ZeroArgument();\n\n  // Occurs when a value already holds the desired property, or is not whitelisted\n  error InvalidArgument();\n\n  // If a required condition for executing the function is not met, it reverts and throws this error\n  error InvalidConditions();\n\n  // Throws if the msg.sender is not the required address\n  error InvalidSender();\n\n  event SherlockCoreSet(ISherlock sherlock);\n\n  /// @notice Set sherlock core address where premiums should be send too\n  /// @param _sherlock Current core contract\n  /// @dev Only deployer is able to set core address on all chains except Hardhat network\n  /// @dev One time function, will revert once `sherlock` != address(0)\n  /// @dev This contract will be deployed first, passed on as argument in core constuctor\n  /// @dev ^ that's needed for tvl accounting, once core is deployed this function is called\n  /// @dev emits `SherlockCoreSet`\n  function setSherlockCoreAddress(ISherlock _sherlock) external;\n\n  /// @notice Pause external functions in contract\n  function pause() external;\n\n  /// @notice Unpause external functions in contract\n  function unpause() external;\n}\n\nabstract contract Manager is IManager, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  address private constant DEPLOYER = 0xAdBb28C2FEe078440B7088bbcd68DCfA63e55625;\n  ISherlock internal sherlockCore;\n\n  modifier onlySherlockCore() {\n    if (msg.sender != address(sherlockCore)) revert InvalidSender();\n    _;\n  }\n\n  /// @notice Set sherlock core address\n  /// @param _sherlock Current core contract\n  /// @dev Only deployer is able to set core address on all chains except Hardhat network\n  /// @dev One time function, will revert once `sherlock` != address(0)\n  /// @dev This contract will be deployed first, passed on as argument in core constuctor\n  /// @dev emits `SherlockCoreSet`\n  function setSherlockCoreAddress(ISherlock _sherlock) external override {\n    if (address(_sherlock) == address(0)) revert ZeroArgument();\n    // 31337 is of the Hardhat network blockchain\n    if (block.chainid != 31337 && msg.sender != DEPLOYER) revert InvalidSender();\n\n    if (address(sherlockCore) != address(0)) revert InvalidConditions();\n    sherlockCore = _sherlock;\n\n    emit SherlockCoreSet(_sherlock);\n  }\n\n  // Internal function to send tokens remaining in a contract to the receiver address\n  function _sweep(address _receiver, IERC20[] memory _extraTokens) internal {\n    // Loops through the extra tokens (ERC20) provided and sends all of them to the receiver address\n    for (uint256 i; i < _extraTokens.length; i++) {\n      IERC20 token = _extraTokens[i];\n      token.safeTransfer(_receiver, token.balanceOf(address(this)));\n    }\n    // Sends any remaining ETH to the receiver address (as long as receiver address is payable)\n    (bool success, ) = _receiver.call{ value: address(this).balance }('');\n    if (success == false) revert InvalidConditions();\n  }\n\n  function pause() external onlySherlockCore {\n    _pause();\n  }\n\n  function unpause() external onlySherlockCore {\n    _unpause();\n  }\n}\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/// @dev expects 6 decimals input tokens\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 22k cost of escalating\n  /// @dev usdcFee = https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  /// @dev price = (BOND * 2) + (usdcFee * 2)\n  /// @dev this is because the price is proposed and disputed in the same transaction\n\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then, the next callback in the process, disputePriceFor(), gets called by the UMA's contract.\n  // @note reentrancy is allowed for this call\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then, the next callback in the process, priceSettled(), gets called by the UMA's contract.\n  // @note reentrancy is allowed for this call\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\n", "commit_id": "e98cc28ce298ea461fc9cd4579d243badcae22f0"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// This contract contains the logic for handling claims\n// The idea is that the first level of handling a claim is the Sherlock Protocol Claims Committee (SPCC)(a multisig)\n// If a protocol agent doesn't like that result, they can escalate the claim to UMA's Optimistic Oracle (OO), who will be the final decision\n// We also build in a multisig (controlled by UMA) to give the final approve to pay out after the OO approves a claim\n\nimport './Manager.sol';\nimport '../interfaces/managers/ISherlockClaimManager.sol';\nimport '../interfaces/managers/ISherlockProtocolManager.sol';\nimport '../interfaces/UMAprotocol/SkinnyOptimisticOracleInterface.sol';\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\n/// @dev expects 6 decimals input tokens\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 22k cost of escalating\n  /// @dev usdcFee = https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  /// @dev price = (BOND * 2) + (usdcFee * 2)\n  /// @dev this is because the price is proposed and disputed in the same transaction\n\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then, the next callback in the process, disputePriceFor(), gets called by the UMA's contract.\n  // @note Does not have reentrancy protection because it is called by the OO contract which is non-reentrant.\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then, the next callback in the process, priceSettled(), gets called by the UMA's contract.\n  // @note Does not have reentrancy protection because it is called by the OO contract which is non-reentrant.\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// This contract contains the logic for handling claims\n// The idea is that the first level of handling a claim is the Sherlock Protocol Claims Committee (SPCC)(a multisig)\n// If a protocol agent doesn't like that result, they can escalate the claim to UMA's Optimistic Oracle (OO), who will be the final decision\n// We also build in a multisig (controlled by UMA) to give the final approve to pay out after the OO approves a claim\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n/// @title Sherlock core interface for stakers\n/// @author Evert Kors\ninterface ISherlockStake {\n  /// @notice View the current lockup end timestamp of `_tokenID`\n  /// @return Timestamp when NFT position unlocks\n  function lockupEnd(uint256 _tokenID) external view returns (uint256);\n\n  /// @notice View the current SHER reward of `_tokenID`\n  /// @return Amount of SHER rewarded to owner upon reaching the end of the lockup\n  function sherRewards(uint256 _tokenID) external view returns (uint256);\n\n  /// @notice View the current token balance claimable upon reaching end of the lockup\n  /// @return Amount of tokens assigned to owner when unstaking position\n  function tokenBalanceOf(uint256 _tokenID) external view returns (uint256);\n\n  /// @notice View the current TVL for all stakers\n  /// @return Total amount of tokens staked\n  /// @dev Adds principal + strategy + premiums\n  /// @dev Will calculate the most up to date value for each piece\n  function totalTokenBalanceStakers() external view returns (uint256);\n\n  /// @notice Stakes `_amount` of tokens and locks up for `_period` seconds, `_receiver` will receive the NFT receipt\n  /// @param _amount Amount of tokens to stake\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @param _receiver Address that will receive the NFT representing the position\n  /// @return _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to this ID after `_period` ends\n  /// @dev `_period` needs to be whitelisted\n  function initialStake(\n    uint256 _amount,\n    uint256 _period,\n    address _receiver\n  ) external returns (uint256 _id, uint256 _sher);\n\n  /// @notice Redeem NFT `_id` and receive `_amount` of tokens\n  /// @param _id TokenID of the position\n  /// @return _amount Amount of tokens (USDC) owed to NFT ID\n  /// @dev Only the owner of `_id` will be able to redeem their position\n  /// @dev The SHER rewards are sent to the NFT owner\n  /// @dev Can only be called after lockup `_period` has ended\n  function redeemNFT(uint256 _id) external returns (uint256 _amount);\n\n  /// @notice Owner restakes position with ID: `_id` for `_period` seconds\n  /// @param _id ID of the position\n  /// @param _period Period of time, in seconds, to lockup your funds\n  /// @return _sher Amount of SHER tokens to be released to owner address after `_period` ends\n  /// @dev Only the owner of `_id` will be able to restake their position using this call\n  /// @dev `_period` needs to be whitelisted\n  /// @dev Can only be called after lockup `_period` has ended\n  function ownerRestake(uint256 _id, uint256 _period) external returns (uint256 _sher);\n\n  /// @notice Allows someone who doesn't own the position (an arbitrager) to restake the position for 3 months (ARB_RESTAKE_PERIOD)\n  /// @param _id ID of the position\n  /// @return _sher Amount of SHER tokens to be released to position owner on expiry of the 3 month lockup\n  /// @return _arbReward Amount of tokens (USDC) sent to caller (the arbitrager) in return for calling the function\n  /// @dev Can only be called after lockup `_period` is more than 2 weeks in the past (assuming ARB_RESTAKE_WAIT_TIME is 2 weeks)\n  /// @dev Max 20% (ARB_RESTAKE_MAX_PERCENTAGE) of tokens associated with a position are used to incentivize arbs (x)\n  /// @dev During a 2 week period the reward ratio will move from 0% to 100% (* x)\n  function arbRestake(uint256 _id) external returns (uint256 _sher, uint256 _arbReward);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\ninterface ISherDistributionManager is IManager {\n  // anyone can just send token to this contract to fund rewards\n\n  event Initialized(uint256 maxRewardsEndTVL, uint256 zeroRewardsStartTVL, uint256 maxRewardRate);\n\n  /// @notice Caller will receive `_sher` SHER tokens based on `_amount` and `_period`\n  /// @param _amount Amount of tokens (in USDC) staked\n  /// @param _period Period of time for stake, in seconds\n  /// @param _id ID for this NFT position\n  /// @param _receiver Address that will be linked to this position\n  /// @return _sher Amount of SHER tokens sent to Sherlock core contract\n  /// @dev Calling contract will depend on before + after balance diff and return value\n  /// @dev INCLUDES stake in calculation, function expects the `_amount` to be deposited already\n  /// @dev If tvl=50 and amount=50, this means it is calculating SHER rewards for the first 50 tokens going in\n  function pullReward(\n    uint256 _amount,\n    uint256 _period,\n    uint256 _id,\n    address _receiver\n  ) external returns (uint256 _sher);\n\n  /// @notice Calculates how many `_sher` SHER tokens are owed to a stake position based on `_amount` and `_period`\n  /// @param _tvl TVL to use for reward calculation (pre-stake TVL)\n  /// @param _amount Amount of tokens (USDC) staked\n  /// @param _period Stake period (in seconds)\n  /// @return _sher Amount of SHER tokens owed to this stake position\n  /// @dev EXCLUDES `_amount` of stake, this will be added on top of TVL (_tvl is excluding _amount)\n  /// @dev If tvl=0 and amount=50, it would calculate for the first 50 tokens going in (different from pullReward())\n  function calcReward(\n    uint256 _tvl,\n    uint256 _amount,\n    uint256 _period\n  ) external view returns (uint256 _sher);\n\n  /// @notice Function used to check if this is the current active distribution manager\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n/// @title Sherlock core interface for protocols\n/// @author Evert Kors\ninterface ISherlockProtocolManager is IManager {\n  // msg.sender is not authorized to call this function\n  error Unauthorized();\n\n  // If a protocol was never instantiated or was removed and the claim deadline has passed, this error is returned\n  error ProtocolNotExists(bytes32 protocol);\n\n  // When comparing two arrays and the lengths are not equal (but are supposed to be equal)\n  error UnequalArrayLength();\n\n  // If there is not enough balance in the contract for the amount requested (after any requirements are met), this is returned\n  error InsufficientBalance(bytes32 protocol);\n\n  event MinBalance(uint256 previous, uint256 current);\n\n  event AccountingError(bytes32 indexed protocol, uint256 amount, uint256 insufficientTokens);\n\n  event ProtocolAdded(bytes32 indexed protocol);\n\n  event ProtocolRemovedByArb(bytes32 indexed protocol, address arb, uint256 profit);\n\n  event ProtocolRemoved(bytes32 indexed protocol);\n\n  event ProtocolUpdated(\n    bytes32 indexed protocol,\n    bytes32 coverage,\n    uint256 nonStakers,\n    uint256 coverageAmount\n  );\n\n  event ProtocolAgentTransfer(bytes32 indexed protocol, address from, address to);\n\n  event ProtocolBalanceDeposited(bytes32 indexed protocol, uint256 amount);\n\n  event ProtocolBalanceWithdrawn(bytes32 indexed protocol, uint256 amount);\n\n  event ProtocolPremiumChanged(bytes32 indexed protocol, uint256 oldPremium, uint256 newPremium);\n\n  /// @notice View current amount of all premiums that are owed to stakers\n  /// @return Premiums claimable\n  /// @dev Will increase every block\n  /// @dev base + (now - last_settled) * ps\n  function claimablePremiums() external view returns (uint256);\n\n  /// @notice Transfer current claimable premiums (for stakers) to core Sherlock address\n  /// @dev Callable by everyone\n  /// @dev Funds will be transferred to Sherlock core contract\n  function claimPremiumsForStakers() external;\n\n  /// @notice View current protocolAgent of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @return Address able to submit claims\n  function protocolAgent(bytes32 _protocol) external view returns (address);\n\n  /// @notice View current premium of protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of premium `_protocol` pays per second\n  function premium(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice View current active balance of covered protocol\n  /// @param _protocol Protocol identifier\n  /// @return Active balance\n  /// @dev Accrued debt is subtracted from the stored active balance\n  function activeBalance(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice View seconds of coverage left for `_protocol` before it runs out of active balance\n  /// @param _protocol Protocol identifier\n  /// @return Seconds of coverage left\n  function secondsOfCoverageLeft(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice Add a new protocol to Sherlock\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Address able to submit a claim on behalf of the protocol\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Adding a protocol allows the `_protocolAgent` to submit a claim\n  /// @dev Coverage is not started yet as the protocol doesn't pay a premium at this point\n  /// @dev `_nonStakers` is scaled by 10**18\n  /// @dev Only callable by governance\n  function protocolAdd(\n    bytes32 _protocol,\n    address _protocolAgent,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external;\n\n  /// @notice Update info regarding a protocol\n  /// @param _protocol Protocol identifier\n  /// @param _coverage Hash referencing the active coverage agreement\n  /// @param _nonStakers Percentage of premium payments to nonstakers, scaled by 10**18\n  /// @param _coverageAmount Max amount claimable by this protocol\n  /// @dev Only callable by governance\n  function protocolUpdate(\n    bytes32 _protocol,\n    bytes32 _coverage,\n    uint256 _nonStakers,\n    uint256 _coverageAmount\n  ) external;\n\n  /// @notice Remove a protocol from coverage\n  /// @param _protocol Protocol identifier\n  /// @dev Before removing a protocol the premium must be 0\n  /// @dev Removing a protocol basically stops the `_protocolAgent` from being active (can still submit claims until claim deadline though)\n  /// @dev Pays off debt + sends remaining balance to protocol agent\n  /// @dev This call should be subject to a timelock\n  /// @dev Only callable by governance\n  function protocolRemove(bytes32 _protocol) external;\n\n  /// @notice Remove a protocol with insufficient active balance\n  /// @param _protocol Protocol identifier\n  function forceRemoveByActiveBalance(bytes32 _protocol) external;\n\n  /// @notice Removes a protocol with insufficent seconds of coverage left\n  /// @param _protocol Protocol identifier\n  function forceRemoveBySecondsOfCoverage(bytes32 _protocol) external;\n\n  /// @notice View minimal balance needed before liquidation can start\n  /// @return Minimal balance needed\n  function minActiveBalance() external view returns (uint256);\n\n  /// @notice Sets the minimum active balance before an arb can remove a protocol\n  /// @param _minActiveBalance Minimum balance needed (in USDC)\n  /// @dev Only gov\n  function setMinActiveBalance(uint256 _minActiveBalance) external;\n\n  /// @notice Set premium of `_protocol` to `_premium`\n  /// @param _protocol Protocol identifier\n  /// @param _premium Amount of premium `_protocol` pays per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremium(bytes32 _protocol, uint256 _premium) external;\n\n  /// @notice Set premium of multiple protocols\n  /// @param _protocol Array of protocol identifiers\n  /// @param _premium Array of premium amounts protocols pay per second\n  /// @dev The value 0 would mean inactive coverage\n  /// @dev Only callable by governance\n  function setProtocolPremiums(bytes32[] calldata _protocol, uint256[] calldata _premium) external;\n\n  /// @notice Deposits `_amount` of token to the active balance of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to deposit\n  /// @dev Approval should be made before calling\n  function depositToActiveBalance(bytes32 _protocol, uint256 _amount) external;\n\n  /// @notice Withdraws `_amount` of token from the active balance of `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens to withdraw\n  /// @dev Only protocol agent is able to withdraw\n  /// @dev Balance can be withdrawn up until 7 days worth of active balance\n  function withdrawActiveBalance(bytes32 _protocol, uint256 _amount) external;\n\n  /// @notice Transfer protocol agent role\n  /// @param _protocol Protocol identifier\n  /// @param _protocolAgent Account able to submit a claim on behalf of the protocol\n  /// @dev Only the active protocolAgent is able to transfer the role\n  function transferProtocolAgent(bytes32 _protocol, address _protocolAgent) external;\n\n  /// @notice View the amount nonstakers can claim from this protocol\n  /// @param _protocol Protocol identifier\n  /// @return Amount of tokens claimable by nonstakers\n  /// @dev this reads from a storage variable + (now-lastsettled) * premiums\n  function nonStakersClaimable(bytes32 _protocol) external view returns (uint256);\n\n  /// @notice Choose an `_amount` of tokens that nonstakers (`_receiver` address) will receive from `_protocol`\n  /// @param _protocol Protocol identifier\n  /// @param _amount Amount of tokens\n  /// @param _receiver Address to receive tokens\n  /// @dev Only callable by nonstakers role\n  function nonStakersClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver\n  ) external;\n\n  /// @param _protocol Protocol identifier\n  /// @return current and previous are the current and previous coverage amounts for this protocol\n  function coverageAmounts(bytes32 _protocol)\n    external\n    view\n    returns (uint256 current, uint256 previous);\n\n  /// @notice Function used to check if this is the current active protocol manager\n  /// @return Boolean indicating it's active\n  /// @dev If inactive the owner can pull all ERC20s and ETH\n  /// @dev Will be checked by calling the sherlock contract\n  function isActive() external view returns (bool);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\ninterface ISherlockClaimManagerCallbackReceiver {\n  /// @notice Calls this function on approved contracts and passes args\n  /// @param _protocol The protocol that is receiving the payout\n  /// @param _claimID The claim ID that is receiving the payout\n  /// @param _amount The amount of USDC being paid out for this claim\n  function PreCorePayoutCallback(\n    bytes32 _protocol,\n    uint256 _claimID,\n    uint256 _amount\n  ) external;\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity ^0.8.0;\n\n\n/**\n * @title Financial contract facing Oracle interface.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract OptimisticOracleInterface {\n  // Struct representing the state of a price request.\n  enum State {\n    Invalid, // Never requested.\n    Requested, // Requested, no other actions taken.\n    Proposed, // Proposed, but not expired or disputed yet.\n    Expired, // Proposed, not disputed, past liveness.\n    Disputed, // Disputed, but no DVM price returned yet.\n    Resolved, // Disputed and DVM price is available.\n    Settled // Final price has been set in the contract (can get here from Expired or Resolved).\n  }\n\n  // Struct representing a price request.\n  struct Request {\n    address proposer; // Address of the proposer.\n    address disputer; // Address of the disputer.\n    IERC20 currency; // ERC20 token used to pay rewards and fees.\n    bool settled; // True if the request is settled.\n    bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\n    int256 proposedPrice; // Price that the proposer submitted.\n    int256 resolvedPrice; // Price resolved once the request is settled.\n    uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n    uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n    uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n    uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n    uint256 customLiveness; // Custom liveness value set by the requester.\n  }\n\n  // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n  // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n  // to accept a price request made with ancillary data length over a certain size.\n  uint256 public constant ancillaryBytesLimit = 8192;\n\n  /**\n   * @notice Requests a new price.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data representing additional args being passed with the price request.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\n   * This can be changed with a subsequent call to setBond().\n   */\n  function requestPrice(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Set the proposal bond associated with a price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param bond custom bond amount to set.\n   * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\n   * changed again with a subsequent call to setBond().\n   */\n  function setBond(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    uint256 bond\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \"hedge\" the caller\n   * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\n   * bond, so there is still profit to be made even if the reward is refunded.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   */\n  function setRefundOnDispute(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual;\n\n  /**\n   * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\n   * being auto-resolved.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param customLiveness new custom liveness.\n   */\n  function setCustomLiveness(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    uint256 customLiveness\n  ) external virtual;\n\n  /**\n   * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n   * from this proposal. However, any bonds are pulled from the caller.\n   * @param proposer address to set as the proposer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePriceFor(\n    address proposer,\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    int256 proposedPrice\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value for an existing price request.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePrice(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n   * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n   * @param disputer address to set as the disputer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was value (the proposal was incorrect).\n   */\n  function disputePriceFor(\n    address disputer,\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price value for an existing price request with an active proposal.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePrice(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\n   * or settleable. Note: this method is not view so that this call may actually settle the price request if it\n   * hasn't been settled.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return resolved price.\n   */\n  function settleAndGetPrice(\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual returns (int256);\n\n  /**\n   * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n   * the returned bonds as well as additional rewards.\n   */\n  function settle(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) external virtual returns (uint256 payout);\n\n  /**\n   * @notice Gets the current data structure containing all information about a price request.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return the Request data structure.\n   */\n  function getRequest(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public view virtual returns (Request memory);\n\n  /**\n   * @notice Returns the state of a price request.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return the State enum value.\n   */\n  function getState(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public view virtual returns (State);\n\n  /**\n   * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @return true if price has resolved or settled, false otherwise.\n   */\n  function hasPrice(\n    address requester,\n    bytes32 identifier,\n    uint256 timestamp,\n    bytes memory ancillaryData\n  ) public view virtual returns (bool);\n\n  function stampAncillaryData(bytes memory ancillaryData, address requester)\n    public\n    view\n    virtual\n    returns (bytes memory);\n}\n\n/**\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\n * @notice Differences from normal OptimisticOracle:\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\n *   set in `requestPrice`, which has an expanded input set.\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\n *   can be fetched via the `Settle` event or the return value of `settle`.\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\n *   full request struct.\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n */\nabstract contract SkinnyOptimisticOracleInterface {\n  event RequestPrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event ProposePrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event DisputePrice(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  event Settle(\n    address indexed requester,\n    bytes32 indexed identifier,\n    uint32 timestamp,\n    bytes ancillaryData,\n    Request request\n  );\n  // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\n  // in that refundOnDispute is removed.\n  struct Request {\n    address proposer; // Address of the proposer.\n    address disputer; // Address of the disputer.\n    IERC20 currency; // ERC20 token used to pay rewards and fees.\n    bool settled; // True if the request is settled.\n    int256 proposedPrice; // Price that the proposer submitted.\n    int256 resolvedPrice; // Price resolved once the request is settled.\n    uint256 expirationTime; // Time at which the request auto-settles without a dispute.\n    uint256 reward; // Amount of the currency to pay to the proposer on settlement.\n    uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\n    uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\n    uint256 customLiveness; // Custom liveness value set by the requester.\n  }\n\n  // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\n  // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\n  // to accept a price request made with ancillary data length over a certain size.\n  uint256 public constant ancillaryBytesLimit = 8192;\n\n  /**\n   * @notice Requests a new price.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data representing additional args being passed with the price request.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n   * @param customLiveness custom proposal liveness to set for request.\n   * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\n   */\n  function requestPrice(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward,\n    uint256 bond,\n    uint256 customLiveness\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\n   * from this proposal. However, any bonds are pulled from the caller.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * propose a price for.\n   * @param proposer address to set as the proposer.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePriceFor(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    address proposer,\n    int256 proposedPrice\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Proposes a price value where caller is the proposer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * propose a price for.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function proposePrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\n   * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\n   * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\n   * @dev The caller is the requester, but the proposer can be customized.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\n   * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\n   *               which could make sense if the contract requests and proposes the value in the same call or\n   *               provides its own reward system.\n   * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\n   * @param customLiveness custom proposal liveness to set for request.\n   * @param proposer address to set as the proposer.\n   * @param proposedPrice price being proposed.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the proposer once settled if the proposal is correct.\n   */\n  function requestAndProposePriceFor(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    IERC20 currency,\n    uint256 reward,\n    uint256 bond,\n    uint256 customLiveness,\n    address proposer,\n    int256 proposedPrice\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\n   * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * dispute.\n   * @param disputer address to set as the disputer.\n   * @param requester sender of the initial price request.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePriceFor(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request,\n    address disputer,\n    address requester\n  ) public virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Disputes a price request with an active proposal where caller is the disputer.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * dispute.\n   * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\n   * the disputer once settled if the dispute was valid (the proposal was incorrect).\n   */\n  function disputePrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (uint256 totalBond);\n\n  /**\n   * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters whose hash must match the request that the caller wants to\n   * settle.\n   * @return payout the amount that the \"winner\" (proposer or disputer) receives on settlement. This amount includes\n   * the returned bonds as well as additional rewards.\n   * @return resolvedPrice the price that the request settled to.\n   */\n  function settle(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (uint256 payout, int256 resolvedPrice);\n\n  /**\n   * @notice Computes the current state of a price request. See the State enum for more details.\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters.\n   * @return the State.\n   */\n  function getState(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) external virtual returns (OptimisticOracleInterface.State);\n\n  /**\n   * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\n   * @param requester sender of the initial price request.\n   * @param identifier price identifier to identify the existing request.\n   * @param timestamp timestamp to identify the existing request.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request price request parameters. The hash of these parameters must match with the request hash that is\n   * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\n   * will revert.\n   * @return boolean indicating true if price exists and false if not.\n   */\n  function hasPrice(\n    address requester,\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    Request memory request\n  ) public virtual returns (bool);\n\n  /**\n   * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param requester sender of the initial price request.\n   * @return the stamped ancillary bytes.\n   */\n  function stampAncillaryData(bytes memory ancillaryData, address requester)\n    public\n    pure\n    virtual\n    returns (bytes memory);\n}\n\n/**\n * @title Optimistic Requester.\n * @notice Optional interface that requesters can implement to receive callbacks.\n * @dev This contract does _not_ work with ERC777 collateral currencies or any others that call into the receiver on\n * transfer(). Using an ERC777 token would allow a user to maliciously grief other participants (while also losing\n * money themselves).\n */\ninterface OptimisticRequester {\n  /**\n   * @notice Callback for proposals.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request request params after proposal.\n   */\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external;\n\n  /**\n   * @notice Callback for disputes.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request request params after dispute.\n   */\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external;\n\n  /**\n   * @notice Callback for settlement.\n   * @param identifier price identifier being requested.\n   * @param timestamp timestamp of the price being requested.\n   * @param ancillaryData ancillary data of the price being requested.\n   * @param request request params after settlement.\n   */\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external;\n}\n\ninterface ISherlockClaimManager is IManager, OptimisticRequester {\n  // Doesn't allow a new claim to be submitted by a protocol agent if a claim is already active for that protocol\n  error ClaimActive();\n\n  // If the current state of a claim does not match the expected state, this error is thrown\n  error InvalidState();\n\n  event ClaimCreated(\n    uint256 claimID,\n    bytes32 indexed protocol,\n    uint256 amount,\n    address receiver,\n    bool previousCoverageUsed\n  );\n\n  event CallbackAdded(ISherlockClaimManagerCallbackReceiver callback);\n\n  event CallbackRemoved(ISherlockClaimManagerCallbackReceiver callback);\n\n  event ClaimStatusChanged(uint256 indexed claimID, State previousState, State currentState);\n\n  event ClaimPayout(uint256 claimID, address receiver, uint256 amount);\n\n  event ClaimHalted(uint256 claimID);\n\n  event UMAHORenounced();\n\n  enum State {\n    NonExistent, // Claim doesn't exist (this is the default state on creation)\n    SpccPending, // Claim is created, SPCC is able to set state to valid\n    SpccApproved, // Final state, claim is valid\n    SpccDenied, // Claim denied by SPCC, claim can be escalated within 4 weeks\n    UmaPriceProposed, // Price is proposed but not escalated\n    ReadyToProposeUmaDispute, // Price is proposed, callback received, ready to submit dispute\n    UmaDisputeProposed, // Escalation is done, waiting for confirmation\n    UmaPending, // Claim is escalated, in case Spcc denied or didn't act within 7 days.\n    UmaApproved, // Final state, claim is valid, claim can be enacted after 1 day, umaHaltOperator has 1 day to change to denied\n    UmaDenied, // Final state, claim is invalid\n    Halted, // UMAHO can halt claim if state is UmaApproved\n    Cleaned // Claim is removed by protocol agent\n  }\n\n  struct Claim {\n    uint256 created;\n    uint256 updated;\n    address initiator;\n    bytes32 protocol;\n    uint256 amount;\n    address receiver;\n    uint32 timestamp;\n    State state;\n    bytes ancillaryData;\n  }\n\n  // requestAndProposePriceFor() --> proposer = protocolAgent\n  // disputePriceFor() --> disputor = sherlock.strategyManager() (current active one)\n  // priceSettled will be the the callback that contains the main data\n\n  // user has to pay 7.5k to dispute a claim, we will execute a safeTransferFrom(user, address(this), 7.5k)\n  // we need to approve the contract 7.5k as it will be transferred from address(this)  // + 2x final fee\n  // the bond will be 5k on requestAndProposePriceFor()                                 // + 1x final fee\n  // the bond will be 2.5k on disputePriceFor()                                         // + 1x final fee\n  // on settle eiter strategy gets 7.5k. or the proposer get their bond back.           // + 1x final fee\n\n  // lastClaimID <-- starts with 0, so initial id = 1\n  // have claim counter, easy to identify certain claims by their number\n  // but use hash(callback.request.propose + callback.timestamp) as the internal UUID to handle the callbacks\n\n  // So SPCC and UMAHO are hardcoded (UMAHO can be renounced)\n  // In case these need to be updated, deploy different contract and upgrade it on the sherlock gov side.\n\n  // On price proposed callback --> call disputePriceFor with callbackdata + sherlock.strategyManager() and address(this)\n\n  /// @notice `SHERLOCK_CLAIM` in utf8\n  function UMA_IDENTIFIER() external view returns (bytes32);\n\n  function sherlockProtocolClaimsCommittee() external view returns (address);\n\n  /// @notice operator is able to deny approved UMA claims\n  function umaHaltOperator() external view returns (address);\n\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external;\n\n  function claim(uint256 _claimID) external view returns (Claim memory);\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external;\n\n  function spccApprove(uint256 _claimID) external;\n\n  function spccRefuse(uint256 _claimID) external;\n\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev proposedPrice = _amount\n  function escalate(uint256 _claimID, uint256 _amount) external;\n\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  function payoutClaim(uint256 _claimID) external;\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  function executeHalt(uint256 _claimID) external;\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n\ninterface IStrategyManager is IManager {\n  /// @return Returns the token type being deposited into a strategy\n  function want() external view returns (IERC20);\n\n  /// @notice Withdraws all USDC from the strategy back into the Sherlock core contract\n  /// @dev Only callable by the Sherlock core contract\n  /// @return The final amount withdrawn\n  function withdrawAll() external returns (uint256);\n\n  /// @notice Withdraws a specific amount of USDC from the strategy back into the Sherlock core contract\n  /// @param _amount Amount of USDC to withdraw\n  function withdraw(uint256 _amount) external;\n\n  /// @notice Deposits all USDC held in this contract into the strategy\n  function deposit() external;\n\n  /// @return Returns the USDC balance in this contract\n  function balanceOf() external view returns (uint256);\n}\n\n/// @title Sherlock core interface for governance\n/// @author Evert Kors\ninterface ISherlockGov {\n  event ClaimPayout(address receiver, uint256 amount);\n  event YieldStrategyUpdateWithdrawAllError(bytes error);\n  event YieldStrategyUpdated(IStrategyManager previous, IStrategyManager current);\n  event ProtocolManagerUpdated(ISherlockProtocolManager previous, ISherlockProtocolManager current);\n  event ClaimManagerUpdated(ISherlockClaimManager previous, ISherlockClaimManager current);\n  event NonStakerAddressUpdated(address previous, address current);\n  event SherDistributionManagerUpdated(\n    ISherDistributionManager previous,\n    ISherDistributionManager current\n  );\n\n  event StakingPeriodEnabled(uint256 period);\n\n  event StakingPeriodDisabled(uint256 period);\n\n  /// @notice Allows stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already enabled\n  function enableStakingPeriod(uint256 _period) external;\n\n  /// @notice Disallow stakers to stake for `_period` of time\n  /// @param _period Period of time, in seconds,\n  /// @dev should revert if already disabled\n  function disableStakingPeriod(uint256 _period) external;\n\n  /// @notice View if `_period` is a valid period\n  /// @return Boolean indicating if period is valid\n  function stakingPeriods(uint256 _period) external view returns (bool);\n\n  /// @notice Update SHER distribution manager contract\n  /// @param _sherDistributionManager New adddress of the manager\n  function updateSherDistributionManager(ISherDistributionManager _sherDistributionManager)\n    external;\n\n  /// @notice Remove SHER token rewards\n  function removeSherDistributionManager() external;\n\n  /// @notice Read SHER distribution manager\n  /// @return Address of current SHER distribution manager\n  function sherDistributionManager() external view returns (ISherDistributionManager);\n\n  /// @notice Update address eligible for non staker rewards from protocol premiums\n  /// @param _nonStakers Address eligible for non staker rewards\n  function updateNonStakersAddress(address _nonStakers) external;\n\n  /// @notice View current non stakers address\n  /// @return Current non staker address\n  /// @dev Is able to pull funds out of the contract\n  function nonStakersAddress() external view returns (address);\n\n  /// @notice View current address able to manage protocols\n  /// @return Protocol manager implemenation\n  function sherlockProtocolManager() external view returns (ISherlockProtocolManager);\n\n  /// @notice Transfer protocol manager implementation address\n  /// @param _protocolManager new implementation address\n  function updateSherlockProtocolManager(ISherlockProtocolManager _protocolManager) external;\n\n  /// @notice View current address able to pull payouts\n  /// @return Address able to pull payouts\n  function sherlockClaimManager() external view returns (ISherlockClaimManager);\n\n  /// @notice Transfer claim manager role to different address\n  /// @param _claimManager New address of claim manager\n  function updateSherlockClaimManager(ISherlockClaimManager _claimManager) external;\n\n  /// @notice Update yield strategy\n  /// @param _yieldStrategy New address of the strategy\n  /// @dev try a yieldStrategyWithdrawAll() on old, ignore failure\n  function updateYieldStrategy(IStrategyManager _yieldStrategy) external;\n\n  /// @notice Update yield strategy ignoring current state\n  /// @param _yieldStrategy New address of the strategy\n  /// @dev tries a yieldStrategyWithdrawAll() on old strategy, ignore failure\n  function updateYieldStrategyForce(IStrategyManager _yieldStrategy) external;\n\n  /// @notice Read current strategy\n  /// @return Address of current strategy\n  /// @dev can never be address(0)\n  function yieldStrategy() external view returns (IStrategyManager);\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n/// @title Sherlock interface for payout manager\n/// @author Evert Kors\ninterface ISherlockPayout {\n  /// @notice Initiate a payout of `_amount` to `_receiver`\n  /// @param _receiver Receiver of payout\n  /// @param _amount Amount to send\n  /// @dev only payout manager should call this\n  /// @dev should pull money out of strategy\n  function payoutClaim(address _receiver, uint256 _amount) external;\n}\n// IGNORE_LICENSE-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/******************************************************************************\\\n* Author: Evert Kors <dev@sherlock.xyz> (https://twitter.com/evert0x)\n* Sherlock Protocol: https://sherlock.xyz\n/******************************************************************************/\n\n\n/// @title Sherlock core interface for yield strategy\n/// @author Evert Kors\ninterface ISherlockStrategy {\n  /// @notice Deposit `_amount` into active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyDeposit(uint256 _amount) external;\n\n  /// @notice Withdraw `_amount` from active strategy\n  /// @param _amount Amount of tokens\n  /// @dev gov only\n  function yieldStrategyWithdraw(uint256 _amount) external;\n\n  /// @notice Withdraw all funds from active strategy\n  /// @dev gov only\n  function yieldStrategyWithdrawAll() external;\n}\n\ninterface ISherlock is ISherlockStake, ISherlockGov, ISherlockPayout, ISherlockStrategy, IERC721 {\n  // msg.sender is not authorized to call this function\n  error Unauthorized();\n\n  // An address or other value passed in is equal to zero (and shouldn't be)\n  error ZeroArgument();\n\n  // Occurs when a value already holds the desired property, or is not whitelisted\n  error InvalidArgument();\n\n  // Required conditions are not true/met\n  error InvalidConditions();\n\n  // If the SHER tokens held in a contract are not the value they are supposed to be\n  error InvalidSherAmount(uint256 expected, uint256 actual);\n\n  // Checks the ERC-721 functions _exists() to see if an NFT ID actually exists and errors if not\n  error NonExistent();\n\n  event ArbRestaked(uint256 indexed tokenID, uint256 reward);\n\n  event Restaked(uint256 indexed tokenID);\n}\n\n\ninterface IManager {\n  // An address or other value passed in is equal to zero (and shouldn't be)\n  error ZeroArgument();\n\n  // Occurs when a value already holds the desired property, or is not whitelisted\n  error InvalidArgument();\n\n  // If a required condition for executing the function is not met, it reverts and throws this error\n  error InvalidConditions();\n\n  // Throws if the msg.sender is not the required address\n  error InvalidSender();\n\n  event SherlockCoreSet(ISherlock sherlock);\n\n  /// @notice Set sherlock core address where premiums should be send too\n  /// @param _sherlock Current core contract\n  /// @dev Only deployer is able to set core address on all chains except Hardhat network\n  /// @dev One time function, will revert once `sherlock` != address(0)\n  /// @dev This contract will be deployed first, passed on as argument in core constuctor\n  /// @dev ^ that's needed for tvl accounting, once core is deployed this function is called\n  /// @dev emits `SherlockCoreSet`\n  function setSherlockCoreAddress(ISherlock _sherlock) external;\n\n  /// @notice Pause external functions in contract\n  function pause() external;\n\n  /// @notice Unpause external functions in contract\n  function unpause() external;\n}\n\nabstract contract Manager is IManager, Ownable, Pausable {\n  using SafeERC20 for IERC20;\n\n  address private constant DEPLOYER = 0xAdBb28C2FEe078440B7088bbcd68DCfA63e55625;\n  ISherlock internal sherlockCore;\n\n  modifier onlySherlockCore() {\n    if (msg.sender != address(sherlockCore)) revert InvalidSender();\n    _;\n  }\n\n  /// @notice Set sherlock core address\n  /// @param _sherlock Current core contract\n  /// @dev Only deployer is able to set core address on all chains except Hardhat network\n  /// @dev One time function, will revert once `sherlock` != address(0)\n  /// @dev This contract will be deployed first, passed on as argument in core constuctor\n  /// @dev emits `SherlockCoreSet`\n  function setSherlockCoreAddress(ISherlock _sherlock) external override {\n    if (address(_sherlock) == address(0)) revert ZeroArgument();\n    // 31337 is of the Hardhat network blockchain\n    if (block.chainid != 31337 && msg.sender != DEPLOYER) revert InvalidSender();\n\n    if (address(sherlockCore) != address(0)) revert InvalidConditions();\n    sherlockCore = _sherlock;\n\n    emit SherlockCoreSet(_sherlock);\n  }\n\n  // Internal function to send tokens remaining in a contract to the receiver address\n  function _sweep(address _receiver, IERC20[] memory _extraTokens) internal {\n    // Loops through the extra tokens (ERC20) provided and sends all of them to the receiver address\n    for (uint256 i; i < _extraTokens.length; i++) {\n      IERC20 token = _extraTokens[i];\n      token.safeTransfer(_receiver, token.balanceOf(address(this)));\n    }\n    // Sends any remaining ETH to the receiver address (as long as receiver address is payable)\n    (bool success, ) = _receiver.call{ value: address(this).balance }('');\n    if (success == false) revert InvalidConditions();\n  }\n\n  function pause() external onlySherlockCore {\n    _pause();\n  }\n\n  function unpause() external onlySherlockCore {\n    _unpause();\n  }\n}\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\n/// @dev expects 6 decimals input tokens\ncontract SherlockClaimManager is ISherlockClaimManager, ReentrancyGuard, Manager {\n  using SafeERC20 for IERC20;\n\n  // The bond required for a protocol agent to escalate a claim to UMA Optimistic Oracle (OO)\n  /// @dev at time of writing will result in a 22k cost of escalating\n  /// @dev usdcFee = https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/Store.sol#L131\n  /// @dev price = (BOND * 2) + (usdcFee * 2)\n  /// @dev this is because the price is proposed and disputed in the same transaction\n\n  uint256 internal constant BOND = 9_600 * 10**6; // 20k bond\n\n  // The amount of time the protocol agent has to escalate a claim\n  uint256 public constant ESCALATE_TIME = 4 weeks;\n\n  // The UMA Halt Operator (UMAHO) is the multisig (controlled by UMA) who gives final approval to pay out a claim\n  // After the OO has voted to pay out\n  // This variable represents the amount of time during which UMAHO can block a claim that was approved by the OO\n  // After this time period, the claim (which was approved by the OO) is inferred to be approved by UMAHO as well\n  uint256 public constant UMAHO_TIME = 24 hours;\n\n  // The amount of time the Sherlock Protocol Claims Committee (SPCC) gets to decide on a claim\n  // If no action is taken by SPCC during this time, then the protocol agent can escalate the decision to the UMA OO\n  uint256 public constant SPCC_TIME = 7 days;\n\n  // A pre-defined amount of time for the proposed price ($0) to be disputed within the OO\n  // Note This value is not important as we immediately dispute the proposed price\n  // 7200 represents 2 hours\n  uint256 internal constant LIVENESS = 7200;\n\n  // This is how UMA will know that Sherlock is requesting a decision from the OO\n  // This is \"SHERLOCK_CLAIM\" in hex value\n  bytes32 public constant override UMA_IDENTIFIER =\n    bytes32(0x534845524c4f434b5f434c41494d000000000000000000000000000000000000);\n\n  uint256 public constant MAX_CALLBACKS = 4;\n\n  // The Optimistic Oracle contract that we interact with\n  SkinnyOptimisticOracleInterface public constant UMA =\n    SkinnyOptimisticOracleInterface(0xeE3Afe347D5C74317041E2618C49534dAf887c24);\n\n  // USDC\n  IERC20 public constant TOKEN = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n  // The address of the multisig controlled by UMA that can emergency halt a claim that was approved by the OO\n  address public override umaHaltOperator;\n  // The address of the multisig controlled by Sherlock advisors who make the first judgment on a claim\n  address public immutable override sherlockProtocolClaimsCommittee;\n\n  // Takes a protocol's internal ID as a key and whether or not the protocol has a claim active as the value\n  // Note Each protocol can only have one claim active at a time (this prevents spam)\n  mapping(bytes32 => bool) public protocolClaimActive;\n\n  // A protocol's public claim ID is simply incremented by 1 from the last claim ID made by any protocol (1, 2, 3, etc.)\n  // A protocol's internal ID is the keccak256() of a protocol's ancillary data field\n  // A protocol's ancillary data field will contain info like the hash of the protocol's coverage agreement (each will be unique)\n  // The public ID (1, 2, 3, etc.) is easy to track while the internal ID is used for interacting with UMA\n  mapping(uint256 => bytes32) internal publicToInternalID;\n\n  // Opposite of the last field, allows us to move between a protocol's public ID and internal ID\n  mapping(bytes32 => uint256) internal internalToPublicID;\n\n  // Protocol's internal ID is the key, active claim is the value\n  // Claim object is initialized in startClaim() below\n  // See ISherlockClaimManager.sol for Claim struct\n  mapping(bytes32 => Claim) internal claims_;\n\n  // The last claim ID we used for a claim (ID is incremented by 1 each time)\n  uint256 internal lastClaimID;\n\n  // A request object used in the UMA OO\n  SkinnyOptimisticOracleInterface.Request private umaRequest;\n\n  // An array of contracts that implement the callback provided in this contract\n  ISherlockClaimManagerCallbackReceiver[] public claimCallbacks;\n\n  // Used for callbacks on UMA functions\n  // This modifier is used for a function being called by the OO contract, requires this contract as caller\n  // Requires the OO contract to pass in the Sherlock identifier\n  modifier onlyUMA(bytes32 identifier) {\n    if (identifier != UMA_IDENTIFIER) revert InvalidArgument();\n    if (msg.sender != address(UMA)) revert InvalidSender();\n    _;\n  }\n\n  // Only the Sherlock Claims Committee multisig can call a function with this modifier\n  modifier onlySPCC() {\n    if (msg.sender != sherlockProtocolClaimsCommittee) revert InvalidSender();\n    _;\n  }\n\n  // Only the UMA Halt Operator multisig can call a function with this modifier\n  modifier onlyUMAHO() {\n    if (msg.sender != umaHaltOperator) revert InvalidSender();\n    _;\n  }\n\n  // We pass in the contract addresses (both will be multisigs) in the constructor\n  constructor(address _umaho, address _spcc) {\n    if (_umaho == address(0)) revert ZeroArgument();\n    if (_spcc == address(0)) revert ZeroArgument();\n\n    umaHaltOperator = _umaho;\n    sherlockProtocolClaimsCommittee = _spcc;\n  }\n\n  // Checks to see if a claim can be escalated to the UMA OO\n  // Claim must be either\n  // 1) Denied by SPCC and within 4 weeks after denial\n  // 2) Beyond the designated time window for SPCC to respond\n  function _isEscalateState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccDenied && block.timestamp <= updated + ESCALATE_TIME) return true;\n\n    uint256 spccDeadline = updated + SPCC_TIME;\n    if (\n      _oldState == State.SpccPending &&\n      spccDeadline < block.timestamp &&\n      block.timestamp <= spccDeadline + ESCALATE_TIME\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  // Checks to see if a claim can be paid out\n  // Will be paid out if:\n  // 1) SPCC approved it\n  // 2) UMA OO approved it and there is no UMAHO anymore\n  // 3) UMA OO approved it and the designated window for the UMAHO to block it has passed\n  function _isPayoutState(State _oldState, uint256 updated) internal view returns (bool) {\n    if (_oldState == State.SpccApproved) return true;\n\n    // If there is no UMA Halt Operator, then it can be paid out on UmaApproved state\n    if (umaHaltOperator == address(0)) {\n      if (_oldState == State.UmaApproved) return true;\n    } else {\n      // If there IS a nonzero UMAHO address, must wait for UMAHO halt period to pass\n      if (_oldState == State.UmaApproved && updated + UMAHO_TIME < block.timestamp) return true;\n    }\n    return false;\n  }\n\n  function _isCleanupState(State _oldState) internal pure returns (bool) {\n    if (_oldState == State.SpccDenied) return true;\n    if (_oldState == State.SpccPending) return true;\n    return false;\n  }\n\n  // Deletes the data associated with a claim (after claim has reached its final state)\n  // _claimIdentifier is the internal claim ID\n  function _cleanUpClaim(bytes32 _claimIdentifier) internal {\n    // Protocol no longer has an active claim associated with it\n    delete protocolClaimActive[claims_[_claimIdentifier].protocol];\n    // Claim object is deleted\n    delete claims_[_claimIdentifier];\n\n    uint256 publicID = internalToPublicID[_claimIdentifier];\n    // Deletes the public and internal ID key mappings\n    delete publicToInternalID[publicID];\n    delete internalToPublicID[_claimIdentifier];\n  }\n\n  // Each claim has a state that represents what part of the claims process it is in\n  // _claimIdentifier is the internal claim ID\n  // _state represents the state to which a protocol's state field will be changed\n  // See ISherlockClaimManager.sol for the State enum\n  function _setState(bytes32 _claimIdentifier, State _state) internal returns (State _oldState) {\n    // retrieves the Claim object\n    Claim storage claim = claims_[_claimIdentifier];\n    // retrieves the current state (which we preemptively set to the old state)\n    _oldState = claim.state;\n\n    emit ClaimStatusChanged(internalToPublicID[_claimIdentifier], _oldState, _state);\n\n    // If the new state is NonExistent, then we clean up this claim (delete the claim effectively)\n    // Else we update the state to the new state and record the last updated timestamp\n    if (_state == State.NonExistent) {\n      _cleanUpClaim(_claimIdentifier);\n    } else {\n      claims_[_claimIdentifier].state = _state;\n      claims_[_claimIdentifier].updated = block.timestamp;\n    }\n  }\n\n  // Allows us to remove the UMA Halt Operator multisig address if we decide we no longer need UMAHO's services\n  /// @notice gov is able to renounce the role\n  function renounceUmaHaltOperator() external override onlyOwner {\n    if (umaHaltOperator == address(0)) revert InvalidConditions();\n\n    delete umaHaltOperator;\n    emit UMAHORenounced();\n  }\n\n  // Returns the Claim struct for a given claim ID (function takes public ID but converts to internal ID)\n  function claim(uint256 _claimID) external view override returns (Claim memory claim_) {\n    bytes32 id_ = publicToInternalID[_claimID];\n    if (id_ == bytes32(0)) revert InvalidArgument();\n\n    claim_ = claims_[id_];\n    if (claim_.state == State.NonExistent) revert InvalidArgument();\n  }\n\n  // This function allows a new contract to be added that will implement PreCorePayoutCallback()\n  // The intention of this callback is to allow other contracts to trigger payouts, etc. when Sherlock triggers one\n  // This would be helpful for a reinsurer who should pay out when Sherlock pays out\n  // Data is passed to the \"reinsurer\" so it can know if it should pay out and how much\n  /// @dev only add trusted and gas verified callbacks.\n  function addCallback(ISherlockClaimManagerCallbackReceiver _callback)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // Checks to see if the max amount of callback contracts has been reached\n    if (claimCallbacks.length == MAX_CALLBACKS) revert InvalidState();\n    // Checks to see if this callback contract already exists\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      if (claimCallbacks[i] == _callback) revert InvalidArgument();\n    }\n\n    claimCallbacks.push(_callback);\n    emit CallbackAdded(_callback);\n  }\n\n  // This removes a contract from the claimCallbacks array\n  function removeCallback(ISherlockClaimManagerCallbackReceiver _callback, uint256 _index)\n    external\n    onlyOwner\n    nonReentrant\n  {\n    if (address(_callback) == address(0)) revert ZeroArgument();\n    // If the index and the callback contract don't line up, revert\n    if (claimCallbacks[_index] != _callback) revert InvalidArgument();\n\n    // Move last index to index of _callback\n    // Creates a copy of the last index value and pastes it over the _index value\n    claimCallbacks[_index] = claimCallbacks[claimCallbacks.length - 1];\n    // Remove last index (because it is now a duplicate)\n    claimCallbacks.pop();\n    emit CallbackRemoved(_callback);\n  }\n\n  /// @notice Cleanup claim if escalation is not pursued\n  /// @param _protocol protocol ID\n  /// @param _claimID public claim ID\n  /// @dev Retrieves current protocol agent for cleanup\n  /// @dev State is either SpccPending or SpccDenied\n  function cleanUp(bytes32 _protocol, uint256 _claimID) external whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_claimID == uint256(0)) revert ZeroArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    // If there is no active claim\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // verify if claim belongs to protocol agent\n    if (claim.protocol != _protocol) revert InvalidArgument();\n\n    State _oldState = _setState(claimIdentifier, State.Cleaned);\n    if (_isCleanupState(_oldState) == false) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Cleaned) revert InvalidState();\n  }\n\n  /// @notice Initiate a claim for a specific protocol as the protocol agent\n  /// @param _protocol protocol ID (different from the internal or public claim ID fields)\n  /// @param _amount amount of USDC which is being claimed by the protocol\n  /// @param _receiver address to receive the amount of USDC being claimed\n  /// @param _timestamp timestamp at which the exploit first occurred\n  /// @param ancillaryData other data associated with the claim, such as the coverage agreement\n  /// @dev The protocol agent that starts a claim will be the protocol agent during the claims lifecycle\n  /// @dev Even if the protocol agent role is tranferred during the lifecycle\n  /// @dev This is done because a protocols coverage can end after an exploit, either wilfully or forcefully.\n  /// @dev The protocol agent is still active for 7 days after coverage ends, so a claim can still be submitted.\n  /// @dev But in case the claim is approved after the 7 day period, `payoutClaim()` can not be called as the protocol agent is 0\n  function startClaim(\n    bytes32 _protocol,\n    uint256 _amount,\n    address _receiver,\n    uint32 _timestamp,\n    bytes memory ancillaryData\n  ) external override nonReentrant whenNotPaused {\n    if (_protocol == bytes32(0)) revert ZeroArgument();\n    if (_amount == uint256(0)) revert ZeroArgument();\n    if (_receiver == address(0)) revert ZeroArgument();\n    if (_timestamp == uint32(0)) revert ZeroArgument();\n    if (_timestamp >= block.timestamp) revert InvalidArgument();\n    if (ancillaryData.length == 0) revert ZeroArgument();\n    if (address(sherlockCore) == address(0)) revert InvalidConditions();\n    // Protocol must not already have another claim active\n    if (protocolClaimActive[_protocol]) revert ClaimActive();\n\n    // Creates the internal ID for this claim\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n    // State for this newly created claim must be equal to the default state (NonExistent)\n    if (claims_[claimIdentifier].state != State.NonExistent) revert InvalidArgument();\n\n    // Gets the instance of the protocol manager contract\n    ISherlockProtocolManager protocolManager = sherlockCore.sherlockProtocolManager();\n    // Gets the protocol agent associated with the protocol ID passed in\n    address agent = protocolManager.protocolAgent(_protocol);\n    // Caller of this function must be the protocol agent address associated with the protocol ID passed in\n    if (msg.sender != agent) revert InvalidSender();\n\n    // Gets the current and previous coverage amount for this protocol\n    (uint256 current, uint256 previous) = protocolManager.coverageAmounts(_protocol);\n    // The max amount a protocol can claim is the higher of the current and previous coverage amounts\n    uint256 maxClaim = current > previous ? current : previous;\n    // True if a protocol is claiming based on its previous coverage amount (only used in event emission)\n    bool prevCoverage = _amount > current;\n    // Requires the amount claimed is less than or equal to the higher of the current and previous coverage amounts\n    if (_amount > maxClaim) revert InvalidArgument();\n\n    // Increments the last claim ID by 1 to get the public claim ID\n    // Note initial claimID will be 1\n    uint256 claimID = ++lastClaimID;\n    // Protocol now has an active claim\n    protocolClaimActive[_protocol] = true;\n    // Sets the mappings for public and internal claim IDs\n    publicToInternalID[claimID] = claimIdentifier;\n    internalToPublicID[claimIdentifier] = claimID;\n\n    // Initializes a Claim object and adds it to claims_ mapping\n    // Created and updated fields are set to current time\n    // State is updated to SpccPending (waiting on SPCC decision now)\n    claims_[claimIdentifier] = Claim(\n      block.timestamp,\n      block.timestamp,\n      msg.sender,\n      _protocol,\n      _amount,\n      _receiver,\n      _timestamp,\n      State.SpccPending,\n      ancillaryData\n    );\n\n    emit ClaimCreated(claimID, _protocol, _amount, _receiver, prevCoverage);\n    emit ClaimStatusChanged(claimID, State.NonExistent, State.SpccPending);\n  }\n\n  // Only SPCC can call this\n  // SPCC approves the claim and it can now be paid out\n  // Requires that the last state of the claim was SpccPending\n  function spccApprove(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccApproved) != State.SpccPending) revert InvalidState();\n  }\n\n  // Only SPCC can call this\n  // SPCC denies the claim and now the protocol agent can escalate to UMA OO if they desire\n  function spccRefuse(uint256 _claimID) external override whenNotPaused onlySPCC nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    if (_setState(claimIdentifier, State.SpccDenied) != State.SpccPending) revert InvalidState();\n  }\n\n  // If SPCC denied (or didn't respond to) the claim, a protocol agent can now escalate it to UMA's OO\n  /// @notice Callable by protocol agent\n  /// @param _claimID Public claim ID\n  /// @param _amount Bond amount sent by protocol agent\n  /// @dev Use hardcoded USDC address\n  /// @dev Use hardcoded bond amount\n  /// @dev Use hardcoded liveness 7200 (2 hours)\n  /// @dev Requires the caller to be the account that initially started the claim\n  // Amount sent needs to be at least equal to the BOND amount required\n  function escalate(uint256 _claimID, uint256 _amount)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n  {\n    if (_amount < BOND) revert InvalidArgument();\n\n    // Gets the internal ID of the claim\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Retrieves the claim struct\n    Claim storage claim = claims_[claimIdentifier];\n    // Requires the caller to be the account that initially started the claim\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    // Timestamp when claim was last updated\n    uint256 updated = claim.updated;\n    // Sets the state to UmaPriceProposed\n    State _oldState = _setState(claimIdentifier, State.UmaPriceProposed);\n\n    // Can this claim be updated (based on its current state)? If no, revert\n    if (_isEscalateState(_oldState, updated) == false) revert InvalidState();\n\n    // Transfers the bond amount from the protocol agent to this address\n    TOKEN.safeTransferFrom(msg.sender, address(this), _amount);\n    // Approves the OO contract to spend the bond amount\n    TOKEN.safeApprove(address(UMA), _amount);\n\n    // Sherlock protocol proposes a claim amount of $0 to the UMA OO to begin with\n    // This line https://github.com/UMAprotocol/protocol/blob/master/packages/core/contracts/oracle/implementation/SkinnyOptimisticOracle.sol#L585\n    // Will result in disputeSuccess=true if the DVM resolved price != 0\n    // Note: The resolved price needs to exactly match the claim amount\n    // Otherwise the `umaApproved` in our settled callback will be false\n    UMA.requestAndProposePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      TOKEN, // USDC\n      0, // Reward is 0, Sherlock handles rewards on its own\n      BOND, // Cost of making a request to the UMA OO (as decided by Sherlock)\n      LIVENESS, // Proposal liveness\n      address(sherlockCore), // Sherlock core address\n      0 // price\n    );\n\n    // If the state is not equal to ReadyToProposeUmaDispute, revert\n    // Then set the new state to UmaDisputeProposed\n    // Note State gets set to ReadyToProposeUmaDispute in the callback function from requestAndProposePriceFor()\n    if (_setState(claimIdentifier, State.UmaDisputeProposed) != State.ReadyToProposeUmaDispute) {\n      revert InvalidState();\n    }\n\n    // The protocol agent is now disputing Sherlock's proposed claim amount of $0\n    UMA.disputePriceFor(\n      UMA_IDENTIFIER, // Sherlock ID so UMA knows the request came from Sherlock\n      claim.timestamp, // Timestamp to identify the request\n      claim.ancillaryData, // Ancillary data such as the coverage agreement\n      umaRequest, // Refers to the original request made by Sherlock in requestAndProposePriceFor()\n      msg.sender, // Protocol agent, known as the disputer (the one who is disputing Sherlock's $0 proposed claim amount)\n      address(this) // This contract's address is the requester (Sherlock made the original request and proposed $0 claim amount)\n    );\n\n    // State gets updated to UmaPending in the disputePriceFor() callback (priceDisputed())\n    if (claim.state != State.UmaPending) revert InvalidState();\n\n    // Deletes the original request made by Sherlock\n    delete umaRequest;\n    // Approves the OO to spend $0\n    // This is just out of caution, don't want UMA to be approved for any amount of tokens they shouldn't be\n    TOKEN.safeApprove(address(UMA), 0);\n    // Checks for remaining balance in the contract\n    uint256 remaining = TOKEN.balanceOf(address(this));\n    // Sends remaining balance to the protocol agent\n    // A protocol agent should be able to send the exact amount to avoid the extra gas from this function\n    if (remaining != 0) TOKEN.safeTransfer(msg.sender, remaining);\n  }\n\n  // Checks to make sure a payout is valid, then calls the core Sherlock payout function\n  /// @notice Execute claim, storage will be removed after\n  /// @param _claimID Public ID of the claim\n  /// @dev Needs to be SpccApproved or UmaApproved && >UMAHO_TIME\n  /// @dev Funds will be pulled from core\n  // We are ok with spending the extra time to wait for the UMAHO time to expire before paying out\n  // We could have UMAHO multisig send a tx to confirm the payout (payout would happen sooner),\n  // But doesn't seem worth it to save half a day or so\n  function payoutClaim(uint256 _claimID) external override nonReentrant whenNotPaused {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    Claim storage claim = claims_[claimIdentifier];\n    // Only the claim initiator can call this, and payout gets sent to receiver address\n    if (msg.sender != claim.initiator) revert InvalidSender();\n\n    bytes32 protocol = claim.protocol;\n    // Address to receive the payout\n    // Note We could make the receiver a param in this function, but we want it to be known asap\n    // Can find and correct problems if the receiver is specified when the claim is initiated\n    address receiver = claim.receiver;\n    // Amount (in USDC) to be paid out\n    uint256 amount = claim.amount;\n    // Time when claim was last updated\n    uint256 updated = claim.updated;\n\n    // Sets new state to NonExistent as the claim is over once it is paid out\n    State _oldState = _setState(claimIdentifier, State.NonExistent);\n    // Checks to make sure this claim can be paid out\n    if (_isPayoutState(_oldState, updated) == false) revert InvalidState();\n\n    // Calls the PreCorePayoutCallback function on any contracts in claimCallbacks\n    for (uint256 i; i < claimCallbacks.length; i++) {\n      claimCallbacks[i].PreCorePayoutCallback(protocol, _claimID, amount);\n    }\n\n    emit ClaimPayout(_claimID, receiver, amount);\n\n    // We could potentially transfer more than `amount` in case balance > amount\n    // We are leaving this as is for simplicity's sake\n    // We don't expect to have tokens in this contract unless a reinsurer is providing them for a payout\n    // In which case they should provide the exact amount, and balance == amount is true\n    uint256 balance = TOKEN.balanceOf(address(this));\n    if (balance != 0) TOKEN.safeTransfer(receiver, balance);\n    if (balance < amount) sherlockCore.payoutClaim(receiver, amount - balance);\n  }\n\n  /// @notice UMAHO is able to execute a halt if the state is UmaApproved and state was updated less than UMAHO_TIME ago\n  // Once the UMAHO_TIME is up, UMAHO can still halt the claim, but only if the claim hasn't been paid out yet\n  function executeHalt(uint256 _claimID) external override whenNotPaused onlyUMAHO nonReentrant {\n    bytes32 claimIdentifier = publicToInternalID[_claimID];\n    if (claimIdentifier == bytes32(0)) revert InvalidArgument();\n\n    // Sets state of claim to nonexistent, reverts if the old state was anything but UmaApproved\n    if (_setState(claimIdentifier, State.Halted) != State.UmaApproved) revert InvalidState();\n    if (_setState(claimIdentifier, State.NonExistent) != State.Halted) revert InvalidState();\n\n    emit ClaimHalted(_claimID);\n  }\n\n  //\n  // UMA callbacks\n  //\n\n  // Once requestAndProposePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaPriceProposed to ReadyToProposeUmaDispute\n  // Then, the next callback in the process, disputePriceFor(), gets called by the UMA's contract.\n  // @note Does not have reentrancy protection because it is called by the OO contract which is non-reentrant.\n  function priceProposed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to ReadyToProposeUmaDispute\n    if (_setState(claimIdentifier, State.ReadyToProposeUmaDispute) != State.UmaPriceProposed) {\n      revert InvalidState();\n    }\n    // Sets global umaRequest variable to the request coming from this price proposal\n    umaRequest = request;\n  }\n\n  // Once disputePriceFor() is executed in UMA's contracts, this function gets called\n  // We change the claim's state from UmaDisputeProposed to UmaPending\n  // Then, the next callback in the process, priceSettled(), gets called by the UMA's contract.\n  // @note Does not have reentrancy protection because it is called by the OO contract which is non-reentrant.\n  function priceDisputed(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override whenNotPaused onlyUMA(identifier) {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n    if (claim.updated != block.timestamp) revert InvalidConditions();\n\n    // Sets state to UmaPending\n    if (_setState(claimIdentifier, State.UmaPending) != State.UmaDisputeProposed) {\n      revert InvalidState();\n    }\n  }\n\n  // Once priceSettled() is executed in UMA's contracts, this function gets called\n  // UMA OO gives back a resolved price (either 0 or claim.amount) and\n  // Claim's state is changed to either UmaApproved or UmaDenied\n  // If UmaDenied, the claim is dead and state is immediately changed to NonExistent and cleaned up\n  /// @dev still want to capture settled price in a paused state. Otherwise claim is stuck.\n  function priceSettled(\n    bytes32 identifier,\n    uint32 timestamp,\n    bytes memory ancillaryData,\n    SkinnyOptimisticOracleInterface.Request memory request\n  ) external override onlyUMA(identifier) nonReentrant {\n    bytes32 claimIdentifier = keccak256(ancillaryData);\n\n    Claim storage claim = claims_[claimIdentifier];\n\n    // Retrives the resolved price for this claim (either 0 if Sherlock wins, or the amount of the claim as proposed by the protocol agent)\n    uint256 resolvedPrice = uint256(request.resolvedPrice);\n    // UMA approved the claim if the resolved price is equal to the claim amount set by the protocol agent\n    bool umaApproved = resolvedPrice == claim.amount;\n\n    // If UMA approves the claim, set state to UmaApproved\n    // If UMA denies, set state to UmaDenied, then to NonExistent (deletes the claim data)\n    if (umaApproved) {\n      if (_setState(claimIdentifier, State.UmaApproved) != State.UmaPending) revert InvalidState();\n    } else {\n      if (_setState(claimIdentifier, State.UmaDenied) != State.UmaPending) revert InvalidState();\n      if (_setState(claimIdentifier, State.NonExistent) != State.UmaDenied) revert InvalidState();\n    }\n  }\n}\n", "commit_id": "aace01f52c94cb0f54006ca449bfe94528a80229"}}