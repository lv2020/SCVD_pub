{"filename": "contracts/Conference.sol", "patch": "@@ -36,7 +36,7 @@ contract Conference is Rejector, Killable {\n \t\tif (msg.value == deposit) {\n \t\t\t_;\n \t\t}else{\n-\t\t\tif(msg.sender.send(msg.value)){/* not much you can do */}\n+\t\t\tif(!msg.sender.send(msg.value)) throw;\n \t\t}\n \t}\n \n@@ -50,15 +50,15 @@ contract Conference is Rejector, Killable {\n \t\tif (ended == false) {\n \t\t\t_;\n \t\t}else{\n-\t\t\tif(msg.sender.send(msg.value)){/*not much you can do*/}\n+\t\t\tif(!msg.sender.send(msg.value)) throw;\n \t\t}\n \t}\n \n \tmodifier withinLimitOrReturn {\n \t\tif (registered < limitOfParticipants ) {\n \t\t\t_;\n \t\t}else{\n-\t\t\tif(msg.sender.send(msg.value)){/* not much you can do */}\n+\t\t\tif(!msg.sender.send(msg.value)) throw;\n \t\t}\n \t}\n \n@@ -116,9 +116,10 @@ contract Conference is Rejector, Killable {\n \n \tfunction withdraw() public onlyPayable notPaid {\n \t\tParticipant participant = participants[msg.sender];\n-\t\tif (msg.sender.send(participant.payout)) {\n-\t\t\tparticipant.paid = true;\n-\t\t\ttotalBalance -= participant.payout;\n+\t\tparticipant.paid = true;\n+\t\ttotalBalance -= participant.payout;\n+\t\tif (!msg.sender.send(participant.payout)) {\n+\t\t\tthrow;\n \t\t}\n \t}\n \n@@ -162,9 +163,9 @@ contract Conference is Rejector, Killable {\n \n \t/* return the remaining of balance if there are any unclaimed after cooling period */\n \tfunction clear() public onlyOwner isEnded onlyAfter(endedAt + coolingPeriod) {\n-\t\tif(owner.send(totalBalance)){\n-\t\t\ttotalBalance = 0;\n-\t\t}\n+\t\tvar leftOver = totalBalance;\n+\t\ttotalBalance = 0;\n+\t\tif(!owner.send(leftOver)) throw;\n \t}\n \n \tfunction setLimitOfParticipants(uint _limitOfParticipants) public onlyOwner{", "project_link": "https://github.com/makoto/blockparty/commit/20c22f060bee358e423646afcc4d79e1346da3f9", "bug_version": {"raw_code": "pragma solidity ^0.4.2;\nimport './zeppelin/Rejector.sol';\nimport './zeppelin/Ownable.sol';\nimport './zeppelin/Killable.sol';\n\ncontract Conference is Rejector, Killable {\n\tstring public name;\n\tuint256 public totalBalance;\n\tuint256 public deposit;\n\tuint public limitOfParticipants;\n\tuint public registered;\n\tuint public attended;\n\tbool public ended;\n\tuint public endedAt;\n\tuint public coolingPeriod;\n\n\tmapping (address => Participant) public participants;\n\tmapping (uint => address) public participantsIndex;\n\tbool paid;\n\tuint256 _payout;\n\n\tstruct Participant {\n\t\tstring participantName;\n\t\taddress addr;\n\t\tbool attended;\n\t\tuint256 payout;\n\t\tbool paid;\n\t}\n\n\tevent Register(string participantName, address addr, uint256 balance, uint256 value);\n\tevent Attend(address addr, uint256 balance);\n\tevent Payback(address addr, uint256 _payout, uint256 balance, bool paid);\n\n\t/* Modifiers */\n\tmodifier sentDepositOrReturn {\n\t\tif (msg.value == deposit) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(msg.sender.send(msg.value)){/* not much you can do */}\n\t\t}\n\t}\n\n\tmodifier onlyActive {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyActiveOrReturn {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(msg.sender.send(msg.value)){/*not much you can do*/}\n\t\t}\n\t}\n\n\tmodifier withinLimitOrReturn {\n\t\tif (registered < limitOfParticipants ) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(msg.sender.send(msg.value)){/* not much you can do */}\n\t\t}\n\t}\n\n\tmodifier isEnded {\n\t\tif (ended){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyAfter(uint _time) {\n\t\tif (now > _time){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyPayable {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.payout > 0){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.paid == false){\n\t\t\t_;\n\t\t}\n\t}\n\n\t/* Public functions */\n\n\tfunction Conference(uint _coolingPeriod) {\n\t\tname = 'Edcon Post conference lunch';\n\t\tdeposit = 1 ether;\n\t\ttotalBalance = 0;\n\t\tregistered = 0;\n\t\tattended = 0;\n\t\tlimitOfParticipants = 10;\n\t\tended = false;\n\t\tif (_coolingPeriod != 0) {\n\t\t\tcoolingPeriod = _coolingPeriod;\n\t\t} else {\n\t\t\tcoolingPeriod = 1 weeks;\n\t\t}\n\t}\n\n\tfunction register(string _participant) public sentDepositOrReturn withinLimitOrReturn onlyActiveOrReturn payable{\n\t\tRegister(_participant, msg.sender, msg.sender.balance, msg.value);\n\t\tif (isRegistered(msg.sender)) throw;\n\t\tregistered++;\n\t\tparticipantsIndex[registered] = msg.sender;\n\t\tparticipants[msg.sender] = Participant(_participant, msg.sender, false, 0, false);\n\t\ttotalBalance = totalBalance + (deposit * 1);\n\t}\n\n\tfunction withdraw() public onlyPayable notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (msg.sender.send(participant.payout)) {\n\t\t\tparticipant.paid = true;\n\t\t\ttotalBalance -= participant.payout;\n\t\t}\n\t}\n\n\t/* Constants */\n\tfunction isRegistered(address _addr) constant returns (bool){\n\t\treturn participants[_addr].addr != 0x0;\n\t}\n\n\tfunction isAttended(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].attended;\n\t}\n\n\tfunction isPaid(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].paid;\n\t}\n\n\tfunction payout() constant returns(uint256){\n\t\tif (attended == 0) return 0;\n\t\treturn uint(totalBalance) / uint(attended);\n\t}\n\n\t/* Admin only functions */\n\n\tfunction payback() onlyOwner{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tif(participants[participantsIndex[i]].attended){\n\t\t\t\tparticipants[participantsIndex[i]].payout = payout();\n\t\t\t}\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\tfunction cancel() onlyOwner onlyActive{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tparticipants[participantsIndex[i]].payout = deposit;\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\t/* return the remaining of balance if there are any unclaimed after cooling period */\n\tfunction clear() public onlyOwner isEnded onlyAfter(endedAt + coolingPeriod) {\n\t\tif(owner.send(totalBalance)){\n\t\t\ttotalBalance = 0;\n\t\t}\n\t}\n\n\tfunction setLimitOfParticipants(uint _limitOfParticipants) public onlyOwner{\n\t\tlimitOfParticipants = _limitOfParticipants;\n\t}\n\n\tfunction attend(address[] _addresses) public onlyOwner{\n\t\tfor(uint i=0;i<_addresses.length;i++){\n\t\t\tvar _addr = _addresses[i];\n\t\t\tif (isRegistered(_addr) != true) throw;\n\t\t\tif (isAttended(_addr)) throw;\n\t\t\tAttend(_addr, msg.sender.balance);\n\t\t\tparticipants[_addr].attended = true;\n\t\t\tattended++;\n\t\t}\n\t}\n}\n", "flattened_code": "pragma solidity ^0.4.2;\npragma solidity ^0.4.2;\n\n/*\n * Rejector\n * Base contract for rejecting direct deposits.\n * Fallback function throws immediately.\n */\ncontract Rejector {\n  function() { throw; }\n}\npragma solidity ^0.4.2;\n/*\n * Ownable\n * Base contract with an owner\n */\ncontract Ownable {\n  address public owner;\n\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == owner)\n      _;\n  }\n}\npragma solidity ^0.4.2;\n\n\n/*\n * Killable\n * Base contract that can be killed by owner\n */\ncontract Killable is Ownable {\n  function kill() {\n    if (msg.sender == owner) suicide(owner);\n  }\n}\n\ncontract Conference is Rejector, Killable {\n\tstring public name;\n\tuint256 public totalBalance;\n\tuint256 public deposit;\n\tuint public limitOfParticipants;\n\tuint public registered;\n\tuint public attended;\n\tbool public ended;\n\tuint public endedAt;\n\tuint public coolingPeriod;\n\n\tmapping (address => Participant) public participants;\n\tmapping (uint => address) public participantsIndex;\n\tbool paid;\n\tuint256 _payout;\n\n\tstruct Participant {\n\t\tstring participantName;\n\t\taddress addr;\n\t\tbool attended;\n\t\tuint256 payout;\n\t\tbool paid;\n\t}\n\n\tevent Register(string participantName, address addr, uint256 balance, uint256 value);\n\tevent Attend(address addr, uint256 balance);\n\tevent Payback(address addr, uint256 _payout, uint256 balance, bool paid);\n\n\t/* Modifiers */\n\tmodifier sentDepositOrReturn {\n\t\tif (msg.value == deposit) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(msg.sender.send(msg.value)){/* not much you can do */}\n\t\t}\n\t}\n\n\tmodifier onlyActive {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyActiveOrReturn {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(msg.sender.send(msg.value)){/*not much you can do*/}\n\t\t}\n\t}\n\n\tmodifier withinLimitOrReturn {\n\t\tif (registered < limitOfParticipants ) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(msg.sender.send(msg.value)){/* not much you can do */}\n\t\t}\n\t}\n\n\tmodifier isEnded {\n\t\tif (ended){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyAfter(uint _time) {\n\t\tif (now > _time){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyPayable {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.payout > 0){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.paid == false){\n\t\t\t_;\n\t\t}\n\t}\n\n\t/* Public functions */\n\n\tfunction Conference(uint _coolingPeriod) {\n\t\tname = 'Edcon Post conference lunch';\n\t\tdeposit = 1 ether;\n\t\ttotalBalance = 0;\n\t\tregistered = 0;\n\t\tattended = 0;\n\t\tlimitOfParticipants = 10;\n\t\tended = false;\n\t\tif (_coolingPeriod != 0) {\n\t\t\tcoolingPeriod = _coolingPeriod;\n\t\t} else {\n\t\t\tcoolingPeriod = 1 weeks;\n\t\t}\n\t}\n\n\tfunction register(string _participant) public sentDepositOrReturn withinLimitOrReturn onlyActiveOrReturn payable{\n\t\tRegister(_participant, msg.sender, msg.sender.balance, msg.value);\n\t\tif (isRegistered(msg.sender)) throw;\n\t\tregistered++;\n\t\tparticipantsIndex[registered] = msg.sender;\n\t\tparticipants[msg.sender] = Participant(_participant, msg.sender, false, 0, false);\n\t\ttotalBalance = totalBalance + (deposit * 1);\n\t}\n\n\tfunction withdraw() public onlyPayable notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (msg.sender.send(participant.payout)) {\n\t\t\tparticipant.paid = true;\n\t\t\ttotalBalance -= participant.payout;\n\t\t}\n\t}\n\n\t/* Constants */\n\tfunction isRegistered(address _addr) constant returns (bool){\n\t\treturn participants[_addr].addr != 0x0;\n\t}\n\n\tfunction isAttended(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].attended;\n\t}\n\n\tfunction isPaid(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].paid;\n\t}\n\n\tfunction payout() constant returns(uint256){\n\t\tif (attended == 0) return 0;\n\t\treturn uint(totalBalance) / uint(attended);\n\t}\n\n\t/* Admin only functions */\n\n\tfunction payback() onlyOwner{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tif(participants[participantsIndex[i]].attended){\n\t\t\t\tparticipants[participantsIndex[i]].payout = payout();\n\t\t\t}\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\tfunction cancel() onlyOwner onlyActive{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tparticipants[participantsIndex[i]].payout = deposit;\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\t/* return the remaining of balance if there are any unclaimed after cooling period */\n\tfunction clear() public onlyOwner isEnded onlyAfter(endedAt + coolingPeriod) {\n\t\tif(owner.send(totalBalance)){\n\t\t\ttotalBalance = 0;\n\t\t}\n\t}\n\n\tfunction setLimitOfParticipants(uint _limitOfParticipants) public onlyOwner{\n\t\tlimitOfParticipants = _limitOfParticipants;\n\t}\n\n\tfunction attend(address[] _addresses) public onlyOwner{\n\t\tfor(uint i=0;i<_addresses.length;i++){\n\t\t\tvar _addr = _addresses[i];\n\t\t\tif (isRegistered(_addr) != true) throw;\n\t\t\tif (isAttended(_addr)) throw;\n\t\t\tAttend(_addr, msg.sender.balance);\n\t\t\tparticipants[_addr].attended = true;\n\t\t\tattended++;\n\t\t}\n\t}\n}\n", "commit_id": "7c9e7ac624fdb779646ac68327549246e3dea150"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.2;\nimport './zeppelin/Rejector.sol';\nimport './zeppelin/Ownable.sol';\nimport './zeppelin/Killable.sol';\n\ncontract Conference is Rejector, Killable {\n\tstring public name;\n\tuint256 public totalBalance;\n\tuint256 public deposit;\n\tuint public limitOfParticipants;\n\tuint public registered;\n\tuint public attended;\n\tbool public ended;\n\tuint public endedAt;\n\tuint public coolingPeriod;\n\n\tmapping (address => Participant) public participants;\n\tmapping (uint => address) public participantsIndex;\n\tbool paid;\n\tuint256 _payout;\n\n\tstruct Participant {\n\t\tstring participantName;\n\t\taddress addr;\n\t\tbool attended;\n\t\tuint256 payout;\n\t\tbool paid;\n\t}\n\n\tevent Register(string participantName, address addr, uint256 balance, uint256 value);\n\tevent Attend(address addr, uint256 balance);\n\tevent Payback(address addr, uint256 _payout, uint256 balance, bool paid);\n\n\t/* Modifiers */\n\tmodifier sentDepositOrReturn {\n\t\tif (msg.value == deposit) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(!msg.sender.send(msg.value)) throw;\n\t\t}\n\t}\n\n\tmodifier onlyActive {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyActiveOrReturn {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(!msg.sender.send(msg.value)) throw;\n\t\t}\n\t}\n\n\tmodifier withinLimitOrReturn {\n\t\tif (registered < limitOfParticipants ) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(!msg.sender.send(msg.value)) throw;\n\t\t}\n\t}\n\n\tmodifier isEnded {\n\t\tif (ended){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyAfter(uint _time) {\n\t\tif (now > _time){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyPayable {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.payout > 0){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.paid == false){\n\t\t\t_;\n\t\t}\n\t}\n\n\t/* Public functions */\n\n\tfunction Conference(uint _coolingPeriod) {\n\t\tname = 'Edcon Post conference lunch';\n\t\tdeposit = 1 ether;\n\t\ttotalBalance = 0;\n\t\tregistered = 0;\n\t\tattended = 0;\n\t\tlimitOfParticipants = 10;\n\t\tended = false;\n\t\tif (_coolingPeriod != 0) {\n\t\t\tcoolingPeriod = _coolingPeriod;\n\t\t} else {\n\t\t\tcoolingPeriod = 1 weeks;\n\t\t}\n\t}\n\n\tfunction register(string _participant) public sentDepositOrReturn withinLimitOrReturn onlyActiveOrReturn payable{\n\t\tRegister(_participant, msg.sender, msg.sender.balance, msg.value);\n\t\tif (isRegistered(msg.sender)) throw;\n\t\tregistered++;\n\t\tparticipantsIndex[registered] = msg.sender;\n\t\tparticipants[msg.sender] = Participant(_participant, msg.sender, false, 0, false);\n\t\ttotalBalance = totalBalance + (deposit * 1);\n\t}\n\n\tfunction withdraw() public onlyPayable notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tparticipant.paid = true;\n\t\ttotalBalance -= participant.payout;\n\t\tif (!msg.sender.send(participant.payout)) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\t/* Constants */\n\tfunction isRegistered(address _addr) constant returns (bool){\n\t\treturn participants[_addr].addr != 0x0;\n\t}\n\n\tfunction isAttended(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].attended;\n\t}\n\n\tfunction isPaid(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].paid;\n\t}\n\n\tfunction payout() constant returns(uint256){\n\t\tif (attended == 0) return 0;\n\t\treturn uint(totalBalance) / uint(attended);\n\t}\n\n\t/* Admin only functions */\n\n\tfunction payback() onlyOwner{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tif(participants[participantsIndex[i]].attended){\n\t\t\t\tparticipants[participantsIndex[i]].payout = payout();\n\t\t\t}\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\tfunction cancel() onlyOwner onlyActive{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tparticipants[participantsIndex[i]].payout = deposit;\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\t/* return the remaining of balance if there are any unclaimed after cooling period */\n\tfunction clear() public onlyOwner isEnded onlyAfter(endedAt + coolingPeriod) {\n\t\tvar leftOver = totalBalance;\n\t\ttotalBalance = 0;\n\t\tif(!owner.send(leftOver)) throw;\n\t}\n\n\tfunction setLimitOfParticipants(uint _limitOfParticipants) public onlyOwner{\n\t\tlimitOfParticipants = _limitOfParticipants;\n\t}\n\n\tfunction attend(address[] _addresses) public onlyOwner{\n\t\tfor(uint i=0;i<_addresses.length;i++){\n\t\t\tvar _addr = _addresses[i];\n\t\t\tif (isRegistered(_addr) != true) throw;\n\t\t\tif (isAttended(_addr)) throw;\n\t\t\tAttend(_addr, msg.sender.balance);\n\t\t\tparticipants[_addr].attended = true;\n\t\t\tattended++;\n\t\t}\n\t}\n}\n", "flattened_code": "pragma solidity ^0.4.2;\npragma solidity ^0.4.2;\n\n/*\n * Rejector\n * Base contract for rejecting direct deposits.\n * Fallback function throws immediately.\n */\ncontract Rejector {\n  function() { throw; }\n}\npragma solidity ^0.4.2;\n/*\n * Ownable\n * Base contract with an owner\n */\ncontract Ownable {\n  address public owner;\n\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender == owner)\n      _;\n  }\n}\npragma solidity ^0.4.2;\n\n\n/*\n * Killable\n * Base contract that can be killed by owner\n */\ncontract Killable is Ownable {\n  function kill() {\n    if (msg.sender == owner) suicide(owner);\n  }\n}\n\ncontract Conference is Rejector, Killable {\n\tstring public name;\n\tuint256 public totalBalance;\n\tuint256 public deposit;\n\tuint public limitOfParticipants;\n\tuint public registered;\n\tuint public attended;\n\tbool public ended;\n\tuint public endedAt;\n\tuint public coolingPeriod;\n\n\tmapping (address => Participant) public participants;\n\tmapping (uint => address) public participantsIndex;\n\tbool paid;\n\tuint256 _payout;\n\n\tstruct Participant {\n\t\tstring participantName;\n\t\taddress addr;\n\t\tbool attended;\n\t\tuint256 payout;\n\t\tbool paid;\n\t}\n\n\tevent Register(string participantName, address addr, uint256 balance, uint256 value);\n\tevent Attend(address addr, uint256 balance);\n\tevent Payback(address addr, uint256 _payout, uint256 balance, bool paid);\n\n\t/* Modifiers */\n\tmodifier sentDepositOrReturn {\n\t\tif (msg.value == deposit) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(!msg.sender.send(msg.value)) throw;\n\t\t}\n\t}\n\n\tmodifier onlyActive {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyActiveOrReturn {\n\t\tif (ended == false) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(!msg.sender.send(msg.value)) throw;\n\t\t}\n\t}\n\n\tmodifier withinLimitOrReturn {\n\t\tif (registered < limitOfParticipants ) {\n\t\t\t_;\n\t\t}else{\n\t\t\tif(!msg.sender.send(msg.value)) throw;\n\t\t}\n\t}\n\n\tmodifier isEnded {\n\t\tif (ended){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyAfter(uint _time) {\n\t\tif (now > _time){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier onlyPayable {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.payout > 0){\n\t\t\t_;\n\t\t}\n\t}\n\n\tmodifier notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tif (participant.paid == false){\n\t\t\t_;\n\t\t}\n\t}\n\n\t/* Public functions */\n\n\tfunction Conference(uint _coolingPeriod) {\n\t\tname = 'Edcon Post conference lunch';\n\t\tdeposit = 1 ether;\n\t\ttotalBalance = 0;\n\t\tregistered = 0;\n\t\tattended = 0;\n\t\tlimitOfParticipants = 10;\n\t\tended = false;\n\t\tif (_coolingPeriod != 0) {\n\t\t\tcoolingPeriod = _coolingPeriod;\n\t\t} else {\n\t\t\tcoolingPeriod = 1 weeks;\n\t\t}\n\t}\n\n\tfunction register(string _participant) public sentDepositOrReturn withinLimitOrReturn onlyActiveOrReturn payable{\n\t\tRegister(_participant, msg.sender, msg.sender.balance, msg.value);\n\t\tif (isRegistered(msg.sender)) throw;\n\t\tregistered++;\n\t\tparticipantsIndex[registered] = msg.sender;\n\t\tparticipants[msg.sender] = Participant(_participant, msg.sender, false, 0, false);\n\t\ttotalBalance = totalBalance + (deposit * 1);\n\t}\n\n\tfunction withdraw() public onlyPayable notPaid {\n\t\tParticipant participant = participants[msg.sender];\n\t\tparticipant.paid = true;\n\t\ttotalBalance -= participant.payout;\n\t\tif (!msg.sender.send(participant.payout)) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\t/* Constants */\n\tfunction isRegistered(address _addr) constant returns (bool){\n\t\treturn participants[_addr].addr != 0x0;\n\t}\n\n\tfunction isAttended(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].attended;\n\t}\n\n\tfunction isPaid(address _addr) constant returns (bool){\n\t\treturn isRegistered(_addr) && participants[_addr].paid;\n\t}\n\n\tfunction payout() constant returns(uint256){\n\t\tif (attended == 0) return 0;\n\t\treturn uint(totalBalance) / uint(attended);\n\t}\n\n\t/* Admin only functions */\n\n\tfunction payback() onlyOwner{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tif(participants[participantsIndex[i]].attended){\n\t\t\t\tparticipants[participantsIndex[i]].payout = payout();\n\t\t\t}\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\tfunction cancel() onlyOwner onlyActive{\n\t\tfor(uint i=1;i<=registered;i++){\n\t\t\tparticipants[participantsIndex[i]].payout = deposit;\n\t\t}\n\t\tended = true;\n\t\tendedAt = now;\n\t}\n\n\t/* return the remaining of balance if there are any unclaimed after cooling period */\n\tfunction clear() public onlyOwner isEnded onlyAfter(endedAt + coolingPeriod) {\n\t\tvar leftOver = totalBalance;\n\t\ttotalBalance = 0;\n\t\tif(!owner.send(leftOver)) throw;\n\t}\n\n\tfunction setLimitOfParticipants(uint _limitOfParticipants) public onlyOwner{\n\t\tlimitOfParticipants = _limitOfParticipants;\n\t}\n\n\tfunction attend(address[] _addresses) public onlyOwner{\n\t\tfor(uint i=0;i<_addresses.length;i++){\n\t\t\tvar _addr = _addresses[i];\n\t\t\tif (isRegistered(_addr) != true) throw;\n\t\t\tif (isAttended(_addr)) throw;\n\t\t\tAttend(_addr, msg.sender.balance);\n\t\t\tparticipants[_addr].attended = true;\n\t\t\tattended++;\n\t\t}\n\t}\n}\n", "commit_id": "20c22f060bee358e423646afcc4d79e1346da3f9"}}