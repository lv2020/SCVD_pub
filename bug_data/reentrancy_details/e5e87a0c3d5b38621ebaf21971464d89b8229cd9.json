{"filename": "contracts/Marmo.sol", "patch": "@@ -101,9 +101,10 @@ contract Marmo is Ownable {\n         address _owner = owner;\n         require(msg.sender == _owner || _owner == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\n         require(gasleft() > _minGasLimit, \"gasleft() too low\");\n-        (success, data) = _to.call.value(_value)(_data);\n \n         intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\n+\n+        (success, data) = _to.call.value(_value)(_data);\n         \n         emit Relayed(\n             id,", "project_link": "https://github.com/ripio/marmo-contracts/commit/e5e87a0c3d5b38621ebaf21971464d89b8229cd9", "bug_version": {"raw_code": "pragma solidity ^0.5.0;\n\nimport \"./commons/SigUtils.sol\";\nimport \"./commons/Ownable.sol\";\n\ncontract Marmo is Ownable {\n    event Relayed(\n        bytes32 indexed _id,\n        bytes32[] _dependencies,\n        address _to,\n        uint256 _value,\n        bytes _data,\n        bytes32 _salt,\n        uint256 _expiration,\n        bool _success\n    );\n\n    event Canceled(\n        bytes32 _id\n    );\n\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\n    mapping(bytes32 => bytes32) private intentReceipt;\n\n    function init(address _owner) external {\n        _init(_owner);\n    }\n\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function encodeTransactionData(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration\n    ) public view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                this,\n                keccak256(abi.encodePacked(_dependencies)),\n                _to,\n                _value,\n                keccak256(_data),\n                _minGasLimit,\n                _maxGasPrice,\n                _salt,\n                _expiration\n            )\n        );\n    }\n\n    function dependenciesSatisfied(bytes32[] memory _dependencies) internal view returns (bool) {\n        for (uint256 i; i < _dependencies.length; i++) {\n            (,, address relayer) = _decodeReceipt(intentReceipt[_dependencies[i]]);\n            if (relayer == address(0)) return false;\n        }\n        \n        return true;\n    }\n\n    function relay(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration,\n        bytes memory _signature\n    ) public returns (\n        bool success,\n        bytes memory data \n    ) {\n        bytes32 id = encodeTransactionData(_dependencies, _to, _value, _data, _minGasLimit, _maxGasPrice, _salt, _expiration);\n        \n        if(intentReceipt[id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        require(now < _expiration, \"Intent is expired\");\n        require(tx.gasprice <= _maxGasPrice, \"Gas price too high\");\n        require(dependenciesSatisfied(_dependencies), \"Parent relay not found\");\n        address _owner = owner;\n        require(msg.sender == _owner || _owner == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\n        require(gasleft() > _minGasLimit, \"gasleft() too low\");\n        (success, data) = _to.call.value(_value)(_data);\n\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\n        \n        emit Relayed(\n            id,\n            _dependencies,\n            _to,\n            _value,\n            _data,\n            _salt,\n            _expiration,\n            success\n        );\n    }\n\n    function cancel(bytes32 _id) external {\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\n        if(intentReceipt[_id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\n    }\n\n    function _encodeReceipt(\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) internal pure returns (bytes32 _receipt) {\n        assembly {\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\n        }\n    }\n    \n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) {\n        assembly {\n            _canceled := shr(255, _receipt)\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    function() external payable {}\n}\n", "flattened_code": "pragma solidity ^0.5.0;\n\npragma solidity ^0.5.0;\n\nlibrary SigUtils {\n    /**\n      @dev Recovers address who signed the message \n      @param _hash operation ethereum signed message hash\n      @param _signature message `hash` signature  \n    */\n    function ecrecover2 (\n        bytes32 _hash, \n        bytes memory _signature\n    ) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(_signature, 32))\n            s := mload(add(_signature, 64))\n            v := and(mload(add(_signature, 65)), 255)\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        return ecrecover(_hash, v, r, s);\n    }\n}\npragma solidity ^0.5.0;\n\ncontract Ownable {\n    event SetOwner(address _owner);\n\n    address public owner;\n\n    /**\n      @dev Setup function sets initial storage of contract.\n      @param _owner List of signer.\n    */\n    function _init(address _owner) internal {\n        require(owner == address(0), \"Owner already defined\");\n        owner = _owner;\n        emit SetOwner(_owner);\n    }\n\n    function isOwner(address _owner) public view returns (bool) {\n        return _owner != address(0) && owner == _owner;\n    }\n}\n\ncontract Marmo is Ownable {\n    event Relayed(\n        bytes32 indexed _id,\n        bytes32[] _dependencies,\n        address _to,\n        uint256 _value,\n        bytes _data,\n        bytes32 _salt,\n        uint256 _expiration,\n        bool _success\n    );\n\n    event Canceled(\n        bytes32 _id\n    );\n\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\n    mapping(bytes32 => bytes32) private intentReceipt;\n\n    function init(address _owner) external {\n        _init(_owner);\n    }\n\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function encodeTransactionData(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration\n    ) public view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                this,\n                keccak256(abi.encodePacked(_dependencies)),\n                _to,\n                _value,\n                keccak256(_data),\n                _minGasLimit,\n                _maxGasPrice,\n                _salt,\n                _expiration\n            )\n        );\n    }\n\n    function dependenciesSatisfied(bytes32[] memory _dependencies) internal view returns (bool) {\n        for (uint256 i; i < _dependencies.length; i++) {\n            (,, address relayer) = _decodeReceipt(intentReceipt[_dependencies[i]]);\n            if (relayer == address(0)) return false;\n        }\n        \n        return true;\n    }\n\n    function relay(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration,\n        bytes memory _signature\n    ) public returns (\n        bool success,\n        bytes memory data \n    ) {\n        bytes32 id = encodeTransactionData(_dependencies, _to, _value, _data, _minGasLimit, _maxGasPrice, _salt, _expiration);\n        \n        if(intentReceipt[id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        require(now < _expiration, \"Intent is expired\");\n        require(tx.gasprice <= _maxGasPrice, \"Gas price too high\");\n        require(dependenciesSatisfied(_dependencies), \"Parent relay not found\");\n        address _owner = owner;\n        require(msg.sender == _owner || _owner == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\n        require(gasleft() > _minGasLimit, \"gasleft() too low\");\n        (success, data) = _to.call.value(_value)(_data);\n\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\n        \n        emit Relayed(\n            id,\n            _dependencies,\n            _to,\n            _value,\n            _data,\n            _salt,\n            _expiration,\n            success\n        );\n    }\n\n    function cancel(bytes32 _id) external {\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\n        if(intentReceipt[_id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\n    }\n\n    function _encodeReceipt(\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) internal pure returns (bytes32 _receipt) {\n        assembly {\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\n        }\n    }\n    \n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) {\n        assembly {\n            _canceled := shr(255, _receipt)\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    function() external payable {}\n}\n", "commit_id": "ce24e3a69729d2a8003ed2117cef9fe6c5c0cad3"}, "fixed_version": {"raw_code": "pragma solidity ^0.5.0;\n\nimport \"./commons/SigUtils.sol\";\nimport \"./commons/Ownable.sol\";\n\ncontract Marmo is Ownable {\n    event Relayed(\n        bytes32 indexed _id,\n        bytes32[] _dependencies,\n        address _to,\n        uint256 _value,\n        bytes _data,\n        bytes32 _salt,\n        uint256 _expiration,\n        bool _success\n    );\n\n    event Canceled(\n        bytes32 _id\n    );\n\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\n    mapping(bytes32 => bytes32) private intentReceipt;\n\n    function init(address _owner) external {\n        _init(_owner);\n    }\n\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function encodeTransactionData(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration\n    ) public view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                this,\n                keccak256(abi.encodePacked(_dependencies)),\n                _to,\n                _value,\n                keccak256(_data),\n                _minGasLimit,\n                _maxGasPrice,\n                _salt,\n                _expiration\n            )\n        );\n    }\n\n    function dependenciesSatisfied(bytes32[] memory _dependencies) internal view returns (bool) {\n        for (uint256 i; i < _dependencies.length; i++) {\n            (,, address relayer) = _decodeReceipt(intentReceipt[_dependencies[i]]);\n            if (relayer == address(0)) return false;\n        }\n        \n        return true;\n    }\n\n    function relay(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration,\n        bytes memory _signature\n    ) public returns (\n        bool success,\n        bytes memory data \n    ) {\n        bytes32 id = encodeTransactionData(_dependencies, _to, _value, _data, _minGasLimit, _maxGasPrice, _salt, _expiration);\n        \n        if(intentReceipt[id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        require(now < _expiration, \"Intent is expired\");\n        require(tx.gasprice <= _maxGasPrice, \"Gas price too high\");\n        require(dependenciesSatisfied(_dependencies), \"Parent relay not found\");\n        address _owner = owner;\n        require(msg.sender == _owner || _owner == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\n        require(gasleft() > _minGasLimit, \"gasleft() too low\");\n\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\n\n        (success, data) = _to.call.value(_value)(_data);\n        \n        emit Relayed(\n            id,\n            _dependencies,\n            _to,\n            _value,\n            _data,\n            _salt,\n            _expiration,\n            success\n        );\n    }\n\n    function cancel(bytes32 _id) external {\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\n        if(intentReceipt[_id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\n    }\n\n    function _encodeReceipt(\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) internal pure returns (bytes32 _receipt) {\n        assembly {\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\n        }\n    }\n    \n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) {\n        assembly {\n            _canceled := shr(255, _receipt)\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    function() external payable {}\n}\n", "flattened_code": "pragma solidity ^0.5.0;\n\npragma solidity ^0.5.0;\n\nlibrary SigUtils {\n    /**\n      @dev Recovers address who signed the message \n      @param _hash operation ethereum signed message hash\n      @param _signature message `hash` signature  \n    */\n    function ecrecover2 (\n        bytes32 _hash, \n        bytes memory _signature\n    ) internal pure returns (address) {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(_signature, 32))\n            s := mload(add(_signature, 64))\n            v := and(mload(add(_signature, 65)), 255)\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        return ecrecover(_hash, v, r, s);\n    }\n}\npragma solidity ^0.5.0;\n\ncontract Ownable {\n    event SetOwner(address _owner);\n\n    address public owner;\n\n    /**\n      @dev Setup function sets initial storage of contract.\n      @param _owner List of signer.\n    */\n    function _init(address _owner) internal {\n        require(owner == address(0), \"Owner already defined\");\n        owner = _owner;\n        emit SetOwner(_owner);\n    }\n\n    function isOwner(address _owner) public view returns (bool) {\n        return _owner != address(0) && owner == _owner;\n    }\n}\n\ncontract Marmo is Ownable {\n    event Relayed(\n        bytes32 indexed _id,\n        bytes32[] _dependencies,\n        address _to,\n        uint256 _value,\n        bytes _data,\n        bytes32 _salt,\n        uint256 _expiration,\n        bool _success\n    );\n\n    event Canceled(\n        bytes32 _id\n    );\n\n    // [1 bit (canceled) 95 bits (block) 160 bits (relayer)]\n    mapping(bytes32 => bytes32) private intentReceipt;\n\n    function init(address _owner) external {\n        _init(_owner);\n    }\n\n    function relayedBy(bytes32 _id) external view returns (address _relayer) {\n        (,,_relayer) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function relayedAt(bytes32 _id) external view returns (uint256 _block) {\n        (,_block,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function isCanceled(bytes32 _id) external view returns (bool _canceled) {\n        (_canceled,,) = _decodeReceipt(intentReceipt[_id]);\n    }\n\n    function encodeTransactionData(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration\n    ) public view returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\n                this,\n                keccak256(abi.encodePacked(_dependencies)),\n                _to,\n                _value,\n                keccak256(_data),\n                _minGasLimit,\n                _maxGasPrice,\n                _salt,\n                _expiration\n            )\n        );\n    }\n\n    function dependenciesSatisfied(bytes32[] memory _dependencies) internal view returns (bool) {\n        for (uint256 i; i < _dependencies.length; i++) {\n            (,, address relayer) = _decodeReceipt(intentReceipt[_dependencies[i]]);\n            if (relayer == address(0)) return false;\n        }\n        \n        return true;\n    }\n\n    function relay(\n        bytes32[] memory _dependencies,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        uint256 _minGasLimit,\n        uint256 _maxGasPrice,\n        bytes32 _salt,\n        uint256 _expiration,\n        bytes memory _signature\n    ) public returns (\n        bool success,\n        bytes memory data \n    ) {\n        bytes32 id = encodeTransactionData(_dependencies, _to, _value, _data, _minGasLimit, _maxGasPrice, _salt, _expiration);\n        \n        if(intentReceipt[id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        require(now < _expiration, \"Intent is expired\");\n        require(tx.gasprice <= _maxGasPrice, \"Gas price too high\");\n        require(dependenciesSatisfied(_dependencies), \"Parent relay not found\");\n        address _owner = owner;\n        require(msg.sender == _owner || _owner == SigUtils.ecrecover2(id, _signature), \"Invalid signature\");\n        require(gasleft() > _minGasLimit, \"gasleft() too low\");\n\n        intentReceipt[id] = _encodeReceipt(false, block.number, msg.sender);\n\n        (success, data) = _to.call.value(_value)(_data);\n        \n        emit Relayed(\n            id,\n            _dependencies,\n            _to,\n            _value,\n            _data,\n            _salt,\n            _expiration,\n            success\n        );\n    }\n\n    function cancel(bytes32 _id) external {\n        require(msg.sender == address(this), \"Only wallet can cancel txs\");\n        if(intentReceipt[_id] != bytes32(0)) {\n            (bool canceled, , address relayer) = _decodeReceipt(intentReceipt[_id]);\n            require(relayer == address(0), \"Intent already relayed\");\n            require(!canceled, \"Intent was canceled\");\n            revert(\"Unknown error\");\n        }\n\n        intentReceipt[_id] = _encodeReceipt(true, 0, address(0));\n    }\n\n    function _encodeReceipt(\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) internal pure returns (bytes32 _receipt) {\n        assembly {\n            _receipt := or(shl(255, _canceled), or(shl(160, _block), _relayer))\n        }\n    }\n    \n    function _decodeReceipt(bytes32 _receipt) internal pure returns (\n        bool _canceled,\n        uint256 _block,\n        address _relayer\n    ) {\n        assembly {\n            _canceled := shr(255, _receipt)\n            _block := and(shr(160, _receipt), 0x7fffffffffffffffffffffff)\n            _relayer := and(_receipt, 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    function() external payable {}\n}\n", "commit_id": "e5e87a0c3d5b38621ebaf21971464d89b8229cd9"}}