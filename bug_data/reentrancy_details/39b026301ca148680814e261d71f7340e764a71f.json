{"filename": "solidity/contracts/GroupSelectionSeed.sol", "patch": "@@ -17,8 +17,9 @@ pragma solidity 0.5.17;\n import \"@keep-network/keep-core/contracts/IRandomBeacon.sol\";\n \n import \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n+import \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n \n-contract GroupSelectionSeed is IRandomBeaconConsumer {\n+contract GroupSelectionSeed is IRandomBeaconConsumer, ReentrancyGuard {\n     using SafeMath for uint256;\n \n     IRandomBeacon randomBeacon;\n@@ -79,18 +80,17 @@ contract GroupSelectionSeed is IRandomBeaconConsumer {\n     /// reseedFee function. Factory is automatically triggering reseeding after\n     /// opening a new keep but the reseed can be also triggered at any moment\n     /// using this function.\n-    function requestNewGroupSelectionSeed() public payable {\n-        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n-\n+    function requestNewGroupSelectionSeed() public payable nonReentrant {\n         reseedPool = reseedPool.add(msg.value);\n+\n+        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n         require(reseedPool >= beaconFee, \"Not enough funds to trigger reseed\");\n+        reseedPool = reseedPool.sub(beaconFee);\n \n         (bool success, bytes memory returnData) = requestRelayEntry(beaconFee);\n         if (!success) {\n             revert(string(returnData));\n         }\n-\n-        reseedPool = reseedPool.sub(beaconFee);\n     }\n \n     /// @notice Updates group selection seed.", "project_link": "https://github.com/keep-network/keep-ecdsa/commit/720291b519b98f49fe0939cb0125facd0cb35de3", "bug_version": {"raw_code": "/**\n\u2593\u2593\u258c \u2593\u2593 \u2590\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2584\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580    \u2590\u2593\u2593\u2593\u2593\u2593\u2593    \u2590\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580      \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584       \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580\n  \u2593\u2593\u2593\u2593\u2593\u2593   \u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584     \u2590\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"@keep-network/keep-core/contracts/IRandomBeacon.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract GroupSelectionSeed is IRandomBeaconConsumer {\n    using SafeMath for uint256;\n\n    IRandomBeacon randomBeacon;\n\n    // Gas required for a callback from the random beacon. The value specifies\n    // gas required to call `__beaconCallback` function in the worst-case\n    // scenario with all the checks and maximum allowed uint256 relay entry as\n    // a callback parameter.\n    uint256 public constant callbackGas = 30000;\n\n    // Random beacon sends back callback surplus to the requestor. It may also\n    // decide to send additional request subsidy fee. What's more, it may happen\n    // that the beacon is busy and we will not refresh group selection seed from\n    // the beacon. We accumulate all funds received from the beacon in the\n    // reseed pool and later use this pool to reseed using a public reseed\n    // function on a manual request at any moment.\n    uint256 public reseedPool;\n\n    uint256 public groupSelectionSeed;\n\n    constructor(address _randomBeacon) public {\n        randomBeacon = IRandomBeacon(_randomBeacon);\n\n        // Initial value before the random beacon updates the seed.\n        // https://www.wolframalpha.com/input/?i=pi+to+78+digits\n        groupSelectionSeed = 31415926535897932384626433832795028841971693993751058209749445923078164062862;\n    }\n\n    /// @notice Adds any received funds to the reseed pool.\n    function() external payable {\n        reseedPool += msg.value;\n    }\n\n    /// @notice Sets a new group selection seed value.\n    /// @dev The function is expected to be called in a callback by the random\n    /// beacon.\n    /// @param _relayEntry Beacon output.\n    function __beaconCallback(uint256 _relayEntry) external onlyRandomBeacon {\n        groupSelectionSeed = _relayEntry;\n    }\n\n    /// @notice Gets a fee estimate for a new random entry.\n    /// @return Uint256 estimate.\n    function newEntryFeeEstimate() public view returns (uint256) {\n        return randomBeacon.entryFeeEstimate(callbackGas);\n    }\n\n    /// @notice Calculates the fee requestor has to pay to reseed the factory\n    /// for signer selection. Depending on how much value is stored in the\n    /// reseed pool and the price of a new relay entry, returned value may vary.\n    function newGroupSelectionSeedFee() public view returns (uint256) {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        return beaconFee <= reseedPool ? 0 : beaconFee.sub(reseedPool);\n    }\n\n    /// @notice Reseeds the value used for a signer selection. Requires enough\n    /// payment to be passed. The required payment can be calculated using\n    /// reseedFee function. Factory is automatically triggering reseeding after\n    /// opening a new keep but the reseed can be also triggered at any moment\n    /// using this function.\n    function requestNewGroupSelectionSeed() public payable {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n\n        reseedPool = reseedPool.add(msg.value);\n        require(reseedPool >= beaconFee, \"Not enough funds to trigger reseed\");\n\n        (bool success, bytes memory returnData) = requestRelayEntry(beaconFee);\n        if (!success) {\n            revert(string(returnData));\n        }\n\n        reseedPool = reseedPool.sub(beaconFee);\n    }\n\n    /// @notice Updates group selection seed.\n    /// @dev The main goal of this function is to request the random beacon to\n    /// generate a new random number. The beacon generates the number asynchronously\n    /// and will call a callback function when the number is ready. In the meantime\n    /// we update current group selection seed to a new value using a hash function.\n    /// In case of the random beacon request failure this function won't revert\n    /// but add beacon payment to factory's reseed pool.\n    function newGroupSelectionSeed() internal {\n        // Calculate new group selection seed based on the current seed.\n        // We added address of the factory as a key to calculate value different\n        // than sortition pool RNG will, so we don't end up selecting almost\n        // identical group.\n        groupSelectionSeed = uint256(\n            keccak256(abi.encodePacked(groupSelectionSeed, address(this)))\n        );\n\n        // Call the random beacon to get a random group selection seed.\n        (bool success, ) = requestRelayEntry(msg.value);\n        if (!success) {\n            reseedPool += msg.value;\n        }\n    }\n\n    /// @notice Requests for a relay entry using the beacon payment provided as\n    /// the parameter.\n    function requestRelayEntry(uint256 payment)\n        internal\n        returns (bool, bytes memory)\n    {\n        return\n            address(randomBeacon).call.value(payment)(\n                abi.encodeWithSignature(\n                    \"requestRelayEntry(address,uint256)\",\n                    address(this),\n                    callbackGas\n                )\n            );\n    }\n\n    /// @notice Checks if the caller is the random beacon.\n    /// @dev Throws an error if called by any account other than the random beacon.\n    modifier onlyRandomBeacon() {\n        require(\n            address(randomBeacon) == msg.sender,\n            \"Caller is not the random beacon\"\n        );\n        _;\n    }\n}\n", "flattened_code": "/**\n\u2593\u2593\u258c \u2593\u2593 \u2590\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2584\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580    \u2590\u2593\u2593\u2593\u2593\u2593\u2593    \u2590\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580      \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584       \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580\n  \u2593\u2593\u2593\u2593\u2593\u2593   \u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584     \u2590\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/**\n\u2593\u2593\u258c \u2593\u2593 \u2590\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2584\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580    \u2590\u2593\u2593\u2593\u2593\u2593\u2593    \u2590\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580      \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584       \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580\n  \u2593\u2593\u2593\u2593\u2593\u2593   \u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584     \u2590\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title Keep Random Beacon\n///\n/// @notice Keep Random Beacon generates verifiable randomness that is resistant\n/// to bad actors both in the relay network and on the anchoring blockchain.\ninterface IRandomBeacon {\n    /// @notice Event emitted for each new relay entry generated. It contains\n    /// request ID allowing to associate the generated relay entry with relay\n    /// request created previously with `requestRelayEntry` function. Event is\n    /// emitted no matter if callback was executed or not.\n    ///\n    /// @param requestId Relay request ID for which entry was generated.\n    /// @param entry Generated relay entry.\n    event RelayEntryGenerated(uint256 requestId, uint256 entry);\n\n    /// @notice Provides the customer with an estimated entry fee in wei to use\n    /// in the request. The fee estimate is only valid for the transaction it is\n    /// called in, so the customer must make the request immediately after\n    /// obtaining the estimate. Insufficient payment will lead to the request\n    /// being rejected and the transaction reverted.\n    ///\n    /// The customer may decide to provide more ether for an entry fee than\n    /// estimated by this function. This is especially helpful when callback gas\n    /// cost fluctuates. Any surplus between the passed fee and the actual cost\n    /// of producing an entry and executing a callback is returned back to the\n    /// customer.\n    /// @param callbackGas Gas required for the callback.\n    function entryFeeEstimate(uint256 callbackGas)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Submits a request to generate a new relay entry. Executes\n    /// callback on the provided callback contract with the generated entry and\n    /// emits `RelayEntryGenerated(uint256 requestId, uint256 entry)` event.\n    /// Callback contract has to declare public `__beaconCallback(uint256)`\n    /// function that is going to be executed with the result, once ready.\n    /// It is recommended to implement `IRandomBeaconConsumer` interface to\n    /// ensure the correct callback function signature.\n    ///\n    /// @dev Beacon does not support concurrent relay requests. No new requests\n    /// should be made while the beacon is already processing another request.\n    /// Requests made while the beacon is busy will be rejected and the\n    /// transaction reverted.\n    ///\n    /// @param callbackContract Callback contract address. Callback is called\n    /// once a new relay entry has been generated. Must declare public\n    /// `__beaconCallback(uint256)` function. It is recommended to implement\n    /// `IRandomBeaconConsumer` interface to ensure the correct callback function\n    /// signature.\n    /// @param callbackGas Gas required for the callback.\n    /// The customer needs to ensure they provide a sufficient callback gas\n    /// to cover the gas fee of executing the callback. Any surplus is returned\n    /// to the customer. If the callback gas amount turns to be not enough to\n    /// execute the callback, callback execution is skipped.\n    /// @return An uint256 representing uniquely generated relay request ID\n    function requestRelayEntry(address callbackContract, uint256 callbackGas)\n        external\n        payable\n        returns (uint256);\n\n    /// @notice Submits a request to generate a new relay entry. Emits\n    /// `RelayEntryGenerated(uint256 requestId, uint256 entry)` event for the\n    /// generated entry.\n    ///\n    /// @dev Beacon does not support concurrent relay requests. No new requests\n    /// should be made while the beacon is already processing another request.\n    /// Requests made while the beacon is busy will be rejected and the\n    /// transaction reverted.\n    ///\n    /// @return An uint256 representing uniquely generated relay request ID\n    function requestRelayEntry() external payable returns (uint256);\n}\n\n/// @title Keep Random Beacon Consumer\n///\n/// @notice Receives Keep Random Beacon relay entries with `__beaconCallback`\n/// function. Contract implementing this interface does not have to be the one\n/// requesting relay entry but it is the one receiving the requested relay entry\n/// once it is produced.\n///\n/// @dev Use this interface to indicate the contract receives relay entries from\n/// the beacon and to ensure the correctness of callback function signature.\ninterface IRandomBeaconConsumer {\n    /// @notice Receives relay entry produced by Keep Random Beacon. This function\n    /// should be called only by Keep Random Beacon.\n    ///\n    /// @param relayEntry Relay entry (random number) produced by Keep Random\n    /// Beacon.\n    function __beaconCallback(uint256 relayEntry) external;\n}\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract GroupSelectionSeed is IRandomBeaconConsumer {\n    using SafeMath for uint256;\n\n    IRandomBeacon randomBeacon;\n\n    // Gas required for a callback from the random beacon. The value specifies\n    // gas required to call `__beaconCallback` function in the worst-case\n    // scenario with all the checks and maximum allowed uint256 relay entry as\n    // a callback parameter.\n    uint256 public constant callbackGas = 30000;\n\n    // Random beacon sends back callback surplus to the requestor. It may also\n    // decide to send additional request subsidy fee. What's more, it may happen\n    // that the beacon is busy and we will not refresh group selection seed from\n    // the beacon. We accumulate all funds received from the beacon in the\n    // reseed pool and later use this pool to reseed using a public reseed\n    // function on a manual request at any moment.\n    uint256 public reseedPool;\n\n    uint256 public groupSelectionSeed;\n\n    constructor(address _randomBeacon) public {\n        randomBeacon = IRandomBeacon(_randomBeacon);\n\n        // Initial value before the random beacon updates the seed.\n        // https://www.wolframalpha.com/input/?i=pi+to+78+digits\n        groupSelectionSeed = 31415926535897932384626433832795028841971693993751058209749445923078164062862;\n    }\n\n    /// @notice Adds any received funds to the reseed pool.\n    function() external payable {\n        reseedPool += msg.value;\n    }\n\n    /// @notice Sets a new group selection seed value.\n    /// @dev The function is expected to be called in a callback by the random\n    /// beacon.\n    /// @param _relayEntry Beacon output.\n    function __beaconCallback(uint256 _relayEntry) external onlyRandomBeacon {\n        groupSelectionSeed = _relayEntry;\n    }\n\n    /// @notice Gets a fee estimate for a new random entry.\n    /// @return Uint256 estimate.\n    function newEntryFeeEstimate() public view returns (uint256) {\n        return randomBeacon.entryFeeEstimate(callbackGas);\n    }\n\n    /// @notice Calculates the fee requestor has to pay to reseed the factory\n    /// for signer selection. Depending on how much value is stored in the\n    /// reseed pool and the price of a new relay entry, returned value may vary.\n    function newGroupSelectionSeedFee() public view returns (uint256) {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        return beaconFee <= reseedPool ? 0 : beaconFee.sub(reseedPool);\n    }\n\n    /// @notice Reseeds the value used for a signer selection. Requires enough\n    /// payment to be passed. The required payment can be calculated using\n    /// reseedFee function. Factory is automatically triggering reseeding after\n    /// opening a new keep but the reseed can be also triggered at any moment\n    /// using this function.\n    function requestNewGroupSelectionSeed() public payable {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n\n        reseedPool = reseedPool.add(msg.value);\n        require(reseedPool >= beaconFee, \"Not enough funds to trigger reseed\");\n\n        (bool success, bytes memory returnData) = requestRelayEntry(beaconFee);\n        if (!success) {\n            revert(string(returnData));\n        }\n\n        reseedPool = reseedPool.sub(beaconFee);\n    }\n\n    /// @notice Updates group selection seed.\n    /// @dev The main goal of this function is to request the random beacon to\n    /// generate a new random number. The beacon generates the number asynchronously\n    /// and will call a callback function when the number is ready. In the meantime\n    /// we update current group selection seed to a new value using a hash function.\n    /// In case of the random beacon request failure this function won't revert\n    /// but add beacon payment to factory's reseed pool.\n    function newGroupSelectionSeed() internal {\n        // Calculate new group selection seed based on the current seed.\n        // We added address of the factory as a key to calculate value different\n        // than sortition pool RNG will, so we don't end up selecting almost\n        // identical group.\n        groupSelectionSeed = uint256(\n            keccak256(abi.encodePacked(groupSelectionSeed, address(this)))\n        );\n\n        // Call the random beacon to get a random group selection seed.\n        (bool success, ) = requestRelayEntry(msg.value);\n        if (!success) {\n            reseedPool += msg.value;\n        }\n    }\n\n    /// @notice Requests for a relay entry using the beacon payment provided as\n    /// the parameter.\n    function requestRelayEntry(uint256 payment)\n        internal\n        returns (bool, bytes memory)\n    {\n        return\n            address(randomBeacon).call.value(payment)(\n                abi.encodeWithSignature(\n                    \"requestRelayEntry(address,uint256)\",\n                    address(this),\n                    callbackGas\n                )\n            );\n    }\n\n    /// @notice Checks if the caller is the random beacon.\n    /// @dev Throws an error if called by any account other than the random beacon.\n    modifier onlyRandomBeacon() {\n        require(\n            address(randomBeacon) == msg.sender,\n            \"Caller is not the random beacon\"\n        );\n        _;\n    }\n}\n", "commit_id": "39b026301ca148680814e261d71f7340e764a71f"}, "fixed_version": {"raw_code": "/**\n\u2593\u2593\u258c \u2593\u2593 \u2590\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2584\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580    \u2590\u2593\u2593\u2593\u2593\u2593\u2593    \u2590\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580      \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584       \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580\n  \u2593\u2593\u2593\u2593\u2593\u2593   \u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584     \u2590\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"@keep-network/keep-core/contracts/IRandomBeacon.sol\";\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\n\ncontract GroupSelectionSeed is IRandomBeaconConsumer, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    IRandomBeacon randomBeacon;\n\n    // Gas required for a callback from the random beacon. The value specifies\n    // gas required to call `__beaconCallback` function in the worst-case\n    // scenario with all the checks and maximum allowed uint256 relay entry as\n    // a callback parameter.\n    uint256 public constant callbackGas = 30000;\n\n    // Random beacon sends back callback surplus to the requestor. It may also\n    // decide to send additional request subsidy fee. What's more, it may happen\n    // that the beacon is busy and we will not refresh group selection seed from\n    // the beacon. We accumulate all funds received from the beacon in the\n    // reseed pool and later use this pool to reseed using a public reseed\n    // function on a manual request at any moment.\n    uint256 public reseedPool;\n\n    uint256 public groupSelectionSeed;\n\n    constructor(address _randomBeacon) public {\n        randomBeacon = IRandomBeacon(_randomBeacon);\n\n        // Initial value before the random beacon updates the seed.\n        // https://www.wolframalpha.com/input/?i=pi+to+78+digits\n        groupSelectionSeed = 31415926535897932384626433832795028841971693993751058209749445923078164062862;\n    }\n\n    /// @notice Adds any received funds to the reseed pool.\n    function() external payable {\n        reseedPool += msg.value;\n    }\n\n    /// @notice Sets a new group selection seed value.\n    /// @dev The function is expected to be called in a callback by the random\n    /// beacon.\n    /// @param _relayEntry Beacon output.\n    function __beaconCallback(uint256 _relayEntry) external onlyRandomBeacon {\n        groupSelectionSeed = _relayEntry;\n    }\n\n    /// @notice Gets a fee estimate for a new random entry.\n    /// @return Uint256 estimate.\n    function newEntryFeeEstimate() public view returns (uint256) {\n        return randomBeacon.entryFeeEstimate(callbackGas);\n    }\n\n    /// @notice Calculates the fee requestor has to pay to reseed the factory\n    /// for signer selection. Depending on how much value is stored in the\n    /// reseed pool and the price of a new relay entry, returned value may vary.\n    function newGroupSelectionSeedFee() public view returns (uint256) {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        return beaconFee <= reseedPool ? 0 : beaconFee.sub(reseedPool);\n    }\n\n    /// @notice Reseeds the value used for a signer selection. Requires enough\n    /// payment to be passed. The required payment can be calculated using\n    /// reseedFee function. Factory is automatically triggering reseeding after\n    /// opening a new keep but the reseed can be also triggered at any moment\n    /// using this function.\n    function requestNewGroupSelectionSeed() public payable nonReentrant {\n        reseedPool = reseedPool.add(msg.value);\n\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        require(reseedPool >= beaconFee, \"Not enough funds to trigger reseed\");\n        reseedPool = reseedPool.sub(beaconFee);\n\n        (bool success, bytes memory returnData) = requestRelayEntry(beaconFee);\n        if (!success) {\n            revert(string(returnData));\n        }\n    }\n\n    /// @notice Updates group selection seed.\n    /// @dev The main goal of this function is to request the random beacon to\n    /// generate a new random number. The beacon generates the number asynchronously\n    /// and will call a callback function when the number is ready. In the meantime\n    /// we update current group selection seed to a new value using a hash function.\n    /// In case of the random beacon request failure this function won't revert\n    /// but add beacon payment to factory's reseed pool.\n    function newGroupSelectionSeed() internal {\n        // Calculate new group selection seed based on the current seed.\n        // We added address of the factory as a key to calculate value different\n        // than sortition pool RNG will, so we don't end up selecting almost\n        // identical group.\n        groupSelectionSeed = uint256(\n            keccak256(abi.encodePacked(groupSelectionSeed, address(this)))\n        );\n\n        // Call the random beacon to get a random group selection seed.\n        (bool success, ) = requestRelayEntry(msg.value);\n        if (!success) {\n            reseedPool += msg.value;\n        }\n    }\n\n    /// @notice Requests for a relay entry using the beacon payment provided as\n    /// the parameter.\n    function requestRelayEntry(uint256 payment)\n        internal\n        returns (bool, bytes memory)\n    {\n        return\n            address(randomBeacon).call.value(payment)(\n                abi.encodeWithSignature(\n                    \"requestRelayEntry(address,uint256)\",\n                    address(this),\n                    callbackGas\n                )\n            );\n    }\n\n    /// @notice Checks if the caller is the random beacon.\n    /// @dev Throws an error if called by any account other than the random beacon.\n    modifier onlyRandomBeacon() {\n        require(\n            address(randomBeacon) == msg.sender,\n            \"Caller is not the random beacon\"\n        );\n        _;\n    }\n}\n", "flattened_code": "/**\n\u2593\u2593\u258c \u2593\u2593 \u2590\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2584\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580    \u2590\u2593\u2593\u2593\u2593\u2593\u2593    \u2590\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580      \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584       \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580\n  \u2593\u2593\u2593\u2593\u2593\u2593   \u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584     \u2590\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/**\n\u2593\u2593\u258c \u2593\u2593 \u2590\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2584\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c\u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593    \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580    \u2590\u2593\u2593\u2593\u2593\u2593\u2593    \u2590\u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580      \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2593\u2593\u2593\u2593\u2593\u2593\u2584\u2584\u2584\u2584         \u2590\u2593\u2593\u2593\u2593\u2593\u258c   \u2590\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593         \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u258c        \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n  \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584       \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2593\u2593\u2593\u2593\u2593\u2593\u2580\u2580\u2580\u2580         \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2580\n  \u2593\u2593\u2593\u2593\u2593\u2593   \u2580\u2593\u2593\u2593\u2593\u2593\u2593\u2584     \u2590\u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2593\u2593\u2593\u2593\u2593\u2593     \u2593\u2593\u2593\u2593\u2593   \u2590\u2593\u2593\u2593\u2593\u2593\u258c\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2588\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2590\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593 \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593  \u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\u2593\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\n/// @title Keep Random Beacon\n///\n/// @notice Keep Random Beacon generates verifiable randomness that is resistant\n/// to bad actors both in the relay network and on the anchoring blockchain.\ninterface IRandomBeacon {\n    /// @notice Event emitted for each new relay entry generated. It contains\n    /// request ID allowing to associate the generated relay entry with relay\n    /// request created previously with `requestRelayEntry` function. Event is\n    /// emitted no matter if callback was executed or not.\n    ///\n    /// @param requestId Relay request ID for which entry was generated.\n    /// @param entry Generated relay entry.\n    event RelayEntryGenerated(uint256 requestId, uint256 entry);\n\n    /// @notice Provides the customer with an estimated entry fee in wei to use\n    /// in the request. The fee estimate is only valid for the transaction it is\n    /// called in, so the customer must make the request immediately after\n    /// obtaining the estimate. Insufficient payment will lead to the request\n    /// being rejected and the transaction reverted.\n    ///\n    /// The customer may decide to provide more ether for an entry fee than\n    /// estimated by this function. This is especially helpful when callback gas\n    /// cost fluctuates. Any surplus between the passed fee and the actual cost\n    /// of producing an entry and executing a callback is returned back to the\n    /// customer.\n    /// @param callbackGas Gas required for the callback.\n    function entryFeeEstimate(uint256 callbackGas)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Submits a request to generate a new relay entry. Executes\n    /// callback on the provided callback contract with the generated entry and\n    /// emits `RelayEntryGenerated(uint256 requestId, uint256 entry)` event.\n    /// Callback contract has to declare public `__beaconCallback(uint256)`\n    /// function that is going to be executed with the result, once ready.\n    /// It is recommended to implement `IRandomBeaconConsumer` interface to\n    /// ensure the correct callback function signature.\n    ///\n    /// @dev Beacon does not support concurrent relay requests. No new requests\n    /// should be made while the beacon is already processing another request.\n    /// Requests made while the beacon is busy will be rejected and the\n    /// transaction reverted.\n    ///\n    /// @param callbackContract Callback contract address. Callback is called\n    /// once a new relay entry has been generated. Must declare public\n    /// `__beaconCallback(uint256)` function. It is recommended to implement\n    /// `IRandomBeaconConsumer` interface to ensure the correct callback function\n    /// signature.\n    /// @param callbackGas Gas required for the callback.\n    /// The customer needs to ensure they provide a sufficient callback gas\n    /// to cover the gas fee of executing the callback. Any surplus is returned\n    /// to the customer. If the callback gas amount turns to be not enough to\n    /// execute the callback, callback execution is skipped.\n    /// @return An uint256 representing uniquely generated relay request ID\n    function requestRelayEntry(address callbackContract, uint256 callbackGas)\n        external\n        payable\n        returns (uint256);\n\n    /// @notice Submits a request to generate a new relay entry. Emits\n    /// `RelayEntryGenerated(uint256 requestId, uint256 entry)` event for the\n    /// generated entry.\n    ///\n    /// @dev Beacon does not support concurrent relay requests. No new requests\n    /// should be made while the beacon is already processing another request.\n    /// Requests made while the beacon is busy will be rejected and the\n    /// transaction reverted.\n    ///\n    /// @return An uint256 representing uniquely generated relay request ID\n    function requestRelayEntry() external payable returns (uint256);\n}\n\n/// @title Keep Random Beacon Consumer\n///\n/// @notice Receives Keep Random Beacon relay entries with `__beaconCallback`\n/// function. Contract implementing this interface does not have to be the one\n/// requesting relay entry but it is the one receiving the requested relay entry\n/// once it is produced.\n///\n/// @dev Use this interface to indicate the contract receives relay entries from\n/// the beacon and to ensure the correctness of callback function signature.\ninterface IRandomBeaconConsumer {\n    /// @notice Receives relay entry produced by Keep Random Beacon. This function\n    /// should be called only by Keep Random Beacon.\n    ///\n    /// @param relayEntry Relay entry (random number) produced by Keep Random\n    /// Beacon.\n    function __beaconCallback(uint256 relayEntry) external;\n}\n\npragma solidity ^0.5.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _guardCounter += 1;\n        uint256 localCounter = _guardCounter;\n        _;\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\n    }\n}\n\ncontract GroupSelectionSeed is IRandomBeaconConsumer, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    IRandomBeacon randomBeacon;\n\n    // Gas required for a callback from the random beacon. The value specifies\n    // gas required to call `__beaconCallback` function in the worst-case\n    // scenario with all the checks and maximum allowed uint256 relay entry as\n    // a callback parameter.\n    uint256 public constant callbackGas = 30000;\n\n    // Random beacon sends back callback surplus to the requestor. It may also\n    // decide to send additional request subsidy fee. What's more, it may happen\n    // that the beacon is busy and we will not refresh group selection seed from\n    // the beacon. We accumulate all funds received from the beacon in the\n    // reseed pool and later use this pool to reseed using a public reseed\n    // function on a manual request at any moment.\n    uint256 public reseedPool;\n\n    uint256 public groupSelectionSeed;\n\n    constructor(address _randomBeacon) public {\n        randomBeacon = IRandomBeacon(_randomBeacon);\n\n        // Initial value before the random beacon updates the seed.\n        // https://www.wolframalpha.com/input/?i=pi+to+78+digits\n        groupSelectionSeed = 31415926535897932384626433832795028841971693993751058209749445923078164062862;\n    }\n\n    /// @notice Adds any received funds to the reseed pool.\n    function() external payable {\n        reseedPool += msg.value;\n    }\n\n    /// @notice Sets a new group selection seed value.\n    /// @dev The function is expected to be called in a callback by the random\n    /// beacon.\n    /// @param _relayEntry Beacon output.\n    function __beaconCallback(uint256 _relayEntry) external onlyRandomBeacon {\n        groupSelectionSeed = _relayEntry;\n    }\n\n    /// @notice Gets a fee estimate for a new random entry.\n    /// @return Uint256 estimate.\n    function newEntryFeeEstimate() public view returns (uint256) {\n        return randomBeacon.entryFeeEstimate(callbackGas);\n    }\n\n    /// @notice Calculates the fee requestor has to pay to reseed the factory\n    /// for signer selection. Depending on how much value is stored in the\n    /// reseed pool and the price of a new relay entry, returned value may vary.\n    function newGroupSelectionSeedFee() public view returns (uint256) {\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        return beaconFee <= reseedPool ? 0 : beaconFee.sub(reseedPool);\n    }\n\n    /// @notice Reseeds the value used for a signer selection. Requires enough\n    /// payment to be passed. The required payment can be calculated using\n    /// reseedFee function. Factory is automatically triggering reseeding after\n    /// opening a new keep but the reseed can be also triggered at any moment\n    /// using this function.\n    function requestNewGroupSelectionSeed() public payable nonReentrant {\n        reseedPool = reseedPool.add(msg.value);\n\n        uint256 beaconFee = randomBeacon.entryFeeEstimate(callbackGas);\n        require(reseedPool >= beaconFee, \"Not enough funds to trigger reseed\");\n        reseedPool = reseedPool.sub(beaconFee);\n\n        (bool success, bytes memory returnData) = requestRelayEntry(beaconFee);\n        if (!success) {\n            revert(string(returnData));\n        }\n    }\n\n    /// @notice Updates group selection seed.\n    /// @dev The main goal of this function is to request the random beacon to\n    /// generate a new random number. The beacon generates the number asynchronously\n    /// and will call a callback function when the number is ready. In the meantime\n    /// we update current group selection seed to a new value using a hash function.\n    /// In case of the random beacon request failure this function won't revert\n    /// but add beacon payment to factory's reseed pool.\n    function newGroupSelectionSeed() internal {\n        // Calculate new group selection seed based on the current seed.\n        // We added address of the factory as a key to calculate value different\n        // than sortition pool RNG will, so we don't end up selecting almost\n        // identical group.\n        groupSelectionSeed = uint256(\n            keccak256(abi.encodePacked(groupSelectionSeed, address(this)))\n        );\n\n        // Call the random beacon to get a random group selection seed.\n        (bool success, ) = requestRelayEntry(msg.value);\n        if (!success) {\n            reseedPool += msg.value;\n        }\n    }\n\n    /// @notice Requests for a relay entry using the beacon payment provided as\n    /// the parameter.\n    function requestRelayEntry(uint256 payment)\n        internal\n        returns (bool, bytes memory)\n    {\n        return\n            address(randomBeacon).call.value(payment)(\n                abi.encodeWithSignature(\n                    \"requestRelayEntry(address,uint256)\",\n                    address(this),\n                    callbackGas\n                )\n            );\n    }\n\n    /// @notice Checks if the caller is the random beacon.\n    /// @dev Throws an error if called by any account other than the random beacon.\n    modifier onlyRandomBeacon() {\n        require(\n            address(randomBeacon) == msg.sender,\n            \"Caller is not the random beacon\"\n        );\n        _;\n    }\n}\n", "commit_id": "720291b519b98f49fe0939cb0125facd0cb35de3"}}