{"filename": "contracts/RenPool.sol", "patch": "@@ -133,20 +133,20 @@ contract RenPool {\n \tfunction deposit(uint256 _amount) external {\n \t\taddress sender = msg.sender;\n \n-\t\trequire(isLocked == false, \"RenPool: Pool is locked\");\n+\t\trequire(!isLocked, \"RenPool: Pool is locked\");\n \t\trequire(_amount > 0, \"RenPool: Invalid amount\");\n \t\trequire(_amount + totalPooled <= bond, \"RenPool: Amount surpasses bond\");\n \n \t\tbalances[sender] += _amount;\n \t\ttotalPooled += _amount;\n \n-\t\trenToken.transferFrom(sender, address(this), _amount);\n-\n \t\temit RenDeposited(sender, _amount);\n \n \t\tif (totalPooled == bond) {\n \t\t\t_lockPool();\n \t\t}\n+\n+\t\trequire(renToken.transferFrom(sender, address(this), _amount), \"RenPool: Deposit failed\");\n \t}\n \n \t/**\n@@ -157,13 +157,13 @@ contract RenPool {\n \t\tuint256 senderBalance = balances[sender];\n \n \t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n-\t\trequire(isLocked == false, \"Pool is locked\");\n+\t\trequire(!isLocked, \"Pool is locked\");\n \n \t\ttotalPooled -= _amount;\n \t\tbalances[sender] -= _amount;\n \n \t\trequire(\n-\t\t\trenToken.transfer(sender, _amount) == true,\n+\t\t\trenToken.transfer(sender, _amount),\n \t\t\t\"Withdraw failed\"\n \t\t);\n \n@@ -180,7 +180,7 @@ contract RenPool {\n \t\tuint256 senderBalance = balances[sender];\n \n \t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n-\t\trequire(isLocked == true, \"Pool is not locked\");\n+\t\trequire(isLocked, \"Pool is not locked\");\n \n \t\twithdrawRequests[sender] = _amount;\n \n@@ -197,19 +197,19 @@ contract RenPool {\n \t\t// TODO: make sure user cannot fullfil his own request\n \t\t// TODO: add test for when _target doesn't have an associated withdrawRequest\n \n-\t\trequire(isLocked == true, \"Pool is not locked\");\n+\t\trequire(isLocked, \"Pool is not locked\");\n \n \t\tbalances[sender] += amount;\n \t\tbalances[_target] -= amount;\n \t\tdelete withdrawRequests[_target];\n \n \t\t// Transfer funds from sender to _target\n \t\trequire(\n-\t\t\trenToken.transferFrom(sender, address(this), amount) == true,\n+\t\t\trenToken.transferFrom(sender, address(this), amount),\n \t\t\t\"Deposit failed\"\n \t\t);\n \t\trequire(\n-\t\t\trenToken.transfer(_target, amount) == true,\n+\t\t\trenToken.transfer(_target, amount),\n \t\t\t\"Refund failed\"\n \t\t);\n \n@@ -233,10 +233,10 @@ contract RenPool {\n \t * registering the darknode.\n \t */\n \tfunction approveBondTransfer() external onlyNodeOperator {\n-\t\trequire(isLocked == true, \"Pool is not locked\");\n+\t\trequire(isLocked, \"Pool is not locked\");\n \n \t\trequire(\n-\t\t\trenToken.approve(address(darknodeRegistry), bond) == true,\n+\t\t\trenToken.approve(address(darknodeRegistry), bond),\n \t\t\t\"Bond transfer failed\"\n \t\t);\n \t}\n@@ -255,7 +255,7 @@ contract RenPool {\n \t * other darknodes and traders to encrypt messages to the trader.\n \t */\n \tfunction registerDarknode(address _darknodeID, bytes calldata _publicKey) external onlyNodeOperator {\n-\t\trequire(isLocked == true, \"Pool is not locked\");\n+\t\trequire(isLocked, \"Pool is not locked\");\n \n \t\tdarknodeRegistry.register(_darknodeID, _publicKey);\n ", "project_link": "https://github.com/Ethernautas/renpool/commit/762b892c9a556bb1db7feb4916676713c36038be", "bug_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IDarknodeRegistry.sol\";\nimport \"../interfaces/IDarknodePayment.sol\";\nimport \"../interfaces/IClaimRewards.sol\";\nimport \"../interfaces/IGateway.sol\";\n// TODO: use safeMath\n// TODO: Ownable + Ownable.initialize(_owner);\n\ncontract RenPool {\n\tuint8 public constant DECIMALS = 18;\n\n\taddress public owner; // This will be our address, in case we need to refund everyone\n\taddress public nodeOperator;\n\taddress public darknodeID;\n\n\tbytes public publicKey;\n\t// ^ What happens if we register and deregister and register back again?\n\n\tuint256 public bond;\n\tuint256 public totalPooled;\n\tuint256 public ownerFee; // Percentage\n\tuint256 public nodeOperatorFee; // Percentage\n\n\tuint64 public nonce;\n\n\tbool public isLocked;\n  // ^ we could use enum instead POOL_STATUS = { OPEN /* 0 */, CLOSE /* 1 */ }\n\n\tmapping(address => uint256) public balances;\n\tmapping(address => uint256) public withdrawRequests;\n\n\tIERC20 public renToken;\n\tIDarknodeRegistry public darknodeRegistry;\n\tIDarknodePayment public darknodePayment;\n\tIClaimRewards public claimRewards;\n\tIGateway public gateway; // OR IMintGateway????\n\n\tevent RenDeposited(address indexed _from, uint256 _amount);\n\tevent RenWithdrawn(address indexed _from, uint256 _amount);\n\tevent EthDeposited(address indexed _from, uint256 _amount);\n\tevent EthWithdrawn(address indexed _from, uint256 _amount);\n\tevent PoolLocked();\n\tevent PoolUnlocked();\n\n\t/**\n\t * @notice Deploy a new RenPool instance.\n\t *\n\t * @param _renTokenAddr The REN token contract address.\n\t * @param _darknodeRegistryAddr The DarknodeRegistry contract address.\n\t * @param _darknodePaymentAddr The DarknodePayment contract address.\n\t * @param _claimRewardsAddr The ClaimRewards contract address.\n\t * @param _gatewayAddr The Gateway contract address.\n\t * @param _owner The protocol owner's address. Possibly a multising wallet.\n\t * @param _bond The amount of REN tokens required to register a darknode.\n\t */\n\tconstructor(\n\t\taddress _renTokenAddr,\n\t\taddress _darknodeRegistryAddr,\n\t\taddress _darknodePaymentAddr,\n\t\taddress _claimRewardsAddr,\n\t\taddress _gatewayAddr,\n\t\taddress _owner,\n\t\tuint256 _bond\n\t)\n\t{\n\t\towner = _owner;\n\t\tnodeOperator = msg.sender;\n\t\trenToken = IERC20(_renTokenAddr);\n\t\tdarknodeRegistry = IDarknodeRegistry(_darknodeRegistryAddr);\n\t\tdarknodePayment = IDarknodePayment(_darknodePaymentAddr);\n\t\tclaimRewards = IClaimRewards(_claimRewardsAddr);\n\t\tgateway = IGateway(_gatewayAddr);\n\t\tbond = _bond;\n\t\tisLocked = false;\n\t\ttotalPooled = 0;\n\t\townerFee = 5;\n\t\tnodeOperatorFee = 5;\n\t\tnonce = 0;\n\n\t\t// TODO: register pool into RenPoolStore\n\t}\n\n\tmodifier onlyNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwnerNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == owner || msg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not owner nor node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire (\n\t\t\tmsg.sender == owner,\n\t\t\t\"RenPool: Caller is not owner\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Lock pool so that no direct deposits/withdrawals can\n\t * be performed.\n\t */\n\tfunction _lockPool() private {\n\t\tisLocked = true;\n\t\temit PoolLocked();\n\t}\n\n\tfunction unlockPool() external onlyOwnerNodeOperator {\n\t\trequire(renToken.balanceOf(address(this)) > 0, \"Pool balance is zero\");\n\t\tisLocked = false;\n\t\temit PoolUnlocked();\n\t}\n\n\t/**\n\t * @notice Deposit REN into the RenPool contract. Before depositing,\n\t * the transfer must be approved in the REN contract. In case the\n\t * predefined bond is reached, the pool is locked preventing any\n\t * further deposits or withdrawals.\n\t *\n\t * @param _amount The amount of REN to be deposited into the pool.\n\t */\n\tfunction deposit(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\n\t\trequire(isLocked == false, \"RenPool: Pool is locked\");\n\t\trequire(_amount > 0, \"RenPool: Invalid amount\");\n\t\trequire(_amount + totalPooled <= bond, \"RenPool: Amount surpasses bond\");\n\n\t\tbalances[sender] += _amount;\n\t\ttotalPooled += _amount;\n\n\t\trenToken.transferFrom(sender, address(this), _amount);\n\n\t\temit RenDeposited(sender, _amount);\n\n\t\tif (totalPooled == bond) {\n\t\t\t_lockPool();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw REN tokens while the pool is still open.\n\t */\n\tfunction withdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(isLocked == false, \"Pool is locked\");\n\n\t\ttotalPooled -= _amount;\n\t\tbalances[sender] -= _amount;\n\n\t\trequire(\n\t\t\trenToken.transfer(sender, _amount) == true,\n\t\t\t\"Withdraw failed\"\n\t\t);\n\n\t\temit RenWithdrawn(sender, _amount);\n\t}\n\n\t/**\n\t * TODO\n\t * @dev Users can have up to a single request active. In case of several\n\t * calls to this method, only the last request will be preserved.\n\t */\n\tfunction requestWithdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\twithdrawRequests[sender] = _amount;\n\n\t\t// TODO emit event\n\t}\n\n\t/**\n\t * TODO\n\t */\n\tfunction fulfillWithdrawRequest(address _target) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 amount = withdrawRequests[_target];\n\t\t// ^ This could not be defined plus make sure amount > 0\n\t\t// TODO: make sure user cannot fullfil his own request\n\t\t// TODO: add test for when _target doesn't have an associated withdrawRequest\n\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\tbalances[sender] += amount;\n\t\tbalances[_target] -= amount;\n\t\tdelete withdrawRequests[_target];\n\n\t\t// Transfer funds from sender to _target\n\t\trequire(\n\t\t\trenToken.transferFrom(sender, address(this), amount) == true,\n\t\t\t\"Deposit failed\"\n\t\t);\n\t\trequire(\n\t\t\trenToken.transfer(_target, amount) == true,\n\t\t\t\"Refund failed\"\n\t\t);\n\n\t\t// TODO emit event\n\t}\n\n\t// TODO: cancelWithdrawRequest\n\t// TODO: getWithdrawRequests\n\n\t/**\n\t * @notice Return REN balance for the given address.\n\t *\n\t * @param _target Address to be queried.\n\t */\n\tfunction balanceOf(address _target) external view returns(uint) {\n\t\treturn balances[_target];\n\t}\n\n\t/**\n\t * @notice Transfer bond to the darknodeRegistry contract prior to\n\t * registering the darknode.\n\t */\n\tfunction approveBondTransfer() external onlyNodeOperator {\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\trequire(\n\t\t\trenToken.approve(address(darknodeRegistry), bond) == true,\n\t\t\t\"Bond transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Register a darknode and transfer the bond to the darknodeRegistry\n\t * contract. Before registering, the bond transfer must be approved in the\n\t * darknodeRegistry contract (see approveTransferBond). The caller must\n\t * provide a public encryption key for the darknode. The darknode will remain\n\t * pending registration until the next epoch. Only after this period can the\n\t * darknode be deregistered. The caller of this method will be stored as the\n\t * owner of the darknode.\n\t *\n\t * @param _darknodeID The darknode ID that will be registered.\n\t * @param _publicKey The public key of the darknode. It is stored to allow\n\t * other darknodes and traders to encrypt messages to the trader.\n\t */\n\tfunction registerDarknode(address _darknodeID, bytes calldata _publicKey) external onlyNodeOperator {\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\tdarknodeRegistry.register(_darknodeID, _publicKey);\n\n\t\tdarknodeID = _darknodeID;\n\t\tpublicKey = _publicKey;\n\t}\n\n\t/**\n\t * @notice Deregister a darknode. The darknode will not be deregistered\n\t * until the end of the epoch. After another epoch, the bond can be\n\t * refunded by calling the refund method.\n\t *\n\t * @dev We don't reset darknodeID/publicKey values after deregistration in order\n\t * to being able to call refund.\n\t */\n\tfunction deregisterDarknode() external onlyOwnerNodeOperator {\n\t\tdarknodeRegistry.deregister(darknodeID);\n\t}\n\n\t/**\n\t * @notice Refund the bond of a deregistered darknode. This will make the\n\t * darknode available for registration again. Anyone can call this function\n\t * but the bond will always be refunded to the darknode owner.\n\t *\n\t * @dev No need to reset darknodeID/publicKey values after refund.\n\t */\n\tfunction refundBond() external {\n\t\tdarknodeRegistry.refund(darknodeID);\n\t}\n\n\t/**\n\t * @notice Allow ETH deposits in case gas is necessary to pay for transactions.\n\t */\n\treceive() external payable {\n\t\temit EthDeposited(msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @notice Allow node operator to withdraw any remaining gas.\n\t */\n\tfunction withdrawGas() external onlyNodeOperator {\n\t\tuint256 balance = address(this).balance;\n\t\tpayable(nodeOperator).transfer(balance);\n\t\temit EthWithdrawn(nodeOperator, balance);\n\t}\n\n\t/**\n\t * @notice Transfer rewards from darknode to darknode owner prior to calling claimDarknodeRewards.\n\t *\n\t * @param _tokens List of tokens to transfer. (here we could have a list with all available tokens)\n\t */\n\tfunction transferRewardsToDarknodeOwner(address[] calldata _tokens) external {\n\t\tdarknodePayment.withdrawMultiple(address(this), _tokens);\n\t}\n\n\t/**\n\t * @notice Claim darknode rewards.\n\t *\n\t * @param _assetSymbol The asset being claimed. e.g. \"BTC\" or \"DOGE\".\n\t * @param _amount The amount of the token being minted, in its smallest\n\t * denomination (e.g. satoshis for BTC).\n\t * @param _recipientAddress The Ethereum address to which the assets are\n\t * being withdrawn to. This same address must then call `mint` on\n\t * the asset's Ren Gateway contract.\n\t */\n\tfunction claimDarknodeRewards(\n\t\tstring memory _assetSymbol,\n\t\tuint256 _amount, // avoid this param, read from user balance instead. What about airdrops?\n\t\taddress _recipientAddress\n\t)\n\t\texternal\n\t\treturns(uint256, uint256)\n\t{\n\t\t// TODO: check that sender has the amount to be claimed\n\t\tuint256 fractionInBps = 10_000; // TODO: this should be the share of the user for the given token\n\t\tuint256 sig = claimRewards.claimRewardsToEthereum(_assetSymbol, _recipientAddress, fractionInBps);\n\t\tnonce += 1;\n\n\t\treturn (sig, nonce);\n\t\t// bytes32 pHash = keccak256(abi.encode(_assetSymbol, _recipientAddress));\n\t\t// bytes32 nHash = keccak256(abi.encode(nonce, _amount, pHash));\n\n\t\t// gateway.mint(pHash, _amount, nHash, sig);\n\n\t\t/*\n                    const nHash = randomBytes(32);\n                    const pHash = randomBytes(32);\n\n                    const hash = await gateway.hashForSignature.call(\n                        pHash,\n                        value,\n                        user,\n                        nHash\n                    );\n                    const sig = ecsign(\n                        Buffer.from(hash.slice(2), \"hex\"),\n                        privKey\n                    );\n\t\t\t\t\t\t\t\t\t\tSee: https://github.com/renproject/gateway-sol/blob/7bd51d8a897952a31134875d7b2b621e4542deaa/test/Gateway.ts\n\t\t*/\n\t}\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IDarknodeRegistry {\n\t/**\n\t\t* @notice Register a darknode and transfer the bond to the REN contract.\n\t\t* Before registering, the bond transfer must be approved in the REN\n\t\t* contract. The caller must provide a public encryption key for the\n\t\t* darknode. The darknode will remain pending registration until the next\n\t\t* epoch. Only after this period can the darknode be deregistered. The\n\t\t* caller of this method will be stored as the owner of the darknode.\n\t\t*\n\t\t* @param _darknodeID The darknode ID that will be registered.\n\t\t* @param _publicKey The public key of the darknode. It is stored to allow\n\t\t* other darknodes and traders to encrypt messages to the trader.\n\t\t*/\n\tfunction register(address _darknodeID, bytes calldata _publicKey) external;\n\n\t/**\n\t\t* @notice Retrieves the address of the account that registered a darknode.\n\t\t*\n\t\t* @param _darknodeID The ID of the darknode to retrieve the owner for.\n\t\t*/\n\tfunction getDarknodeOperator(address _darknodeID) external view returns (address payable);\n\n\t/**\n\t\t* @notice Deregister a darknode. The darknode will not be deregistered\n\t\t* until the end of the epoch. After another epoch, the bond can be\n\t\t* refunded by calling the refund method.\n\t\t*\n\t\t* @param _darknodeID The darknode ID that will be deregistered. The caller\n\t\t* of this method store.darknodeRegisteredAt(_darknodeID) must be\n\t\t* the owner of this darknode.\n\t\t*/\n\tfunction deregister(address _darknodeID) external;\n\n\t/**\n\t\t* @notice Refund the bond of a deregistered darknode. This will make the\n\t\t* darknode available for registration again. Anyone can call this function\n\t\t* but the bond will always be refunded to the darknode owner.\n\t\t*\n\t\t* @param _darknodeID The darknode ID that will be refunded. The caller\n\t\t* of this method must be the owner of this darknode.\n\t\t*/\n\tfunction refund(address _darknodeID) external;\n\n\t/**\n\t\t* @notice Returns whether a darknode is scheduled to become registered\n\t\t* at next epoch.\n\t\t*\n\t\t* @param _darknodeID The ID of the darknode to return\n\t\t*/\n\tfunction isPendingRegistration(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Returns if a darknode is in the pending deregistered state. In\n\t\t* this state a darknode is still considered registered.\n\t\t*/\n\tfunction isPendingDeregistration(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Returns if a darknode is in the registered state.\n\t\t*/\n\tfunction isRegistered(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Returns if a darknode is in the deregistered state.\n\t\t*/\n\tfunction isDeregistered(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Progress the epoch if it is possible to do so. This captures\n\t\t* the current timestamp and current blockhash and overrides the current\n\t\t* epoch.\n\t\t*/\n\tfunction epoch() external;\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IDarknodePayment {\n\t/**\n\t * @notice Transfers the funds allocated to the darknode to the darknode owner.\n\t *\n\t * @param _darknode The address of the darknode\n\t * @param _token Which token to transfer\n\t */\n\tfunction withdraw(address _darknode, address _token) external;\n\n\tfunction withdrawMultiple(address _darknode, address[] calldata _tokens) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IClaimRewards {\n\t/**\n\t * `claimRewardsToEthereum` triggers a withdrawal of a darknode operator's\n\t * rewards. `claimRewardsToEthereum` must be called by the operator\n\t * performing the withdrawals. When RenVM sees the claim, it will produce a\n\t * signature which needs to be submitted to the asset's Ren Gateway contract\n\t * on Ethereum.\n\t *\n\t * @param assetSymbol_ The asset being claimed. e.g. \"BTC\" or \"DOGE\"\n\t * @param recipientAddress_ The Ethereum address to which the assets are\n\t * being withdrawn to. This same address must then call `mint` on\n\t * the asset's Ren Gateway contract.\n\t * @param fractionInBps_ A value between 0 and 10000 that indicates the\n\t * percent to withdraw from each of the operator's darknodes.\n\t * 10000 represents 100%, 5000 represents 50%, etc.\n\t */\n\tfunction claimRewardsToEthereum(\n\t\tstring memory assetSymbol_,\n\t\taddress recipientAddress_,\n\t\tuint256 fractionInBps_\n\t) external returns (uint256);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IMintGateway {\n\tfunction mint(\n\t\tbytes32 _pHash,\n\t\tuint256 _amount,\n\t\tbytes32 _nHash,\n\t\tbytes calldata _sig\n\t) external returns (uint256);\n\n\tfunction mintFee() external view returns (uint256);\n}\n\ninterface IBurnGateway {\n\tfunction burn(bytes calldata _to, uint256 _amountScaled) external returns (uint256);\n\tfunction burnFee() external view returns (uint256);\n}\n\n// TODO: In ^0.6.0, should be `interface IGateway is IMintGateway,IBurnGateway {}`\ninterface IGateway {\n\t/**\n\t * @notice mint verifies a mint approval signature from RenVM and creates\n\t * tokens after taking a fee for the `_feeRecipient`.\n\t *\n\t * @param _pHash (payload hash) The hash of the payload associated with the\n\t * mint, ie, asset symbol and recipient address.\n\t * @param _amount The amount of the token being minted, in its smallest\n\t * denomination (e.g. satoshis for BTC).\n\t * @param _nHash (nonce hash) The hash of the nonce, amount and pHash.\n\t * @param _sig The signature of the hash of the following values:\n\t * (pHash, amount, msg.sender, nHash), signed by the mintAuthority. Where\n\t * mintAuthority refers to the address of the key that can sign mint requests.\n\t *\n\t * @dev See: https://github.com/renproject/gateway-sol/blob/7bd51d8a897952a31134875d7b2b621e4542deaa/contracts/Gateway/MintGatewayV3.sol\n\t */\n\t// is IMintGateway\n\tfunction mint(\n\t\tbytes32 _pHash,\n\t\tuint256 _amount,\n\t\tbytes32 _nHash,\n\t\tbytes calldata _sig\n\t) external returns (uint256);\n\n\tfunction mintFee() external view returns (uint256);\n\n\t// is IBurnGateway\n\tfunction burn(bytes calldata _to, uint256 _amountScaled) external returns (uint256);\n\tfunction burnFee() external view returns (uint256);\n}\n// TODO: use safeMath\n// TODO: Ownable + Ownable.initialize(_owner);\n\ncontract RenPool {\n\tuint8 public constant DECIMALS = 18;\n\n\taddress public owner; // This will be our address, in case we need to refund everyone\n\taddress public nodeOperator;\n\taddress public darknodeID;\n\n\tbytes public publicKey;\n\t// ^ What happens if we register and deregister and register back again?\n\n\tuint256 public bond;\n\tuint256 public totalPooled;\n\tuint256 public ownerFee; // Percentage\n\tuint256 public nodeOperatorFee; // Percentage\n\n\tuint64 public nonce;\n\n\tbool public isLocked;\n  // ^ we could use enum instead POOL_STATUS = { OPEN /* 0 */, CLOSE /* 1 */ }\n\n\tmapping(address => uint256) public balances;\n\tmapping(address => uint256) public withdrawRequests;\n\n\tIERC20 public renToken;\n\tIDarknodeRegistry public darknodeRegistry;\n\tIDarknodePayment public darknodePayment;\n\tIClaimRewards public claimRewards;\n\tIGateway public gateway; // OR IMintGateway????\n\n\tevent RenDeposited(address indexed _from, uint256 _amount);\n\tevent RenWithdrawn(address indexed _from, uint256 _amount);\n\tevent EthDeposited(address indexed _from, uint256 _amount);\n\tevent EthWithdrawn(address indexed _from, uint256 _amount);\n\tevent PoolLocked();\n\tevent PoolUnlocked();\n\n\t/**\n\t * @notice Deploy a new RenPool instance.\n\t *\n\t * @param _renTokenAddr The REN token contract address.\n\t * @param _darknodeRegistryAddr The DarknodeRegistry contract address.\n\t * @param _darknodePaymentAddr The DarknodePayment contract address.\n\t * @param _claimRewardsAddr The ClaimRewards contract address.\n\t * @param _gatewayAddr The Gateway contract address.\n\t * @param _owner The protocol owner's address. Possibly a multising wallet.\n\t * @param _bond The amount of REN tokens required to register a darknode.\n\t */\n\tconstructor(\n\t\taddress _renTokenAddr,\n\t\taddress _darknodeRegistryAddr,\n\t\taddress _darknodePaymentAddr,\n\t\taddress _claimRewardsAddr,\n\t\taddress _gatewayAddr,\n\t\taddress _owner,\n\t\tuint256 _bond\n\t)\n\t{\n\t\towner = _owner;\n\t\tnodeOperator = msg.sender;\n\t\trenToken = IERC20(_renTokenAddr);\n\t\tdarknodeRegistry = IDarknodeRegistry(_darknodeRegistryAddr);\n\t\tdarknodePayment = IDarknodePayment(_darknodePaymentAddr);\n\t\tclaimRewards = IClaimRewards(_claimRewardsAddr);\n\t\tgateway = IGateway(_gatewayAddr);\n\t\tbond = _bond;\n\t\tisLocked = false;\n\t\ttotalPooled = 0;\n\t\townerFee = 5;\n\t\tnodeOperatorFee = 5;\n\t\tnonce = 0;\n\n\t\t// TODO: register pool into RenPoolStore\n\t}\n\n\tmodifier onlyNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwnerNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == owner || msg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not owner nor node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire (\n\t\t\tmsg.sender == owner,\n\t\t\t\"RenPool: Caller is not owner\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Lock pool so that no direct deposits/withdrawals can\n\t * be performed.\n\t */\n\tfunction _lockPool() private {\n\t\tisLocked = true;\n\t\temit PoolLocked();\n\t}\n\n\tfunction unlockPool() external onlyOwnerNodeOperator {\n\t\trequire(renToken.balanceOf(address(this)) > 0, \"Pool balance is zero\");\n\t\tisLocked = false;\n\t\temit PoolUnlocked();\n\t}\n\n\t/**\n\t * @notice Deposit REN into the RenPool contract. Before depositing,\n\t * the transfer must be approved in the REN contract. In case the\n\t * predefined bond is reached, the pool is locked preventing any\n\t * further deposits or withdrawals.\n\t *\n\t * @param _amount The amount of REN to be deposited into the pool.\n\t */\n\tfunction deposit(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\n\t\trequire(isLocked == false, \"RenPool: Pool is locked\");\n\t\trequire(_amount > 0, \"RenPool: Invalid amount\");\n\t\trequire(_amount + totalPooled <= bond, \"RenPool: Amount surpasses bond\");\n\n\t\tbalances[sender] += _amount;\n\t\ttotalPooled += _amount;\n\n\t\trenToken.transferFrom(sender, address(this), _amount);\n\n\t\temit RenDeposited(sender, _amount);\n\n\t\tif (totalPooled == bond) {\n\t\t\t_lockPool();\n\t\t}\n\t}\n\n\t/**\n\t * @notice Withdraw REN tokens while the pool is still open.\n\t */\n\tfunction withdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(isLocked == false, \"Pool is locked\");\n\n\t\ttotalPooled -= _amount;\n\t\tbalances[sender] -= _amount;\n\n\t\trequire(\n\t\t\trenToken.transfer(sender, _amount) == true,\n\t\t\t\"Withdraw failed\"\n\t\t);\n\n\t\temit RenWithdrawn(sender, _amount);\n\t}\n\n\t/**\n\t * TODO\n\t * @dev Users can have up to a single request active. In case of several\n\t * calls to this method, only the last request will be preserved.\n\t */\n\tfunction requestWithdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\twithdrawRequests[sender] = _amount;\n\n\t\t// TODO emit event\n\t}\n\n\t/**\n\t * TODO\n\t */\n\tfunction fulfillWithdrawRequest(address _target) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 amount = withdrawRequests[_target];\n\t\t// ^ This could not be defined plus make sure amount > 0\n\t\t// TODO: make sure user cannot fullfil his own request\n\t\t// TODO: add test for when _target doesn't have an associated withdrawRequest\n\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\tbalances[sender] += amount;\n\t\tbalances[_target] -= amount;\n\t\tdelete withdrawRequests[_target];\n\n\t\t// Transfer funds from sender to _target\n\t\trequire(\n\t\t\trenToken.transferFrom(sender, address(this), amount) == true,\n\t\t\t\"Deposit failed\"\n\t\t);\n\t\trequire(\n\t\t\trenToken.transfer(_target, amount) == true,\n\t\t\t\"Refund failed\"\n\t\t);\n\n\t\t// TODO emit event\n\t}\n\n\t// TODO: cancelWithdrawRequest\n\t// TODO: getWithdrawRequests\n\n\t/**\n\t * @notice Return REN balance for the given address.\n\t *\n\t * @param _target Address to be queried.\n\t */\n\tfunction balanceOf(address _target) external view returns(uint) {\n\t\treturn balances[_target];\n\t}\n\n\t/**\n\t * @notice Transfer bond to the darknodeRegistry contract prior to\n\t * registering the darknode.\n\t */\n\tfunction approveBondTransfer() external onlyNodeOperator {\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\trequire(\n\t\t\trenToken.approve(address(darknodeRegistry), bond) == true,\n\t\t\t\"Bond transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Register a darknode and transfer the bond to the darknodeRegistry\n\t * contract. Before registering, the bond transfer must be approved in the\n\t * darknodeRegistry contract (see approveTransferBond). The caller must\n\t * provide a public encryption key for the darknode. The darknode will remain\n\t * pending registration until the next epoch. Only after this period can the\n\t * darknode be deregistered. The caller of this method will be stored as the\n\t * owner of the darknode.\n\t *\n\t * @param _darknodeID The darknode ID that will be registered.\n\t * @param _publicKey The public key of the darknode. It is stored to allow\n\t * other darknodes and traders to encrypt messages to the trader.\n\t */\n\tfunction registerDarknode(address _darknodeID, bytes calldata _publicKey) external onlyNodeOperator {\n\t\trequire(isLocked == true, \"Pool is not locked\");\n\n\t\tdarknodeRegistry.register(_darknodeID, _publicKey);\n\n\t\tdarknodeID = _darknodeID;\n\t\tpublicKey = _publicKey;\n\t}\n\n\t/**\n\t * @notice Deregister a darknode. The darknode will not be deregistered\n\t * until the end of the epoch. After another epoch, the bond can be\n\t * refunded by calling the refund method.\n\t *\n\t * @dev We don't reset darknodeID/publicKey values after deregistration in order\n\t * to being able to call refund.\n\t */\n\tfunction deregisterDarknode() external onlyOwnerNodeOperator {\n\t\tdarknodeRegistry.deregister(darknodeID);\n\t}\n\n\t/**\n\t * @notice Refund the bond of a deregistered darknode. This will make the\n\t * darknode available for registration again. Anyone can call this function\n\t * but the bond will always be refunded to the darknode owner.\n\t *\n\t * @dev No need to reset darknodeID/publicKey values after refund.\n\t */\n\tfunction refundBond() external {\n\t\tdarknodeRegistry.refund(darknodeID);\n\t}\n\n\t/**\n\t * @notice Allow ETH deposits in case gas is necessary to pay for transactions.\n\t */\n\treceive() external payable {\n\t\temit EthDeposited(msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @notice Allow node operator to withdraw any remaining gas.\n\t */\n\tfunction withdrawGas() external onlyNodeOperator {\n\t\tuint256 balance = address(this).balance;\n\t\tpayable(nodeOperator).transfer(balance);\n\t\temit EthWithdrawn(nodeOperator, balance);\n\t}\n\n\t/**\n\t * @notice Transfer rewards from darknode to darknode owner prior to calling claimDarknodeRewards.\n\t *\n\t * @param _tokens List of tokens to transfer. (here we could have a list with all available tokens)\n\t */\n\tfunction transferRewardsToDarknodeOwner(address[] calldata _tokens) external {\n\t\tdarknodePayment.withdrawMultiple(address(this), _tokens);\n\t}\n\n\t/**\n\t * @notice Claim darknode rewards.\n\t *\n\t * @param _assetSymbol The asset being claimed. e.g. \"BTC\" or \"DOGE\".\n\t * @param _amount The amount of the token being minted, in its smallest\n\t * denomination (e.g. satoshis for BTC).\n\t * @param _recipientAddress The Ethereum address to which the assets are\n\t * being withdrawn to. This same address must then call `mint` on\n\t * the asset's Ren Gateway contract.\n\t */\n\tfunction claimDarknodeRewards(\n\t\tstring memory _assetSymbol,\n\t\tuint256 _amount, // avoid this param, read from user balance instead. What about airdrops?\n\t\taddress _recipientAddress\n\t)\n\t\texternal\n\t\treturns(uint256, uint256)\n\t{\n\t\t// TODO: check that sender has the amount to be claimed\n\t\tuint256 fractionInBps = 10_000; // TODO: this should be the share of the user for the given token\n\t\tuint256 sig = claimRewards.claimRewardsToEthereum(_assetSymbol, _recipientAddress, fractionInBps);\n\t\tnonce += 1;\n\n\t\treturn (sig, nonce);\n\t\t// bytes32 pHash = keccak256(abi.encode(_assetSymbol, _recipientAddress));\n\t\t// bytes32 nHash = keccak256(abi.encode(nonce, _amount, pHash));\n\n\t\t// gateway.mint(pHash, _amount, nHash, sig);\n\n\t\t/*\n                    const nHash = randomBytes(32);\n                    const pHash = randomBytes(32);\n\n                    const hash = await gateway.hashForSignature.call(\n                        pHash,\n                        value,\n                        user,\n                        nHash\n                    );\n                    const sig = ecsign(\n                        Buffer.from(hash.slice(2), \"hex\"),\n                        privKey\n                    );\n\t\t\t\t\t\t\t\t\t\tSee: https://github.com/renproject/gateway-sol/blob/7bd51d8a897952a31134875d7b2b621e4542deaa/test/Gateway.ts\n\t\t*/\n\t}\n}\n", "commit_id": "70ab8bf1709519a8be92b0a2efa7f574e2964ad0"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IDarknodeRegistry.sol\";\nimport \"../interfaces/IDarknodePayment.sol\";\nimport \"../interfaces/IClaimRewards.sol\";\nimport \"../interfaces/IGateway.sol\";\n// TODO: use safeMath\n// TODO: Ownable + Ownable.initialize(_owner);\n\ncontract RenPool {\n\tuint8 public constant DECIMALS = 18;\n\n\taddress public owner; // This will be our address, in case we need to refund everyone\n\taddress public nodeOperator;\n\taddress public darknodeID;\n\n\tbytes public publicKey;\n\t// ^ What happens if we register and deregister and register back again?\n\n\tuint256 public bond;\n\tuint256 public totalPooled;\n\tuint256 public ownerFee; // Percentage\n\tuint256 public nodeOperatorFee; // Percentage\n\n\tuint64 public nonce;\n\n\tbool public isLocked;\n  // ^ we could use enum instead POOL_STATUS = { OPEN /* 0 */, CLOSE /* 1 */ }\n\n\tmapping(address => uint256) public balances;\n\tmapping(address => uint256) public withdrawRequests;\n\n\tIERC20 public renToken;\n\tIDarknodeRegistry public darknodeRegistry;\n\tIDarknodePayment public darknodePayment;\n\tIClaimRewards public claimRewards;\n\tIGateway public gateway; // OR IMintGateway????\n\n\tevent RenDeposited(address indexed _from, uint256 _amount);\n\tevent RenWithdrawn(address indexed _from, uint256 _amount);\n\tevent EthDeposited(address indexed _from, uint256 _amount);\n\tevent EthWithdrawn(address indexed _from, uint256 _amount);\n\tevent PoolLocked();\n\tevent PoolUnlocked();\n\n\t/**\n\t * @notice Deploy a new RenPool instance.\n\t *\n\t * @param _renTokenAddr The REN token contract address.\n\t * @param _darknodeRegistryAddr The DarknodeRegistry contract address.\n\t * @param _darknodePaymentAddr The DarknodePayment contract address.\n\t * @param _claimRewardsAddr The ClaimRewards contract address.\n\t * @param _gatewayAddr The Gateway contract address.\n\t * @param _owner The protocol owner's address. Possibly a multising wallet.\n\t * @param _bond The amount of REN tokens required to register a darknode.\n\t */\n\tconstructor(\n\t\taddress _renTokenAddr,\n\t\taddress _darknodeRegistryAddr,\n\t\taddress _darknodePaymentAddr,\n\t\taddress _claimRewardsAddr,\n\t\taddress _gatewayAddr,\n\t\taddress _owner,\n\t\tuint256 _bond\n\t)\n\t{\n\t\towner = _owner;\n\t\tnodeOperator = msg.sender;\n\t\trenToken = IERC20(_renTokenAddr);\n\t\tdarknodeRegistry = IDarknodeRegistry(_darknodeRegistryAddr);\n\t\tdarknodePayment = IDarknodePayment(_darknodePaymentAddr);\n\t\tclaimRewards = IClaimRewards(_claimRewardsAddr);\n\t\tgateway = IGateway(_gatewayAddr);\n\t\tbond = _bond;\n\t\tisLocked = false;\n\t\ttotalPooled = 0;\n\t\townerFee = 5;\n\t\tnodeOperatorFee = 5;\n\t\tnonce = 0;\n\n\t\t// TODO: register pool into RenPoolStore\n\t}\n\n\tmodifier onlyNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwnerNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == owner || msg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not owner nor node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire (\n\t\t\tmsg.sender == owner,\n\t\t\t\"RenPool: Caller is not owner\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Lock pool so that no direct deposits/withdrawals can\n\t * be performed.\n\t */\n\tfunction _lockPool() private {\n\t\tisLocked = true;\n\t\temit PoolLocked();\n\t}\n\n\tfunction unlockPool() external onlyOwnerNodeOperator {\n\t\trequire(renToken.balanceOf(address(this)) > 0, \"Pool balance is zero\");\n\t\tisLocked = false;\n\t\temit PoolUnlocked();\n\t}\n\n\t/**\n\t * @notice Deposit REN into the RenPool contract. Before depositing,\n\t * the transfer must be approved in the REN contract. In case the\n\t * predefined bond is reached, the pool is locked preventing any\n\t * further deposits or withdrawals.\n\t *\n\t * @param _amount The amount of REN to be deposited into the pool.\n\t */\n\tfunction deposit(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\n\t\trequire(!isLocked, \"RenPool: Pool is locked\");\n\t\trequire(_amount > 0, \"RenPool: Invalid amount\");\n\t\trequire(_amount + totalPooled <= bond, \"RenPool: Amount surpasses bond\");\n\n\t\tbalances[sender] += _amount;\n\t\ttotalPooled += _amount;\n\n\t\temit RenDeposited(sender, _amount);\n\n\t\tif (totalPooled == bond) {\n\t\t\t_lockPool();\n\t\t}\n\n\t\trequire(renToken.transferFrom(sender, address(this), _amount), \"RenPool: Deposit failed\");\n\t}\n\n\t/**\n\t * @notice Withdraw REN tokens while the pool is still open.\n\t */\n\tfunction withdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(!isLocked, \"Pool is locked\");\n\n\t\ttotalPooled -= _amount;\n\t\tbalances[sender] -= _amount;\n\n\t\trequire(\n\t\t\trenToken.transfer(sender, _amount),\n\t\t\t\"Withdraw failed\"\n\t\t);\n\n\t\temit RenWithdrawn(sender, _amount);\n\t}\n\n\t/**\n\t * TODO\n\t * @dev Users can have up to a single request active. In case of several\n\t * calls to this method, only the last request will be preserved.\n\t */\n\tfunction requestWithdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\twithdrawRequests[sender] = _amount;\n\n\t\t// TODO emit event\n\t}\n\n\t/**\n\t * TODO\n\t */\n\tfunction fulfillWithdrawRequest(address _target) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 amount = withdrawRequests[_target];\n\t\t// ^ This could not be defined plus make sure amount > 0\n\t\t// TODO: make sure user cannot fullfil his own request\n\t\t// TODO: add test for when _target doesn't have an associated withdrawRequest\n\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\tbalances[sender] += amount;\n\t\tbalances[_target] -= amount;\n\t\tdelete withdrawRequests[_target];\n\n\t\t// Transfer funds from sender to _target\n\t\trequire(\n\t\t\trenToken.transferFrom(sender, address(this), amount),\n\t\t\t\"Deposit failed\"\n\t\t);\n\t\trequire(\n\t\t\trenToken.transfer(_target, amount),\n\t\t\t\"Refund failed\"\n\t\t);\n\n\t\t// TODO emit event\n\t}\n\n\t// TODO: cancelWithdrawRequest\n\t// TODO: getWithdrawRequests\n\n\t/**\n\t * @notice Return REN balance for the given address.\n\t *\n\t * @param _target Address to be queried.\n\t */\n\tfunction balanceOf(address _target) external view returns(uint) {\n\t\treturn balances[_target];\n\t}\n\n\t/**\n\t * @notice Transfer bond to the darknodeRegistry contract prior to\n\t * registering the darknode.\n\t */\n\tfunction approveBondTransfer() external onlyNodeOperator {\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\trequire(\n\t\t\trenToken.approve(address(darknodeRegistry), bond),\n\t\t\t\"Bond transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Register a darknode and transfer the bond to the darknodeRegistry\n\t * contract. Before registering, the bond transfer must be approved in the\n\t * darknodeRegistry contract (see approveTransferBond). The caller must\n\t * provide a public encryption key for the darknode. The darknode will remain\n\t * pending registration until the next epoch. Only after this period can the\n\t * darknode be deregistered. The caller of this method will be stored as the\n\t * owner of the darknode.\n\t *\n\t * @param _darknodeID The darknode ID that will be registered.\n\t * @param _publicKey The public key of the darknode. It is stored to allow\n\t * other darknodes and traders to encrypt messages to the trader.\n\t */\n\tfunction registerDarknode(address _darknodeID, bytes calldata _publicKey) external onlyNodeOperator {\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\tdarknodeRegistry.register(_darknodeID, _publicKey);\n\n\t\tdarknodeID = _darknodeID;\n\t\tpublicKey = _publicKey;\n\t}\n\n\t/**\n\t * @notice Deregister a darknode. The darknode will not be deregistered\n\t * until the end of the epoch. After another epoch, the bond can be\n\t * refunded by calling the refund method.\n\t *\n\t * @dev We don't reset darknodeID/publicKey values after deregistration in order\n\t * to being able to call refund.\n\t */\n\tfunction deregisterDarknode() external onlyOwnerNodeOperator {\n\t\tdarknodeRegistry.deregister(darknodeID);\n\t}\n\n\t/**\n\t * @notice Refund the bond of a deregistered darknode. This will make the\n\t * darknode available for registration again. Anyone can call this function\n\t * but the bond will always be refunded to the darknode owner.\n\t *\n\t * @dev No need to reset darknodeID/publicKey values after refund.\n\t */\n\tfunction refundBond() external {\n\t\tdarknodeRegistry.refund(darknodeID);\n\t}\n\n\t/**\n\t * @notice Allow ETH deposits in case gas is necessary to pay for transactions.\n\t */\n\treceive() external payable {\n\t\temit EthDeposited(msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @notice Allow node operator to withdraw any remaining gas.\n\t */\n\tfunction withdrawGas() external onlyNodeOperator {\n\t\tuint256 balance = address(this).balance;\n\t\tpayable(nodeOperator).transfer(balance);\n\t\temit EthWithdrawn(nodeOperator, balance);\n\t}\n\n\t/**\n\t * @notice Transfer rewards from darknode to darknode owner prior to calling claimDarknodeRewards.\n\t *\n\t * @param _tokens List of tokens to transfer. (here we could have a list with all available tokens)\n\t */\n\tfunction transferRewardsToDarknodeOwner(address[] calldata _tokens) external {\n\t\tdarknodePayment.withdrawMultiple(address(this), _tokens);\n\t}\n\n\t/**\n\t * @notice Claim darknode rewards.\n\t *\n\t * @param _assetSymbol The asset being claimed. e.g. \"BTC\" or \"DOGE\".\n\t * @param _amount The amount of the token being minted, in its smallest\n\t * denomination (e.g. satoshis for BTC).\n\t * @param _recipientAddress The Ethereum address to which the assets are\n\t * being withdrawn to. This same address must then call `mint` on\n\t * the asset's Ren Gateway contract.\n\t */\n\tfunction claimDarknodeRewards(\n\t\tstring memory _assetSymbol,\n\t\tuint256 _amount, // avoid this param, read from user balance instead. What about airdrops?\n\t\taddress _recipientAddress\n\t)\n\t\texternal\n\t\treturns(uint256, uint256)\n\t{\n\t\t// TODO: check that sender has the amount to be claimed\n\t\tuint256 fractionInBps = 10_000; // TODO: this should be the share of the user for the given token\n\t\tuint256 sig = claimRewards.claimRewardsToEthereum(_assetSymbol, _recipientAddress, fractionInBps);\n\t\tnonce += 1;\n\n\t\treturn (sig, nonce);\n\t\t// bytes32 pHash = keccak256(abi.encode(_assetSymbol, _recipientAddress));\n\t\t// bytes32 nHash = keccak256(abi.encode(nonce, _amount, pHash));\n\n\t\t// gateway.mint(pHash, _amount, nHash, sig);\n\n\t\t/*\n                    const nHash = randomBytes(32);\n                    const pHash = randomBytes(32);\n\n                    const hash = await gateway.hashForSignature.call(\n                        pHash,\n                        value,\n                        user,\n                        nHash\n                    );\n                    const sig = ecsign(\n                        Buffer.from(hash.slice(2), \"hex\"),\n                        privKey\n                    );\n\t\t\t\t\t\t\t\t\t\tSee: https://github.com/renproject/gateway-sol/blob/7bd51d8a897952a31134875d7b2b621e4542deaa/test/Gateway.ts\n\t\t*/\n\t}\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IDarknodeRegistry {\n\t/**\n\t\t* @notice Register a darknode and transfer the bond to the REN contract.\n\t\t* Before registering, the bond transfer must be approved in the REN\n\t\t* contract. The caller must provide a public encryption key for the\n\t\t* darknode. The darknode will remain pending registration until the next\n\t\t* epoch. Only after this period can the darknode be deregistered. The\n\t\t* caller of this method will be stored as the owner of the darknode.\n\t\t*\n\t\t* @param _darknodeID The darknode ID that will be registered.\n\t\t* @param _publicKey The public key of the darknode. It is stored to allow\n\t\t* other darknodes and traders to encrypt messages to the trader.\n\t\t*/\n\tfunction register(address _darknodeID, bytes calldata _publicKey) external;\n\n\t/**\n\t\t* @notice Retrieves the address of the account that registered a darknode.\n\t\t*\n\t\t* @param _darknodeID The ID of the darknode to retrieve the owner for.\n\t\t*/\n\tfunction getDarknodeOperator(address _darknodeID) external view returns (address payable);\n\n\t/**\n\t\t* @notice Deregister a darknode. The darknode will not be deregistered\n\t\t* until the end of the epoch. After another epoch, the bond can be\n\t\t* refunded by calling the refund method.\n\t\t*\n\t\t* @param _darknodeID The darknode ID that will be deregistered. The caller\n\t\t* of this method store.darknodeRegisteredAt(_darknodeID) must be\n\t\t* the owner of this darknode.\n\t\t*/\n\tfunction deregister(address _darknodeID) external;\n\n\t/**\n\t\t* @notice Refund the bond of a deregistered darknode. This will make the\n\t\t* darknode available for registration again. Anyone can call this function\n\t\t* but the bond will always be refunded to the darknode owner.\n\t\t*\n\t\t* @param _darknodeID The darknode ID that will be refunded. The caller\n\t\t* of this method must be the owner of this darknode.\n\t\t*/\n\tfunction refund(address _darknodeID) external;\n\n\t/**\n\t\t* @notice Returns whether a darknode is scheduled to become registered\n\t\t* at next epoch.\n\t\t*\n\t\t* @param _darknodeID The ID of the darknode to return\n\t\t*/\n\tfunction isPendingRegistration(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Returns if a darknode is in the pending deregistered state. In\n\t\t* this state a darknode is still considered registered.\n\t\t*/\n\tfunction isPendingDeregistration(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Returns if a darknode is in the registered state.\n\t\t*/\n\tfunction isRegistered(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Returns if a darknode is in the deregistered state.\n\t\t*/\n\tfunction isDeregistered(address _darknodeID) external view returns (bool);\n\n\t/**\n\t\t* @notice Progress the epoch if it is possible to do so. This captures\n\t\t* the current timestamp and current blockhash and overrides the current\n\t\t* epoch.\n\t\t*/\n\tfunction epoch() external;\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IDarknodePayment {\n\t/**\n\t * @notice Transfers the funds allocated to the darknode to the darknode owner.\n\t *\n\t * @param _darknode The address of the darknode\n\t * @param _token Which token to transfer\n\t */\n\tfunction withdraw(address _darknode, address _token) external;\n\n\tfunction withdrawMultiple(address _darknode, address[] calldata _tokens) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IClaimRewards {\n\t/**\n\t * `claimRewardsToEthereum` triggers a withdrawal of a darknode operator's\n\t * rewards. `claimRewardsToEthereum` must be called by the operator\n\t * performing the withdrawals. When RenVM sees the claim, it will produce a\n\t * signature which needs to be submitted to the asset's Ren Gateway contract\n\t * on Ethereum.\n\t *\n\t * @param assetSymbol_ The asset being claimed. e.g. \"BTC\" or \"DOGE\"\n\t * @param recipientAddress_ The Ethereum address to which the assets are\n\t * being withdrawn to. This same address must then call `mint` on\n\t * the asset's Ren Gateway contract.\n\t * @param fractionInBps_ A value between 0 and 10000 that indicates the\n\t * percent to withdraw from each of the operator's darknodes.\n\t * 10000 represents 100%, 5000 represents 50%, etc.\n\t */\n\tfunction claimRewardsToEthereum(\n\t\tstring memory assetSymbol_,\n\t\taddress recipientAddress_,\n\t\tuint256 fractionInBps_\n\t) external returns (uint256);\n}\n// IGNORE_LICENSE-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IMintGateway {\n\tfunction mint(\n\t\tbytes32 _pHash,\n\t\tuint256 _amount,\n\t\tbytes32 _nHash,\n\t\tbytes calldata _sig\n\t) external returns (uint256);\n\n\tfunction mintFee() external view returns (uint256);\n}\n\ninterface IBurnGateway {\n\tfunction burn(bytes calldata _to, uint256 _amountScaled) external returns (uint256);\n\tfunction burnFee() external view returns (uint256);\n}\n\n// TODO: In ^0.6.0, should be `interface IGateway is IMintGateway,IBurnGateway {}`\ninterface IGateway {\n\t/**\n\t * @notice mint verifies a mint approval signature from RenVM and creates\n\t * tokens after taking a fee for the `_feeRecipient`.\n\t *\n\t * @param _pHash (payload hash) The hash of the payload associated with the\n\t * mint, ie, asset symbol and recipient address.\n\t * @param _amount The amount of the token being minted, in its smallest\n\t * denomination (e.g. satoshis for BTC).\n\t * @param _nHash (nonce hash) The hash of the nonce, amount and pHash.\n\t * @param _sig The signature of the hash of the following values:\n\t * (pHash, amount, msg.sender, nHash), signed by the mintAuthority. Where\n\t * mintAuthority refers to the address of the key that can sign mint requests.\n\t *\n\t * @dev See: https://github.com/renproject/gateway-sol/blob/7bd51d8a897952a31134875d7b2b621e4542deaa/contracts/Gateway/MintGatewayV3.sol\n\t */\n\t// is IMintGateway\n\tfunction mint(\n\t\tbytes32 _pHash,\n\t\tuint256 _amount,\n\t\tbytes32 _nHash,\n\t\tbytes calldata _sig\n\t) external returns (uint256);\n\n\tfunction mintFee() external view returns (uint256);\n\n\t// is IBurnGateway\n\tfunction burn(bytes calldata _to, uint256 _amountScaled) external returns (uint256);\n\tfunction burnFee() external view returns (uint256);\n}\n// TODO: use safeMath\n// TODO: Ownable + Ownable.initialize(_owner);\n\ncontract RenPool {\n\tuint8 public constant DECIMALS = 18;\n\n\taddress public owner; // This will be our address, in case we need to refund everyone\n\taddress public nodeOperator;\n\taddress public darknodeID;\n\n\tbytes public publicKey;\n\t// ^ What happens if we register and deregister and register back again?\n\n\tuint256 public bond;\n\tuint256 public totalPooled;\n\tuint256 public ownerFee; // Percentage\n\tuint256 public nodeOperatorFee; // Percentage\n\n\tuint64 public nonce;\n\n\tbool public isLocked;\n  // ^ we could use enum instead POOL_STATUS = { OPEN /* 0 */, CLOSE /* 1 */ }\n\n\tmapping(address => uint256) public balances;\n\tmapping(address => uint256) public withdrawRequests;\n\n\tIERC20 public renToken;\n\tIDarknodeRegistry public darknodeRegistry;\n\tIDarknodePayment public darknodePayment;\n\tIClaimRewards public claimRewards;\n\tIGateway public gateway; // OR IMintGateway????\n\n\tevent RenDeposited(address indexed _from, uint256 _amount);\n\tevent RenWithdrawn(address indexed _from, uint256 _amount);\n\tevent EthDeposited(address indexed _from, uint256 _amount);\n\tevent EthWithdrawn(address indexed _from, uint256 _amount);\n\tevent PoolLocked();\n\tevent PoolUnlocked();\n\n\t/**\n\t * @notice Deploy a new RenPool instance.\n\t *\n\t * @param _renTokenAddr The REN token contract address.\n\t * @param _darknodeRegistryAddr The DarknodeRegistry contract address.\n\t * @param _darknodePaymentAddr The DarknodePayment contract address.\n\t * @param _claimRewardsAddr The ClaimRewards contract address.\n\t * @param _gatewayAddr The Gateway contract address.\n\t * @param _owner The protocol owner's address. Possibly a multising wallet.\n\t * @param _bond The amount of REN tokens required to register a darknode.\n\t */\n\tconstructor(\n\t\taddress _renTokenAddr,\n\t\taddress _darknodeRegistryAddr,\n\t\taddress _darknodePaymentAddr,\n\t\taddress _claimRewardsAddr,\n\t\taddress _gatewayAddr,\n\t\taddress _owner,\n\t\tuint256 _bond\n\t)\n\t{\n\t\towner = _owner;\n\t\tnodeOperator = msg.sender;\n\t\trenToken = IERC20(_renTokenAddr);\n\t\tdarknodeRegistry = IDarknodeRegistry(_darknodeRegistryAddr);\n\t\tdarknodePayment = IDarknodePayment(_darknodePaymentAddr);\n\t\tclaimRewards = IClaimRewards(_claimRewardsAddr);\n\t\tgateway = IGateway(_gatewayAddr);\n\t\tbond = _bond;\n\t\tisLocked = false;\n\t\ttotalPooled = 0;\n\t\townerFee = 5;\n\t\tnodeOperatorFee = 5;\n\t\tnonce = 0;\n\n\t\t// TODO: register pool into RenPoolStore\n\t}\n\n\tmodifier onlyNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwnerNodeOperator() {\n\t\trequire (\n\t\t\tmsg.sender == owner || msg.sender == nodeOperator,\n\t\t\t\"RenPool: Caller is not owner nor node operator\"\n\t\t);\n\t\t_;\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire (\n\t\t\tmsg.sender == owner,\n\t\t\t\"RenPool: Caller is not owner\"\n\t\t);\n\t\t_;\n\t}\n\n\t/**\n\t * @notice Lock pool so that no direct deposits/withdrawals can\n\t * be performed.\n\t */\n\tfunction _lockPool() private {\n\t\tisLocked = true;\n\t\temit PoolLocked();\n\t}\n\n\tfunction unlockPool() external onlyOwnerNodeOperator {\n\t\trequire(renToken.balanceOf(address(this)) > 0, \"Pool balance is zero\");\n\t\tisLocked = false;\n\t\temit PoolUnlocked();\n\t}\n\n\t/**\n\t * @notice Deposit REN into the RenPool contract. Before depositing,\n\t * the transfer must be approved in the REN contract. In case the\n\t * predefined bond is reached, the pool is locked preventing any\n\t * further deposits or withdrawals.\n\t *\n\t * @param _amount The amount of REN to be deposited into the pool.\n\t */\n\tfunction deposit(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\n\t\trequire(!isLocked, \"RenPool: Pool is locked\");\n\t\trequire(_amount > 0, \"RenPool: Invalid amount\");\n\t\trequire(_amount + totalPooled <= bond, \"RenPool: Amount surpasses bond\");\n\n\t\tbalances[sender] += _amount;\n\t\ttotalPooled += _amount;\n\n\t\temit RenDeposited(sender, _amount);\n\n\t\tif (totalPooled == bond) {\n\t\t\t_lockPool();\n\t\t}\n\n\t\trequire(renToken.transferFrom(sender, address(this), _amount), \"RenPool: Deposit failed\");\n\t}\n\n\t/**\n\t * @notice Withdraw REN tokens while the pool is still open.\n\t */\n\tfunction withdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(!isLocked, \"Pool is locked\");\n\n\t\ttotalPooled -= _amount;\n\t\tbalances[sender] -= _amount;\n\n\t\trequire(\n\t\t\trenToken.transfer(sender, _amount),\n\t\t\t\"Withdraw failed\"\n\t\t);\n\n\t\temit RenWithdrawn(sender, _amount);\n\t}\n\n\t/**\n\t * TODO\n\t * @dev Users can have up to a single request active. In case of several\n\t * calls to this method, only the last request will be preserved.\n\t */\n\tfunction requestWithdraw(uint256 _amount) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 senderBalance = balances[sender];\n\n\t\trequire(senderBalance > 0 && senderBalance >= _amount, \"Insufficient funds\");\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\twithdrawRequests[sender] = _amount;\n\n\t\t// TODO emit event\n\t}\n\n\t/**\n\t * TODO\n\t */\n\tfunction fulfillWithdrawRequest(address _target) external {\n\t\taddress sender = msg.sender;\n\t\tuint256 amount = withdrawRequests[_target];\n\t\t// ^ This could not be defined plus make sure amount > 0\n\t\t// TODO: make sure user cannot fullfil his own request\n\t\t// TODO: add test for when _target doesn't have an associated withdrawRequest\n\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\tbalances[sender] += amount;\n\t\tbalances[_target] -= amount;\n\t\tdelete withdrawRequests[_target];\n\n\t\t// Transfer funds from sender to _target\n\t\trequire(\n\t\t\trenToken.transferFrom(sender, address(this), amount),\n\t\t\t\"Deposit failed\"\n\t\t);\n\t\trequire(\n\t\t\trenToken.transfer(_target, amount),\n\t\t\t\"Refund failed\"\n\t\t);\n\n\t\t// TODO emit event\n\t}\n\n\t// TODO: cancelWithdrawRequest\n\t// TODO: getWithdrawRequests\n\n\t/**\n\t * @notice Return REN balance for the given address.\n\t *\n\t * @param _target Address to be queried.\n\t */\n\tfunction balanceOf(address _target) external view returns(uint) {\n\t\treturn balances[_target];\n\t}\n\n\t/**\n\t * @notice Transfer bond to the darknodeRegistry contract prior to\n\t * registering the darknode.\n\t */\n\tfunction approveBondTransfer() external onlyNodeOperator {\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\trequire(\n\t\t\trenToken.approve(address(darknodeRegistry), bond),\n\t\t\t\"Bond transfer failed\"\n\t\t);\n\t}\n\n\t/**\n\t * @notice Register a darknode and transfer the bond to the darknodeRegistry\n\t * contract. Before registering, the bond transfer must be approved in the\n\t * darknodeRegistry contract (see approveTransferBond). The caller must\n\t * provide a public encryption key for the darknode. The darknode will remain\n\t * pending registration until the next epoch. Only after this period can the\n\t * darknode be deregistered. The caller of this method will be stored as the\n\t * owner of the darknode.\n\t *\n\t * @param _darknodeID The darknode ID that will be registered.\n\t * @param _publicKey The public key of the darknode. It is stored to allow\n\t * other darknodes and traders to encrypt messages to the trader.\n\t */\n\tfunction registerDarknode(address _darknodeID, bytes calldata _publicKey) external onlyNodeOperator {\n\t\trequire(isLocked, \"Pool is not locked\");\n\n\t\tdarknodeRegistry.register(_darknodeID, _publicKey);\n\n\t\tdarknodeID = _darknodeID;\n\t\tpublicKey = _publicKey;\n\t}\n\n\t/**\n\t * @notice Deregister a darknode. The darknode will not be deregistered\n\t * until the end of the epoch. After another epoch, the bond can be\n\t * refunded by calling the refund method.\n\t *\n\t * @dev We don't reset darknodeID/publicKey values after deregistration in order\n\t * to being able to call refund.\n\t */\n\tfunction deregisterDarknode() external onlyOwnerNodeOperator {\n\t\tdarknodeRegistry.deregister(darknodeID);\n\t}\n\n\t/**\n\t * @notice Refund the bond of a deregistered darknode. This will make the\n\t * darknode available for registration again. Anyone can call this function\n\t * but the bond will always be refunded to the darknode owner.\n\t *\n\t * @dev No need to reset darknodeID/publicKey values after refund.\n\t */\n\tfunction refundBond() external {\n\t\tdarknodeRegistry.refund(darknodeID);\n\t}\n\n\t/**\n\t * @notice Allow ETH deposits in case gas is necessary to pay for transactions.\n\t */\n\treceive() external payable {\n\t\temit EthDeposited(msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @notice Allow node operator to withdraw any remaining gas.\n\t */\n\tfunction withdrawGas() external onlyNodeOperator {\n\t\tuint256 balance = address(this).balance;\n\t\tpayable(nodeOperator).transfer(balance);\n\t\temit EthWithdrawn(nodeOperator, balance);\n\t}\n\n\t/**\n\t * @notice Transfer rewards from darknode to darknode owner prior to calling claimDarknodeRewards.\n\t *\n\t * @param _tokens List of tokens to transfer. (here we could have a list with all available tokens)\n\t */\n\tfunction transferRewardsToDarknodeOwner(address[] calldata _tokens) external {\n\t\tdarknodePayment.withdrawMultiple(address(this), _tokens);\n\t}\n\n\t/**\n\t * @notice Claim darknode rewards.\n\t *\n\t * @param _assetSymbol The asset being claimed. e.g. \"BTC\" or \"DOGE\".\n\t * @param _amount The amount of the token being minted, in its smallest\n\t * denomination (e.g. satoshis for BTC).\n\t * @param _recipientAddress The Ethereum address to which the assets are\n\t * being withdrawn to. This same address must then call `mint` on\n\t * the asset's Ren Gateway contract.\n\t */\n\tfunction claimDarknodeRewards(\n\t\tstring memory _assetSymbol,\n\t\tuint256 _amount, // avoid this param, read from user balance instead. What about airdrops?\n\t\taddress _recipientAddress\n\t)\n\t\texternal\n\t\treturns(uint256, uint256)\n\t{\n\t\t// TODO: check that sender has the amount to be claimed\n\t\tuint256 fractionInBps = 10_000; // TODO: this should be the share of the user for the given token\n\t\tuint256 sig = claimRewards.claimRewardsToEthereum(_assetSymbol, _recipientAddress, fractionInBps);\n\t\tnonce += 1;\n\n\t\treturn (sig, nonce);\n\t\t// bytes32 pHash = keccak256(abi.encode(_assetSymbol, _recipientAddress));\n\t\t// bytes32 nHash = keccak256(abi.encode(nonce, _amount, pHash));\n\n\t\t// gateway.mint(pHash, _amount, nHash, sig);\n\n\t\t/*\n                    const nHash = randomBytes(32);\n                    const pHash = randomBytes(32);\n\n                    const hash = await gateway.hashForSignature.call(\n                        pHash,\n                        value,\n                        user,\n                        nHash\n                    );\n                    const sig = ecsign(\n                        Buffer.from(hash.slice(2), \"hex\"),\n                        privKey\n                    );\n\t\t\t\t\t\t\t\t\t\tSee: https://github.com/renproject/gateway-sol/blob/7bd51d8a897952a31134875d7b2b621e4542deaa/test/Gateway.ts\n\t\t*/\n\t}\n}\n", "commit_id": "762b892c9a556bb1db7feb4916676713c36038be"}}