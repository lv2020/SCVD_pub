{"filename": "contracts/ShareholderAgreement.sol", "patch": "@@ -177,8 +177,6 @@ contract ShareholderAgreement {\n \t\tuint amountOwed = amountOfDividendOwed(msg.sender);\n \t\tif(amountOwed == 0) return false;\n \t\t\n-\t\tmsg.sender.transfer(amountOwed);\n-\n \t\tfor (uint index = 0; index < shareholderCheckpoints[msg.sender].length; index++) {\n \t\t\tif(\n \t\t\t\tshareholderCheckpoints[msg.sender][index].paid == false && shareholderCheckpoints[msg.sender][index].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n@@ -197,6 +195,7 @@ contract ShareholderAgreement {\n \t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n \n \t\t// TODO make a new checkpoint\n+\t\tmsg.sender.transfer(amountOwed);\t\t\n \t\tDividendPaid(msg.sender, amountOwed);\n \t\treturn true;\n \t}", "project_link": "https://github.com/bradleat/dividend-splitting-contract/commit/87baeff8e82161b37a36f131ee1aa8f7f5dfec4e", "bug_version": {"raw_code": "pragma solidity ^0.4.11;\n\n\ncontract ShareholderAgreement {\n\n\tstruct Vote {\n\t\tuint numNewShares;\n\t\tuint salePriceWei;\n\t\tuint votesFor;\n\t\taddress proposedBy;\n\t\tbool finished;\n\t\taddress walletForFundraising;\n\t\tuint sharesSold;\n\t}\n\n\tstruct ShareholderCheckpoint {\n\t\tuint atTreasuryCheckpointIndex;\n\t\tuint shares;\n\t\tbool voting;\n\t\tbool paid;\n\t}\n\n\tstruct TreasuryCheckpoint {\n\t\tuint profits;\n\t\tuint totalSharesOutstanding;\n\t}\n\n\t// checkpoint of profits and shares outstanding\n\tTreasuryCheckpoint[] public treasuryCheckpoints;\n\n\tVote[] public votes;\n\n\tmapping (address => uint) public shareholderVotingFor;\n\n\t// checkpoints of balances for shareholders\n\tmapping (address => ShareholderCheckpoint[]) public shareholderCheckpoints;\n\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent DividendPaid(address indexed to, uint value);\n\tevent ProfitsAdded(uint value);\n\tevent NewProposal(uint indexed proposalIndex, address indexed proposedBy);\n\tevent ProposalPassed(uint indexed proposalIndex, address indexed proposedBy);\n\tevent SharesIssued(uint indexed proposalIndex, uint indexed numNewShares, address indexed proposedBy);\n\n\tfunction ShareholderAgreement(\n\t\tuint _totalShares\n\t) {\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: _totalShares\n\t\t}));\n\n\t\tshareholderCheckpoints[msg.sender].push(ShareholderCheckpoint({\n\t\t\tatTreasuryCheckpointIndex: 0,\n\t\t\tshares: _totalShares,\n\t\t\tpaid: false,\n\t\t\tvoting: false\n\t\t}));\n\t\t// push an initial vote that represents a safe null-vote to set for `shareholderVotingFor` (index of 0)\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _totalShares,\n\t\t\tsalePriceWei: 0,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: true,\n\t\t\twalletForFundraising: 0x0,\n\t\t\tsharesSold: _totalShares\n\t\t}));\n\n\t}\n\n\tfunction transfer(address _receiver, uint _amount) returns(bool sufficient) {\n\t\tif(shareholderCheckpoints[msg.sender].length == 0) return false;\n\n\t\tuint senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\t\tuint receiverCheckpointIndex;\n\t\tif(shareholderCheckpoints[_receiver].length != 0) {\n\t\t\treceiverCheckpointIndex = shareholderCheckpoints[_receiver].length - 1;\n\t\t}\n\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares < _amount) return false;\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].voting == true) return false;\n\t\tif(shareholderCheckpoints[_receiver].length != 0){\n\t\t\tif (shareholderCheckpoints[_receiver][receiverCheckpointIndex].voting == true) return false;\n\t\t}\n\n\t\t// make a new checkpoint if the shareholder's checkpoint is older than the atTreasuryCheckpointIndex\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t\t++senderCheckpointIndex;\n\t\t}\n\n\t\t// make sure the reciever has an available checkpoint that is not older than the atTreasuryCheckpointIndex\n\t\tif (shareholderCheckpoints[_receiver].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: 0,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\treceiverCheckpointIndex = 0;\n\t\t}\n\t\telse if (shareholderCheckpoints[_receiver][receiverCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length -1,\n\t\t\t\tshares: shareholderCheckpoints[_receiver][receiverCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\t++receiverCheckpointIndex;\n\t\t}\n\n\t\t\n\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares -= _amount;\n\t\tshareholderCheckpoints[_receiver][receiverCheckpointIndex].shares += _amount;\n\t\tTransfer(msg.sender, _receiver, _amount);\n\t\treturn true;\n\t}\n\n\n\tfunction getSharesFor(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\t\t\n\t\tuint accountCheckpointIndex = shareholderCheckpoints[_account].length - 1;\n\n\t\treturn shareholderCheckpoints[_account][accountCheckpointIndex].shares;\n\t}\n\n\tfunction amountOfDividendOwed(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\n\t\tvar checkpoints = shareholderCheckpoints[_account];\n\t\t/*\n\t\t\twe need to see if the shareholder has any shares in\n\t\t\tblocks between (& incl.) `nextShareholderIndex` and  (& not incl.) `treasuryCheckpoints.length -1`\n\t\t*/\n\t\tuint amountOwed = 0;\n\t\tfor (uint index = 0; index < checkpoints.length; index++) {\n\t\t\tvar checkpoint = checkpoints[index];\n\t\t\tif(\n\t\t\t\tcheckpoint.paid == false && checkpoint.atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tvar indexOfLatestCheckpoint = treasuryCheckpoints.length - 1; // pay until last index avail\n\t\t\t\tif(checkpoints.length - 1 > index){ // if there is a checkpoint after this one\n\t\t\t\t\tindexOfLatestCheckpoint = checkpoints[index + 1].atTreasuryCheckpointIndex; // then pay until the next checkpoint\n\t\t\t\t}\n\n\t\t\t\t// has to loop through the to make sure it account for totalSharesOutstanding\n\t\t\t\tfor (uint i = checkpoint.atTreasuryCheckpointIndex; i < indexOfLatestCheckpoint; i++){\n\t\t\t\t\tamountOwed += checkpoint.shares * treasuryCheckpoints[i + 1].profits / treasuryCheckpoints[i + 1].totalSharesOutstanding;\n\t\t\t\t}\n\t\t\t\t// amountOwed += (\n\t\t\t\t// \tcheckpoint.shares * treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].profits \n\t\t\t\t// \t/ treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].totalSharesOutstanding);\n\t\t\t\t// calculate amount owed\n\t\t\t}\n\t\t}\n\n\t\treturn amountOwed;\n\t\t// look at the current treasury checkpoint \n\n\t}\n\n\tfunction payoutDividendOwed() returns (bool) {\n\t\tuint amountOwed = amountOfDividendOwed(msg.sender);\n\t\tif(amountOwed == 0) return false;\n\t\t\n\t\tmsg.sender.transfer(amountOwed);\n\n\t\tfor (uint index = 0; index < shareholderCheckpoints[msg.sender].length; index++) {\n\t\t\tif(\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid == false && shareholderCheckpoints[msg.sender][index].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid = true;\n\t\t\t}\n\t\t}\n\n\t\tvar newCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t// TODO make a new checkpoint\n\t\tDividendPaid(msg.sender, amountOwed);\n\t\treturn true;\n\t}\n\n\tfunction () payable {\n\t\t// we set a min amount so that low value transactions cannot create extra check points needlessly\n\t\trequire(msg.value >= 500 finney);\n\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: msg.value,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\t// we issue two checkpoints so that the second checkpoint may be used for issuing new shares\n\t\t// in the buyShares function without changing the amount of profits owed\n\t\t// could prob do this somewhere else as where (like before issuing shares, make sure the last checkpoint had no profits)\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\tProfitsAdded(msg.value);\n\t\t// todo call event\n\t}\n\n\tfunction proposeVote (uint _numNewShares, uint _salePriceWei, address _walletForFundraising) returns (bool) {\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _numNewShares,\n\t\t\tsalePriceWei: _salePriceWei,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: false,\n\t\t\twalletForFundraising: _walletForFundraising,\n\t\t\tsharesSold: 0\n\t\t}));\n\t\tNewProposal(votes.length - 1, msg.sender);\n\t\treturn true;\n\t}\n\n\tfunction vote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tvotes[_proposalIndex].finished == false &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == false\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = true;\n\t\t\tvotes[_proposalIndex].votesFor += shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\tshareholderVotingFor[msg.sender] = _proposalIndex;\n\t\t\t// see if vote is finished here\n\t\t\tif ((votes[_proposalIndex].votesFor * 100) / treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding > 51){\n\t\t\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\t\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\t\t\tprofits: 0,\n\t\t\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t\t\t}));\n\t\t\t\tvotes[_proposalIndex].finished = true;\n\t\t\t\tProposalPassed(_proposalIndex, votes[_proposalIndex].proposedBy);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfunction unvote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tshareholderVotingFor[msg.sender] == _proposalIndex &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == true\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = false;\n\t\t\tif(votes[_proposalIndex].finished == false){\n\t\t\t\tvotes[_proposalIndex].votesFor -= shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\t\tshareholderVotingFor[msg.sender] = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction buyShares(uint _proposalIndex, uint _numShares) payable returns (bool) {\n\n\t\trequire(msg.value == votes[_proposalIndex].salePriceWei * _numShares);\n\t\trequire(votes[_proposalIndex].numNewShares - votes[_proposalIndex].sharesSold >= _numShares);\n\n\t\tvar senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif(shareholderCheckpoints[msg.sender].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t}\n\t\telse if(shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\t\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares + _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t}\n\t\telse {\n\t\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares += _numShares;\n\t\t}\n\t\t\n\t\tvotes[_proposalIndex].sharesSold += _numShares;\n\t\ttreasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding += _numShares;\n\n\t\tvotes[_proposalIndex].walletForFundraising.transfer(msg.value);\n\t\tSharesIssued(_proposalIndex, _numShares, votes[_proposalIndex].proposedBy);\n\t\treturn true;\n\n\t}\n\n}\n", "flattened_code": "pragma solidity ^0.4.11;\n\n\ncontract ShareholderAgreement {\n\n\tstruct Vote {\n\t\tuint numNewShares;\n\t\tuint salePriceWei;\n\t\tuint votesFor;\n\t\taddress proposedBy;\n\t\tbool finished;\n\t\taddress walletForFundraising;\n\t\tuint sharesSold;\n\t}\n\n\tstruct ShareholderCheckpoint {\n\t\tuint atTreasuryCheckpointIndex;\n\t\tuint shares;\n\t\tbool voting;\n\t\tbool paid;\n\t}\n\n\tstruct TreasuryCheckpoint {\n\t\tuint profits;\n\t\tuint totalSharesOutstanding;\n\t}\n\n\t// checkpoint of profits and shares outstanding\n\tTreasuryCheckpoint[] public treasuryCheckpoints;\n\n\tVote[] public votes;\n\n\tmapping (address => uint) public shareholderVotingFor;\n\n\t// checkpoints of balances for shareholders\n\tmapping (address => ShareholderCheckpoint[]) public shareholderCheckpoints;\n\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent DividendPaid(address indexed to, uint value);\n\tevent ProfitsAdded(uint value);\n\tevent NewProposal(uint indexed proposalIndex, address indexed proposedBy);\n\tevent ProposalPassed(uint indexed proposalIndex, address indexed proposedBy);\n\tevent SharesIssued(uint indexed proposalIndex, uint indexed numNewShares, address indexed proposedBy);\n\n\tfunction ShareholderAgreement(\n\t\tuint _totalShares\n\t) {\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: _totalShares\n\t\t}));\n\n\t\tshareholderCheckpoints[msg.sender].push(ShareholderCheckpoint({\n\t\t\tatTreasuryCheckpointIndex: 0,\n\t\t\tshares: _totalShares,\n\t\t\tpaid: false,\n\t\t\tvoting: false\n\t\t}));\n\t\t// push an initial vote that represents a safe null-vote to set for `shareholderVotingFor` (index of 0)\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _totalShares,\n\t\t\tsalePriceWei: 0,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: true,\n\t\t\twalletForFundraising: 0x0,\n\t\t\tsharesSold: _totalShares\n\t\t}));\n\n\t}\n\n\tfunction transfer(address _receiver, uint _amount) returns(bool sufficient) {\n\t\tif(shareholderCheckpoints[msg.sender].length == 0) return false;\n\n\t\tuint senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\t\tuint receiverCheckpointIndex;\n\t\tif(shareholderCheckpoints[_receiver].length != 0) {\n\t\t\treceiverCheckpointIndex = shareholderCheckpoints[_receiver].length - 1;\n\t\t}\n\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares < _amount) return false;\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].voting == true) return false;\n\t\tif(shareholderCheckpoints[_receiver].length != 0){\n\t\t\tif (shareholderCheckpoints[_receiver][receiverCheckpointIndex].voting == true) return false;\n\t\t}\n\n\t\t// make a new checkpoint if the shareholder's checkpoint is older than the atTreasuryCheckpointIndex\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t\t++senderCheckpointIndex;\n\t\t}\n\n\t\t// make sure the reciever has an available checkpoint that is not older than the atTreasuryCheckpointIndex\n\t\tif (shareholderCheckpoints[_receiver].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: 0,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\treceiverCheckpointIndex = 0;\n\t\t}\n\t\telse if (shareholderCheckpoints[_receiver][receiverCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length -1,\n\t\t\t\tshares: shareholderCheckpoints[_receiver][receiverCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\t++receiverCheckpointIndex;\n\t\t}\n\n\t\t\n\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares -= _amount;\n\t\tshareholderCheckpoints[_receiver][receiverCheckpointIndex].shares += _amount;\n\t\tTransfer(msg.sender, _receiver, _amount);\n\t\treturn true;\n\t}\n\n\n\tfunction getSharesFor(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\t\t\n\t\tuint accountCheckpointIndex = shareholderCheckpoints[_account].length - 1;\n\n\t\treturn shareholderCheckpoints[_account][accountCheckpointIndex].shares;\n\t}\n\n\tfunction amountOfDividendOwed(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\n\t\tvar checkpoints = shareholderCheckpoints[_account];\n\t\t/*\n\t\t\twe need to see if the shareholder has any shares in\n\t\t\tblocks between (& incl.) `nextShareholderIndex` and  (& not incl.) `treasuryCheckpoints.length -1`\n\t\t*/\n\t\tuint amountOwed = 0;\n\t\tfor (uint index = 0; index < checkpoints.length; index++) {\n\t\t\tvar checkpoint = checkpoints[index];\n\t\t\tif(\n\t\t\t\tcheckpoint.paid == false && checkpoint.atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tvar indexOfLatestCheckpoint = treasuryCheckpoints.length - 1; // pay until last index avail\n\t\t\t\tif(checkpoints.length - 1 > index){ // if there is a checkpoint after this one\n\t\t\t\t\tindexOfLatestCheckpoint = checkpoints[index + 1].atTreasuryCheckpointIndex; // then pay until the next checkpoint\n\t\t\t\t}\n\n\t\t\t\t// has to loop through the to make sure it account for totalSharesOutstanding\n\t\t\t\tfor (uint i = checkpoint.atTreasuryCheckpointIndex; i < indexOfLatestCheckpoint; i++){\n\t\t\t\t\tamountOwed += checkpoint.shares * treasuryCheckpoints[i + 1].profits / treasuryCheckpoints[i + 1].totalSharesOutstanding;\n\t\t\t\t}\n\t\t\t\t// amountOwed += (\n\t\t\t\t// \tcheckpoint.shares * treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].profits \n\t\t\t\t// \t/ treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].totalSharesOutstanding);\n\t\t\t\t// calculate amount owed\n\t\t\t}\n\t\t}\n\n\t\treturn amountOwed;\n\t\t// look at the current treasury checkpoint \n\n\t}\n\n\tfunction payoutDividendOwed() returns (bool) {\n\t\tuint amountOwed = amountOfDividendOwed(msg.sender);\n\t\tif(amountOwed == 0) return false;\n\t\t\n\t\tmsg.sender.transfer(amountOwed);\n\n\t\tfor (uint index = 0; index < shareholderCheckpoints[msg.sender].length; index++) {\n\t\t\tif(\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid == false && shareholderCheckpoints[msg.sender][index].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid = true;\n\t\t\t}\n\t\t}\n\n\t\tvar newCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t// TODO make a new checkpoint\n\t\tDividendPaid(msg.sender, amountOwed);\n\t\treturn true;\n\t}\n\n\tfunction () payable {\n\t\t// we set a min amount so that low value transactions cannot create extra check points needlessly\n\t\trequire(msg.value >= 500 finney);\n\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: msg.value,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\t// we issue two checkpoints so that the second checkpoint may be used for issuing new shares\n\t\t// in the buyShares function without changing the amount of profits owed\n\t\t// could prob do this somewhere else as where (like before issuing shares, make sure the last checkpoint had no profits)\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\tProfitsAdded(msg.value);\n\t\t// todo call event\n\t}\n\n\tfunction proposeVote (uint _numNewShares, uint _salePriceWei, address _walletForFundraising) returns (bool) {\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _numNewShares,\n\t\t\tsalePriceWei: _salePriceWei,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: false,\n\t\t\twalletForFundraising: _walletForFundraising,\n\t\t\tsharesSold: 0\n\t\t}));\n\t\tNewProposal(votes.length - 1, msg.sender);\n\t\treturn true;\n\t}\n\n\tfunction vote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tvotes[_proposalIndex].finished == false &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == false\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = true;\n\t\t\tvotes[_proposalIndex].votesFor += shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\tshareholderVotingFor[msg.sender] = _proposalIndex;\n\t\t\t// see if vote is finished here\n\t\t\tif ((votes[_proposalIndex].votesFor * 100) / treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding > 51){\n\t\t\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\t\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\t\t\tprofits: 0,\n\t\t\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t\t\t}));\n\t\t\t\tvotes[_proposalIndex].finished = true;\n\t\t\t\tProposalPassed(_proposalIndex, votes[_proposalIndex].proposedBy);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfunction unvote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tshareholderVotingFor[msg.sender] == _proposalIndex &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == true\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = false;\n\t\t\tif(votes[_proposalIndex].finished == false){\n\t\t\t\tvotes[_proposalIndex].votesFor -= shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\t\tshareholderVotingFor[msg.sender] = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction buyShares(uint _proposalIndex, uint _numShares) payable returns (bool) {\n\n\t\trequire(msg.value == votes[_proposalIndex].salePriceWei * _numShares);\n\t\trequire(votes[_proposalIndex].numNewShares - votes[_proposalIndex].sharesSold >= _numShares);\n\n\t\tvar senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif(shareholderCheckpoints[msg.sender].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t}\n\t\telse if(shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\t\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares + _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t}\n\t\telse {\n\t\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares += _numShares;\n\t\t}\n\t\t\n\t\tvotes[_proposalIndex].sharesSold += _numShares;\n\t\ttreasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding += _numShares;\n\n\t\tvotes[_proposalIndex].walletForFundraising.transfer(msg.value);\n\t\tSharesIssued(_proposalIndex, _numShares, votes[_proposalIndex].proposedBy);\n\t\treturn true;\n\n\t}\n\n}\n", "commit_id": "2a7b7cb8400ac7ffa2644b9cc68e8545bbc74343"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.11;\n\n\ncontract ShareholderAgreement {\n\n\tstruct Vote {\n\t\tuint numNewShares;\n\t\tuint salePriceWei;\n\t\tuint votesFor;\n\t\taddress proposedBy;\n\t\tbool finished;\n\t\taddress walletForFundraising;\n\t\tuint sharesSold;\n\t}\n\n\tstruct ShareholderCheckpoint {\n\t\tuint atTreasuryCheckpointIndex;\n\t\tuint shares;\n\t\tbool voting;\n\t\tbool paid;\n\t}\n\n\tstruct TreasuryCheckpoint {\n\t\tuint profits;\n\t\tuint totalSharesOutstanding;\n\t}\n\n\t// checkpoint of profits and shares outstanding\n\tTreasuryCheckpoint[] public treasuryCheckpoints;\n\n\tVote[] public votes;\n\n\tmapping (address => uint) public shareholderVotingFor;\n\n\t// checkpoints of balances for shareholders\n\tmapping (address => ShareholderCheckpoint[]) public shareholderCheckpoints;\n\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent DividendPaid(address indexed to, uint value);\n\tevent ProfitsAdded(uint value);\n\tevent NewProposal(uint indexed proposalIndex, address indexed proposedBy);\n\tevent ProposalPassed(uint indexed proposalIndex, address indexed proposedBy);\n\tevent SharesIssued(uint indexed proposalIndex, uint indexed numNewShares, address indexed proposedBy);\n\n\tfunction ShareholderAgreement(\n\t\tuint _totalShares\n\t) {\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: _totalShares\n\t\t}));\n\n\t\tshareholderCheckpoints[msg.sender].push(ShareholderCheckpoint({\n\t\t\tatTreasuryCheckpointIndex: 0,\n\t\t\tshares: _totalShares,\n\t\t\tpaid: false,\n\t\t\tvoting: false\n\t\t}));\n\t\t// push an initial vote that represents a safe null-vote to set for `shareholderVotingFor` (index of 0)\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _totalShares,\n\t\t\tsalePriceWei: 0,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: true,\n\t\t\twalletForFundraising: 0x0,\n\t\t\tsharesSold: _totalShares\n\t\t}));\n\n\t}\n\n\tfunction transfer(address _receiver, uint _amount) returns(bool sufficient) {\n\t\tif(shareholderCheckpoints[msg.sender].length == 0) return false;\n\n\t\tuint senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\t\tuint receiverCheckpointIndex;\n\t\tif(shareholderCheckpoints[_receiver].length != 0) {\n\t\t\treceiverCheckpointIndex = shareholderCheckpoints[_receiver].length - 1;\n\t\t}\n\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares < _amount) return false;\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].voting == true) return false;\n\t\tif(shareholderCheckpoints[_receiver].length != 0){\n\t\t\tif (shareholderCheckpoints[_receiver][receiverCheckpointIndex].voting == true) return false;\n\t\t}\n\n\t\t// make a new checkpoint if the shareholder's checkpoint is older than the atTreasuryCheckpointIndex\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t\t++senderCheckpointIndex;\n\t\t}\n\n\t\t// make sure the reciever has an available checkpoint that is not older than the atTreasuryCheckpointIndex\n\t\tif (shareholderCheckpoints[_receiver].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: 0,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\treceiverCheckpointIndex = 0;\n\t\t}\n\t\telse if (shareholderCheckpoints[_receiver][receiverCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length -1,\n\t\t\t\tshares: shareholderCheckpoints[_receiver][receiverCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\t++receiverCheckpointIndex;\n\t\t}\n\n\t\t\n\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares -= _amount;\n\t\tshareholderCheckpoints[_receiver][receiverCheckpointIndex].shares += _amount;\n\t\tTransfer(msg.sender, _receiver, _amount);\n\t\treturn true;\n\t}\n\n\n\tfunction getSharesFor(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\t\t\n\t\tuint accountCheckpointIndex = shareholderCheckpoints[_account].length - 1;\n\n\t\treturn shareholderCheckpoints[_account][accountCheckpointIndex].shares;\n\t}\n\n\tfunction amountOfDividendOwed(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\n\t\tvar checkpoints = shareholderCheckpoints[_account];\n\t\t/*\n\t\t\twe need to see if the shareholder has any shares in\n\t\t\tblocks between (& incl.) `nextShareholderIndex` and  (& not incl.) `treasuryCheckpoints.length -1`\n\t\t*/\n\t\tuint amountOwed = 0;\n\t\tfor (uint index = 0; index < checkpoints.length; index++) {\n\t\t\tvar checkpoint = checkpoints[index];\n\t\t\tif(\n\t\t\t\tcheckpoint.paid == false && checkpoint.atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tvar indexOfLatestCheckpoint = treasuryCheckpoints.length - 1; // pay until last index avail\n\t\t\t\tif(checkpoints.length - 1 > index){ // if there is a checkpoint after this one\n\t\t\t\t\tindexOfLatestCheckpoint = checkpoints[index + 1].atTreasuryCheckpointIndex; // then pay until the next checkpoint\n\t\t\t\t}\n\n\t\t\t\t// has to loop through the to make sure it account for totalSharesOutstanding\n\t\t\t\tfor (uint i = checkpoint.atTreasuryCheckpointIndex; i < indexOfLatestCheckpoint; i++){\n\t\t\t\t\tamountOwed += checkpoint.shares * treasuryCheckpoints[i + 1].profits / treasuryCheckpoints[i + 1].totalSharesOutstanding;\n\t\t\t\t}\n\t\t\t\t// amountOwed += (\n\t\t\t\t// \tcheckpoint.shares * treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].profits \n\t\t\t\t// \t/ treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].totalSharesOutstanding);\n\t\t\t\t// calculate amount owed\n\t\t\t}\n\t\t}\n\n\t\treturn amountOwed;\n\t\t// look at the current treasury checkpoint \n\n\t}\n\n\tfunction payoutDividendOwed() returns (bool) {\n\t\tuint amountOwed = amountOfDividendOwed(msg.sender);\n\t\tif(amountOwed == 0) return false;\n\t\t\n\t\tfor (uint index = 0; index < shareholderCheckpoints[msg.sender].length; index++) {\n\t\t\tif(\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid == false && shareholderCheckpoints[msg.sender][index].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid = true;\n\t\t\t}\n\t\t}\n\n\t\tvar newCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t// TODO make a new checkpoint\n\t\tmsg.sender.transfer(amountOwed);\t\t\n\t\tDividendPaid(msg.sender, amountOwed);\n\t\treturn true;\n\t}\n\n\tfunction () payable {\n\t\t// we set a min amount so that low value transactions cannot create extra check points needlessly\n\t\trequire(msg.value >= 500 finney);\n\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: msg.value,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\t// we issue two checkpoints so that the second checkpoint may be used for issuing new shares\n\t\t// in the buyShares function without changing the amount of profits owed\n\t\t// could prob do this somewhere else as where (like before issuing shares, make sure the last checkpoint had no profits)\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\tProfitsAdded(msg.value);\n\t\t// todo call event\n\t}\n\n\tfunction proposeVote (uint _numNewShares, uint _salePriceWei, address _walletForFundraising) returns (bool) {\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _numNewShares,\n\t\t\tsalePriceWei: _salePriceWei,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: false,\n\t\t\twalletForFundraising: _walletForFundraising,\n\t\t\tsharesSold: 0\n\t\t}));\n\t\tNewProposal(votes.length - 1, msg.sender);\n\t\treturn true;\n\t}\n\n\tfunction vote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tvotes[_proposalIndex].finished == false &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == false\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = true;\n\t\t\tvotes[_proposalIndex].votesFor += shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\tshareholderVotingFor[msg.sender] = _proposalIndex;\n\t\t\t// see if vote is finished here\n\t\t\tif ((votes[_proposalIndex].votesFor * 100) / treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding > 51){\n\t\t\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\t\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\t\t\tprofits: 0,\n\t\t\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t\t\t}));\n\t\t\t\tvotes[_proposalIndex].finished = true;\n\t\t\t\tProposalPassed(_proposalIndex, votes[_proposalIndex].proposedBy);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfunction unvote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tshareholderVotingFor[msg.sender] == _proposalIndex &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == true\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = false;\n\t\t\tif(votes[_proposalIndex].finished == false){\n\t\t\t\tvotes[_proposalIndex].votesFor -= shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\t\tshareholderVotingFor[msg.sender] = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction buyShares(uint _proposalIndex, uint _numShares) payable returns (bool) {\n\n\t\trequire(msg.value == votes[_proposalIndex].salePriceWei * _numShares);\n\t\trequire(votes[_proposalIndex].numNewShares - votes[_proposalIndex].sharesSold >= _numShares);\n\n\t\tvar senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif(shareholderCheckpoints[msg.sender].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t}\n\t\telse if(shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\t\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares + _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t}\n\t\telse {\n\t\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares += _numShares;\n\t\t}\n\t\t\n\t\tvotes[_proposalIndex].sharesSold += _numShares;\n\t\ttreasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding += _numShares;\n\n\t\tvotes[_proposalIndex].walletForFundraising.transfer(msg.value);\n\t\tSharesIssued(_proposalIndex, _numShares, votes[_proposalIndex].proposedBy);\n\t\treturn true;\n\n\t}\n\n}\n", "flattened_code": "pragma solidity ^0.4.11;\n\n\ncontract ShareholderAgreement {\n\n\tstruct Vote {\n\t\tuint numNewShares;\n\t\tuint salePriceWei;\n\t\tuint votesFor;\n\t\taddress proposedBy;\n\t\tbool finished;\n\t\taddress walletForFundraising;\n\t\tuint sharesSold;\n\t}\n\n\tstruct ShareholderCheckpoint {\n\t\tuint atTreasuryCheckpointIndex;\n\t\tuint shares;\n\t\tbool voting;\n\t\tbool paid;\n\t}\n\n\tstruct TreasuryCheckpoint {\n\t\tuint profits;\n\t\tuint totalSharesOutstanding;\n\t}\n\n\t// checkpoint of profits and shares outstanding\n\tTreasuryCheckpoint[] public treasuryCheckpoints;\n\n\tVote[] public votes;\n\n\tmapping (address => uint) public shareholderVotingFor;\n\n\t// checkpoints of balances for shareholders\n\tmapping (address => ShareholderCheckpoint[]) public shareholderCheckpoints;\n\n\tevent Transfer(address indexed from, address indexed to, uint value);\n\tevent DividendPaid(address indexed to, uint value);\n\tevent ProfitsAdded(uint value);\n\tevent NewProposal(uint indexed proposalIndex, address indexed proposedBy);\n\tevent ProposalPassed(uint indexed proposalIndex, address indexed proposedBy);\n\tevent SharesIssued(uint indexed proposalIndex, uint indexed numNewShares, address indexed proposedBy);\n\n\tfunction ShareholderAgreement(\n\t\tuint _totalShares\n\t) {\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: _totalShares\n\t\t}));\n\n\t\tshareholderCheckpoints[msg.sender].push(ShareholderCheckpoint({\n\t\t\tatTreasuryCheckpointIndex: 0,\n\t\t\tshares: _totalShares,\n\t\t\tpaid: false,\n\t\t\tvoting: false\n\t\t}));\n\t\t// push an initial vote that represents a safe null-vote to set for `shareholderVotingFor` (index of 0)\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _totalShares,\n\t\t\tsalePriceWei: 0,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: true,\n\t\t\twalletForFundraising: 0x0,\n\t\t\tsharesSold: _totalShares\n\t\t}));\n\n\t}\n\n\tfunction transfer(address _receiver, uint _amount) returns(bool sufficient) {\n\t\tif(shareholderCheckpoints[msg.sender].length == 0) return false;\n\n\t\tuint senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\t\tuint receiverCheckpointIndex;\n\t\tif(shareholderCheckpoints[_receiver].length != 0) {\n\t\t\treceiverCheckpointIndex = shareholderCheckpoints[_receiver].length - 1;\n\t\t}\n\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares < _amount) return false;\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].voting == true) return false;\n\t\tif(shareholderCheckpoints[_receiver].length != 0){\n\t\t\tif (shareholderCheckpoints[_receiver][receiverCheckpointIndex].voting == true) return false;\n\t\t}\n\n\t\t// make a new checkpoint if the shareholder's checkpoint is older than the atTreasuryCheckpointIndex\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif (shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t\t++senderCheckpointIndex;\n\t\t}\n\n\t\t// make sure the reciever has an available checkpoint that is not older than the atTreasuryCheckpointIndex\n\t\tif (shareholderCheckpoints[_receiver].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: 0,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\treceiverCheckpointIndex = 0;\n\t\t}\n\t\telse if (shareholderCheckpoints[_receiver][receiverCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length -1,\n\t\t\t\tshares: shareholderCheckpoints[_receiver][receiverCheckpointIndex].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[_receiver].push(newCheckpoint);\n\t\t\t++receiverCheckpointIndex;\n\t\t}\n\n\t\t\n\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares -= _amount;\n\t\tshareholderCheckpoints[_receiver][receiverCheckpointIndex].shares += _amount;\n\t\tTransfer(msg.sender, _receiver, _amount);\n\t\treturn true;\n\t}\n\n\n\tfunction getSharesFor(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\t\t\n\t\tuint accountCheckpointIndex = shareholderCheckpoints[_account].length - 1;\n\n\t\treturn shareholderCheckpoints[_account][accountCheckpointIndex].shares;\n\t}\n\n\tfunction amountOfDividendOwed(address _account) constant returns(uint) {\n\t\tif(shareholderCheckpoints[_account].length == 0) return 0;\n\n\t\tvar checkpoints = shareholderCheckpoints[_account];\n\t\t/*\n\t\t\twe need to see if the shareholder has any shares in\n\t\t\tblocks between (& incl.) `nextShareholderIndex` and  (& not incl.) `treasuryCheckpoints.length -1`\n\t\t*/\n\t\tuint amountOwed = 0;\n\t\tfor (uint index = 0; index < checkpoints.length; index++) {\n\t\t\tvar checkpoint = checkpoints[index];\n\t\t\tif(\n\t\t\t\tcheckpoint.paid == false && checkpoint.atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tvar indexOfLatestCheckpoint = treasuryCheckpoints.length - 1; // pay until last index avail\n\t\t\t\tif(checkpoints.length - 1 > index){ // if there is a checkpoint after this one\n\t\t\t\t\tindexOfLatestCheckpoint = checkpoints[index + 1].atTreasuryCheckpointIndex; // then pay until the next checkpoint\n\t\t\t\t}\n\n\t\t\t\t// has to loop through the to make sure it account for totalSharesOutstanding\n\t\t\t\tfor (uint i = checkpoint.atTreasuryCheckpointIndex; i < indexOfLatestCheckpoint; i++){\n\t\t\t\t\tamountOwed += checkpoint.shares * treasuryCheckpoints[i + 1].profits / treasuryCheckpoints[i + 1].totalSharesOutstanding;\n\t\t\t\t}\n\t\t\t\t// amountOwed += (\n\t\t\t\t// \tcheckpoint.shares * treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].profits \n\t\t\t\t// \t/ treasuryCheckpoints[checkpoint.atTreasuryCheckpointIndex + 1].totalSharesOutstanding);\n\t\t\t\t// calculate amount owed\n\t\t\t}\n\t\t}\n\n\t\treturn amountOwed;\n\t\t// look at the current treasury checkpoint \n\n\t}\n\n\tfunction payoutDividendOwed() returns (bool) {\n\t\tuint amountOwed = amountOfDividendOwed(msg.sender);\n\t\tif(amountOwed == 0) return false;\n\t\t\n\t\tfor (uint index = 0; index < shareholderCheckpoints[msg.sender].length; index++) {\n\t\t\tif(\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid == false && shareholderCheckpoints[msg.sender][index].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1\n\t\t\t){\n\t\t\t\tshareholderCheckpoints[msg.sender][index].paid = true;\n\t\t\t}\n\t\t}\n\n\t\tvar newCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t// TODO make a new checkpoint\n\t\tmsg.sender.transfer(amountOwed);\t\t\n\t\tDividendPaid(msg.sender, amountOwed);\n\t\treturn true;\n\t}\n\n\tfunction () payable {\n\t\t// we set a min amount so that low value transactions cannot create extra check points needlessly\n\t\trequire(msg.value >= 500 finney);\n\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: msg.value,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\t// we issue two checkpoints so that the second checkpoint may be used for issuing new shares\n\t\t// in the buyShares function without changing the amount of profits owed\n\t\t// could prob do this somewhere else as where (like before issuing shares, make sure the last checkpoint had no profits)\n\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\tprofits: 0,\n\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t}));\n\t\tProfitsAdded(msg.value);\n\t\t// todo call event\n\t}\n\n\tfunction proposeVote (uint _numNewShares, uint _salePriceWei, address _walletForFundraising) returns (bool) {\n\t\tvotes.push(Vote({\n\t\t\tnumNewShares: _numNewShares,\n\t\t\tsalePriceWei: _salePriceWei,\n\t\t\tvotesFor: 0,\n\t\t\tproposedBy: msg.sender,\n\t\t\tfinished: false,\n\t\t\twalletForFundraising: _walletForFundraising,\n\t\t\tsharesSold: 0\n\t\t}));\n\t\tNewProposal(votes.length - 1, msg.sender);\n\t\treturn true;\n\t}\n\n\tfunction vote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tvotes[_proposalIndex].finished == false &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == false\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = true;\n\t\t\tvotes[_proposalIndex].votesFor += shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\tshareholderVotingFor[msg.sender] = _proposalIndex;\n\t\t\t// see if vote is finished here\n\t\t\tif ((votes[_proposalIndex].votesFor * 100) / treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding > 51){\n\t\t\t\tuint totalSharesOutstanding = treasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding;\n\t\t\t\ttreasuryCheckpoints.push(TreasuryCheckpoint({\n\t\t\t\t\tprofits: 0,\n\t\t\t\t\ttotalSharesOutstanding: totalSharesOutstanding\n\t\t\t\t}));\n\t\t\t\tvotes[_proposalIndex].finished = true;\n\t\t\t\tProposalPassed(_proposalIndex, votes[_proposalIndex].proposedBy);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfunction unvote(uint _proposalIndex) returns (bool) {\n\t\tif(\n\t\t\tshareholderVotingFor[msg.sender] == _proposalIndex &&\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting == true\n\t\t){\n\t\t\tshareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].voting = false;\n\t\t\tif(votes[_proposalIndex].finished == false){\n\t\t\t\tvotes[_proposalIndex].votesFor -= shareholderCheckpoints[msg.sender][shareholderCheckpoints[msg.sender].length - 1].shares;\n\t\t\t\tshareholderVotingFor[msg.sender] = 0;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction buyShares(uint _proposalIndex, uint _numShares) payable returns (bool) {\n\n\t\trequire(msg.value == votes[_proposalIndex].salePriceWei * _numShares);\n\t\trequire(votes[_proposalIndex].numNewShares - votes[_proposalIndex].sharesSold >= _numShares);\n\n\t\tvar senderCheckpointIndex = shareholderCheckpoints[msg.sender].length - 1;\n\n\t\tShareholderCheckpoint memory newCheckpoint; // this gets reused\n\t\tif(shareholderCheckpoints[msg.sender].length == 0){\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\n\t\t}\n\t\telse if(shareholderCheckpoints[msg.sender][senderCheckpointIndex].atTreasuryCheckpointIndex < treasuryCheckpoints.length - 1) {\n\t\t\t\n\t\t\tnewCheckpoint = ShareholderCheckpoint({\n\t\t\t\tatTreasuryCheckpointIndex: treasuryCheckpoints.length - 1,\n\t\t\t\tshares: shareholderCheckpoints[msg.sender][senderCheckpointIndex].shares + _numShares,\n\t\t\t\tpaid: false,\n\t\t\t\tvoting: false\n\t\t\t});\n\n\t\t\tshareholderCheckpoints[msg.sender].push(newCheckpoint);\n\t\t}\n\t\telse {\n\t\t\tshareholderCheckpoints[msg.sender][senderCheckpointIndex].shares += _numShares;\n\t\t}\n\t\t\n\t\tvotes[_proposalIndex].sharesSold += _numShares;\n\t\ttreasuryCheckpoints[treasuryCheckpoints.length - 1].totalSharesOutstanding += _numShares;\n\n\t\tvotes[_proposalIndex].walletForFundraising.transfer(msg.value);\n\t\tSharesIssued(_proposalIndex, _numShares, votes[_proposalIndex].proposedBy);\n\t\treturn true;\n\n\t}\n\n}\n", "commit_id": "87baeff8e82161b37a36f131ee1aa8f7f5dfec4e"}}