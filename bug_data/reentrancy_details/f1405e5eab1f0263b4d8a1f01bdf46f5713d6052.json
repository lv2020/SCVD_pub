{"filename": "contracts/SimpleAuction.sol", "patch": "@@ -159,6 +159,11 @@ contract SimpleAuction is /* AccessControl, */ MetaTxContext, ERC1155Holder {\n         address buyer = bid.buyer;\n         uint256 price = bid.price;\n \n+        // Reset the storage. Make the auction not exist anymore.\n+        bid.buyer = address(0);\n+        bid.price = 0;\n+        bid.closeTimeSec = 0;\n+\n         if (buyer != address(0)) {\n             // In case there was a buyer,\n             // transfer the payment to the seller.\n@@ -175,11 +180,6 @@ contract SimpleAuction is /* AccessControl, */ MetaTxContext, ERC1155Holder {\n             davinci.safeTransferFrom(address(this), seller, nftId, 1, \"\");\n         }\n \n-        // Reset the storage. Make the auction not exist anymore.\n-        bid.buyer = address(0);\n-        bid.price = 0;\n-        bid.closeTimeSec = 0;\n-\n         emit SettleAuction(seller, nftId, price, buyer);\n     }\n }", "project_link": "https://github.com/Cerebellum-Network/Freeport-Smart-Contracts/commit/f1405e5eab1f0263b4d8a1f01bdf46f5713d6052", "bug_version": {"raw_code": "pragma solidity ^0.8.0;\n\nimport \"./davinciParts/MetaTxContext.sol\";\nimport \"./Davinci.sol\";\nimport \"./token/ERC1155/utils/ERC1155Holder.sol\";\n\n\n/**\nAn auction is characterized by a sequence of transactions and their corresponding events:\n\n- `StartAuction`: A seller offers to sell one NFT to the highest bidder, with a minimum price, and a closing time.\n\n- Any number of `BidOnAuction`: A potential buyer accepts the minimum price or a price at least 10% higher\nthan that of the previous bidder.\nThe closing time may be extended.\nA deposit is taken from the new bidder. The deposit of the previous bidder is returned, if any.\nBidding is no longer possible after the closing time.\n\n- `SettleAuction`: The sale is completed between the seller and the highest bidder, or cancelled if there was no bidder.\nSome royalties may be taken from the sale price, as configured by the NFT creator (see `TransferFees.sol`).\nThe settlement is only possible after the closing time.\n\nWhile an auction is active, it is identified by the tuple `(seller address, NFT ID)`.\nHowever, after the auction is settled, a new auction with the *same tuple* may start.\n */\ncontract SimpleAuction is /* AccessControl, */ MetaTxContext, ERC1155Holder {\n\n    /** Supports interfaces of AccessControl and ERC1155Receiver.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public view virtual override(AccessControl, ERC1155Receiver) returns (bool) {\n        return AccessControl.supportsInterface(interfaceId)\n        || ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    Davinci public davinci;\n\n    /** This contract must have the TRANSFER_OPERATOR role in the Davinci contract.\n     */\n    constructor(Davinci _davinci) {\n        davinci = _davinci;\n    }\n\n    /** The token ID that represents the CERE currency for all payments in this contract. */\n    uint256 public constant CURRENCY = 0;\n\n    struct Bid {\n        address buyer; // 0 means no buyer yet.\n        uint256 price; // The highest bid price. The initial value is set by the seller.\n        uint256 closeTimeSec; // Bidding is open until the close time. After this time, the settlement becomes possible. A non-zero value also means that the auction exists.\n    }\n\n    /** Seller => NFT ID => Bid.\n     */\n    mapping(address => mapping(uint256 => Bid)) public sellerNftBids;\n\n    /**\n     * Note: `price` is the minimum price minus 10%, because a bid must be 10% higher, resulting in the requested minimum price.\n     */\n    event StartAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec);\n\n    /**\n     * Note: `price`, `closeTimeSec`, and `buyer` may have changed for the auction `(seller, nftId)`.\n     */\n    event BidOnAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec,\n        address buyer);\n\n    /**\n     * Note: `buyer == 0` means no buyer, and the NFT went back to the seller.\n     */\n    event SettleAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        address buyer);\n\n    /**\n     */\n    function startAuction(uint256 nftId, uint256 minPrice, uint closeTimeSec)\n    public {\n        address seller = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction does not exist.\n        require(bid.closeTimeSec == 0, \"the auction must not exist\");\n\n        // Check that the close time is non-zero and in the future.\n        require(block.timestamp < closeTimeSec, \"the close time must be in the future\");\n\n        // Deduct the minimum increment to work with the logic of minPrice in the function bid().\n        uint256 price = minPrice * 100 / 110;\n        require(price > 0, \"the starting price must be greater than 0\");\n\n        // TODO: Check that minPrice is greater than the fixed royalty, if any.\n\n        // Create the auction.\n        bid.buyer = address(0);\n        bid.price = price;\n        bid.closeTimeSec = closeTimeSec;\n\n        // Take the NFT from the seller.\n        davinci.safeTransferFrom(seller, address(this), nftId, 1, \"\");\n\n        emit StartAuction(seller, nftId, price, closeTimeSec);\n    }\n\n    /**\n     */\n    function bidOnAuction(address seller, uint256 nftId, uint256 price)\n    public {\n        address buyer = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists and is open.\n        require(block.timestamp < bid.closeTimeSec, \"the auction must be open\");\n\n        // Push back the end of the auction if it is too close.\n        if (bid.closeTimeSec < block.timestamp + 10 * 60) {\n            bid.closeTimeSec += 10 * 60;\n        }\n\n        // Check that the new bid is sufficiently large.\n        uint256 previousDeposit = bid.price;\n        uint minPrice = previousDeposit * 110 / 100;\n        require(price >= minPrice, \"a new bid must be 10% greater than the current bid\");\n\n        // Refund the previous buyer.\n        address previousBuyer = bid.buyer;\n        if (previousBuyer != address(0)) {\n            davinci.safeTransferFrom(address(this), previousBuyer, CURRENCY, previousDeposit, \"\");\n        }\n\n        // Take the new deposit from the new buyer.\n        bid.buyer = buyer;\n        bid.price = price;\n        davinci.safeTransferFrom(buyer, address(this), CURRENCY, price, \"\");\n\n        emit BidOnAuction(seller, nftId, price, bid.closeTimeSec, buyer);\n    }\n\n    function settleAuction(address seller, uint256 nftId)\n    public {\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists.\n        require(bid.closeTimeSec != 0, \"the auction must exist\");\n\n        // Check that the auction is closed.\n        require(bid.closeTimeSec <= block.timestamp, \"the auction must be closed\");\n\n        address buyer = bid.buyer;\n        uint256 price = bid.price;\n\n        if (buyer != address(0)) {\n            // In case there was a buyer,\n            // transfer the payment to the seller.\n            davinci.safeTransferFrom(address(this), seller, CURRENCY, price, \"\");\n\n            // Transfer the NFT to the buyer.\n            davinci.safeTransferFrom(address(this), buyer, nftId, 1, \"\");\n\n            // Collect royalty.\n            davinci.captureFee(seller, nftId, price, 1);\n        } else {\n            // Otherwise, there was no buyer,\n            // give back the NFT to the seller.\n            davinci.safeTransferFrom(address(this), seller, nftId, 1, \"\");\n        }\n\n        // Reset the storage. Make the auction not exist anymore.\n        bid.buyer = address(0);\n        bid.price = 0;\n        bid.closeTimeSec = 0;\n\n        emit SettleAuction(seller, nftId, price, buyer);\n    }\n}\n", "flattened_code": "pragma solidity ^0.8.0;\n\n// Based on @openzeppelin/contracts/metatx/ERC2771Context.sol 4.1.0\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n/*\n * @dev Context variant with ERC2771 support.\n */\nabstract contract MetaTxContext is AccessControl {\n\n    bytes32 public constant META_TX_FORWARDER = keccak256(\"META_TX_FORWARDER\");\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return hasRole(META_TX_FORWARDER, forwarder);\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {sender := shr(96, calldataload(sub(calldatasize(), 20)))}\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[: msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\n// From @openzeppelin/contracts 4.1.0\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155).interfaceId\n            || interfaceId == type(IERC1155MetadataURI).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n/** This contract implements NFTs.\n *\n * Integrate the implementation of ERC1155 and AccessControl from OpenZeppelin.\n */\nabstract contract BaseNFT is ERC1155, MetaTxContext {\n\n    // Enable the implementation of meta transactions (ERC2771).\n    function _msgSender() internal view virtual override(Context, MetaTxContext) returns (address sender) {\n        return MetaTxContext._msgSender();\n    }\n\n    // Enable the implementation of meta transactions (ERC2771).\n    function _msgData() internal view virtual override(Context, MetaTxContext) returns (bytes calldata) {\n        return MetaTxContext._msgData();\n    }\n\n    /** Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public view virtual override(ERC1155, AccessControl) returns (bool) {\n        return ERC1155.supportsInterface(interfaceId)\n        || AccessControl.supportsInterface(interfaceId);\n    }\n\n    constructor()\n    ERC1155(\"https://cere.network/nft/{id}.json\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function _forceTransfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount)\n    internal {\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        address operator = _msgSender();\n        emit TransferSingle(operator, from, to, id, amount);\n    }\n}\n\n/** Define a currency for fees.\n*/\nabstract contract Currency is BaseNFT {\n\n    /** The token ID that represents the CERE currency for all payments in this contract. */\n    uint256 public constant CURRENCY = 0;\n\n    /** The global supply of CERE tokens on all chains.\n     * That is 10 billion tokens, with 10 decimals.\n     */\n    uint256 public constant CURRENCY_SUPPLY = 10e9 * 1e10;\n\n    function _forceTransferCurrency(\n        address from,\n        address to,\n        uint256 amount)\n    internal {\n        uint256 fromBalance = _balances[CURRENCY][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[CURRENCY][from] = fromBalance - amount;\n        _balances[CURRENCY][to] += amount;\n\n        address operator = _msgSender();\n        emit TransferSingle(operator, from, to, CURRENCY, amount);\n    }\n}\n\n/** The role TRANSFER_OPERATOR is allowed to make any transfer.\n * This is useful to connect a marketplace contract.\n */\nabstract contract TransferOperator is Currency {\n\n    bytes32 public constant TRANSFER_OPERATOR = keccak256(\"TRANSFER_OPERATOR\");\n\n    /** Return true for operators with the role TRANSFER_OPERATOR.\n     *\n     * Otherwise, apply the standard approval logic of ERC1155.\n     * See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n    public view virtual override returns (bool) {\n\n        if (hasRole(TRANSFER_OPERATOR, operator)) return true;\n\n        return super.isApprovedForAll(account, operator);\n    }\n}\n\n/** An implementation of ChildERC20 used by the Polygon bridge.\n *\n * This contract contains a bridge account. The balance of the bridge represents all the tokens\n * that exist on other chains (Cere Chain and Cere ERC20 on Ethereum).\n *\n * See https://docs.matic.network/docs/develop/ethereum-matic/pos/mapping-assets\n */\nabstract contract PolygonChildERC20 is TransferOperator {\n\n    /** ERC20 Transfer event for bridging this ERC1155 contract to ERC20 on Ethereum.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /** The address of the bridge account in this contract. */\n    address constant BRIDGE = address(0);\n\n    /** The address of the Polygon bridge contract that is allowed to deposit tokens. */\n    address public childChainManagerProxy;\n\n    /** Fill the bridge with the supply of CERE tokens on all chains.\n     *\n     * Sets the deployer account as ChainManager. To enable the bridge, change it to the actual ChainManager\n     * using updateChildChainManager.\n     */\n    constructor() {\n        // _mint(BRIDGE, CURRENCY, CURRENCY_SUPPLY, \"\");\n        //     OR\n        _balances[CURRENCY][BRIDGE] = CURRENCY_SUPPLY;\n\n        childChainManagerProxy = _msgSender();\n    }\n\n    /** Return the total amount of currency available in the bridge, which can be deposited into this contract.\n     */\n    function currencyInBridge()\n    external view returns (uint256) {\n        return _balances[CURRENCY][BRIDGE];\n    }\n\n    /** Change the ChainManager, which can deposit currency into any account.\n     *\n     * Only the current ChainManager is allowed to change the ChainManager.\n     */\n    function updateChildChainManager(address newChildChainManagerProxy)\n    external {\n        require(newChildChainManagerProxy != address(0), \"Bad ChildChainManagerProxy address\");\n        require(_msgSender() == childChainManagerProxy, \"Only the current ChainManager is allowed to change the ChainManager.\");\n\n        childChainManagerProxy = newChildChainManagerProxy;\n    }\n\n    /** Deposit currency from Ethereum into a user account in this contract.\n     *\n     * This is implemented by moving tokens from the bridge account to the user account.\n     *\n     * Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.\n     *\n     * There is an extra encoding necessary for the amount. In JavaScript, add this:\n     * `web3.eth.abi.encodeParameter('uint256', amount)`\n     */\n    function deposit(address user, bytes calldata depositData)\n    external {\n        require(_msgSender() == childChainManagerProxy, \"Only the ChainManager is allowed to deposit\");\n\n        uint256 amount = abi.decode(depositData, (uint256));\n\n        _forceTransferCurrency(BRIDGE, user, amount);\n\n        emit Transfer(BRIDGE, user, amount);\n    }\n\n    /** Withdraw currency from a user account in this contract to Ethereum.\n     *\n     * This is implemented by moving tokens from the user account to the bridge account.\n     *\n     * Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.\n     */\n    function withdraw(uint256 amount)\n    external {\n        address user = _msgSender();\n\n        _forceTransferCurrency(user, BRIDGE, amount);\n\n        emit Transfer(user, BRIDGE, amount);\n    }\n}\n\n/**\n- Issue NFTs.\n- Keep track of the address of the issuer of an NFT.\n- Enforce rules of issuance: the supply is fixed.\n\n##### Structure of an NFT\n\nThe following attributes of a type of NFT are immutable. They are used to derive the ID of the NFTs.\n- Issuer: the address of the issuer of this type of NFT.\n- Supply: how many NFT of this type exists.\n\n*/\nabstract contract Issuance is PolygonChildERC20 {\n    /** A counter of NFT types issued by each issuer.\n     * This is used to generate unique NFT IDs.\n     */\n    mapping(address => uint32) public issuanceNonces;\n\n    /** Issue a supply of NFTs of a new type, and return its ID.\n     *\n     * No more NFT of this type can be issued again.\n     *\n     * The caller will be recorded as the issuer and it will initially own the entire supply.\n     */\n    function issue(uint64 supply, bytes memory data)\n    public returns (uint256) {\n        return _issueAs(_msgSender(), supply, data);\n    }\n\n    /** Internal implementation of the function issue.\n     */\n    function _issueAs(address issuer, uint64 supply, bytes memory data)\n    internal returns (uint256) {\n        uint32 nonce = issuanceNonces[issuer];\n        issuanceNonces[issuer] = nonce + 1;\n\n        uint256 nftId = getNftId(issuer, nonce, supply);\n\n        require(supply > 0);\n        _mint(issuer, nftId, supply, data);\n\n        return nftId;\n    }\n\n    /** Return whether an address is the issuer of an NFT type.\n     *\n     * This does not imply that the NFTs exist.\n     */\n    function _isIssuer(address addr, uint256 nftId)\n    internal pure returns (bool) {\n        (address issuer, uint32 nonce, uint64 supply) = _parseNftId(nftId);\n        return addr == issuer;\n    }\n\n    /** Return whether the address is the issuer of an NFT type, and\n     * currently owns all NFT of this type (normally right after issuance).\n     */\n    function _isIssuerAndOnlyOwner(address addr, uint256 id)\n    internal view returns (bool) {\n        (address issuer, uint32 nonce, uint64 supply) = _parseNftId(id);\n        uint64 balance = uint64(balanceOf(issuer, id));\n\n        bool isIssuer = addr == issuer;\n        bool ownsAll = balance == supply;\n        return isIssuer && ownsAll;\n    }\n\n    /** Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.\n     */\n    function getNftId(address issuer, uint32 nonce, uint64 supply)\n    public pure returns (uint256) {\n        // issuer || nonce || supply: 160 + 32 + 64 = 256 bits\n        uint256 id = (uint256(uint160(issuer)) << (32 + 64))\n        | (uint256(nonce) << 64)\n        | uint256(supply);\n        return id;\n    }\n\n    /** Parse an NFT ID into its issuer, its supply, and an arbitrary nonce.\n     *\n     * This does not imply that the NFTs exist.\n     */\n    function _parseNftId(uint256 id)\n    internal pure returns (address issuer, uint32 nonce, uint64 supply) {\n        issuer = address(uint160((id & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000) >> (32 + 64)));\n        nonce = /*     */ uint32((id & 0x0000000000000000000000000000000000000000FFFFFFFF0000000000000000) >> 64);\n        supply = /*    */ uint64((id & 0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF));\n        return (issuer, nonce, supply);\n    }\n}\n\n/**\nA Joint Account (JA) is an account such that multiple owners have a claim on their respective share of the funds.\n\nJoint Accounts support the contract currency only. They cannot be used for NFTs.\n\nAn owner may be another Joint Account, or a smart contract.\nIt is possible to withdraw funds through nested JAs,\nbecause anyone can trigger a withdrawal from a JA to its owners,\nincluding if that owner is itself a JA.\n\n[An implementation that distributes to all owners at once.]\n*/\nabstract contract JointAccounts is Issuance {\n    /** The total fraction representing 100% of an account.\n     */\n    uint256 public BASIS_POINTS = 100 * 100;\n\n    uint256 public MAX_JOINT_ACCOUNT_SHARES = 10;\n\n    struct JointAccountShare {\n        address owner;\n        uint256 fraction;\n    }\n\n    mapping(address => JointAccountShare[]) public jointAccounts;\n\n    /** Notify that a Joint Account was created at the address `account`.\n     *\n     * One such event is emitted for each owner, including his fraction of the account in basis points (1% of 1%).\n     */\n    event JointAccountShareCreated(\n        address indexed account,\n        address indexed owner,\n        uint256 fraction);\n\n    /** Create an account such that multiple owners have a claim on their respective share.\n     *\n     * The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000.\n     *\n     * Anyone can create Joint Accounts including any owners.\n     */\n    function createJointAccount(address[] memory owners, uint256[] memory fractions)\n    public returns (address) {\n        require(owners.length == fractions.length, \"Arrays of owners and fractions must have the same length\");\n        require(owners.length <= MAX_JOINT_ACCOUNT_SHARES, \"Too many shares\");\n\n        address account = makeAddressOfJointAccount(owners, fractions);\n        JointAccountShare[] storage newShares = jointAccounts[account];\n\n        require(newShares.length == 0, \"The account already exists\");\n\n        uint256 totalFraction = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            address owner = owners[i];\n            uint256 fraction = fractions[i];\n            require(owner != address(0) && fraction != 0, \"0 values are not permitted\");\n\n            newShares.push(JointAccountShare({owner : owner, fraction : fraction}));\n            totalFraction += fraction;\n\n            emit JointAccountShareCreated(account, owner, fraction);\n        }\n        require(totalFraction == BASIS_POINTS, \"Total fractions must be 10,000\");\n\n        return account;\n    }\n\n    /** Distribute all tokens available to all owners of a Joint Account.\n     *\n     * The function createJointAccount must be called beforehand.\n     *\n     * Anyone can trigger the distribution.\n     */\n    function distributeJointAccount(address account)\n    public {\n        uint accountBalance = balanceOf(account, CURRENCY);\n        JointAccountShare[] storage shares = jointAccounts[account];\n\n        for (uint i = 0; i < shares.length; i++) {\n            JointAccountShare storage share = shares[i];\n            uint256 ownerBalance = accountBalance * share.fraction / BASIS_POINTS;\n\n            _forceTransferCurrency(account, share.owner, ownerBalance);\n        }\n    }\n\n    /** Generate a unique address identifying a list of owners and shares.\n     *\n     * It may be used to predict the address of a Joint Account and receive payments\n     * even before calling the function createJointAccount.\n     */\n    function makeAddressOfJointAccount(address[] memory owners, uint256[] memory fractions)\n    public pure returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(owners, fractions));\n        return address(bytes20(hash));\n    }\n\n    /** Return the fraction of an account owned by the given address, in basis points (1% of 1%).\n     *\n     * If the account does not exist, or if the given address is not an owner of it, this returns 0.\n     * If the owner appears more than once in the account, this reports only the first share.\n     */\n    function fractionOfJAOwner(address account, address maybeOwner)\n    public view returns (uint) {\n        JointAccountShare[] storage shares = jointAccounts[account];\n\n        for (uint256 i = 0; i < shares.length; i++) {\n            JointAccountShare storage share = shares[i];\n            if (share.owner == maybeOwner) {\n                return share.fraction;\n            }\n        }\n        return 0;\n    }\n\n    /** Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.\n     */\n    function balanceOfJAOwner(address account, address owner)\n    public view returns (uint256) {\n        uint fraction = fractionOfJAOwner(account, owner);\n        uint accountBalance = balanceOf(account, CURRENCY);\n        uint256 ownerBalance = accountBalance * fraction / BASIS_POINTS;\n        return ownerBalance;\n    }\n\n}\n\n/**\n- Hold configuration of NFTs: services, royalties.\n- Capture royalties on primary and secondary transfers.\n- Report configured royalties to service providers (supports Joint Accounts).\n */\nabstract contract TransferFees is JointAccounts {\n\n    bytes32 public constant BYPASS_SENDER = keccak256(\"BYPASS_SENDER\");\n\n    // Royalties configurable per NFT by issuers.\n    mapping(uint256 => address) primaryRoyaltyAccounts;\n    mapping(uint256 => uint256) primaryRoyaltyCuts;\n    mapping(uint256 => uint256) primaryRoyaltyMinimums;\n    mapping(uint256 => address) secondaryRoyaltyAccounts;\n    mapping(uint256 => uint256) secondaryRoyaltyCuts;\n    mapping(uint256 => uint256) secondaryRoyaltyMinimums;\n    mapping(uint256 => uint256) royaltiesConfigLockedUntil;\n\n    /** Notify that royalties were configured on an NFT type.\n     */\n    event RoyaltiesConfigured(\n        uint256 indexed nftId,\n        address primaryRoyaltyAccount,\n        uint256 primaryRoyaltyCut,\n        uint256 primaryRoyaltyMinimum,\n        address secondaryRoyaltyAccount,\n        uint256 secondaryRoyaltyCut,\n        uint256 secondaryRoyaltyMinimum);\n\n    /** Notify that royalties are locked and cannot change, until the given time (in UNIX seconds),\n     * or forever (lockUntil = 0xFFFFFFFF).\n     */\n    event RoyaltiesLocked(\n        uint256 indexed nftId,\n        uint256 lockUntil);\n\n    /** Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.\n     */\n    function getRoyalties(uint256 nftId)\n    public view returns (\n        address primaryRoyaltyAccount,\n        uint256 primaryRoyaltyCut,\n        uint256 primaryRoyaltyMinimum,\n        address secondaryRoyaltyAccount,\n        uint256 secondaryRoyaltyCut,\n        uint256 secondaryRoyaltyMinimum\n    ) {\n        return (primaryRoyaltyAccounts[nftId], primaryRoyaltyCuts[nftId], primaryRoyaltyMinimums[nftId],\n        secondaryRoyaltyAccounts[nftId], secondaryRoyaltyCuts[nftId], secondaryRoyaltyMinimums[nftId]);\n    }\n\n    /** Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT.\n     *\n     * This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA,\n     * the shares of the royalties for this owner are returned.\n     */\n    function getRoyaltiesForBeneficiary(uint256 nftId, address beneficiary)\n    public view returns (uint256 primaryCut, uint256 primaryMinimum, uint256 secondaryCut, uint256 secondaryMinimum) {\n\n        // If the royalty account is the given beneficiary, return the configured fees.\n        // Otherwise, the royalty account may be a Joint Account, and the beneficiary a share owner of it.\n        // Otherwise, \"fraction\" will be 0, and 0 values will be returned.\n\n        // Primary royalties.\n        primaryCut = primaryRoyaltyCuts[nftId];\n        primaryMinimum = primaryRoyaltyMinimums[nftId];\n        address primaryAccount = primaryRoyaltyAccounts[nftId];\n        if (primaryAccount != beneficiary) {\n            uint256 fraction = fractionOfJAOwner(primaryAccount, beneficiary);\n            primaryCut = primaryCut * fraction / BASIS_POINTS;\n            primaryMinimum = primaryMinimum * fraction / BASIS_POINTS;\n        }\n\n        // Secondary royalties.\n        secondaryCut = secondaryRoyaltyCuts[nftId];\n        secondaryMinimum = secondaryRoyaltyMinimums[nftId];\n        address secondaryAccount = secondaryRoyaltyAccounts[nftId];\n        if (secondaryAccount != beneficiary) {\n            uint256 fraction = fractionOfJAOwner(secondaryAccount, beneficiary);\n            secondaryCut = secondaryCut * fraction / BASIS_POINTS;\n            secondaryMinimum = secondaryMinimum * fraction / BASIS_POINTS;\n        }\n\n        return (primaryCut, primaryMinimum, secondaryCut, secondaryMinimum);\n    }\n\n    /** Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.\n     * This configuration is available to the issuer of this NFT.\n     *\n     * A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance).\n     * Otherwise, it is a secondary transfer.\n     *\n     * A royalty is defined in two parts (both optional):\n     * a cut of the sale price of an NFT, and a minimum royalty per transfer.\n     * For simple transfers not attached to a price, or a too low price, the minimum royalty is charged.\n     *\n     * The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts.\n     *\n     * The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time,\n     * effectively giving up his ability to modify the royalties. See the function lockRoyalties.\n     *\n     * There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst\n     * several parties, use a Joint Account (see function createJointAccount).\n     */\n    function configureRoyalties(\n        uint256 nftId,\n        address primaryRoyaltyAccount,\n        uint256 primaryRoyaltyCut,\n        uint256 primaryRoyaltyMinimum,\n        address secondaryRoyaltyAccount,\n        uint256 secondaryRoyaltyCut,\n        uint256 secondaryRoyaltyMinimum)\n    public {\n        address issuer = _msgSender();\n        require(_isIssuer(issuer, nftId), \"Only the issuer of this NFT can set royalties\");\n        require(block.timestamp >= royaltiesConfigLockedUntil[nftId], \"Royalties configuration is locked for now\");\n\n        require(primaryRoyaltyAccount != address(0) || (primaryRoyaltyCut == 0 && primaryRoyaltyMinimum == 0),\n            \"The account must not be 0, unless fees are 0\");\n        primaryRoyaltyAccounts[nftId] = primaryRoyaltyAccount;\n        primaryRoyaltyCuts[nftId] = primaryRoyaltyCut;\n        primaryRoyaltyMinimums[nftId] = primaryRoyaltyMinimum;\n\n        require(secondaryRoyaltyAccount != address(0) || (secondaryRoyaltyCut == 0 && secondaryRoyaltyMinimum == 0),\n            \"The account must not be 0, unless fees are 0\");\n        secondaryRoyaltyAccounts[nftId] = secondaryRoyaltyAccount;\n        secondaryRoyaltyCuts[nftId] = secondaryRoyaltyCut;\n        secondaryRoyaltyMinimums[nftId] = secondaryRoyaltyMinimum;\n\n        emit RoyaltiesConfigured(\n            nftId,\n            primaryRoyaltyAccount,\n            primaryRoyaltyCut,\n            primaryRoyaltyMinimum,\n            secondaryRoyaltyAccount,\n            secondaryRoyaltyCut,\n            secondaryRoyaltyMinimum);\n    }\n\n    /** Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration,\n     * after which he himself will no longer be able to change the configuration, for some time, or forever.\n     *\n     * Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds).\n     * Set to 0xFFFFFFFF to lock forever.\n     */\n    function lockRoyalties(\n        uint256 nftId,\n        uint256 lockUntil)\n    public {\n        address issuer = _msgSender();\n        require(_isIssuer(issuer, nftId));\n\n        require(lockUntil > royaltiesConfigLockedUntil[nftId], \"Royalties configuration cannot be unlocked earlier\");\n        royaltiesConfigLockedUntil[nftId] = lockUntil;\n\n        emit RoyaltiesLocked(nftId, lockUntil);\n    }\n\n    /** Internal hook to trigger the collection of royalties due on a batch of transfers.\n     *\n     * The role BYPASS_SENDER does not pay royalties. This is intended to be used by a privileged service that allows users to make simple non-sale transfers.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data)\n    internal override {\n        // Pay a fee per transfer to a beneficiary, if any.\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            _captureFee(from, tokenIds[i], /*price*/ 0, amounts[i]);\n        }\n    }\n\n    /** Collect the royalty due on a transfer.\n     *\n     * The royalty is calculated based on NFT configuration and the price. It is collected by an internal transfer of currency between \"from\" and the beneficiary. Return the amount collected.\n     *\n     * The caller must be approved by \"from\", or a TRANSFER_OPERATOR.\n     */\n    function captureFee(address from, uint256 nftId, uint256 price, uint256 amount)\n    public returns (uint256) {\n        address operator = _msgSender();\n        require(isApprovedForAll(from, operator), \"the operator must be approved or a TRANSFER_OPERATOR\");\n        return _captureFee(from, nftId, price, amount);\n    }\n\n    /** Collect the royalty due on a transfer.\n     *\n     * The royalty is calculated based on NFT configuration and the price. It is collected by an internal transfer of currency between \"from\" and the beneficiary. Return the amount collected.\n     */\n    function _captureFee(address from, uint256 nftId, uint256 price, uint256 amount)\n    internal returns (uint256) {\n        if (nftId == CURRENCY) return 0;\n\n        // An account with bypass role does not pay royalties.\n        // This uses msg.sender which is supposed to be a transaction relayer,\n        // instead of _msgSender() which is the user wishing to transfer his tokens.\n        if (hasRole(BYPASS_SENDER, msg.sender)) return 0;\n\n        uint256 cut;\n        uint256 minimum;\n        address royaltyAccount;\n        bool isPrimary = _isPrimaryTransfer(from, nftId);\n        if (isPrimary) {\n            cut = primaryRoyaltyCuts[nftId];\n            minimum = primaryRoyaltyMinimums[nftId];\n            royaltyAccount = primaryRoyaltyAccounts[nftId];\n        } else {\n            cut = secondaryRoyaltyCuts[nftId];\n            minimum = secondaryRoyaltyMinimums[nftId];\n            royaltyAccount = secondaryRoyaltyAccounts[nftId];\n        }\n\n        uint256 perTransferFee = price * cut / BASIS_POINTS;\n        if (perTransferFee < minimum) perTransferFee = minimum;\n\n        uint256 totalFee = perTransferFee * amount;\n        if (totalFee != 0) {\n            _forceTransferCurrency(from, royaltyAccount, totalFee);\n        }\n\n        return totalFee;\n    }\n\n    /** Determine whether a transfer is primary (true) or secondary (false).\n     *\n     * See the function setRoyalties.\n     */\n    function _isPrimaryTransfer(address from, uint256 nftId)\n    internal pure returns (bool) {\n        (address issuer, uint32 nonce, uint64 supply) = _parseNftId(nftId);\n        return from == issuer;\n    }\n\n}\n\n\n/**\n- Make offers to sell NFTs.\n- Accept offer.\n- Capture variable royalties.\n */\nabstract contract SimpleExchange is TransferFees {\n\n    /** Seller => NFT ID => Price.\n     */\n    mapping(address => mapping(uint256 => uint256)) sellerNftPriceOffers;\n\n    /** An event emitted when an account `seller` has offered to sell a type of NFT\n     * at a given price.\n     *\n     * This replaces previous offers by the same seller on the same NFT ID, if any.\n     * A price of 0 means \"no offer\" and the previous offer is cancelled.\n     *\n     * An offer does not imply that the seller owns any amount of this NFT.\n     * An offer remains valid until cancelled, for the entire balance at a given time,\n     * regardless of incoming and outgoing transfers on the seller account.\n     */\n    event MakeOffer(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price);\n\n    /** An offer of `seller` was taken by `buyer`.\n     * The transfers of `amount` NFTs of type `nftId`\n     * against `amount * price` of CERE Units were executed.\n     */\n    event TakeOffer(\n        address indexed buyer,\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 amount);\n\n    /** Create an offer to sell a type of NFTs for a price per unit.\n     * All the NFTs of this type owned by the caller will be for sale.\n     *\n     * To cancel, call again with a price of 0.\n     */\n    function makeOffer(uint256 nftId, uint256 price)\n    public {\n        address seller = _msgSender();\n        sellerNftPriceOffers[seller][nftId] = price;\n\n        emit MakeOffer(seller, nftId, price);\n    }\n\n    /** Return the price offered by the given seller for the given NFT type.\n     */\n    function getOffer(address seller, uint256 nftId)\n    public view returns (uint256) {\n        uint price = sellerNftPriceOffers[seller][nftId];\n        return price;\n    }\n\n    /** Accept an offer, paying the price per unit for an amount of NFTs.\n     *\n     * The offer must have been created beforehand by makeOffer.\n     *\n     * The same authorization as safeTransferFrom apply to the buyer (sender or approved operator).\n     *\n     * The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents\n     * a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.\n     */\n    function takeOffer(address buyer, address seller, uint256 nftId, uint256 expectedPriceOrZero, uint256 amount)\n    public {\n        // Check and update the amount offered.\n        uint256 price = sellerNftPriceOffers[seller][nftId];\n        require(price != 0, \"Not for sale\");\n        require(expectedPriceOrZero == 0 || expectedPriceOrZero == price, \"Unexpected price\");\n\n        // Pay. This verifies the intent of the buyer.\n        uint totalPrice = price * amount;\n        safeTransferFrom(buyer, seller, CURRENCY, totalPrice, \"\");\n\n        // Take a fee from the seller (really a cut of the above payment).\n        uint totalFee = _captureFee(seller, nftId, price, amount);\n        require(totalFee <= totalPrice, \"Cannot take more fees than the price.\");\n\n        // Move the NFTs to the buyer.\n        _forceTransfer(seller, buyer, nftId, amount);\n\n        emit TakeOffer(buyer, seller, nftId, price, amount);\n    }\n\n    /** Guarantee that a version of Solidity with safe math is used.\n     */\n    function _mathIsSafe() internal pure {\n    unchecked {} // Use a keyword from Solidity 0.8.0.\n    }\n}\n\n/** Main contract, including all components.\n\n- Hold and transfer NFTs using ERC1155.\n- Support atomic exchanges of NFTs for currency.\n- Issuance of NFTs with fixed supply.\n- Joint Accounts that distribute their funds over multiple owners.\n- Capture royalties on primary and secondary transfers, configurable per NFT type.\n*/\ncontract Davinci is /*\n    ERC1155,\n    AccessControl,\n    MetaTxContext,\n    BaseNFT,\n    Currency,\n    TransferOperator,\n    PolygonChildERC20,\n    Issuance,\n    JointAccounts,\n    TransferFees,\n    */ SimpleExchange {\n\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n\n\n/**\nAn auction is characterized by a sequence of transactions and their corresponding events:\n\n- `StartAuction`: A seller offers to sell one NFT to the highest bidder, with a minimum price, and a closing time.\n\n- Any number of `BidOnAuction`: A potential buyer accepts the minimum price or a price at least 10% higher\nthan that of the previous bidder.\nThe closing time may be extended.\nA deposit is taken from the new bidder. The deposit of the previous bidder is returned, if any.\nBidding is no longer possible after the closing time.\n\n- `SettleAuction`: The sale is completed between the seller and the highest bidder, or cancelled if there was no bidder.\nSome royalties may be taken from the sale price, as configured by the NFT creator (see `TransferFees.sol`).\nThe settlement is only possible after the closing time.\n\nWhile an auction is active, it is identified by the tuple `(seller address, NFT ID)`.\nHowever, after the auction is settled, a new auction with the *same tuple* may start.\n */\ncontract SimpleAuction is /* AccessControl, */ MetaTxContext, ERC1155Holder {\n\n    /** Supports interfaces of AccessControl and ERC1155Receiver.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public view virtual override(AccessControl, ERC1155Receiver) returns (bool) {\n        return AccessControl.supportsInterface(interfaceId)\n        || ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    Davinci public davinci;\n\n    /** This contract must have the TRANSFER_OPERATOR role in the Davinci contract.\n     */\n    constructor(Davinci _davinci) {\n        davinci = _davinci;\n    }\n\n    /** The token ID that represents the CERE currency for all payments in this contract. */\n    uint256 public constant CURRENCY = 0;\n\n    struct Bid {\n        address buyer; // 0 means no buyer yet.\n        uint256 price; // The highest bid price. The initial value is set by the seller.\n        uint256 closeTimeSec; // Bidding is open until the close time. After this time, the settlement becomes possible. A non-zero value also means that the auction exists.\n    }\n\n    /** Seller => NFT ID => Bid.\n     */\n    mapping(address => mapping(uint256 => Bid)) public sellerNftBids;\n\n    /**\n     * Note: `price` is the minimum price minus 10%, because a bid must be 10% higher, resulting in the requested minimum price.\n     */\n    event StartAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec);\n\n    /**\n     * Note: `price`, `closeTimeSec`, and `buyer` may have changed for the auction `(seller, nftId)`.\n     */\n    event BidOnAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec,\n        address buyer);\n\n    /**\n     * Note: `buyer == 0` means no buyer, and the NFT went back to the seller.\n     */\n    event SettleAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        address buyer);\n\n    /**\n     */\n    function startAuction(uint256 nftId, uint256 minPrice, uint closeTimeSec)\n    public {\n        address seller = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction does not exist.\n        require(bid.closeTimeSec == 0, \"the auction must not exist\");\n\n        // Check that the close time is non-zero and in the future.\n        require(block.timestamp < closeTimeSec, \"the close time must be in the future\");\n\n        // Deduct the minimum increment to work with the logic of minPrice in the function bid().\n        uint256 price = minPrice * 100 / 110;\n        require(price > 0, \"the starting price must be greater than 0\");\n\n        // TODO: Check that minPrice is greater than the fixed royalty, if any.\n\n        // Create the auction.\n        bid.buyer = address(0);\n        bid.price = price;\n        bid.closeTimeSec = closeTimeSec;\n\n        // Take the NFT from the seller.\n        davinci.safeTransferFrom(seller, address(this), nftId, 1, \"\");\n\n        emit StartAuction(seller, nftId, price, closeTimeSec);\n    }\n\n    /**\n     */\n    function bidOnAuction(address seller, uint256 nftId, uint256 price)\n    public {\n        address buyer = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists and is open.\n        require(block.timestamp < bid.closeTimeSec, \"the auction must be open\");\n\n        // Push back the end of the auction if it is too close.\n        if (bid.closeTimeSec < block.timestamp + 10 * 60) {\n            bid.closeTimeSec += 10 * 60;\n        }\n\n        // Check that the new bid is sufficiently large.\n        uint256 previousDeposit = bid.price;\n        uint minPrice = previousDeposit * 110 / 100;\n        require(price >= minPrice, \"a new bid must be 10% greater than the current bid\");\n\n        // Refund the previous buyer.\n        address previousBuyer = bid.buyer;\n        if (previousBuyer != address(0)) {\n            davinci.safeTransferFrom(address(this), previousBuyer, CURRENCY, previousDeposit, \"\");\n        }\n\n        // Take the new deposit from the new buyer.\n        bid.buyer = buyer;\n        bid.price = price;\n        davinci.safeTransferFrom(buyer, address(this), CURRENCY, price, \"\");\n\n        emit BidOnAuction(seller, nftId, price, bid.closeTimeSec, buyer);\n    }\n\n    function settleAuction(address seller, uint256 nftId)\n    public {\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists.\n        require(bid.closeTimeSec != 0, \"the auction must exist\");\n\n        // Check that the auction is closed.\n        require(bid.closeTimeSec <= block.timestamp, \"the auction must be closed\");\n\n        address buyer = bid.buyer;\n        uint256 price = bid.price;\n\n        if (buyer != address(0)) {\n            // In case there was a buyer,\n            // transfer the payment to the seller.\n            davinci.safeTransferFrom(address(this), seller, CURRENCY, price, \"\");\n\n            // Transfer the NFT to the buyer.\n            davinci.safeTransferFrom(address(this), buyer, nftId, 1, \"\");\n\n            // Collect royalty.\n            davinci.captureFee(seller, nftId, price, 1);\n        } else {\n            // Otherwise, there was no buyer,\n            // give back the NFT to the seller.\n            davinci.safeTransferFrom(address(this), seller, nftId, 1, \"\");\n        }\n\n        // Reset the storage. Make the auction not exist anymore.\n        bid.buyer = address(0);\n        bid.price = 0;\n        bid.closeTimeSec = 0;\n\n        emit SettleAuction(seller, nftId, price, buyer);\n    }\n}\n", "commit_id": "e1af0130411681ab82e328cc0b677a00e7160919"}, "fixed_version": {"raw_code": "pragma solidity ^0.8.0;\n\nimport \"./davinciParts/MetaTxContext.sol\";\nimport \"./Davinci.sol\";\nimport \"./token/ERC1155/utils/ERC1155Holder.sol\";\n\n\n/**\nAn auction is characterized by a sequence of transactions and their corresponding events:\n\n- `StartAuction`: A seller offers to sell one NFT to the highest bidder, with a minimum price, and a closing time.\n\n- Any number of `BidOnAuction`: A potential buyer accepts the minimum price or a price at least 10% higher\nthan that of the previous bidder.\nThe closing time may be extended.\nA deposit is taken from the new bidder. The deposit of the previous bidder is returned, if any.\nBidding is no longer possible after the closing time.\n\n- `SettleAuction`: The sale is completed between the seller and the highest bidder, or cancelled if there was no bidder.\nSome royalties may be taken from the sale price, as configured by the NFT creator (see `TransferFees.sol`).\nThe settlement is only possible after the closing time.\n\nWhile an auction is active, it is identified by the tuple `(seller address, NFT ID)`.\nHowever, after the auction is settled, a new auction with the *same tuple* may start.\n */\ncontract SimpleAuction is /* AccessControl, */ MetaTxContext, ERC1155Holder {\n\n    /** Supports interfaces of AccessControl and ERC1155Receiver.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public view virtual override(AccessControl, ERC1155Receiver) returns (bool) {\n        return AccessControl.supportsInterface(interfaceId)\n        || ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    Davinci public davinci;\n\n    /** This contract must have the TRANSFER_OPERATOR role in the Davinci contract.\n     */\n    constructor(Davinci _davinci) {\n        davinci = _davinci;\n    }\n\n    /** The token ID that represents the CERE currency for all payments in this contract. */\n    uint256 public constant CURRENCY = 0;\n\n    struct Bid {\n        address buyer; // 0 means no buyer yet.\n        uint256 price; // The highest bid price. The initial value is set by the seller.\n        uint256 closeTimeSec; // Bidding is open until the close time. After this time, the settlement becomes possible. A non-zero value also means that the auction exists.\n    }\n\n    /** Seller => NFT ID => Bid.\n     */\n    mapping(address => mapping(uint256 => Bid)) public sellerNftBids;\n\n    /**\n     * Note: `price` is the minimum price minus 10%, because a bid must be 10% higher, resulting in the requested minimum price.\n     */\n    event StartAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec);\n\n    /**\n     * Note: `price`, `closeTimeSec`, and `buyer` may have changed for the auction `(seller, nftId)`.\n     */\n    event BidOnAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec,\n        address buyer);\n\n    /**\n     * Note: `buyer == 0` means no buyer, and the NFT went back to the seller.\n     */\n    event SettleAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        address buyer);\n\n    /**\n     */\n    function startAuction(uint256 nftId, uint256 minPrice, uint closeTimeSec)\n    public {\n        address seller = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction does not exist.\n        require(bid.closeTimeSec == 0, \"the auction must not exist\");\n\n        // Check that the close time is non-zero and in the future.\n        require(block.timestamp < closeTimeSec, \"the close time must be in the future\");\n\n        // Deduct the minimum increment to work with the logic of minPrice in the function bid().\n        uint256 price = minPrice * 100 / 110;\n        require(price > 0, \"the starting price must be greater than 0\");\n\n        // TODO: Check that minPrice is greater than the fixed royalty, if any.\n\n        // Create the auction.\n        bid.buyer = address(0);\n        bid.price = price;\n        bid.closeTimeSec = closeTimeSec;\n\n        // Take the NFT from the seller.\n        davinci.safeTransferFrom(seller, address(this), nftId, 1, \"\");\n\n        emit StartAuction(seller, nftId, price, closeTimeSec);\n    }\n\n    /**\n     */\n    function bidOnAuction(address seller, uint256 nftId, uint256 price)\n    public {\n        address buyer = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists and is open.\n        require(block.timestamp < bid.closeTimeSec, \"the auction must be open\");\n\n        // Push back the end of the auction if it is too close.\n        if (bid.closeTimeSec < block.timestamp + 10 * 60) {\n            bid.closeTimeSec += 10 * 60;\n        }\n\n        // Check that the new bid is sufficiently large.\n        uint256 previousDeposit = bid.price;\n        uint minPrice = previousDeposit * 110 / 100;\n        require(price >= minPrice, \"a new bid must be 10% greater than the current bid\");\n\n        // Refund the previous buyer.\n        address previousBuyer = bid.buyer;\n        if (previousBuyer != address(0)) {\n            davinci.safeTransferFrom(address(this), previousBuyer, CURRENCY, previousDeposit, \"\");\n        }\n\n        // Take the new deposit from the new buyer.\n        bid.buyer = buyer;\n        bid.price = price;\n        davinci.safeTransferFrom(buyer, address(this), CURRENCY, price, \"\");\n\n        emit BidOnAuction(seller, nftId, price, bid.closeTimeSec, buyer);\n    }\n\n    function settleAuction(address seller, uint256 nftId)\n    public {\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists.\n        require(bid.closeTimeSec != 0, \"the auction must exist\");\n\n        // Check that the auction is closed.\n        require(bid.closeTimeSec <= block.timestamp, \"the auction must be closed\");\n\n        address buyer = bid.buyer;\n        uint256 price = bid.price;\n\n        // Reset the storage. Make the auction not exist anymore.\n        bid.buyer = address(0);\n        bid.price = 0;\n        bid.closeTimeSec = 0;\n\n        if (buyer != address(0)) {\n            // In case there was a buyer,\n            // transfer the payment to the seller.\n            davinci.safeTransferFrom(address(this), seller, CURRENCY, price, \"\");\n\n            // Transfer the NFT to the buyer.\n            davinci.safeTransferFrom(address(this), buyer, nftId, 1, \"\");\n\n            // Collect royalty.\n            davinci.captureFee(seller, nftId, price, 1);\n        } else {\n            // Otherwise, there was no buyer,\n            // give back the NFT to the seller.\n            davinci.safeTransferFrom(address(this), seller, nftId, 1, \"\");\n        }\n\n        emit SettleAuction(seller, nftId, price, buyer);\n    }\n}\n", "flattened_code": "pragma solidity ^0.8.0;\n\n// Based on @openzeppelin/contracts/metatx/ERC2771Context.sol 4.1.0\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n\n/*\n * @dev Context variant with ERC2771 support.\n */\nabstract contract MetaTxContext is AccessControl {\n\n    bytes32 public constant META_TX_FORWARDER = keccak256(\"META_TX_FORWARDER\");\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return hasRole(META_TX_FORWARDER, forwarder);\n    }\n\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {sender := shr(96, calldataload(sub(calldatasize(), 20)))}\n        } else {\n            return super._msgSender();\n        }\n    }\n\n    function _msgData() internal view virtual override returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[: msg.data.length - 20];\n        } else {\n            return super._msgData();\n        }\n    }\n}\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\npragma solidity ^0.8.0;\n\n// From @openzeppelin/contracts 4.1.0\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping (uint256 => mapping(address => uint256)) _balances;\n\n    // Mapping from account to operator approvals\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor (string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155).interfaceId\n            || interfaceId == type(IERC1155MetadataURI).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(account != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(account != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        internal\n        virtual\n    { }\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        private\n    {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n\n/** This contract implements NFTs.\n *\n * Integrate the implementation of ERC1155 and AccessControl from OpenZeppelin.\n */\nabstract contract BaseNFT is ERC1155, MetaTxContext {\n\n    // Enable the implementation of meta transactions (ERC2771).\n    function _msgSender() internal view virtual override(Context, MetaTxContext) returns (address sender) {\n        return MetaTxContext._msgSender();\n    }\n\n    // Enable the implementation of meta transactions (ERC2771).\n    function _msgData() internal view virtual override(Context, MetaTxContext) returns (bytes calldata) {\n        return MetaTxContext._msgData();\n    }\n\n    /** Supports interfaces of AccessControl, ERC1155, and ERC1155 MetadataURI.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public view virtual override(ERC1155, AccessControl) returns (bool) {\n        return ERC1155.supportsInterface(interfaceId)\n        || AccessControl.supportsInterface(interfaceId);\n    }\n\n    constructor()\n    ERC1155(\"https://cere.network/nft/{id}.json\") {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n    }\n\n    function _forceTransfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount)\n    internal {\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        address operator = _msgSender();\n        emit TransferSingle(operator, from, to, id, amount);\n    }\n}\n\n/** Define a currency for fees.\n*/\nabstract contract Currency is BaseNFT {\n\n    /** The token ID that represents the CERE currency for all payments in this contract. */\n    uint256 public constant CURRENCY = 0;\n\n    /** The global supply of CERE tokens on all chains.\n     * That is 10 billion tokens, with 10 decimals.\n     */\n    uint256 public constant CURRENCY_SUPPLY = 10e9 * 1e10;\n\n    function _forceTransferCurrency(\n        address from,\n        address to,\n        uint256 amount)\n    internal {\n        uint256 fromBalance = _balances[CURRENCY][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[CURRENCY][from] = fromBalance - amount;\n        _balances[CURRENCY][to] += amount;\n\n        address operator = _msgSender();\n        emit TransferSingle(operator, from, to, CURRENCY, amount);\n    }\n}\n\n/** The role TRANSFER_OPERATOR is allowed to make any transfer.\n * This is useful to connect a marketplace contract.\n */\nabstract contract TransferOperator is Currency {\n\n    bytes32 public constant TRANSFER_OPERATOR = keccak256(\"TRANSFER_OPERATOR\");\n\n    /** Return true for operators with the role TRANSFER_OPERATOR.\n     *\n     * Otherwise, apply the standard approval logic of ERC1155.\n     * See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator)\n    public view virtual override returns (bool) {\n\n        if (hasRole(TRANSFER_OPERATOR, operator)) return true;\n\n        return super.isApprovedForAll(account, operator);\n    }\n}\n\n/** An implementation of ChildERC20 used by the Polygon bridge.\n *\n * This contract contains a bridge account. The balance of the bridge represents all the tokens\n * that exist on other chains (Cere Chain and Cere ERC20 on Ethereum).\n *\n * See https://docs.matic.network/docs/develop/ethereum-matic/pos/mapping-assets\n */\nabstract contract PolygonChildERC20 is TransferOperator {\n\n    /** ERC20 Transfer event for bridging this ERC1155 contract to ERC20 on Ethereum.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /** The address of the bridge account in this contract. */\n    address constant BRIDGE = address(0);\n\n    /** The address of the Polygon bridge contract that is allowed to deposit tokens. */\n    address public childChainManagerProxy;\n\n    /** Fill the bridge with the supply of CERE tokens on all chains.\n     *\n     * Sets the deployer account as ChainManager. To enable the bridge, change it to the actual ChainManager\n     * using updateChildChainManager.\n     */\n    constructor() {\n        // _mint(BRIDGE, CURRENCY, CURRENCY_SUPPLY, \"\");\n        //     OR\n        _balances[CURRENCY][BRIDGE] = CURRENCY_SUPPLY;\n\n        childChainManagerProxy = _msgSender();\n    }\n\n    /** Return the total amount of currency available in the bridge, which can be deposited into this contract.\n     */\n    function currencyInBridge()\n    external view returns (uint256) {\n        return _balances[CURRENCY][BRIDGE];\n    }\n\n    /** Change the ChainManager, which can deposit currency into any account.\n     *\n     * Only the current ChainManager is allowed to change the ChainManager.\n     */\n    function updateChildChainManager(address newChildChainManagerProxy)\n    external {\n        require(newChildChainManagerProxy != address(0), \"Bad ChildChainManagerProxy address\");\n        require(_msgSender() == childChainManagerProxy, \"Only the current ChainManager is allowed to change the ChainManager.\");\n\n        childChainManagerProxy = newChildChainManagerProxy;\n    }\n\n    /** Deposit currency from Ethereum into a user account in this contract.\n     *\n     * This is implemented by moving tokens from the bridge account to the user account.\n     *\n     * Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.\n     *\n     * There is an extra encoding necessary for the amount. In JavaScript, add this:\n     * `web3.eth.abi.encodeParameter('uint256', amount)`\n     */\n    function deposit(address user, bytes calldata depositData)\n    external {\n        require(_msgSender() == childChainManagerProxy, \"Only the ChainManager is allowed to deposit\");\n\n        uint256 amount = abi.decode(depositData, (uint256));\n\n        _forceTransferCurrency(BRIDGE, user, amount);\n\n        emit Transfer(BRIDGE, user, amount);\n    }\n\n    /** Withdraw currency from a user account in this contract to Ethereum.\n     *\n     * This is implemented by moving tokens from the user account to the bridge account.\n     *\n     * Two events will be emitted: ERC20 Transfer for the relayers, and ERC1155 TransferSingle like all transfers.\n     */\n    function withdraw(uint256 amount)\n    external {\n        address user = _msgSender();\n\n        _forceTransferCurrency(user, BRIDGE, amount);\n\n        emit Transfer(user, BRIDGE, amount);\n    }\n}\n\n/**\n- Issue NFTs.\n- Keep track of the address of the issuer of an NFT.\n- Enforce rules of issuance: the supply is fixed.\n\n##### Structure of an NFT\n\nThe following attributes of a type of NFT are immutable. They are used to derive the ID of the NFTs.\n- Issuer: the address of the issuer of this type of NFT.\n- Supply: how many NFT of this type exists.\n\n*/\nabstract contract Issuance is PolygonChildERC20 {\n    /** A counter of NFT types issued by each issuer.\n     * This is used to generate unique NFT IDs.\n     */\n    mapping(address => uint32) public issuanceNonces;\n\n    /** Issue a supply of NFTs of a new type, and return its ID.\n     *\n     * No more NFT of this type can be issued again.\n     *\n     * The caller will be recorded as the issuer and it will initially own the entire supply.\n     */\n    function issue(uint64 supply, bytes memory data)\n    public returns (uint256) {\n        return _issueAs(_msgSender(), supply, data);\n    }\n\n    /** Internal implementation of the function issue.\n     */\n    function _issueAs(address issuer, uint64 supply, bytes memory data)\n    internal returns (uint256) {\n        uint32 nonce = issuanceNonces[issuer];\n        issuanceNonces[issuer] = nonce + 1;\n\n        uint256 nftId = getNftId(issuer, nonce, supply);\n\n        require(supply > 0);\n        _mint(issuer, nftId, supply, data);\n\n        return nftId;\n    }\n\n    /** Return whether an address is the issuer of an NFT type.\n     *\n     * This does not imply that the NFTs exist.\n     */\n    function _isIssuer(address addr, uint256 nftId)\n    internal pure returns (bool) {\n        (address issuer, uint32 nonce, uint64 supply) = _parseNftId(nftId);\n        return addr == issuer;\n    }\n\n    /** Return whether the address is the issuer of an NFT type, and\n     * currently owns all NFT of this type (normally right after issuance).\n     */\n    function _isIssuerAndOnlyOwner(address addr, uint256 id)\n    internal view returns (bool) {\n        (address issuer, uint32 nonce, uint64 supply) = _parseNftId(id);\n        uint64 balance = uint64(balanceOf(issuer, id));\n\n        bool isIssuer = addr == issuer;\n        bool ownsAll = balance == supply;\n        return isIssuer && ownsAll;\n    }\n\n    /** Calculate the ID of an NFT type, identifying its issuer, its supply, and an arbitrary nonce.\n     */\n    function getNftId(address issuer, uint32 nonce, uint64 supply)\n    public pure returns (uint256) {\n        // issuer || nonce || supply: 160 + 32 + 64 = 256 bits\n        uint256 id = (uint256(uint160(issuer)) << (32 + 64))\n        | (uint256(nonce) << 64)\n        | uint256(supply);\n        return id;\n    }\n\n    /** Parse an NFT ID into its issuer, its supply, and an arbitrary nonce.\n     *\n     * This does not imply that the NFTs exist.\n     */\n    function _parseNftId(uint256 id)\n    internal pure returns (address issuer, uint32 nonce, uint64 supply) {\n        issuer = address(uint160((id & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000) >> (32 + 64)));\n        nonce = /*     */ uint32((id & 0x0000000000000000000000000000000000000000FFFFFFFF0000000000000000) >> 64);\n        supply = /*    */ uint64((id & 0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF));\n        return (issuer, nonce, supply);\n    }\n}\n\n/**\nA Joint Account (JA) is an account such that multiple owners have a claim on their respective share of the funds.\n\nJoint Accounts support the contract currency only. They cannot be used for NFTs.\n\nAn owner may be another Joint Account, or a smart contract.\nIt is possible to withdraw funds through nested JAs,\nbecause anyone can trigger a withdrawal from a JA to its owners,\nincluding if that owner is itself a JA.\n\n[An implementation that distributes to all owners at once.]\n*/\nabstract contract JointAccounts is Issuance {\n    /** The total fraction representing 100% of an account.\n     */\n    uint256 public BASIS_POINTS = 100 * 100;\n\n    uint256 public MAX_JOINT_ACCOUNT_SHARES = 10;\n\n    struct JointAccountShare {\n        address owner;\n        uint256 fraction;\n    }\n\n    mapping(address => JointAccountShare[]) public jointAccounts;\n\n    /** Notify that a Joint Account was created at the address `account`.\n     *\n     * One such event is emitted for each owner, including his fraction of the account in basis points (1% of 1%).\n     */\n    event JointAccountShareCreated(\n        address indexed account,\n        address indexed owner,\n        uint256 fraction);\n\n    /** Create an account such that multiple owners have a claim on their respective share.\n     *\n     * The size of a share is given as a fraction in basis points (1% of 1%). The sum of share fractions must equal 10,000.\n     *\n     * Anyone can create Joint Accounts including any owners.\n     */\n    function createJointAccount(address[] memory owners, uint256[] memory fractions)\n    public returns (address) {\n        require(owners.length == fractions.length, \"Arrays of owners and fractions must have the same length\");\n        require(owners.length <= MAX_JOINT_ACCOUNT_SHARES, \"Too many shares\");\n\n        address account = makeAddressOfJointAccount(owners, fractions);\n        JointAccountShare[] storage newShares = jointAccounts[account];\n\n        require(newShares.length == 0, \"The account already exists\");\n\n        uint256 totalFraction = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            address owner = owners[i];\n            uint256 fraction = fractions[i];\n            require(owner != address(0) && fraction != 0, \"0 values are not permitted\");\n\n            newShares.push(JointAccountShare({owner : owner, fraction : fraction}));\n            totalFraction += fraction;\n\n            emit JointAccountShareCreated(account, owner, fraction);\n        }\n        require(totalFraction == BASIS_POINTS, \"Total fractions must be 10,000\");\n\n        return account;\n    }\n\n    /** Distribute all tokens available to all owners of a Joint Account.\n     *\n     * The function createJointAccount must be called beforehand.\n     *\n     * Anyone can trigger the distribution.\n     */\n    function distributeJointAccount(address account)\n    public {\n        uint accountBalance = balanceOf(account, CURRENCY);\n        JointAccountShare[] storage shares = jointAccounts[account];\n\n        for (uint i = 0; i < shares.length; i++) {\n            JointAccountShare storage share = shares[i];\n            uint256 ownerBalance = accountBalance * share.fraction / BASIS_POINTS;\n\n            _forceTransferCurrency(account, share.owner, ownerBalance);\n        }\n    }\n\n    /** Generate a unique address identifying a list of owners and shares.\n     *\n     * It may be used to predict the address of a Joint Account and receive payments\n     * even before calling the function createJointAccount.\n     */\n    function makeAddressOfJointAccount(address[] memory owners, uint256[] memory fractions)\n    public pure returns (address) {\n        bytes32 hash = keccak256(abi.encodePacked(owners, fractions));\n        return address(bytes20(hash));\n    }\n\n    /** Return the fraction of an account owned by the given address, in basis points (1% of 1%).\n     *\n     * If the account does not exist, or if the given address is not an owner of it, this returns 0.\n     * If the owner appears more than once in the account, this reports only the first share.\n     */\n    function fractionOfJAOwner(address account, address maybeOwner)\n    public view returns (uint) {\n        JointAccountShare[] storage shares = jointAccounts[account];\n\n        for (uint256 i = 0; i < shares.length; i++) {\n            JointAccountShare storage share = shares[i];\n            if (share.owner == maybeOwner) {\n                return share.fraction;\n            }\n        }\n        return 0;\n    }\n\n    /** Calculate the amount of tokens that an owner of a Joint Account can withdraw right now.\n     */\n    function balanceOfJAOwner(address account, address owner)\n    public view returns (uint256) {\n        uint fraction = fractionOfJAOwner(account, owner);\n        uint accountBalance = balanceOf(account, CURRENCY);\n        uint256 ownerBalance = accountBalance * fraction / BASIS_POINTS;\n        return ownerBalance;\n    }\n\n}\n\n/**\n- Hold configuration of NFTs: services, royalties.\n- Capture royalties on primary and secondary transfers.\n- Report configured royalties to service providers (supports Joint Accounts).\n */\nabstract contract TransferFees is JointAccounts {\n\n    bytes32 public constant BYPASS_SENDER = keccak256(\"BYPASS_SENDER\");\n\n    // Royalties configurable per NFT by issuers.\n    mapping(uint256 => address) primaryRoyaltyAccounts;\n    mapping(uint256 => uint256) primaryRoyaltyCuts;\n    mapping(uint256 => uint256) primaryRoyaltyMinimums;\n    mapping(uint256 => address) secondaryRoyaltyAccounts;\n    mapping(uint256 => uint256) secondaryRoyaltyCuts;\n    mapping(uint256 => uint256) secondaryRoyaltyMinimums;\n    mapping(uint256 => uint256) royaltiesConfigLockedUntil;\n\n    /** Notify that royalties were configured on an NFT type.\n     */\n    event RoyaltiesConfigured(\n        uint256 indexed nftId,\n        address primaryRoyaltyAccount,\n        uint256 primaryRoyaltyCut,\n        uint256 primaryRoyaltyMinimum,\n        address secondaryRoyaltyAccount,\n        uint256 secondaryRoyaltyCut,\n        uint256 secondaryRoyaltyMinimum);\n\n    /** Notify that royalties are locked and cannot change, until the given time (in UNIX seconds),\n     * or forever (lockUntil = 0xFFFFFFFF).\n     */\n    event RoyaltiesLocked(\n        uint256 indexed nftId,\n        uint256 lockUntil);\n\n    /** Return the current configuration of royalties for NFTs of type nftId, as set by configureRoyalties.\n     */\n    function getRoyalties(uint256 nftId)\n    public view returns (\n        address primaryRoyaltyAccount,\n        uint256 primaryRoyaltyCut,\n        uint256 primaryRoyaltyMinimum,\n        address secondaryRoyaltyAccount,\n        uint256 secondaryRoyaltyCut,\n        uint256 secondaryRoyaltyMinimum\n    ) {\n        return (primaryRoyaltyAccounts[nftId], primaryRoyaltyCuts[nftId], primaryRoyaltyMinimums[nftId],\n        secondaryRoyaltyAccounts[nftId], secondaryRoyaltyCuts[nftId], secondaryRoyaltyMinimums[nftId]);\n    }\n\n    /** Return the amount of royalties earned by a beneficiary on each primary and secondary transfer of an NFT.\n     *\n     * This function supports Joint Accounts. If royalties are paid to a JA and beneficiary is an owner of the JA,\n     * the shares of the royalties for this owner are returned.\n     */\n    function getRoyaltiesForBeneficiary(uint256 nftId, address beneficiary)\n    public view returns (uint256 primaryCut, uint256 primaryMinimum, uint256 secondaryCut, uint256 secondaryMinimum) {\n\n        // If the royalty account is the given beneficiary, return the configured fees.\n        // Otherwise, the royalty account may be a Joint Account, and the beneficiary a share owner of it.\n        // Otherwise, \"fraction\" will be 0, and 0 values will be returned.\n\n        // Primary royalties.\n        primaryCut = primaryRoyaltyCuts[nftId];\n        primaryMinimum = primaryRoyaltyMinimums[nftId];\n        address primaryAccount = primaryRoyaltyAccounts[nftId];\n        if (primaryAccount != beneficiary) {\n            uint256 fraction = fractionOfJAOwner(primaryAccount, beneficiary);\n            primaryCut = primaryCut * fraction / BASIS_POINTS;\n            primaryMinimum = primaryMinimum * fraction / BASIS_POINTS;\n        }\n\n        // Secondary royalties.\n        secondaryCut = secondaryRoyaltyCuts[nftId];\n        secondaryMinimum = secondaryRoyaltyMinimums[nftId];\n        address secondaryAccount = secondaryRoyaltyAccounts[nftId];\n        if (secondaryAccount != beneficiary) {\n            uint256 fraction = fractionOfJAOwner(secondaryAccount, beneficiary);\n            secondaryCut = secondaryCut * fraction / BASIS_POINTS;\n            secondaryMinimum = secondaryMinimum * fraction / BASIS_POINTS;\n        }\n\n        return (primaryCut, primaryMinimum, secondaryCut, secondaryMinimum);\n    }\n\n    /** Configure the amounts and beneficiaries of royalties on primary and secondary transfers of this NFT.\n     * This configuration is available to the issuer of this NFT.\n     *\n     * A transfer is primary if it comes from the issuer of this NFT (normally the first sale after issuance).\n     * Otherwise, it is a secondary transfer.\n     *\n     * A royalty is defined in two parts (both optional):\n     * a cut of the sale price of an NFT, and a minimum royalty per transfer.\n     * For simple transfers not attached to a price, or a too low price, the minimum royalty is charged.\n     *\n     * The cuts are given in basis points (1% of 1%). The minimums are given in currency amounts.\n     *\n     * The configuration can be changed at any time by default. However, the issuer may commit to it for a period of time,\n     * effectively giving up his ability to modify the royalties. See the function lockRoyalties.\n     *\n     * There can be one beneficiary account for each primary and secondary royalties. To distribute revenues amongst\n     * several parties, use a Joint Account (see function createJointAccount).\n     */\n    function configureRoyalties(\n        uint256 nftId,\n        address primaryRoyaltyAccount,\n        uint256 primaryRoyaltyCut,\n        uint256 primaryRoyaltyMinimum,\n        address secondaryRoyaltyAccount,\n        uint256 secondaryRoyaltyCut,\n        uint256 secondaryRoyaltyMinimum)\n    public {\n        address issuer = _msgSender();\n        require(_isIssuer(issuer, nftId), \"Only the issuer of this NFT can set royalties\");\n        require(block.timestamp >= royaltiesConfigLockedUntil[nftId], \"Royalties configuration is locked for now\");\n\n        require(primaryRoyaltyAccount != address(0) || (primaryRoyaltyCut == 0 && primaryRoyaltyMinimum == 0),\n            \"The account must not be 0, unless fees are 0\");\n        primaryRoyaltyAccounts[nftId] = primaryRoyaltyAccount;\n        primaryRoyaltyCuts[nftId] = primaryRoyaltyCut;\n        primaryRoyaltyMinimums[nftId] = primaryRoyaltyMinimum;\n\n        require(secondaryRoyaltyAccount != address(0) || (secondaryRoyaltyCut == 0 && secondaryRoyaltyMinimum == 0),\n            \"The account must not be 0, unless fees are 0\");\n        secondaryRoyaltyAccounts[nftId] = secondaryRoyaltyAccount;\n        secondaryRoyaltyCuts[nftId] = secondaryRoyaltyCut;\n        secondaryRoyaltyMinimums[nftId] = secondaryRoyaltyMinimum;\n\n        emit RoyaltiesConfigured(\n            nftId,\n            primaryRoyaltyAccount,\n            primaryRoyaltyCut,\n            primaryRoyaltyMinimum,\n            secondaryRoyaltyAccount,\n            secondaryRoyaltyCut,\n            secondaryRoyaltyMinimum);\n    }\n\n    /** Lock the configuration of royalties for this NFT type. Only the issuer may lock the configuration,\n     * after which he himself will no longer be able to change the configuration, for some time, or forever.\n     *\n     * Set lockUntil to a time in the future to lock the configuration until the specified time (in UNIX seconds).\n     * Set to 0xFFFFFFFF to lock forever.\n     */\n    function lockRoyalties(\n        uint256 nftId,\n        uint256 lockUntil)\n    public {\n        address issuer = _msgSender();\n        require(_isIssuer(issuer, nftId));\n\n        require(lockUntil > royaltiesConfigLockedUntil[nftId], \"Royalties configuration cannot be unlocked earlier\");\n        royaltiesConfigLockedUntil[nftId] = lockUntil;\n\n        emit RoyaltiesLocked(nftId, lockUntil);\n    }\n\n    /** Internal hook to trigger the collection of royalties due on a batch of transfers.\n     *\n     * The role BYPASS_SENDER does not pay royalties. This is intended to be used by a privileged service that allows users to make simple non-sale transfers.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data)\n    internal override {\n        // Pay a fee per transfer to a beneficiary, if any.\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            _captureFee(from, tokenIds[i], /*price*/ 0, amounts[i]);\n        }\n    }\n\n    /** Collect the royalty due on a transfer.\n     *\n     * The royalty is calculated based on NFT configuration and the price. It is collected by an internal transfer of currency between \"from\" and the beneficiary. Return the amount collected.\n     *\n     * The caller must be approved by \"from\", or a TRANSFER_OPERATOR.\n     */\n    function captureFee(address from, uint256 nftId, uint256 price, uint256 amount)\n    public returns (uint256) {\n        address operator = _msgSender();\n        require(isApprovedForAll(from, operator), \"the operator must be approved or a TRANSFER_OPERATOR\");\n        return _captureFee(from, nftId, price, amount);\n    }\n\n    /** Collect the royalty due on a transfer.\n     *\n     * The royalty is calculated based on NFT configuration and the price. It is collected by an internal transfer of currency between \"from\" and the beneficiary. Return the amount collected.\n     */\n    function _captureFee(address from, uint256 nftId, uint256 price, uint256 amount)\n    internal returns (uint256) {\n        if (nftId == CURRENCY) return 0;\n\n        // An account with bypass role does not pay royalties.\n        // This uses msg.sender which is supposed to be a transaction relayer,\n        // instead of _msgSender() which is the user wishing to transfer his tokens.\n        if (hasRole(BYPASS_SENDER, msg.sender)) return 0;\n\n        uint256 cut;\n        uint256 minimum;\n        address royaltyAccount;\n        bool isPrimary = _isPrimaryTransfer(from, nftId);\n        if (isPrimary) {\n            cut = primaryRoyaltyCuts[nftId];\n            minimum = primaryRoyaltyMinimums[nftId];\n            royaltyAccount = primaryRoyaltyAccounts[nftId];\n        } else {\n            cut = secondaryRoyaltyCuts[nftId];\n            minimum = secondaryRoyaltyMinimums[nftId];\n            royaltyAccount = secondaryRoyaltyAccounts[nftId];\n        }\n\n        uint256 perTransferFee = price * cut / BASIS_POINTS;\n        if (perTransferFee < minimum) perTransferFee = minimum;\n\n        uint256 totalFee = perTransferFee * amount;\n        if (totalFee != 0) {\n            _forceTransferCurrency(from, royaltyAccount, totalFee);\n        }\n\n        return totalFee;\n    }\n\n    /** Determine whether a transfer is primary (true) or secondary (false).\n     *\n     * See the function setRoyalties.\n     */\n    function _isPrimaryTransfer(address from, uint256 nftId)\n    internal pure returns (bool) {\n        (address issuer, uint32 nonce, uint64 supply) = _parseNftId(nftId);\n        return from == issuer;\n    }\n\n}\n\n\n/**\n- Make offers to sell NFTs.\n- Accept offer.\n- Capture variable royalties.\n */\nabstract contract SimpleExchange is TransferFees {\n\n    /** Seller => NFT ID => Price.\n     */\n    mapping(address => mapping(uint256 => uint256)) sellerNftPriceOffers;\n\n    /** An event emitted when an account `seller` has offered to sell a type of NFT\n     * at a given price.\n     *\n     * This replaces previous offers by the same seller on the same NFT ID, if any.\n     * A price of 0 means \"no offer\" and the previous offer is cancelled.\n     *\n     * An offer does not imply that the seller owns any amount of this NFT.\n     * An offer remains valid until cancelled, for the entire balance at a given time,\n     * regardless of incoming and outgoing transfers on the seller account.\n     */\n    event MakeOffer(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price);\n\n    /** An offer of `seller` was taken by `buyer`.\n     * The transfers of `amount` NFTs of type `nftId`\n     * against `amount * price` of CERE Units were executed.\n     */\n    event TakeOffer(\n        address indexed buyer,\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 amount);\n\n    /** Create an offer to sell a type of NFTs for a price per unit.\n     * All the NFTs of this type owned by the caller will be for sale.\n     *\n     * To cancel, call again with a price of 0.\n     */\n    function makeOffer(uint256 nftId, uint256 price)\n    public {\n        address seller = _msgSender();\n        sellerNftPriceOffers[seller][nftId] = price;\n\n        emit MakeOffer(seller, nftId, price);\n    }\n\n    /** Return the price offered by the given seller for the given NFT type.\n     */\n    function getOffer(address seller, uint256 nftId)\n    public view returns (uint256) {\n        uint price = sellerNftPriceOffers[seller][nftId];\n        return price;\n    }\n\n    /** Accept an offer, paying the price per unit for an amount of NFTs.\n     *\n     * The offer must have been created beforehand by makeOffer.\n     *\n     * The same authorization as safeTransferFrom apply to the buyer (sender or approved operator).\n     *\n     * The parameter expectedPriceOrZero can be used to validate the price that the buyer expects to pay. This prevents\n     * a race condition with makeOffer or setExchangeRate. Pass 0 to disable this validation and accept any current price.\n     */\n    function takeOffer(address buyer, address seller, uint256 nftId, uint256 expectedPriceOrZero, uint256 amount)\n    public {\n        // Check and update the amount offered.\n        uint256 price = sellerNftPriceOffers[seller][nftId];\n        require(price != 0, \"Not for sale\");\n        require(expectedPriceOrZero == 0 || expectedPriceOrZero == price, \"Unexpected price\");\n\n        // Pay. This verifies the intent of the buyer.\n        uint totalPrice = price * amount;\n        safeTransferFrom(buyer, seller, CURRENCY, totalPrice, \"\");\n\n        // Take a fee from the seller (really a cut of the above payment).\n        uint totalFee = _captureFee(seller, nftId, price, amount);\n        require(totalFee <= totalPrice, \"Cannot take more fees than the price.\");\n\n        // Move the NFTs to the buyer.\n        _forceTransfer(seller, buyer, nftId, amount);\n\n        emit TakeOffer(buyer, seller, nftId, price, amount);\n    }\n\n    /** Guarantee that a version of Solidity with safe math is used.\n     */\n    function _mathIsSafe() internal pure {\n    unchecked {} // Use a keyword from Solidity 0.8.0.\n    }\n}\n\n/** Main contract, including all components.\n\n- Hold and transfer NFTs using ERC1155.\n- Support atomic exchanges of NFTs for currency.\n- Issuance of NFTs with fixed supply.\n- Joint Accounts that distribute their funds over multiple owners.\n- Capture royalties on primary and secondary transfers, configurable per NFT type.\n*/\ncontract Davinci is /*\n    ERC1155,\n    AccessControl,\n    MetaTxContext,\n    BaseNFT,\n    Currency,\n    TransferOperator,\n    PolygonChildERC20,\n    Issuance,\n    JointAccounts,\n    TransferFees,\n    */ SimpleExchange {\n\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n\n\n/**\nAn auction is characterized by a sequence of transactions and their corresponding events:\n\n- `StartAuction`: A seller offers to sell one NFT to the highest bidder, with a minimum price, and a closing time.\n\n- Any number of `BidOnAuction`: A potential buyer accepts the minimum price or a price at least 10% higher\nthan that of the previous bidder.\nThe closing time may be extended.\nA deposit is taken from the new bidder. The deposit of the previous bidder is returned, if any.\nBidding is no longer possible after the closing time.\n\n- `SettleAuction`: The sale is completed between the seller and the highest bidder, or cancelled if there was no bidder.\nSome royalties may be taken from the sale price, as configured by the NFT creator (see `TransferFees.sol`).\nThe settlement is only possible after the closing time.\n\nWhile an auction is active, it is identified by the tuple `(seller address, NFT ID)`.\nHowever, after the auction is settled, a new auction with the *same tuple* may start.\n */\ncontract SimpleAuction is /* AccessControl, */ MetaTxContext, ERC1155Holder {\n\n    /** Supports interfaces of AccessControl and ERC1155Receiver.\n     */\n    function supportsInterface(bytes4 interfaceId)\n    public view virtual override(AccessControl, ERC1155Receiver) returns (bool) {\n        return AccessControl.supportsInterface(interfaceId)\n        || ERC1155Receiver.supportsInterface(interfaceId);\n    }\n\n    Davinci public davinci;\n\n    /** This contract must have the TRANSFER_OPERATOR role in the Davinci contract.\n     */\n    constructor(Davinci _davinci) {\n        davinci = _davinci;\n    }\n\n    /** The token ID that represents the CERE currency for all payments in this contract. */\n    uint256 public constant CURRENCY = 0;\n\n    struct Bid {\n        address buyer; // 0 means no buyer yet.\n        uint256 price; // The highest bid price. The initial value is set by the seller.\n        uint256 closeTimeSec; // Bidding is open until the close time. After this time, the settlement becomes possible. A non-zero value also means that the auction exists.\n    }\n\n    /** Seller => NFT ID => Bid.\n     */\n    mapping(address => mapping(uint256 => Bid)) public sellerNftBids;\n\n    /**\n     * Note: `price` is the minimum price minus 10%, because a bid must be 10% higher, resulting in the requested minimum price.\n     */\n    event StartAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec);\n\n    /**\n     * Note: `price`, `closeTimeSec`, and `buyer` may have changed for the auction `(seller, nftId)`.\n     */\n    event BidOnAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        uint256 closeTimeSec,\n        address buyer);\n\n    /**\n     * Note: `buyer == 0` means no buyer, and the NFT went back to the seller.\n     */\n    event SettleAuction(\n        address indexed seller,\n        uint256 indexed nftId,\n        uint256 price,\n        address buyer);\n\n    /**\n     */\n    function startAuction(uint256 nftId, uint256 minPrice, uint closeTimeSec)\n    public {\n        address seller = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction does not exist.\n        require(bid.closeTimeSec == 0, \"the auction must not exist\");\n\n        // Check that the close time is non-zero and in the future.\n        require(block.timestamp < closeTimeSec, \"the close time must be in the future\");\n\n        // Deduct the minimum increment to work with the logic of minPrice in the function bid().\n        uint256 price = minPrice * 100 / 110;\n        require(price > 0, \"the starting price must be greater than 0\");\n\n        // TODO: Check that minPrice is greater than the fixed royalty, if any.\n\n        // Create the auction.\n        bid.buyer = address(0);\n        bid.price = price;\n        bid.closeTimeSec = closeTimeSec;\n\n        // Take the NFT from the seller.\n        davinci.safeTransferFrom(seller, address(this), nftId, 1, \"\");\n\n        emit StartAuction(seller, nftId, price, closeTimeSec);\n    }\n\n    /**\n     */\n    function bidOnAuction(address seller, uint256 nftId, uint256 price)\n    public {\n        address buyer = _msgSender();\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists and is open.\n        require(block.timestamp < bid.closeTimeSec, \"the auction must be open\");\n\n        // Push back the end of the auction if it is too close.\n        if (bid.closeTimeSec < block.timestamp + 10 * 60) {\n            bid.closeTimeSec += 10 * 60;\n        }\n\n        // Check that the new bid is sufficiently large.\n        uint256 previousDeposit = bid.price;\n        uint minPrice = previousDeposit * 110 / 100;\n        require(price >= minPrice, \"a new bid must be 10% greater than the current bid\");\n\n        // Refund the previous buyer.\n        address previousBuyer = bid.buyer;\n        if (previousBuyer != address(0)) {\n            davinci.safeTransferFrom(address(this), previousBuyer, CURRENCY, previousDeposit, \"\");\n        }\n\n        // Take the new deposit from the new buyer.\n        bid.buyer = buyer;\n        bid.price = price;\n        davinci.safeTransferFrom(buyer, address(this), CURRENCY, price, \"\");\n\n        emit BidOnAuction(seller, nftId, price, bid.closeTimeSec, buyer);\n    }\n\n    function settleAuction(address seller, uint256 nftId)\n    public {\n        Bid storage bid = sellerNftBids[seller][nftId];\n\n        // Check that the auction exists.\n        require(bid.closeTimeSec != 0, \"the auction must exist\");\n\n        // Check that the auction is closed.\n        require(bid.closeTimeSec <= block.timestamp, \"the auction must be closed\");\n\n        address buyer = bid.buyer;\n        uint256 price = bid.price;\n\n        // Reset the storage. Make the auction not exist anymore.\n        bid.buyer = address(0);\n        bid.price = 0;\n        bid.closeTimeSec = 0;\n\n        if (buyer != address(0)) {\n            // In case there was a buyer,\n            // transfer the payment to the seller.\n            davinci.safeTransferFrom(address(this), seller, CURRENCY, price, \"\");\n\n            // Transfer the NFT to the buyer.\n            davinci.safeTransferFrom(address(this), buyer, nftId, 1, \"\");\n\n            // Collect royalty.\n            davinci.captureFee(seller, nftId, price, 1);\n        } else {\n            // Otherwise, there was no buyer,\n            // give back the NFT to the seller.\n            davinci.safeTransferFrom(address(this), seller, nftId, 1, \"\");\n        }\n\n        emit SettleAuction(seller, nftId, price, buyer);\n    }\n}\n", "commit_id": "f1405e5eab1f0263b4d8a1f01bdf46f5713d6052"}}