{"filename": "auction_improve.sol", "patch": "@@ -0,0 +1,121 @@\n+pragma solidity ^0.5.1; \n+\n+contract Auction_product{\n+    enum AuctionState{running ,cancelled , ended}\n+    AuctionState public state;\n+    \n+    address payable owner;\n+    uint public startingPrice=1;\n+    uint public highestBid;\n+    address payable highestBidder;\n+    uint countOfProduct;\n+    mapping(address => uint) pendingReturns;\n+    \n+    event HighestBidIncreased(address bidder, uint amount);\n+    event AuctionEnded(address winner, uint amount);\n+    uint public count;\n+    \n+    \n+    struct Product{\n+        uint id;\n+        string name;\n+        address payable vendor;\n+        uint price;\n+        bool complete;\n+        uint approvalCount;\n+    }\n+    Product[] allProduct;\n+    \n+    constructor() public{\n+        state=AuctionState.running;\n+        owner=msg.sender;\n+    }\n+    \n+    modifier onlyOwner(){\n+        require(msg.sender== owner);\n+        _;\n+    }\n+    \n+     function addProduct(string memory _name, uint _price,address payable _vendor) public onlyOwner{\n+        Product memory newproduct = Product({\n+            id : countOfProduct,\n+            name : _name,\n+            vendor : _vendor,\n+            price : _price,\n+            complete: true,\n+            approvalCount: 0\n+        });\n+        allProduct.push(newproduct);\n+        countOfProduct++;\n+    }\n+    \n+    mapping(address => bool) bidders;\n+    \n+    function bid() public payable{\n+        require(state == AuctionState.running, \"Auction closed/cancelled\");\n+        require(msg.sender!=owner,\"Owner can't buy this product\");\n+        uint temp= pendingReturns[msg.sender]+msg.value;\n+        require(temp>=startingPrice && temp>highestBid);\n+        highestBid=temp;\n+        highestBidder=msg.sender;\n+        pendingReturns[msg.sender] = temp;\n+        emit HighestBidIncreased(msg.sender, temp);\n+        bidders[msg.sender]=true;\n+        count++;\n+    }\n+    \n+    \n+    \n+    function withdraw() internal {\n+        uint amount = pendingReturns[msg.sender];\n+        require(amount > 0);\n+        if (state == AuctionState.cancelled) {\n+            safeWithdraw();\n+        } else {\n+            require(msg.sender != highestBidder);\n+            safeWithdraw();\n+        }\n+        pendingReturns[msg.sender] = 0;\n+    }\n+    \n+    function safeWithdraw() internal {\n+        uint amount = pendingReturns[msg.sender];\n+        msg.sender.transfer(amount);\n+    }\n+    \n+    function auctionEnd() public {\n+        require(msg.sender == owner);\n+        require(state==AuctionState.running);\n+        safeauctionEnd();\n+        emit AuctionEnded(highestBidder, highestBid);\n+        state=AuctionState.ended;\n+    }\n+    \n+    function safeauctionEnd() internal{\n+        address(owner).transfer(highestBid);\n+    }\n+    \n+    function auctionCancel() public{\n+        require(msg.sender == owner);\n+        state=AuctionState.cancelled;\n+    }\n+    mapping(address => mapping(string => bool)) checkBidder;\n+    \n+    function approve(string memory nameOfproduct, uint id) public{\n+        require(bidders[msg.sender]==true);\n+        require(checkBidder[msg.sender][nameOfproduct]==false);\n+        allProduct[id].approvalCount++;\n+        allProduct[id].complete = true;\n+    }\n+    \n+    function buy(uint id) public payable {\n+        require(msg.value >= allProduct[id].price);\n+        address(allProduct[id].vendor).transfer(msg.value);\n+    }\n+    \n+    function approveBuy(uint id) public onlyOwner{\n+        require(allProduct[id].approvalCount > (count/2));\n+        buy(id);\n+    }\n+    \n+}\n\\ No newline at end of file", "project_link": "https://github.com/Vishal1010101/Solidity_programs/commit/0936965eb195ddc586274a93b24e6fb0a62030f8", "bug_version": {"raw_code": "", "commit_id": "c9bd7666f6a43da4afb64e020779ac774c695521"}, "fixed_version": {"raw_code": "pragma solidity ^0.5.1; \n\ncontract Auction_product{\n    enum AuctionState{running ,cancelled , ended}\n    AuctionState public state;\n    \n    address payable owner;\n    uint public startingPrice=1;\n    uint public highestBid;\n    address payable highestBidder;\n    uint countOfProduct;\n    mapping(address => uint) pendingReturns;\n    \n    event HighestBidIncreased(address bidder, uint amount);\n    event AuctionEnded(address winner, uint amount);\n    uint public count;\n    \n    \n    struct Product{\n        uint id;\n        string name;\n        address payable vendor;\n        uint price;\n        bool complete;\n        uint approvalCount;\n    }\n    Product[] allProduct;\n    \n    constructor() public{\n        state=AuctionState.running;\n        owner=msg.sender;\n    }\n    \n    modifier onlyOwner(){\n        require(msg.sender== owner);\n        _;\n    }\n    \n     function addProduct(string memory _name, uint _price,address payable _vendor) public onlyOwner{\n        Product memory newproduct = Product({\n            id : countOfProduct,\n            name : _name,\n            vendor : _vendor,\n            price : _price,\n            complete: true,\n            approvalCount: 0\n        });\n        allProduct.push(newproduct);\n        countOfProduct++;\n    }\n    \n    mapping(address => bool) bidders;\n    \n    function bid() public payable{\n        require(state == AuctionState.running, \"Auction closed/cancelled\");\n        require(msg.sender!=owner,\"Owner can't buy this product\");\n        uint temp= pendingReturns[msg.sender]+msg.value;\n        require(temp>=startingPrice && temp>highestBid);\n        highestBid=temp;\n        highestBidder=msg.sender;\n        pendingReturns[msg.sender] = temp;\n        emit HighestBidIncreased(msg.sender, temp);\n        bidders[msg.sender]=true;\n        count++;\n    }\n    \n    \n    \n    function withdraw() internal {\n        uint amount = pendingReturns[msg.sender];\n        require(amount > 0);\n        if (state == AuctionState.cancelled) {\n            safeWithdraw();\n        } else {\n            require(msg.sender != highestBidder);\n            safeWithdraw();\n        }\n        pendingReturns[msg.sender] = 0;\n    }\n    \n    function safeWithdraw() internal {\n        uint amount = pendingReturns[msg.sender];\n        msg.sender.transfer(amount);\n    }\n    \n    function auctionEnd() public {\n        require(msg.sender == owner);\n        require(state==AuctionState.running);\n        safeauctionEnd();\n        emit AuctionEnded(highestBidder, highestBid);\n        state=AuctionState.ended;\n    }\n    \n    function safeauctionEnd() internal{\n        address(owner).transfer(highestBid);\n    }\n    \n    function auctionCancel() public{\n        require(msg.sender == owner);\n        state=AuctionState.cancelled;\n    }\n    mapping(address => mapping(string => bool)) checkBidder;\n    \n    function approve(string memory nameOfproduct, uint id) public{\n        require(bidders[msg.sender]==true);\n        require(checkBidder[msg.sender][nameOfproduct]==false);\n        allProduct[id].approvalCount++;\n        allProduct[id].complete = true;\n    }\n    \n    function buy(uint id) public payable {\n        require(msg.value >= allProduct[id].price);\n        address(allProduct[id].vendor).transfer(msg.value);\n    }\n    \n    function approveBuy(uint id) public onlyOwner{\n        require(allProduct[id].approvalCount > (count/2));\n        buy(id);\n    }\n    \n}", "commit_id": "0936965eb195ddc586274a93b24e6fb0a62030f8"}}