{"filename": "contracts/utils/Reentrancy.sol", "patch": "@@ -12,7 +12,7 @@ contract ReEntrancy {\n     }\n \n     function attack(bytes32 _swapID, bytes32 _secretKey) external {\n-        _htlcEth.issuerWithdrawal(_swapID, _secretKey);\n+        htlcEth.issuerWithdrawal(_swapID, _secretKey);\n     }\n  \n }\n\\ No newline at end of file", "project_link": "https://github.com/dami777/security-token/commit/854f8468bb7f2712623a167f67102f48edbf125d", "bug_version": {"raw_code": "pragma solidity 0.8.10;\n\nimport \"../htlc/HTLC_ETH.sol\";\n\n\ncontract ReEntrancy {\n\n    HTLC_ETH htlcEth;\n\n    constructor(address _htlcEth) {\n        htlcEth = HTLC_ETH(_htlcEth);\n    }\n\n    function attack(bytes32 _swapID, bytes32 _secretKey) external {\n        _htlcEth.issuerWithdrawal(_swapID, _secretKey);\n    }\n \n}", "flattened_code": "pragma solidity 0.8.10;\n\n/// @title  HTLC to release ETH from investor to issuer\n/// @dev    Contract for DVP. Investor funds this contract with his ETH and gets the security token in exchange.\n\npragma solidity 0.8.10;\n\npragma solidity 0.8.10;\n\n\nlibrary OrderLibrary {\n\n    struct OrderSwap {\n\n        \n        address _recipient;\n        address _investor;\n        uint256 _price;\n        uint256 _amount;\n        uint256 _expiration;\n        bytes32 _secretHash;\n        bytes32 _secretKey;\n        bytes32 _swapID;\n        bytes32 _partition;\n        bool _funded;\n        \n    }\n\n\n    enum SwapState {\n\n        INVALID,\n        OPEN,\n        CLOSED,\n        EXPIRED\n\n    }\n\n}\n\ncontract HTLC_ETH {\n\n\n   fallback () external {\n\n    }\n\n    address private _owner;\n\n    mapping(bytes32 => OrderLibrary.OrderSwap) private _orderSwap;      //  map the order struct to the order ID\n    mapping(bytes32 => OrderLibrary.SwapState) private _swapState;      //  to keep track of the swap state of an id\n    constructor () {\n\n        _owner = msg.sender;\n\n    }\n\n    /// @dev    Issuer initializes the order with the same orderID in the htlc1400 contract\n    /// @dev    The issuer uses the ID to withdraw USDT from this contract, while the investor uses the ID to withdraw from the htlc1400 contract\n    /// @param  _swapID is the ID of the swap order. This ID must be valid on the htlc1400 contract for swap to occur\n    /// @param _investor is the address that will fund this contract with the given _swapID\n    /// @param  _price is the price of the security token to be purchased. This contract is funded by investor for this particular order\n    /// @param _expiration is the time expected for this order to expire before a refund can enabled\n    /// @param _secretHash is the hash of the secret set on this contract and htlc1400 for this particular swap ID\n\n    function openOrder(bytes32 _swapID, address _investor, uint256 _price, uint256 _amount, uint256 _expiration, bytes32 _secretHash, bytes32 _secretKey, bytes32 _partition) external {\n\n        require(msg.sender == _owner, \"invalid caller\");\n        require(_swapState[_swapID] == OrderLibrary.SwapState.INVALID, \"this order id exist already\");\n        require( _secretHash == sha256(abi.encode(_secretKey)), \"the secret doesn't match the hash\");\n        _orderSwap[_swapID] = OrderLibrary.OrderSwap(msg.sender, _investor, _price, _amount, _expiration, _secretHash, bytes32(0), _swapID, _partition, false);\n        _swapState[_swapID] = OrderLibrary.SwapState.OPEN;\n        emit OpenedOrder(_investor, _swapID, _partition, _amount, _price, _expiration, _secretHash);\n\n    }\n\n\n    /// @param _swapID is the id of the order to be funded\n    /// @notice `_orderSwap[_swapID]._funded == false`, i.e the order must not be funded yet\n    /// @notice `_swapState[_swapID] == OrderLibrary.SwapState.OPEN` ,  i.e the order state must be opened\n    /// @dev this contract must be approved by the caller before calling this function\n\n    function fundOrder(bytes32 _swapID) payable external {\n\n        require(_swapState[_swapID] == OrderLibrary.SwapState.OPEN, \"this order isn't opened\");\n        require(_orderSwap[_swapID]._funded == false, \"this order has been funded\");\n        require(_orderSwap[_swapID]._investor == msg.sender, \"invalid caller\");\n        require(_orderSwap[_swapID]._price == msg.value, \"invalid amount\");\n        OrderLibrary.OrderSwap memory _order = _orderSwap[_swapID];\n        _orderSwap[_swapID]._funded = true;\n        emit Funded(_order._investor, _order._partition, _order._amount, _order._price);\n\n    }\n\n\n    /// @param _swapID is the id of the order to withdrawn the usdt from\n    /// @param _secretKey is the secret the issuer must provide and reveal to the investor. The investor will in turn use this secret to withdraw the security token from the htlc1400 contract\n    /// @notice the caller is the owner of the contract\n    /// @notice the order must be OPEN\n    /// @notice the order must not be an expired order\n    /// @notice the hash of the secretKey must equal the hash in the order\n\n    function issuerWithdrawal(bytes32 _swapID, bytes32 _secretKey) external {\n\n        //require(msg.sender == _owner, \"invalid caller\");\n        //require(_swapState[_swapID] == OrderLibrary.SwapState.OPEN, \"this order is not opened\");\n        //require(_orderSwap[_swapID]._funded == true, \"this order has not been funded\");\n        OrderLibrary.OrderSwap memory _order = _orderSwap[_swapID];\n        require(block.timestamp < _order._expiration, \"order has expired\");\n        require(sha256(abi.encode(_secretKey)) == _order._secretHash, \"invalid secret\"); \n        payable(msg.sender).transfer(_order._price);\n        _orderSwap[_swapID]._secretKey = _secretKey;\n        _swapState[_swapID] = OrderLibrary.SwapState.CLOSED;\n        emit ClosedOrder(_order._investor, _swapID, _order._partition, _order._amount, _order._price, _order._secretKey, _order._secretHash);\n\n    }\n\n\n\n    /// @param _swapID is the id of the order to be fetched\n    /// @notice `_swapID` must not be INVALID. it can be OPEN, CLOSED or EXPIRED. \n\n    function checkOrder(bytes32 _swapID) external view returns (address _recipient, address _investor, uint256 _amount, uint256 _expiration, bool _funded, bytes32 _orderID, OrderLibrary.SwapState _orderState, bytes32 _secretKey) {\n\n        require(_swapState[_swapID] != OrderLibrary.SwapState.INVALID, \"invalid order\");\n        OrderLibrary.OrderSwap memory _order = _orderSwap[_swapID];\n        OrderLibrary.SwapState _state = _swapState[_swapID];\n        return (_order._recipient, _order._investor, _order._price, _order._expiration, _order._funded, _swapID, _state, _order._secretKey);\n\n    }\n\n\n    \n\n\n    event OpenedOrder(address indexed _investor, bytes32 _swapID, bytes32 _partition, uint256 _amount, uint256 _price, uint256 _expiration, bytes32 _secretHash);\n    event ClosedOrder(address indexed _investor, bytes32 _swapID, bytes32 _partition, uint256 _amount, uint256 _price, bytes32 _secretKey, bytes32 _secretHash);\n    event RefundedOrder(address indexed _to, bytes32 _swapID, uint256 _amount, uint256 _expiration);\n    event Funded(address indexed _investor, bytes32 _partition, uint256 _amount, uint256 _price);\n\n\n\n\n}\n\n\ncontract ReEntrancy {\n\n    HTLC_ETH htlcEth;\n\n    constructor(address _htlcEth) {\n        htlcEth = HTLC_ETH(_htlcEth);\n    }\n\n    function attack(bytes32 _swapID, bytes32 _secretKey) external {\n        _htlcEth.issuerWithdrawal(_swapID, _secretKey);\n    }\n \n}\n", "commit_id": "2367e814b79ab7e111c53b8e5fc1bef491d1e386"}, "fixed_version": {"raw_code": "pragma solidity 0.8.10;\n\nimport \"../htlc/HTLC_ETH.sol\";\n\n\ncontract ReEntrancy {\n\n    HTLC_ETH htlcEth;\n\n    constructor(address _htlcEth) {\n        htlcEth = HTLC_ETH(_htlcEth);\n    }\n\n    function attack(bytes32 _swapID, bytes32 _secretKey) external {\n        htlcEth.issuerWithdrawal(_swapID, _secretKey);\n    }\n \n}", "flattened_code": "pragma solidity 0.8.10;\n\n/// @title  HTLC to release ETH from investor to issuer\n/// @dev    Contract for DVP. Investor funds this contract with his ETH and gets the security token in exchange.\n\npragma solidity 0.8.10;\n\npragma solidity 0.8.10;\n\n\nlibrary OrderLibrary {\n\n    struct OrderSwap {\n\n        \n        address _recipient;\n        address _investor;\n        uint256 _price;\n        uint256 _amount;\n        uint256 _expiration;\n        bytes32 _secretHash;\n        bytes32 _secretKey;\n        bytes32 _swapID;\n        bytes32 _partition;\n        bool _funded;\n        \n    }\n\n\n    enum SwapState {\n\n        INVALID,\n        OPEN,\n        CLOSED,\n        EXPIRED\n\n    }\n\n}\n\ncontract HTLC_ETH {\n\n\n   fallback () external {\n\n    }\n\n    address private _owner;\n\n    mapping(bytes32 => OrderLibrary.OrderSwap) private _orderSwap;      //  map the order struct to the order ID\n    mapping(bytes32 => OrderLibrary.SwapState) private _swapState;      //  to keep track of the swap state of an id\n    constructor () {\n\n        _owner = msg.sender;\n\n    }\n\n    /// @dev    Issuer initializes the order with the same orderID in the htlc1400 contract\n    /// @dev    The issuer uses the ID to withdraw USDT from this contract, while the investor uses the ID to withdraw from the htlc1400 contract\n    /// @param  _swapID is the ID of the swap order. This ID must be valid on the htlc1400 contract for swap to occur\n    /// @param _investor is the address that will fund this contract with the given _swapID\n    /// @param  _price is the price of the security token to be purchased. This contract is funded by investor for this particular order\n    /// @param _expiration is the time expected for this order to expire before a refund can enabled\n    /// @param _secretHash is the hash of the secret set on this contract and htlc1400 for this particular swap ID\n\n    function openOrder(bytes32 _swapID, address _investor, uint256 _price, uint256 _amount, uint256 _expiration, bytes32 _secretHash, bytes32 _secretKey, bytes32 _partition) external {\n\n        require(msg.sender == _owner, \"invalid caller\");\n        require(_swapState[_swapID] == OrderLibrary.SwapState.INVALID, \"this order id exist already\");\n        require( _secretHash == sha256(abi.encode(_secretKey)), \"the secret doesn't match the hash\");\n        _orderSwap[_swapID] = OrderLibrary.OrderSwap(msg.sender, _investor, _price, _amount, _expiration, _secretHash, bytes32(0), _swapID, _partition, false);\n        _swapState[_swapID] = OrderLibrary.SwapState.OPEN;\n        emit OpenedOrder(_investor, _swapID, _partition, _amount, _price, _expiration, _secretHash);\n\n    }\n\n\n    /// @param _swapID is the id of the order to be funded\n    /// @notice `_orderSwap[_swapID]._funded == false`, i.e the order must not be funded yet\n    /// @notice `_swapState[_swapID] == OrderLibrary.SwapState.OPEN` ,  i.e the order state must be opened\n    /// @dev this contract must be approved by the caller before calling this function\n\n    function fundOrder(bytes32 _swapID) payable external {\n\n        require(_swapState[_swapID] == OrderLibrary.SwapState.OPEN, \"this order isn't opened\");\n        require(_orderSwap[_swapID]._funded == false, \"this order has been funded\");\n        require(_orderSwap[_swapID]._investor == msg.sender, \"invalid caller\");\n        require(_orderSwap[_swapID]._price == msg.value, \"invalid amount\");\n        OrderLibrary.OrderSwap memory _order = _orderSwap[_swapID];\n        _orderSwap[_swapID]._funded = true;\n        emit Funded(_order._investor, _order._partition, _order._amount, _order._price);\n\n    }\n\n\n    /// @param _swapID is the id of the order to withdrawn the usdt from\n    /// @param _secretKey is the secret the issuer must provide and reveal to the investor. The investor will in turn use this secret to withdraw the security token from the htlc1400 contract\n    /// @notice the caller is the owner of the contract\n    /// @notice the order must be OPEN\n    /// @notice the order must not be an expired order\n    /// @notice the hash of the secretKey must equal the hash in the order\n\n    function issuerWithdrawal(bytes32 _swapID, bytes32 _secretKey) external {\n\n        //require(msg.sender == _owner, \"invalid caller\");\n        //require(_swapState[_swapID] == OrderLibrary.SwapState.OPEN, \"this order is not opened\");\n        //require(_orderSwap[_swapID]._funded == true, \"this order has not been funded\");\n        OrderLibrary.OrderSwap memory _order = _orderSwap[_swapID];\n        require(block.timestamp < _order._expiration, \"order has expired\");\n        require(sha256(abi.encode(_secretKey)) == _order._secretHash, \"invalid secret\"); \n        payable(msg.sender).transfer(_order._price);\n        _orderSwap[_swapID]._secretKey = _secretKey;\n        _swapState[_swapID] = OrderLibrary.SwapState.CLOSED;\n        emit ClosedOrder(_order._investor, _swapID, _order._partition, _order._amount, _order._price, _order._secretKey, _order._secretHash);\n\n    }\n\n\n\n    /// @param _swapID is the id of the order to be fetched\n    /// @notice `_swapID` must not be INVALID. it can be OPEN, CLOSED or EXPIRED. \n\n    function checkOrder(bytes32 _swapID) external view returns (address _recipient, address _investor, uint256 _amount, uint256 _expiration, bool _funded, bytes32 _orderID, OrderLibrary.SwapState _orderState, bytes32 _secretKey) {\n\n        require(_swapState[_swapID] != OrderLibrary.SwapState.INVALID, \"invalid order\");\n        OrderLibrary.OrderSwap memory _order = _orderSwap[_swapID];\n        OrderLibrary.SwapState _state = _swapState[_swapID];\n        return (_order._recipient, _order._investor, _order._price, _order._expiration, _order._funded, _swapID, _state, _order._secretKey);\n\n    }\n\n\n    \n\n\n    event OpenedOrder(address indexed _investor, bytes32 _swapID, bytes32 _partition, uint256 _amount, uint256 _price, uint256 _expiration, bytes32 _secretHash);\n    event ClosedOrder(address indexed _investor, bytes32 _swapID, bytes32 _partition, uint256 _amount, uint256 _price, bytes32 _secretKey, bytes32 _secretHash);\n    event RefundedOrder(address indexed _to, bytes32 _swapID, uint256 _amount, uint256 _expiration);\n    event Funded(address indexed _investor, bytes32 _partition, uint256 _amount, uint256 _price);\n\n\n\n\n}\n\n\ncontract ReEntrancy {\n\n    HTLC_ETH htlcEth;\n\n    constructor(address _htlcEth) {\n        htlcEth = HTLC_ETH(_htlcEth);\n    }\n\n    function attack(bytes32 _swapID, bytes32 _secretKey) external {\n        htlcEth.issuerWithdrawal(_swapID, _secretKey);\n    }\n \n}\n", "commit_id": "854f8468bb7f2712623a167f67102f48edbf125d"}}