{"filename": "Lethery.sol", "patch": "@@ -66,11 +66,14 @@ contract Lethery{\n         if (msg.sender != rounds[round].winner){\n             return;\n         }\n+\n+        uint amount = rounds[round].jackpot;\n+        rounds[round].jackpot = 0;\n+\n         //send money and dont forget to multiply with price\n-        if(!rounds[round].winner.send(rounds[round].jackpot*price)){\n+        if(!rounds[round].winner.send(amount * price)){\n             return;\n         }\n-        rounds[round].jackpot = 0;\n     }\n \n     function getMyBalance(address a, uint256 round) constant returns(uint){", "project_link": "https://github.com/simonDos/Lethery/commit/9414877d30d43183988defb684c1a9e0d855fd71", "bug_version": {"raw_code": "pragma solidity ^0.4.2;\n\ncontract Lethery{\n\n    address owner;\n    uint256 price = 1000000000000000000;\n    uint256 nonce = 0;\n    uint256 decisionBlock;\n    uint256 interval = 100;\n\n    struct Round{\n        address winner;\n        uint256 winNr;\n        uint256 roundNr;\n        uint256 jackpot;\n        address[] addresses;\n        mapping (address => uint256) contributions;\n    }\n    mapping(uint256 => Round) rounds;\n    uint256 rn = 0;\n\n\n    function Lethery(){\n        owner = msg.sender;\n        //set blocknumber of first drawing\n        decisionBlock = block.number + interval;\n    }\n\n    function commit() payable{\n        //amount of full ether commited\n        uint256 amount = msg.value/price;\n        //record amount and address\n        rounds[rn].contributions[msg.sender] += amount;\n        rounds[rn].addresses.push(msg.sender);\n        //increase jackpot by amount\n        rounds[rn].jackpot += amount;\n        //return excess ether\n        msg.sender.send(msg.value%price);\n    }\n\n    //This function activates the drawing process\n    function drawWinner(){\n        if (block.number < decisionBlock){\n            return;\n        }\n        uint etherCount = 0;\n        uint addressCount = 0;\n        rounds[rn].winNr = rand();\n        while(etherCount < rounds[rn].winNr){\n            address contr = rounds[rn].addresses[addressCount];\n            etherCount += rounds[rn].contributions[contr];\n            addressCount++;\n        }\n        rounds[rn].winner = rounds[rn].addresses[addressCount-1];\n        decisionBlock = block.number + interval;\n        rn++;\n    }\n\n    function rand() private returns (uint){\n        var blockHash = uint256(block.blockhash(block.number));\n        nonce++;\n        return uint(sha3(blockHash+nonce))%(rounds[rn].jackpot);\n    }\n\n    function redeem(uint256 round) {\n        if (msg.sender != rounds[round].winner){\n            return;\n        }\n        //send money and dont forget to multiply with price\n        if(!rounds[round].winner.send(rounds[round].jackpot*price)){\n            return;\n        }\n        rounds[round].jackpot = 0;\n    }\n\n    function getMyBalance(address a, uint256 round) constant returns(uint){\n        return rounds[round].contributions[a];\n    }\n\n    function getJackpotOfRound(uint256 round) constant returns(uint){\n        return rounds[round].jackpot;\n    }\n\n    function getCurrentRoundNr()constant returns(uint256){\n        return rn;\n    }\n\n    function getWinnerOfRound(uint256 round)constant returns(address){\n        return rounds[round].winner;\n    }\n\n    function getWinNrOfRound(uint256 round)constant returns(uint256){\n        return rounds[round].winNr;\n    }\n\n    function getDecisionBlock() constant returns(uint) {\n          return decisionBlock;\n    }\n\n    function remove(){\n        if(msg.sender == owner){\n            selfdestruct(msg.sender);\n        }\n    }\n}\n", "flattened_code": "pragma solidity ^0.4.2;\n\ncontract Lethery{\n\n    address owner;\n    uint256 price = 1000000000000000000;\n    uint256 nonce = 0;\n    uint256 decisionBlock;\n    uint256 interval = 100;\n\n    struct Round{\n        address winner;\n        uint256 winNr;\n        uint256 roundNr;\n        uint256 jackpot;\n        address[] addresses;\n        mapping (address => uint256) contributions;\n    }\n    mapping(uint256 => Round) rounds;\n    uint256 rn = 0;\n\n\n    function Lethery(){\n        owner = msg.sender;\n        //set blocknumber of first drawing\n        decisionBlock = block.number + interval;\n    }\n\n    function commit() payable{\n        //amount of full ether commited\n        uint256 amount = msg.value/price;\n        //record amount and address\n        rounds[rn].contributions[msg.sender] += amount;\n        rounds[rn].addresses.push(msg.sender);\n        //increase jackpot by amount\n        rounds[rn].jackpot += amount;\n        //return excess ether\n        msg.sender.send(msg.value%price);\n    }\n\n    //This function activates the drawing process\n    function drawWinner(){\n        if (block.number < decisionBlock){\n            return;\n        }\n        uint etherCount = 0;\n        uint addressCount = 0;\n        rounds[rn].winNr = rand();\n        while(etherCount < rounds[rn].winNr){\n            address contr = rounds[rn].addresses[addressCount];\n            etherCount += rounds[rn].contributions[contr];\n            addressCount++;\n        }\n        rounds[rn].winner = rounds[rn].addresses[addressCount-1];\n        decisionBlock = block.number + interval;\n        rn++;\n    }\n\n    function rand() private returns (uint){\n        var blockHash = uint256(block.blockhash(block.number));\n        nonce++;\n        return uint(sha3(blockHash+nonce))%(rounds[rn].jackpot);\n    }\n\n    function redeem(uint256 round) {\n        if (msg.sender != rounds[round].winner){\n            return;\n        }\n        //send money and dont forget to multiply with price\n        if(!rounds[round].winner.send(rounds[round].jackpot*price)){\n            return;\n        }\n        rounds[round].jackpot = 0;\n    }\n\n    function getMyBalance(address a, uint256 round) constant returns(uint){\n        return rounds[round].contributions[a];\n    }\n\n    function getJackpotOfRound(uint256 round) constant returns(uint){\n        return rounds[round].jackpot;\n    }\n\n    function getCurrentRoundNr()constant returns(uint256){\n        return rn;\n    }\n\n    function getWinnerOfRound(uint256 round)constant returns(address){\n        return rounds[round].winner;\n    }\n\n    function getWinNrOfRound(uint256 round)constant returns(uint256){\n        return rounds[round].winNr;\n    }\n\n    function getDecisionBlock() constant returns(uint) {\n          return decisionBlock;\n    }\n\n    function remove(){\n        if(msg.sender == owner){\n            selfdestruct(msg.sender);\n        }\n    }\n}\n", "commit_id": "10a42dff0a08650bf6af5e44d393f92a9ac9a606"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.2;\n\ncontract Lethery{\n\n    address owner;\n    uint256 price = 1000000000000000000;\n    uint256 nonce = 0;\n    uint256 decisionBlock;\n    uint256 interval = 100;\n\n    struct Round{\n        address winner;\n        uint256 winNr;\n        uint256 roundNr;\n        uint256 jackpot;\n        address[] addresses;\n        mapping (address => uint256) contributions;\n    }\n    mapping(uint256 => Round) rounds;\n    uint256 rn = 0;\n\n\n    function Lethery(){\n        owner = msg.sender;\n        //set blocknumber of first drawing\n        decisionBlock = block.number + interval;\n    }\n\n    function commit() payable{\n        //amount of full ether commited\n        uint256 amount = msg.value/price;\n        //record amount and address\n        rounds[rn].contributions[msg.sender] += amount;\n        rounds[rn].addresses.push(msg.sender);\n        //increase jackpot by amount\n        rounds[rn].jackpot += amount;\n        //return excess ether\n        msg.sender.send(msg.value%price);\n    }\n\n    //This function activates the drawing process\n    function drawWinner(){\n        if (block.number < decisionBlock){\n            return;\n        }\n        uint etherCount = 0;\n        uint addressCount = 0;\n        rounds[rn].winNr = rand();\n        while(etherCount < rounds[rn].winNr){\n            address contr = rounds[rn].addresses[addressCount];\n            etherCount += rounds[rn].contributions[contr];\n            addressCount++;\n        }\n        rounds[rn].winner = rounds[rn].addresses[addressCount-1];\n        decisionBlock = block.number + interval;\n        rn++;\n    }\n\n    function rand() private returns (uint){\n        var blockHash = uint256(block.blockhash(block.number));\n        nonce++;\n        return uint(sha3(blockHash+nonce))%(rounds[rn].jackpot);\n    }\n\n    function redeem(uint256 round) {\n        if (msg.sender != rounds[round].winner){\n            return;\n        }\n\n        uint amount = rounds[round].jackpot;\n        rounds[round].jackpot = 0;\n\n        //send money and dont forget to multiply with price\n        if(!rounds[round].winner.send(amount * price)){\n            return;\n        }\n    }\n\n    function getMyBalance(address a, uint256 round) constant returns(uint){\n        return rounds[round].contributions[a];\n    }\n\n    function getJackpotOfRound(uint256 round) constant returns(uint){\n        return rounds[round].jackpot;\n    }\n\n    function getCurrentRoundNr()constant returns(uint256){\n        return rn;\n    }\n\n    function getWinnerOfRound(uint256 round)constant returns(address){\n        return rounds[round].winner;\n    }\n\n    function getWinNrOfRound(uint256 round)constant returns(uint256){\n        return rounds[round].winNr;\n    }\n\n    function getDecisionBlock() constant returns(uint) {\n          return decisionBlock;\n    }\n\n    function remove(){\n        if(msg.sender == owner){\n            selfdestruct(msg.sender);\n        }\n    }\n}\n", "flattened_code": "pragma solidity ^0.4.2;\n\ncontract Lethery{\n\n    address owner;\n    uint256 price = 1000000000000000000;\n    uint256 nonce = 0;\n    uint256 decisionBlock;\n    uint256 interval = 100;\n\n    struct Round{\n        address winner;\n        uint256 winNr;\n        uint256 roundNr;\n        uint256 jackpot;\n        address[] addresses;\n        mapping (address => uint256) contributions;\n    }\n    mapping(uint256 => Round) rounds;\n    uint256 rn = 0;\n\n\n    function Lethery(){\n        owner = msg.sender;\n        //set blocknumber of first drawing\n        decisionBlock = block.number + interval;\n    }\n\n    function commit() payable{\n        //amount of full ether commited\n        uint256 amount = msg.value/price;\n        //record amount and address\n        rounds[rn].contributions[msg.sender] += amount;\n        rounds[rn].addresses.push(msg.sender);\n        //increase jackpot by amount\n        rounds[rn].jackpot += amount;\n        //return excess ether\n        msg.sender.send(msg.value%price);\n    }\n\n    //This function activates the drawing process\n    function drawWinner(){\n        if (block.number < decisionBlock){\n            return;\n        }\n        uint etherCount = 0;\n        uint addressCount = 0;\n        rounds[rn].winNr = rand();\n        while(etherCount < rounds[rn].winNr){\n            address contr = rounds[rn].addresses[addressCount];\n            etherCount += rounds[rn].contributions[contr];\n            addressCount++;\n        }\n        rounds[rn].winner = rounds[rn].addresses[addressCount-1];\n        decisionBlock = block.number + interval;\n        rn++;\n    }\n\n    function rand() private returns (uint){\n        var blockHash = uint256(block.blockhash(block.number));\n        nonce++;\n        return uint(sha3(blockHash+nonce))%(rounds[rn].jackpot);\n    }\n\n    function redeem(uint256 round) {\n        if (msg.sender != rounds[round].winner){\n            return;\n        }\n\n        uint amount = rounds[round].jackpot;\n        rounds[round].jackpot = 0;\n\n        //send money and dont forget to multiply with price\n        if(!rounds[round].winner.send(amount * price)){\n            return;\n        }\n    }\n\n    function getMyBalance(address a, uint256 round) constant returns(uint){\n        return rounds[round].contributions[a];\n    }\n\n    function getJackpotOfRound(uint256 round) constant returns(uint){\n        return rounds[round].jackpot;\n    }\n\n    function getCurrentRoundNr()constant returns(uint256){\n        return rn;\n    }\n\n    function getWinnerOfRound(uint256 round)constant returns(address){\n        return rounds[round].winner;\n    }\n\n    function getWinNrOfRound(uint256 round)constant returns(uint256){\n        return rounds[round].winNr;\n    }\n\n    function getDecisionBlock() constant returns(uint) {\n          return decisionBlock;\n    }\n\n    function remove(){\n        if(msg.sender == owner){\n            selfdestruct(msg.sender);\n        }\n    }\n}\n", "commit_id": "9414877d30d43183988defb684c1a9e0d855fd71"}}