{"filename": "contracts/mocks/EvilContract.sol", "patch": "@@ -27,14 +27,20 @@ contract EvilContract {\n     uint maxStorageIndex = minLength > 0 ? minLength - 1 : 0;\n \n     for (uint i = 0; i < maxLength; i++) {\n-      if (i >= maxStorageIndex) {\n+      if (i > maxStorageIndex) {\n         delete _fallbackTargets[i];\n         delete _fallbackValues[i];\n         delete _fallbackData[i];\n       } else {\n-        _fallbackTargets[i] = fallbackTargets[i];\n-        _fallbackValues[i] = fallbackValues[i];\n-        _fallbackData[i] = fallbackData[i];\n+        if (i >= fallbackTargets.length) {\n+          _fallbackTargets[i] = fallbackTargets[i];\n+          _fallbackValues[i] = fallbackValues[i];\n+          _fallbackData[i] = fallbackData[i];\n+        } else {\n+          _fallbackTargets.push(fallbackTargets[i]);\n+          _fallbackValues.push(fallbackValues[i]);\n+          _fallbackData.push(fallbackData[i]);\n+        }\n       }\n     }\n   }", "project_link": "https://github.com/NexusMutual/smart-contracts/commit/349025e4d34cd96b328b2efb042b7d230a17d164", "bug_version": {"raw_code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract EvilContract {\n  address[] public _fallbackTargets;\n  uint[] public _fallbackValues;\n  bytes[] public _fallbackData;\n\n  function setFallbackParams(\n    address[] calldata fallbackTargets,\n    uint[] calldata fallbackValues,\n    bytes[] calldata fallbackData\n  ) external payable {\n    require(fallbackTargets.length == fallbackValues.length, \"Length mismatch\");\n    require(fallbackData.length == fallbackValues.length, \"Length mismatch\");\n\n    uint maxLength = fallbackValues.length > _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint minLength = fallbackValues.length < _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint maxStorageIndex = minLength > 0 ? minLength - 1 : 0;\n\n    for (uint i = 0; i < maxLength; i++) {\n      if (i >= maxStorageIndex) {\n        delete _fallbackTargets[i];\n        delete _fallbackValues[i];\n        delete _fallbackData[i];\n      } else {\n        _fallbackTargets[i] = fallbackTargets[i];\n        _fallbackValues[i] = fallbackValues[i];\n        _fallbackData[i] = fallbackData[i];\n      }\n    }\n  }\n\n  function execute(\n    address[] memory targets,\n    uint[] memory values,\n    bytes[] memory data\n  ) public {\n    for (uint i = 0; i < data.length; i++) {\n\n      (bool ok, bytes memory returndata) = targets[i].call{value: values[i]}(data[i]);\n\n      if (ok) {\n        continue;\n      }\n\n      // pass revert reason\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      }\n\n      revert(\"Low-level call failed\");\n    }\n  }\n\n  fallback() external payable {\n    execute(_fallbackTargets, _fallbackValues, _fallbackData);\n  }\n\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract EvilContract {\n  address[] public _fallbackTargets;\n  uint[] public _fallbackValues;\n  bytes[] public _fallbackData;\n\n  function setFallbackParams(\n    address[] calldata fallbackTargets,\n    uint[] calldata fallbackValues,\n    bytes[] calldata fallbackData\n  ) external payable {\n    require(fallbackTargets.length == fallbackValues.length, \"Length mismatch\");\n    require(fallbackData.length == fallbackValues.length, \"Length mismatch\");\n\n    uint maxLength = fallbackValues.length > _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint minLength = fallbackValues.length < _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint maxStorageIndex = minLength > 0 ? minLength - 1 : 0;\n\n    for (uint i = 0; i < maxLength; i++) {\n      if (i >= maxStorageIndex) {\n        delete _fallbackTargets[i];\n        delete _fallbackValues[i];\n        delete _fallbackData[i];\n      } else {\n        _fallbackTargets[i] = fallbackTargets[i];\n        _fallbackValues[i] = fallbackValues[i];\n        _fallbackData[i] = fallbackData[i];\n      }\n    }\n  }\n\n  function execute(\n    address[] memory targets,\n    uint[] memory values,\n    bytes[] memory data\n  ) public {\n    for (uint i = 0; i < data.length; i++) {\n\n      (bool ok, bytes memory returndata) = targets[i].call{value: values[i]}(data[i]);\n\n      if (ok) {\n        continue;\n      }\n\n      // pass revert reason\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      }\n\n      revert(\"Low-level call failed\");\n    }\n  }\n\n  fallback() external payable {\n    execute(_fallbackTargets, _fallbackValues, _fallbackData);\n  }\n\n}\n", "commit_id": "663a2c9fe7abbbdce4ec110c164e5fcfcaa05fdc"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract EvilContract {\n  address[] public _fallbackTargets;\n  uint[] public _fallbackValues;\n  bytes[] public _fallbackData;\n\n  function setFallbackParams(\n    address[] calldata fallbackTargets,\n    uint[] calldata fallbackValues,\n    bytes[] calldata fallbackData\n  ) external payable {\n    require(fallbackTargets.length == fallbackValues.length, \"Length mismatch\");\n    require(fallbackData.length == fallbackValues.length, \"Length mismatch\");\n\n    uint maxLength = fallbackValues.length > _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint minLength = fallbackValues.length < _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint maxStorageIndex = minLength > 0 ? minLength - 1 : 0;\n\n    for (uint i = 0; i < maxLength; i++) {\n      if (i > maxStorageIndex) {\n        delete _fallbackTargets[i];\n        delete _fallbackValues[i];\n        delete _fallbackData[i];\n      } else {\n        if (i >= fallbackTargets.length) {\n          _fallbackTargets[i] = fallbackTargets[i];\n          _fallbackValues[i] = fallbackValues[i];\n          _fallbackData[i] = fallbackData[i];\n        } else {\n          _fallbackTargets.push(fallbackTargets[i]);\n          _fallbackValues.push(fallbackValues[i]);\n          _fallbackData.push(fallbackData[i]);\n        }\n      }\n    }\n  }\n\n  function execute(\n    address[] memory targets,\n    uint[] memory values,\n    bytes[] memory data\n  ) public {\n    for (uint i = 0; i < data.length; i++) {\n\n      (bool ok, bytes memory returndata) = targets[i].call{value: values[i]}(data[i]);\n\n      if (ok) {\n        continue;\n      }\n\n      // pass revert reason\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      }\n\n      revert(\"Low-level call failed\");\n    }\n  }\n\n  fallback() external payable {\n    execute(_fallbackTargets, _fallbackValues, _fallbackData);\n  }\n\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract EvilContract {\n  address[] public _fallbackTargets;\n  uint[] public _fallbackValues;\n  bytes[] public _fallbackData;\n\n  function setFallbackParams(\n    address[] calldata fallbackTargets,\n    uint[] calldata fallbackValues,\n    bytes[] calldata fallbackData\n  ) external payable {\n    require(fallbackTargets.length == fallbackValues.length, \"Length mismatch\");\n    require(fallbackData.length == fallbackValues.length, \"Length mismatch\");\n\n    uint maxLength = fallbackValues.length > _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint minLength = fallbackValues.length < _fallbackValues.length\n      ? fallbackValues.length\n      : _fallbackValues.length;\n\n    uint maxStorageIndex = minLength > 0 ? minLength - 1 : 0;\n\n    for (uint i = 0; i < maxLength; i++) {\n      if (i > maxStorageIndex) {\n        delete _fallbackTargets[i];\n        delete _fallbackValues[i];\n        delete _fallbackData[i];\n      } else {\n        if (i >= fallbackTargets.length) {\n          _fallbackTargets[i] = fallbackTargets[i];\n          _fallbackValues[i] = fallbackValues[i];\n          _fallbackData[i] = fallbackData[i];\n        } else {\n          _fallbackTargets.push(fallbackTargets[i]);\n          _fallbackValues.push(fallbackValues[i]);\n          _fallbackData.push(fallbackData[i]);\n        }\n      }\n    }\n  }\n\n  function execute(\n    address[] memory targets,\n    uint[] memory values,\n    bytes[] memory data\n  ) public {\n    for (uint i = 0; i < data.length; i++) {\n\n      (bool ok, bytes memory returndata) = targets[i].call{value: values[i]}(data[i]);\n\n      if (ok) {\n        continue;\n      }\n\n      // pass revert reason\n      if (returndata.length > 0) {\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      }\n\n      revert(\"Low-level call failed\");\n    }\n  }\n\n  fallback() external payable {\n    execute(_fallbackTargets, _fallbackValues, _fallbackData);\n  }\n\n}\n", "commit_id": "349025e4d34cd96b328b2efb042b7d230a17d164"}}