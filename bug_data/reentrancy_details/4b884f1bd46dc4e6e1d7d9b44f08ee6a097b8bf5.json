{"filename": "contracts/2key/donation-campaign-contracts/TwoKeyDonationConversionHandler.sol", "patch": "@@ -206,8 +206,8 @@ contract TwoKeyDonationConversionHandler is UpgradeableCampaign, TwoKeyConversio\n     internal\n     {\n         uint amountOfTokens = calculateAmountOfTokens(_conversionAmountETHWei);\n-        erc20InvoiceToken.transfer(_converter, amountOfTokens);\n         converterToAmountOfDonationTokensReceived[_converter] = converterToAmountOfDonationTokensReceived[_converter].add(amountOfTokens);\n+        erc20InvoiceToken.transfer(_converter, amountOfTokens);\n     }\n \n ", "project_link": "https://github.com/2key/contracts/commit/dbc64834a5e35c1eb4c3eb86df21e010d37bf0e6", "bug_version": {"raw_code": "pragma solidity ^0.4.24;\n\n\nimport \"./InvoiceTokenERC20.sol\";\nimport \"../TwoKeyConversionStates.sol\";\nimport \"../TwoKeyConverterStates.sol\";\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../interfaces/ITwoKeyDonationCampaign.sol\";\nimport \"../interfaces/ITwoKeyEventSource.sol\";\nimport \"../interfaces/ITwoKeySingletoneRegistryFetchAddress.sol\";\nimport \"../interfaces/ITwoKeyBaseReputationRegistry.sol\";\nimport \"../interfaces/ITwoKeyMaintainersRegistry.sol\";\nimport \"../interfaces/ITwoKeyExchangeRateContract.sol\";\nimport \"../upgradable-pattern-campaigns/UpgradeableCampaign.sol\";\n\n\ncontract TwoKeyDonationConversionHandler is UpgradeableCampaign, TwoKeyConversionStates, TwoKeyConverterStates {\n\n    using SafeMath for uint256; // Define lib necessary to handle uint operations\n    bool isCampaignInitialized; //defaults to false\n\n    Conversion [] public conversions;\n    InvoiceTokenERC20 public erc20InvoiceToken; // ERC20 token which will be issued as an invoice\n\n    ITwoKeyDonationCampaign twoKeyDonationCampaign;\n\n    event ConversionCreated(uint conversionId);\n\n    address twoKeySingletonRegistry;\n    address twoKeyEventSource;\n\n    string currency;\n    address contractor;\n    uint numberOfConversions;\n    /**\n     * This array will represent counter values where position will be index (which counter) and value will be actual counter value\n     * counters[0] = PENDING_CONVERSIONS\n     * counters[1] = APPROVED_CONVERSIONS\n     * counters[2] = REJECTED_CONVERSIONS\n     * counters[3] = EXECUTED_CONVERSIONS\n     * counters[4] = CANCELLED_CONVERSIONS\n     * counters[5] = UNIQUE_CONVERTERS\n     * counters[6] = RAISED_FUNDS_ETH_WEI\n     * counters[7] = TOKENS_SOLD\n     * counters[8] = TOTAL_BOUNTY\n     * counters[9] = RAISED_FUNDS_FIAT_WEI\n     */\n    uint [] counters; //Metrics counter\n\n\n    mapping(address => uint256) private amountConverterSpentEthWEI; // Amount converter put to the contract in Ether\n    mapping(address => uint256) private converterToAmountOfDonationTokensReceived;\n    mapping(bytes32 => address[]) stateToConverter; //State to all converters in that state\n    mapping(address => ConverterState) converterToState; // Converter to state\n    mapping(address => uint[]) converterToHisConversions;\n    mapping(address => bool) isConverterAnonymous;\n    mapping(address => bool) doesConverterHaveExecutedConversions;\n\n    //Struct to represent donation in Ether\n    struct Conversion {\n        address contractor; // Contractor (creator) of campaign\n        uint256 contractorProceedsETHWei; // How much contractor will receive for this conversion\n        address converter; // Converter is one who's buying tokens -> plasma address\n        ConversionState state;\n        uint256 conversionAmount; // Amount for conversion (In ETH / FIAT)\n        uint256 maxReferralRewardETHWei; // Total referral reward for the conversion\n        uint256 maxReferralReward2key;\n        uint256 moderatorFeeETHWei;\n        uint256 tokensBought;\n    }\n\n    event InvoiceTokenCreated(\n        address token,\n        string tokenName,\n        string tokenSymbol\n    );\n\n\n    modifier onlyContractorOrMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(msg.sender == contractor || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n        _;\n    }\n\n\n    function setInitialParamsDonationConversionHandler(\n        string tokenName,\n        string tokenSymbol,\n        string _currency,\n        address _contractor,\n        address _twoKeyDonationCampaign,\n        address _twoKeySingletonRegistry\n    )\n    public\n    {\n        require(isCampaignInitialized == false);\n\n        counters = new uint[](10);\n        twoKeyDonationCampaign = ITwoKeyDonationCampaign(_twoKeyDonationCampaign);\n        twoKeySingletonRegistry = _twoKeySingletonRegistry;\n        twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\");\n        contractor = _contractor;\n        currency = _currency;\n        // Deploy an ERC20 token which will be used as the Invoice\n        erc20InvoiceToken = new InvoiceTokenERC20(tokenName,tokenSymbol,address(this));\n        // Emit an event with deployed token address, name, and symbol\n        emit InvoiceTokenCreated(address(erc20InvoiceToken), tokenName, tokenSymbol);\n        isCampaignInitialized = true;\n    }\n\n\n    // Internal function to fetch address from TwoKeyRegTwoistry\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(twoKeySingletonRegistry)\n        .getContractProxyAddress(contractName);\n    }\n\n    /**\n     * given the total payout, calculates the moderator fee\n     * @param  _conversionAmountETHWei total payout for escrow\n     * @return moderator fee\n     */\n    function calculateModeratorFee(\n        uint256 _conversionAmountETHWei\n    )\n    private\n    view\n    returns (uint256)\n    {\n        uint256 fee = _conversionAmountETHWei.mul(ITwoKeyEventSource(twoKeyEventSource).getTwoKeyDefaultIntegratorFeeFromAdmin()).div(100);\n        return fee;\n    }\n\n    function emitConvertedEvent(\n        address converterAddress,\n        uint conversionAmount,\n        uint conversionId\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).convertedDonationV2(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(converterAddress),\n            conversionAmount,\n            conversionId\n        );\n    }\n\n    function emitExecutedEvent(\n        address _converterAddress,\n        uint conversionId,\n        uint tokens\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).executedV1(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress),\n            conversionId,\n            tokens\n        );\n    }\n\n    function emitRejectedEvent(\n        address _campaignAddress,\n        address _converterAddress\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).rejected(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress)\n        );\n    }\n\n    /**\n     * @notice Function to calculate amount of donation tokens to be received\n     * @param _conversionAmountETHWei is the amount of conversion in WEI\n     */\n    function calculateAmountOfTokens(\n        uint _conversionAmountETHWei\n    )\n    internal\n    view\n    returns (uint)\n    {\n        if(keccak256(currency) == keccak256('ETH')) {\n            return _conversionAmountETHWei;\n        } else {\n            address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n            uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(currency);\n            uint conversionAmountInFIAT = (_conversionAmountETHWei*rate).div(10**18);\n            return conversionAmountInFIAT;\n        }\n    }\n\n\n    function transferInvoiceToken(\n        address _converter,\n        uint _conversionAmountETHWei\n    )\n    internal\n    {\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmountETHWei);\n        erc20InvoiceToken.transfer(_converter, amountOfTokens);\n        converterToAmountOfDonationTokensReceived[_converter] = converterToAmountOfDonationTokensReceived[_converter].add(amountOfTokens);\n    }\n\n\n\n    /// @notice Function to move converter address from stateA to stateB\n    /// @param _converter is the address of converter\n    /// @param destinationState is the state we'd like to move converter to\n    function moveFromStateAToStateB(\n        address _converter,\n        bytes32 destinationState\n    )\n    internal\n    {\n        ConverterState state = converterToState[_converter];\n        bytes32 key = convertConverterStateToBytes(state);\n        address[] memory pending = stateToConverter[key];\n        for(uint i=0; i< pending.length; i++) {\n            if(pending[i] == _converter) {\n                stateToConverter[destinationState].push(_converter);\n                pending[i] = pending[pending.length-1];\n                delete pending[pending.length-1];\n                stateToConverter[key] = pending;\n                stateToConverter[key].length--;\n                break;\n            }\n        }\n    }\n\n    /// @notice Function where we can change state of converter to Approved\n    /// @dev Converter can only be approved if his previous state is pending or rejected\n    /// @param _converter is the address of converter\n    function moveFromPendingOrRejectedToApprovedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"APPROVED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.APPROVED;\n    }\n\n\n    /// @notice Function where we're going to move state of conversion from pending to rejected\n    /// @dev private function, will be executed in another one\n    /// @param _converter is the address of converter\n    function moveFromPendingToRejectedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"REJECTED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.REJECTED;\n    }\n\n\n    /**\n     * @param _converterAddress is the one who calls join and donate function\n     */\n    function supportForCreateConversion(\n        address _converterAddress,\n        uint _conversionAmount,\n        uint _maxReferralRewardETHWei,\n        bool _isKYCRequired\n    )\n    public\n    returns (uint)\n    {\n        require(msg.sender == address(twoKeyDonationCampaign));\n        //If KYC is required, basic funnel executes and we require that converter is not previously rejected\n        if(_isKYCRequired == true) {\n            require(converterToState[_converterAddress] != ConverterState.REJECTED); // If converter is rejected then can't create conversion\n            // Checking the state for converter, if this is his 1st time, he goes initially to PENDING_APPROVAL\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.PENDING_APPROVAL;\n                stateToConverter[bytes32(\"PENDING_APPROVAL\")].push(_converterAddress);\n            }\n        } else {\n            //If KYC is not required converter is automatically approved\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.APPROVED;\n                stateToConverter[bytes32(\"APPROVED\")].push(_converterAddress);\n            }\n        }\n\n\n        uint256 _moderatorFeeETHWei = calculateModeratorFee(_conversionAmount);\n        uint256 _contractorProceeds = _conversionAmount.sub(_maxReferralRewardETHWei.add(_moderatorFeeETHWei));\n        counters[1] = counters[1].add(1);\n\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmount);\n\n        Conversion memory c = Conversion(\n            contractor,\n            _contractorProceeds,\n            _converterAddress,\n            ConversionState.APPROVED,\n            _conversionAmount,\n            _maxReferralRewardETHWei,\n            0,\n            _moderatorFeeETHWei,\n            amountOfTokens\n        );\n\n        conversions.push(c);\n        converterToHisConversions[_converterAddress].push(numberOfConversions);\n        emitConvertedEvent(_converterAddress, _conversionAmount, numberOfConversions);\n\n        emit ConversionCreated(numberOfConversions);\n        numberOfConversions = numberOfConversions.add(1);\n\n        return numberOfConversions-1;\n\n    }\n\n    function executeConversion(\n        uint _conversionId\n    )\n    public\n    {\n        Conversion conversion = conversions[_conversionId];\n        require(converterToState[conversion.converter] == ConverterState.APPROVED);\n        require(conversion.state == ConversionState.APPROVED);\n\n        counters[1] = counters[1].sub(1); //Decrease number of approved conversions\n\n//         Buy tokens from campaign and distribute rewards between referrers\n        uint totalReward2keys = twoKeyDonationCampaign.buyTokensAndDistributeReferrerRewards(\n            conversion.maxReferralRewardETHWei,\n            conversion.converter,\n            _conversionId\n        );\n\n\n        // Update reputation points in registry for conversion executed event\n//        ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionExecutedEvent(\n//            conversion.converter,\n//            contractor,\n//            twoKeyDonationCampaign\n//        );\n\n\n        amountConverterSpentEthWEI[conversion.converter] = amountConverterSpentEthWEI[conversion.converter].add(conversion.conversionAmount);\n        counters[8] = counters[8].add(totalReward2keys);\n        twoKeyDonationCampaign.buyTokensForModeratorRewards(conversion.moderatorFeeETHWei);\n        twoKeyDonationCampaign.updateContractorProceeds(conversion.contractorProceedsETHWei);\n\n        counters[6] = counters[6].add(conversion.conversionAmount);\n\n        if(doesConverterHaveExecutedConversions[conversion.converter] == false) {\n            counters[5] = counters[5].add(1); //increase number of unique converters\n            doesConverterHaveExecutedConversions[conversion.converter] = true;\n        }\n\n        conversion.maxReferralReward2key = totalReward2keys;\n        conversion.state = ConversionState.EXECUTED;\n        counters[3] = counters[3].add(1); //Increase number of executed conversions\n\n        transferInvoiceToken(conversion.converter, conversion.conversionAmount);\n        emitExecutedEvent(conversion.converter, _conversionId, conversion.tokensBought);\n    }\n\n\n    /// @notice Function where we are approving converter\n    /// @dev only maintainer or contractor can call this method\n    /// @param _converter is the address of converter\n    function approveConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingOrRejectedToApprovedState(_converter);\n    }\n\n    function rejectConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingToRejectedState(_converter);\n\n        uint refundAmount = 0;\n        uint len = converterToHisConversions[_converter].length;\n\n        for(uint i=0; i<len; i++) {\n            uint conversionId = converterToHisConversions[_converter][i];\n            Conversion c = conversions[conversionId];\n\n            //In this case since we don't support FIAT, every conversion is auto approved\n            if(c.state == ConversionState.APPROVED) {\n                counters[1] = counters[1].sub(1); // Reduce number of approved conversions\n                counters[2] = counters[2].add(1); //Increase number of rejected conversions\n//                ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionRejectedEvent(_converter, contractor, twoKeyAcquisitionCampaignERC20);\n                c.state = ConversionState.REJECTED;\n                refundAmount = refundAmount.add(c.conversionAmount);\n            }\n        }\n\n        if(refundAmount > 0) {\n            twoKeyDonationCampaign.sendBackEthWhenConversionRejected(_converter, refundAmount);\n        }\n\n        emitRejectedEvent(twoKeyDonationCampaign, _converter);\n    }\n\n    /**\n     * @notice Function to get all conversion ids for the converter\n     * @param _converter is the address of the converter\n     * @return array of conversion ids\n     * @dev can only be called by converter itself or maintainer/contractor\n     */\n    function getConverterConversionIds(\n        address _converter\n    )\n    public\n    view\n    returns (uint[])\n    {\n        return converterToHisConversions[_converter];\n    }\n\n\n    function getLastConverterConversionId(\n        address _converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToHisConversions[_converter][converterToHisConversions[_converter].length - 1];\n    }\n\n    /**\n     * @notice Get's number of converters per type, and returns tuple, as well as total raised funds\n     getCampaignSummary\n     */\n    function getCampaignSummary()\n    public\n    view\n    returns (uint,uint,uint,uint[])\n    {\n        bytes32 pending = convertConverterStateToBytes(ConverterState.PENDING_APPROVAL);\n        bytes32 approved = convertConverterStateToBytes(ConverterState.APPROVED);\n        bytes32 rejected = convertConverterStateToBytes(ConverterState.REJECTED);\n\n        uint numberOfPending = stateToConverter[pending].length;\n        uint numberOfApproved = stateToConverter[approved].length;\n        uint numberOfRejected = stateToConverter[rejected].length;\n\n        return (\n        numberOfPending,\n        numberOfApproved,\n        numberOfRejected,\n        counters\n        );\n    }\n\n    /**\n     * @notice Function to get number of conversions\n     * @dev Can only be called by contractor or maintainer\n     */\n    function getNumberOfConversions()\n    external\n    view\n    returns (uint)\n    {\n        return numberOfConversions;\n    }\n\n    /**\n     * @notice Function to get converter state\n     * @param _converter is the address of the requested converter\n     * @return hexed string of the state\n     */\n    function getStateForConverter(\n        address _converter\n    )\n    external\n    view\n    returns (bytes32)\n    {\n        return convertConverterStateToBytes(converterToState[_converter]);\n    }\n\n\n    function getAllConvertersPerState(\n        bytes32 state\n    )\n    public\n    view\n    onlyContractorOrMaintainer\n    returns (address[])\n    {\n        return stateToConverter[state];\n    }\n\n    /**\n     * @notice Function to get conversion details by id\n     * @param conversionId is the id of conversion\n     */\n    function getConversion(\n        uint conversionId\n    )\n    external\n    view\n    returns (bytes)\n    {\n        Conversion memory conversion = conversions[conversionId];\n\n        address converter; // Defaults to 0x0\n\n        if(isConverterAnonymous[conversion.converter] == false) {\n            converter = conversion.converter;\n        }\n\n        return abi.encodePacked (\n            conversion.contractor,\n            converter,\n            conversion.contractorProceedsETHWei,\n            conversion.conversionAmount,\n            conversion.tokensBought,\n            conversion.maxReferralRewardETHWei,\n            conversion.maxReferralReward2key,\n            conversion.moderatorFeeETHWei,\n            conversion.state\n        );\n    }\n\n    function getAmountConverterSpent(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return amountConverterSpentEthWEI[converter];\n    }\n\n    function getAmountOfDonationTokensConverterReceived(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToAmountOfDonationTokensReceived[converter];\n    }\n\n}\n", "flattened_code": "pragma solidity ^0.4.24;\n\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address _who) public view returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool);\n    function allowance(address _ocwner, address _spender) public view returns (uint256);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\n/**\n * @author Nikola Madjarevic\n */\ncontract InvoiceTokenERC20 is ERC20 {\n\n    using SafeMath for uint256;\n\n    uint256 internal totalSupply_ = 10000000000000000000000000000;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    address public owner;\n\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n    mapping(address => uint256) internal balances;\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    constructor(string _name, string _symbol, address _tokensOwner) public {\n        owner = _tokensOwner;\n        name = _name;\n        symbol = _symbol;\n        balances[_tokensOwner] = totalSupply_;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    public\n    returns (bool)\n    {\n        revert();\n    }\n\n    /**\n     * @dev approve is not supported regarding the specs\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        revert();\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n    public\n    view\n    returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public onlyOwner returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\npragma solidity ^0.4.24;\n\n/**\n * @author Nikola Madjarevic\n */\ncontract TwoKeyConversionStates {\n    enum ConversionState {PENDING_APPROVAL, APPROVED, EXECUTED, REJECTED, CANCELLED_BY_CONVERTER}\n}\npragma solidity ^0.4.24;\n\ncontract TwoKeyConverterStates {\n    enum ConverterState {NOT_EXISTING, PENDING_APPROVAL, APPROVED, REJECTED}\n\n    /// @notice Function to convert converter state to it's bytes representation (Maybe we don't even need it)\n    /// @param state is conversion state\n    /// @return bytes32 (hex) representation of state\n    function convertConverterStateToBytes(\n        ConverterState state\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        if(ConverterState.NOT_EXISTING == state) {\n            return bytes32(\"NOT_EXISTING\");\n        }\n        else if(ConverterState.PENDING_APPROVAL == state) {\n            return bytes32(\"PENDING_APPROVAL\");\n        }\n        else if(ConverterState.APPROVED == state) {\n            return bytes32(\"APPROVED\");\n        }\n        else if(ConverterState.REJECTED == state) {\n            return bytes32(\"REJECTED\");\n        }\n    }\n}\n\npragma solidity ^0.4.24;\n\ncontract ITwoKeyDonationCampaign {\n\n    function buyTokensForModeratorRewards(\n        uint moderatorFee\n    )\n    public;\n\n    function buyTokensAndDistributeReferrerRewards(\n        uint256 _maxReferralRewardETHWei,\n        address _converter,\n        uint _conversionId\n    )\n    public\n    returns (uint);\n\n    function getReferrerPlasmaBalance(address _influencer) public view returns (uint);\n    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;\n    function getReferrerCut(address me) public view returns (uint256);\n    function updateContractorProceeds(uint value) public;\n    function getReceivedFrom(address _receiver) public view returns (address);\n    function balanceOf(address _owner) public view returns (uint256);\n    function sendBackEthWhenConversionRejected(address _rejectedConverter, uint _conversionAmount) public;\n}\npragma solidity ^0.4.24;\n\n\ncontract ITwoKeyEventSource {\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external view;\n    function rejected(address _campaign, address _converter) external view;\n\n    function convertedAcquisitionV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external\n    view;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonationV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external\n    view;\n\n    function executedV1(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external\n    view;\n\n}\npragma solidity ^0.4.24;\n/**\n * @author Nikola Madjarevic\n * Created at 2/7/19\n */\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestContractVersion(string contractName) public view returns (string);\n}\npragma solidity ^0.4.24;\n/**\n * @author Nikola Madjarevic\n * Created at 2/4/19\n */\ncontract ITwoKeyBaseReputationRegistry {\n    function updateOnConversionExecutedEvent(address converter, address contractor, address acquisitionCampaign) public;\n    function updateOnConversionRejectedEvent(address converter, address contractor, address acquisitionCampaign) public;\n}\npragma solidity ^0.4.24;\n\ncontract ITwoKeyMaintainersRegistry {\n    function onlyMaintainer(address _sender) public view returns (bool);\n}\npragma solidity ^0.4.24;\n\n/**\n * @author Nikola Madjarevic\n */\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n/**\n * @title IRegistry\n * @dev This contract represents the interface of a registry contract\n */\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    */\n    event VersionAdded(string version, address implementation);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract UpgradeabilityCampaignStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    address internal twoKeyFactory;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract UpgradeableCampaign is UpgradeabilityCampaignStorage {\n\n}\n\n\ncontract TwoKeyDonationConversionHandler is UpgradeableCampaign, TwoKeyConversionStates, TwoKeyConverterStates {\n\n    using SafeMath for uint256; // Define lib necessary to handle uint operations\n    bool isCampaignInitialized; //defaults to false\n\n    Conversion [] public conversions;\n    InvoiceTokenERC20 public erc20InvoiceToken; // ERC20 token which will be issued as an invoice\n\n    ITwoKeyDonationCampaign twoKeyDonationCampaign;\n\n    event ConversionCreated(uint conversionId);\n\n    address twoKeySingletonRegistry;\n    address twoKeyEventSource;\n\n    string currency;\n    address contractor;\n    uint numberOfConversions;\n    /**\n     * This array will represent counter values where position will be index (which counter) and value will be actual counter value\n     * counters[0] = PENDING_CONVERSIONS\n     * counters[1] = APPROVED_CONVERSIONS\n     * counters[2] = REJECTED_CONVERSIONS\n     * counters[3] = EXECUTED_CONVERSIONS\n     * counters[4] = CANCELLED_CONVERSIONS\n     * counters[5] = UNIQUE_CONVERTERS\n     * counters[6] = RAISED_FUNDS_ETH_WEI\n     * counters[7] = TOKENS_SOLD\n     * counters[8] = TOTAL_BOUNTY\n     * counters[9] = RAISED_FUNDS_FIAT_WEI\n     */\n    uint [] counters; //Metrics counter\n\n\n    mapping(address => uint256) private amountConverterSpentEthWEI; // Amount converter put to the contract in Ether\n    mapping(address => uint256) private converterToAmountOfDonationTokensReceived;\n    mapping(bytes32 => address[]) stateToConverter; //State to all converters in that state\n    mapping(address => ConverterState) converterToState; // Converter to state\n    mapping(address => uint[]) converterToHisConversions;\n    mapping(address => bool) isConverterAnonymous;\n    mapping(address => bool) doesConverterHaveExecutedConversions;\n\n    //Struct to represent donation in Ether\n    struct Conversion {\n        address contractor; // Contractor (creator) of campaign\n        uint256 contractorProceedsETHWei; // How much contractor will receive for this conversion\n        address converter; // Converter is one who's buying tokens -> plasma address\n        ConversionState state;\n        uint256 conversionAmount; // Amount for conversion (In ETH / FIAT)\n        uint256 maxReferralRewardETHWei; // Total referral reward for the conversion\n        uint256 maxReferralReward2key;\n        uint256 moderatorFeeETHWei;\n        uint256 tokensBought;\n    }\n\n    event InvoiceTokenCreated(\n        address token,\n        string tokenName,\n        string tokenSymbol\n    );\n\n\n    modifier onlyContractorOrMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(msg.sender == contractor || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n        _;\n    }\n\n\n    function setInitialParamsDonationConversionHandler(\n        string tokenName,\n        string tokenSymbol,\n        string _currency,\n        address _contractor,\n        address _twoKeyDonationCampaign,\n        address _twoKeySingletonRegistry\n    )\n    public\n    {\n        require(isCampaignInitialized == false);\n\n        counters = new uint[](10);\n        twoKeyDonationCampaign = ITwoKeyDonationCampaign(_twoKeyDonationCampaign);\n        twoKeySingletonRegistry = _twoKeySingletonRegistry;\n        twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\");\n        contractor = _contractor;\n        currency = _currency;\n        // Deploy an ERC20 token which will be used as the Invoice\n        erc20InvoiceToken = new InvoiceTokenERC20(tokenName,tokenSymbol,address(this));\n        // Emit an event with deployed token address, name, and symbol\n        emit InvoiceTokenCreated(address(erc20InvoiceToken), tokenName, tokenSymbol);\n        isCampaignInitialized = true;\n    }\n\n\n    // Internal function to fetch address from TwoKeyRegTwoistry\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(twoKeySingletonRegistry)\n        .getContractProxyAddress(contractName);\n    }\n\n    /**\n     * given the total payout, calculates the moderator fee\n     * @param  _conversionAmountETHWei total payout for escrow\n     * @return moderator fee\n     */\n    function calculateModeratorFee(\n        uint256 _conversionAmountETHWei\n    )\n    private\n    view\n    returns (uint256)\n    {\n        uint256 fee = _conversionAmountETHWei.mul(ITwoKeyEventSource(twoKeyEventSource).getTwoKeyDefaultIntegratorFeeFromAdmin()).div(100);\n        return fee;\n    }\n\n    function emitConvertedEvent(\n        address converterAddress,\n        uint conversionAmount,\n        uint conversionId\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).convertedDonationV2(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(converterAddress),\n            conversionAmount,\n            conversionId\n        );\n    }\n\n    function emitExecutedEvent(\n        address _converterAddress,\n        uint conversionId,\n        uint tokens\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).executedV1(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress),\n            conversionId,\n            tokens\n        );\n    }\n\n    function emitRejectedEvent(\n        address _campaignAddress,\n        address _converterAddress\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).rejected(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress)\n        );\n    }\n\n    /**\n     * @notice Function to calculate amount of donation tokens to be received\n     * @param _conversionAmountETHWei is the amount of conversion in WEI\n     */\n    function calculateAmountOfTokens(\n        uint _conversionAmountETHWei\n    )\n    internal\n    view\n    returns (uint)\n    {\n        if(keccak256(currency) == keccak256('ETH')) {\n            return _conversionAmountETHWei;\n        } else {\n            address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n            uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(currency);\n            uint conversionAmountInFIAT = (_conversionAmountETHWei*rate).div(10**18);\n            return conversionAmountInFIAT;\n        }\n    }\n\n\n    function transferInvoiceToken(\n        address _converter,\n        uint _conversionAmountETHWei\n    )\n    internal\n    {\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmountETHWei);\n        erc20InvoiceToken.transfer(_converter, amountOfTokens);\n        converterToAmountOfDonationTokensReceived[_converter] = converterToAmountOfDonationTokensReceived[_converter].add(amountOfTokens);\n    }\n\n\n\n    /// @notice Function to move converter address from stateA to stateB\n    /// @param _converter is the address of converter\n    /// @param destinationState is the state we'd like to move converter to\n    function moveFromStateAToStateB(\n        address _converter,\n        bytes32 destinationState\n    )\n    internal\n    {\n        ConverterState state = converterToState[_converter];\n        bytes32 key = convertConverterStateToBytes(state);\n        address[] memory pending = stateToConverter[key];\n        for(uint i=0; i< pending.length; i++) {\n            if(pending[i] == _converter) {\n                stateToConverter[destinationState].push(_converter);\n                pending[i] = pending[pending.length-1];\n                delete pending[pending.length-1];\n                stateToConverter[key] = pending;\n                stateToConverter[key].length--;\n                break;\n            }\n        }\n    }\n\n    /// @notice Function where we can change state of converter to Approved\n    /// @dev Converter can only be approved if his previous state is pending or rejected\n    /// @param _converter is the address of converter\n    function moveFromPendingOrRejectedToApprovedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"APPROVED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.APPROVED;\n    }\n\n\n    /// @notice Function where we're going to move state of conversion from pending to rejected\n    /// @dev private function, will be executed in another one\n    /// @param _converter is the address of converter\n    function moveFromPendingToRejectedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"REJECTED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.REJECTED;\n    }\n\n\n    /**\n     * @param _converterAddress is the one who calls join and donate function\n     */\n    function supportForCreateConversion(\n        address _converterAddress,\n        uint _conversionAmount,\n        uint _maxReferralRewardETHWei,\n        bool _isKYCRequired\n    )\n    public\n    returns (uint)\n    {\n        require(msg.sender == address(twoKeyDonationCampaign));\n        //If KYC is required, basic funnel executes and we require that converter is not previously rejected\n        if(_isKYCRequired == true) {\n            require(converterToState[_converterAddress] != ConverterState.REJECTED); // If converter is rejected then can't create conversion\n            // Checking the state for converter, if this is his 1st time, he goes initially to PENDING_APPROVAL\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.PENDING_APPROVAL;\n                stateToConverter[bytes32(\"PENDING_APPROVAL\")].push(_converterAddress);\n            }\n        } else {\n            //If KYC is not required converter is automatically approved\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.APPROVED;\n                stateToConverter[bytes32(\"APPROVED\")].push(_converterAddress);\n            }\n        }\n\n\n        uint256 _moderatorFeeETHWei = calculateModeratorFee(_conversionAmount);\n        uint256 _contractorProceeds = _conversionAmount.sub(_maxReferralRewardETHWei.add(_moderatorFeeETHWei));\n        counters[1] = counters[1].add(1);\n\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmount);\n\n        Conversion memory c = Conversion(\n            contractor,\n            _contractorProceeds,\n            _converterAddress,\n            ConversionState.APPROVED,\n            _conversionAmount,\n            _maxReferralRewardETHWei,\n            0,\n            _moderatorFeeETHWei,\n            amountOfTokens\n        );\n\n        conversions.push(c);\n        converterToHisConversions[_converterAddress].push(numberOfConversions);\n        emitConvertedEvent(_converterAddress, _conversionAmount, numberOfConversions);\n\n        emit ConversionCreated(numberOfConversions);\n        numberOfConversions = numberOfConversions.add(1);\n\n        return numberOfConversions-1;\n\n    }\n\n    function executeConversion(\n        uint _conversionId\n    )\n    public\n    {\n        Conversion conversion = conversions[_conversionId];\n        require(converterToState[conversion.converter] == ConverterState.APPROVED);\n        require(conversion.state == ConversionState.APPROVED);\n\n        counters[1] = counters[1].sub(1); //Decrease number of approved conversions\n\n//         Buy tokens from campaign and distribute rewards between referrers\n        uint totalReward2keys = twoKeyDonationCampaign.buyTokensAndDistributeReferrerRewards(\n            conversion.maxReferralRewardETHWei,\n            conversion.converter,\n            _conversionId\n        );\n\n\n        // Update reputation points in registry for conversion executed event\n//        ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionExecutedEvent(\n//            conversion.converter,\n//            contractor,\n//            twoKeyDonationCampaign\n//        );\n\n\n        amountConverterSpentEthWEI[conversion.converter] = amountConverterSpentEthWEI[conversion.converter].add(conversion.conversionAmount);\n        counters[8] = counters[8].add(totalReward2keys);\n        twoKeyDonationCampaign.buyTokensForModeratorRewards(conversion.moderatorFeeETHWei);\n        twoKeyDonationCampaign.updateContractorProceeds(conversion.contractorProceedsETHWei);\n\n        counters[6] = counters[6].add(conversion.conversionAmount);\n\n        if(doesConverterHaveExecutedConversions[conversion.converter] == false) {\n            counters[5] = counters[5].add(1); //increase number of unique converters\n            doesConverterHaveExecutedConversions[conversion.converter] = true;\n        }\n\n        conversion.maxReferralReward2key = totalReward2keys;\n        conversion.state = ConversionState.EXECUTED;\n        counters[3] = counters[3].add(1); //Increase number of executed conversions\n\n        transferInvoiceToken(conversion.converter, conversion.conversionAmount);\n        emitExecutedEvent(conversion.converter, _conversionId, conversion.tokensBought);\n    }\n\n\n    /// @notice Function where we are approving converter\n    /// @dev only maintainer or contractor can call this method\n    /// @param _converter is the address of converter\n    function approveConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingOrRejectedToApprovedState(_converter);\n    }\n\n    function rejectConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingToRejectedState(_converter);\n\n        uint refundAmount = 0;\n        uint len = converterToHisConversions[_converter].length;\n\n        for(uint i=0; i<len; i++) {\n            uint conversionId = converterToHisConversions[_converter][i];\n            Conversion c = conversions[conversionId];\n\n            //In this case since we don't support FIAT, every conversion is auto approved\n            if(c.state == ConversionState.APPROVED) {\n                counters[1] = counters[1].sub(1); // Reduce number of approved conversions\n                counters[2] = counters[2].add(1); //Increase number of rejected conversions\n//                ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionRejectedEvent(_converter, contractor, twoKeyAcquisitionCampaignERC20);\n                c.state = ConversionState.REJECTED;\n                refundAmount = refundAmount.add(c.conversionAmount);\n            }\n        }\n\n        if(refundAmount > 0) {\n            twoKeyDonationCampaign.sendBackEthWhenConversionRejected(_converter, refundAmount);\n        }\n\n        emitRejectedEvent(twoKeyDonationCampaign, _converter);\n    }\n\n    /**\n     * @notice Function to get all conversion ids for the converter\n     * @param _converter is the address of the converter\n     * @return array of conversion ids\n     * @dev can only be called by converter itself or maintainer/contractor\n     */\n    function getConverterConversionIds(\n        address _converter\n    )\n    public\n    view\n    returns (uint[])\n    {\n        return converterToHisConversions[_converter];\n    }\n\n\n    function getLastConverterConversionId(\n        address _converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToHisConversions[_converter][converterToHisConversions[_converter].length - 1];\n    }\n\n    /**\n     * @notice Get's number of converters per type, and returns tuple, as well as total raised funds\n     getCampaignSummary\n     */\n    function getCampaignSummary()\n    public\n    view\n    returns (uint,uint,uint,uint[])\n    {\n        bytes32 pending = convertConverterStateToBytes(ConverterState.PENDING_APPROVAL);\n        bytes32 approved = convertConverterStateToBytes(ConverterState.APPROVED);\n        bytes32 rejected = convertConverterStateToBytes(ConverterState.REJECTED);\n\n        uint numberOfPending = stateToConverter[pending].length;\n        uint numberOfApproved = stateToConverter[approved].length;\n        uint numberOfRejected = stateToConverter[rejected].length;\n\n        return (\n        numberOfPending,\n        numberOfApproved,\n        numberOfRejected,\n        counters\n        );\n    }\n\n    /**\n     * @notice Function to get number of conversions\n     * @dev Can only be called by contractor or maintainer\n     */\n    function getNumberOfConversions()\n    external\n    view\n    returns (uint)\n    {\n        return numberOfConversions;\n    }\n\n    /**\n     * @notice Function to get converter state\n     * @param _converter is the address of the requested converter\n     * @return hexed string of the state\n     */\n    function getStateForConverter(\n        address _converter\n    )\n    external\n    view\n    returns (bytes32)\n    {\n        return convertConverterStateToBytes(converterToState[_converter]);\n    }\n\n\n    function getAllConvertersPerState(\n        bytes32 state\n    )\n    public\n    view\n    onlyContractorOrMaintainer\n    returns (address[])\n    {\n        return stateToConverter[state];\n    }\n\n    /**\n     * @notice Function to get conversion details by id\n     * @param conversionId is the id of conversion\n     */\n    function getConversion(\n        uint conversionId\n    )\n    external\n    view\n    returns (bytes)\n    {\n        Conversion memory conversion = conversions[conversionId];\n\n        address converter; // Defaults to 0x0\n\n        if(isConverterAnonymous[conversion.converter] == false) {\n            converter = conversion.converter;\n        }\n\n        return abi.encodePacked (\n            conversion.contractor,\n            converter,\n            conversion.contractorProceedsETHWei,\n            conversion.conversionAmount,\n            conversion.tokensBought,\n            conversion.maxReferralRewardETHWei,\n            conversion.maxReferralReward2key,\n            conversion.moderatorFeeETHWei,\n            conversion.state\n        );\n    }\n\n    function getAmountConverterSpent(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return amountConverterSpentEthWEI[converter];\n    }\n\n    function getAmountOfDonationTokensConverterReceived(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToAmountOfDonationTokensReceived[converter];\n    }\n\n}\n", "commit_id": "4b884f1bd46dc4e6e1d7d9b44f08ee6a097b8bf5"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.24;\n\n\nimport \"./InvoiceTokenERC20.sol\";\nimport \"../TwoKeyConversionStates.sol\";\nimport \"../TwoKeyConverterStates.sol\";\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../interfaces/ITwoKeyDonationCampaign.sol\";\nimport \"../interfaces/ITwoKeyEventSource.sol\";\nimport \"../interfaces/ITwoKeySingletoneRegistryFetchAddress.sol\";\nimport \"../interfaces/ITwoKeyBaseReputationRegistry.sol\";\nimport \"../interfaces/ITwoKeyMaintainersRegistry.sol\";\nimport \"../interfaces/ITwoKeyExchangeRateContract.sol\";\nimport \"../upgradable-pattern-campaigns/UpgradeableCampaign.sol\";\n\n\ncontract TwoKeyDonationConversionHandler is UpgradeableCampaign, TwoKeyConversionStates, TwoKeyConverterStates {\n\n    using SafeMath for uint256; // Define lib necessary to handle uint operations\n    bool isCampaignInitialized; //defaults to false\n\n    Conversion [] public conversions;\n    InvoiceTokenERC20 public erc20InvoiceToken; // ERC20 token which will be issued as an invoice\n\n    ITwoKeyDonationCampaign twoKeyDonationCampaign;\n\n    event ConversionCreated(uint conversionId);\n\n    address twoKeySingletonRegistry;\n    address twoKeyEventSource;\n\n    string currency;\n    address contractor;\n    uint numberOfConversions;\n    /**\n     * This array will represent counter values where position will be index (which counter) and value will be actual counter value\n     * counters[0] = PENDING_CONVERSIONS\n     * counters[1] = APPROVED_CONVERSIONS\n     * counters[2] = REJECTED_CONVERSIONS\n     * counters[3] = EXECUTED_CONVERSIONS\n     * counters[4] = CANCELLED_CONVERSIONS\n     * counters[5] = UNIQUE_CONVERTERS\n     * counters[6] = RAISED_FUNDS_ETH_WEI\n     * counters[7] = TOKENS_SOLD\n     * counters[8] = TOTAL_BOUNTY\n     * counters[9] = RAISED_FUNDS_FIAT_WEI\n     */\n    uint [] counters; //Metrics counter\n\n\n    mapping(address => uint256) private amountConverterSpentEthWEI; // Amount converter put to the contract in Ether\n    mapping(address => uint256) private converterToAmountOfDonationTokensReceived;\n    mapping(bytes32 => address[]) stateToConverter; //State to all converters in that state\n    mapping(address => ConverterState) converterToState; // Converter to state\n    mapping(address => uint[]) converterToHisConversions;\n    mapping(address => bool) isConverterAnonymous;\n    mapping(address => bool) doesConverterHaveExecutedConversions;\n\n    //Struct to represent donation in Ether\n    struct Conversion {\n        address contractor; // Contractor (creator) of campaign\n        uint256 contractorProceedsETHWei; // How much contractor will receive for this conversion\n        address converter; // Converter is one who's buying tokens -> plasma address\n        ConversionState state;\n        uint256 conversionAmount; // Amount for conversion (In ETH / FIAT)\n        uint256 maxReferralRewardETHWei; // Total referral reward for the conversion\n        uint256 maxReferralReward2key;\n        uint256 moderatorFeeETHWei;\n        uint256 tokensBought;\n    }\n\n    event InvoiceTokenCreated(\n        address token,\n        string tokenName,\n        string tokenSymbol\n    );\n\n\n    modifier onlyContractorOrMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(msg.sender == contractor || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n        _;\n    }\n\n\n    function setInitialParamsDonationConversionHandler(\n        string tokenName,\n        string tokenSymbol,\n        string _currency,\n        address _contractor,\n        address _twoKeyDonationCampaign,\n        address _twoKeySingletonRegistry\n    )\n    public\n    {\n        require(isCampaignInitialized == false);\n\n        counters = new uint[](10);\n        twoKeyDonationCampaign = ITwoKeyDonationCampaign(_twoKeyDonationCampaign);\n        twoKeySingletonRegistry = _twoKeySingletonRegistry;\n        twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\");\n        contractor = _contractor;\n        currency = _currency;\n        // Deploy an ERC20 token which will be used as the Invoice\n        erc20InvoiceToken = new InvoiceTokenERC20(tokenName,tokenSymbol,address(this));\n        // Emit an event with deployed token address, name, and symbol\n        emit InvoiceTokenCreated(address(erc20InvoiceToken), tokenName, tokenSymbol);\n        isCampaignInitialized = true;\n    }\n\n\n    // Internal function to fetch address from TwoKeyRegTwoistry\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(twoKeySingletonRegistry)\n        .getContractProxyAddress(contractName);\n    }\n\n    /**\n     * given the total payout, calculates the moderator fee\n     * @param  _conversionAmountETHWei total payout for escrow\n     * @return moderator fee\n     */\n    function calculateModeratorFee(\n        uint256 _conversionAmountETHWei\n    )\n    private\n    view\n    returns (uint256)\n    {\n        uint256 fee = _conversionAmountETHWei.mul(ITwoKeyEventSource(twoKeyEventSource).getTwoKeyDefaultIntegratorFeeFromAdmin()).div(100);\n        return fee;\n    }\n\n    function emitConvertedEvent(\n        address converterAddress,\n        uint conversionAmount,\n        uint conversionId\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).convertedDonationV2(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(converterAddress),\n            conversionAmount,\n            conversionId\n        );\n    }\n\n    function emitExecutedEvent(\n        address _converterAddress,\n        uint conversionId,\n        uint tokens\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).executedV1(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress),\n            conversionId,\n            tokens\n        );\n    }\n\n    function emitRejectedEvent(\n        address _campaignAddress,\n        address _converterAddress\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).rejected(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress)\n        );\n    }\n\n    /**\n     * @notice Function to calculate amount of donation tokens to be received\n     * @param _conversionAmountETHWei is the amount of conversion in WEI\n     */\n    function calculateAmountOfTokens(\n        uint _conversionAmountETHWei\n    )\n    internal\n    view\n    returns (uint)\n    {\n        if(keccak256(currency) == keccak256('ETH')) {\n            return _conversionAmountETHWei;\n        } else {\n            address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n            uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(currency);\n            uint conversionAmountInFIAT = (_conversionAmountETHWei*rate).div(10**18);\n            return conversionAmountInFIAT;\n        }\n    }\n\n\n    function transferInvoiceToken(\n        address _converter,\n        uint _conversionAmountETHWei\n    )\n    internal\n    {\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmountETHWei);\n        converterToAmountOfDonationTokensReceived[_converter] = converterToAmountOfDonationTokensReceived[_converter].add(amountOfTokens);\n        erc20InvoiceToken.transfer(_converter, amountOfTokens);\n    }\n\n\n\n    /// @notice Function to move converter address from stateA to stateB\n    /// @param _converter is the address of converter\n    /// @param destinationState is the state we'd like to move converter to\n    function moveFromStateAToStateB(\n        address _converter,\n        bytes32 destinationState\n    )\n    internal\n    {\n        ConverterState state = converterToState[_converter];\n        bytes32 key = convertConverterStateToBytes(state);\n        address[] memory pending = stateToConverter[key];\n        for(uint i=0; i< pending.length; i++) {\n            if(pending[i] == _converter) {\n                stateToConverter[destinationState].push(_converter);\n                pending[i] = pending[pending.length-1];\n                delete pending[pending.length-1];\n                stateToConverter[key] = pending;\n                stateToConverter[key].length--;\n                break;\n            }\n        }\n    }\n\n    /// @notice Function where we can change state of converter to Approved\n    /// @dev Converter can only be approved if his previous state is pending or rejected\n    /// @param _converter is the address of converter\n    function moveFromPendingOrRejectedToApprovedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"APPROVED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.APPROVED;\n    }\n\n\n    /// @notice Function where we're going to move state of conversion from pending to rejected\n    /// @dev private function, will be executed in another one\n    /// @param _converter is the address of converter\n    function moveFromPendingToRejectedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"REJECTED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.REJECTED;\n    }\n\n\n    /**\n     * @param _converterAddress is the one who calls join and donate function\n     */\n    function supportForCreateConversion(\n        address _converterAddress,\n        uint _conversionAmount,\n        uint _maxReferralRewardETHWei,\n        bool _isKYCRequired\n    )\n    public\n    returns (uint)\n    {\n        require(msg.sender == address(twoKeyDonationCampaign));\n        //If KYC is required, basic funnel executes and we require that converter is not previously rejected\n        if(_isKYCRequired == true) {\n            require(converterToState[_converterAddress] != ConverterState.REJECTED); // If converter is rejected then can't create conversion\n            // Checking the state for converter, if this is his 1st time, he goes initially to PENDING_APPROVAL\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.PENDING_APPROVAL;\n                stateToConverter[bytes32(\"PENDING_APPROVAL\")].push(_converterAddress);\n            }\n        } else {\n            //If KYC is not required converter is automatically approved\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.APPROVED;\n                stateToConverter[bytes32(\"APPROVED\")].push(_converterAddress);\n            }\n        }\n\n\n        uint256 _moderatorFeeETHWei = calculateModeratorFee(_conversionAmount);\n        uint256 _contractorProceeds = _conversionAmount.sub(_maxReferralRewardETHWei.add(_moderatorFeeETHWei));\n        counters[1] = counters[1].add(1);\n\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmount);\n\n        Conversion memory c = Conversion(\n            contractor,\n            _contractorProceeds,\n            _converterAddress,\n            ConversionState.APPROVED,\n            _conversionAmount,\n            _maxReferralRewardETHWei,\n            0,\n            _moderatorFeeETHWei,\n            amountOfTokens\n        );\n\n        conversions.push(c);\n        converterToHisConversions[_converterAddress].push(numberOfConversions);\n        emitConvertedEvent(_converterAddress, _conversionAmount, numberOfConversions);\n\n        emit ConversionCreated(numberOfConversions);\n        numberOfConversions = numberOfConversions.add(1);\n\n        return numberOfConversions-1;\n\n    }\n\n    function executeConversion(\n        uint _conversionId\n    )\n    public\n    {\n        Conversion conversion = conversions[_conversionId];\n        require(converterToState[conversion.converter] == ConverterState.APPROVED);\n        require(conversion.state == ConversionState.APPROVED);\n\n        counters[1] = counters[1].sub(1); //Decrease number of approved conversions\n\n//         Buy tokens from campaign and distribute rewards between referrers\n        uint totalReward2keys = twoKeyDonationCampaign.buyTokensAndDistributeReferrerRewards(\n            conversion.maxReferralRewardETHWei,\n            conversion.converter,\n            _conversionId\n        );\n\n\n        // Update reputation points in registry for conversion executed event\n//        ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionExecutedEvent(\n//            conversion.converter,\n//            contractor,\n//            twoKeyDonationCampaign\n//        );\n\n\n        amountConverterSpentEthWEI[conversion.converter] = amountConverterSpentEthWEI[conversion.converter].add(conversion.conversionAmount);\n        counters[8] = counters[8].add(totalReward2keys);\n        twoKeyDonationCampaign.buyTokensForModeratorRewards(conversion.moderatorFeeETHWei);\n        twoKeyDonationCampaign.updateContractorProceeds(conversion.contractorProceedsETHWei);\n\n        counters[6] = counters[6].add(conversion.conversionAmount);\n\n        if(doesConverterHaveExecutedConversions[conversion.converter] == false) {\n            counters[5] = counters[5].add(1); //increase number of unique converters\n            doesConverterHaveExecutedConversions[conversion.converter] = true;\n        }\n\n        conversion.maxReferralReward2key = totalReward2keys;\n        conversion.state = ConversionState.EXECUTED;\n        counters[3] = counters[3].add(1); //Increase number of executed conversions\n\n        transferInvoiceToken(conversion.converter, conversion.conversionAmount);\n        emitExecutedEvent(conversion.converter, _conversionId, conversion.tokensBought);\n    }\n\n\n    /// @notice Function where we are approving converter\n    /// @dev only maintainer or contractor can call this method\n    /// @param _converter is the address of converter\n    function approveConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingOrRejectedToApprovedState(_converter);\n    }\n\n    function rejectConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingToRejectedState(_converter);\n\n        uint refundAmount = 0;\n        uint len = converterToHisConversions[_converter].length;\n\n        for(uint i=0; i<len; i++) {\n            uint conversionId = converterToHisConversions[_converter][i];\n            Conversion c = conversions[conversionId];\n\n            //In this case since we don't support FIAT, every conversion is auto approved\n            if(c.state == ConversionState.APPROVED) {\n                counters[1] = counters[1].sub(1); // Reduce number of approved conversions\n                counters[2] = counters[2].add(1); //Increase number of rejected conversions\n//                ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionRejectedEvent(_converter, contractor, twoKeyAcquisitionCampaignERC20);\n                c.state = ConversionState.REJECTED;\n                refundAmount = refundAmount.add(c.conversionAmount);\n            }\n        }\n\n        if(refundAmount > 0) {\n            twoKeyDonationCampaign.sendBackEthWhenConversionRejected(_converter, refundAmount);\n        }\n\n        emitRejectedEvent(twoKeyDonationCampaign, _converter);\n    }\n\n    /**\n     * @notice Function to get all conversion ids for the converter\n     * @param _converter is the address of the converter\n     * @return array of conversion ids\n     * @dev can only be called by converter itself or maintainer/contractor\n     */\n    function getConverterConversionIds(\n        address _converter\n    )\n    public\n    view\n    returns (uint[])\n    {\n        return converterToHisConversions[_converter];\n    }\n\n\n    function getLastConverterConversionId(\n        address _converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToHisConversions[_converter][converterToHisConversions[_converter].length - 1];\n    }\n\n    /**\n     * @notice Get's number of converters per type, and returns tuple, as well as total raised funds\n     getCampaignSummary\n     */\n    function getCampaignSummary()\n    public\n    view\n    returns (uint,uint,uint,uint[])\n    {\n        bytes32 pending = convertConverterStateToBytes(ConverterState.PENDING_APPROVAL);\n        bytes32 approved = convertConverterStateToBytes(ConverterState.APPROVED);\n        bytes32 rejected = convertConverterStateToBytes(ConverterState.REJECTED);\n\n        uint numberOfPending = stateToConverter[pending].length;\n        uint numberOfApproved = stateToConverter[approved].length;\n        uint numberOfRejected = stateToConverter[rejected].length;\n\n        return (\n        numberOfPending,\n        numberOfApproved,\n        numberOfRejected,\n        counters\n        );\n    }\n\n    /**\n     * @notice Function to get number of conversions\n     * @dev Can only be called by contractor or maintainer\n     */\n    function getNumberOfConversions()\n    external\n    view\n    returns (uint)\n    {\n        return numberOfConversions;\n    }\n\n    /**\n     * @notice Function to get converter state\n     * @param _converter is the address of the requested converter\n     * @return hexed string of the state\n     */\n    function getStateForConverter(\n        address _converter\n    )\n    external\n    view\n    returns (bytes32)\n    {\n        return convertConverterStateToBytes(converterToState[_converter]);\n    }\n\n\n    function getAllConvertersPerState(\n        bytes32 state\n    )\n    public\n    view\n    onlyContractorOrMaintainer\n    returns (address[])\n    {\n        return stateToConverter[state];\n    }\n\n    /**\n     * @notice Function to get conversion details by id\n     * @param conversionId is the id of conversion\n     */\n    function getConversion(\n        uint conversionId\n    )\n    external\n    view\n    returns (bytes)\n    {\n        Conversion memory conversion = conversions[conversionId];\n\n        address converter; // Defaults to 0x0\n\n        if(isConverterAnonymous[conversion.converter] == false) {\n            converter = conversion.converter;\n        }\n\n        return abi.encodePacked (\n            conversion.contractor,\n            converter,\n            conversion.contractorProceedsETHWei,\n            conversion.conversionAmount,\n            conversion.tokensBought,\n            conversion.maxReferralRewardETHWei,\n            conversion.maxReferralReward2key,\n            conversion.moderatorFeeETHWei,\n            conversion.state\n        );\n    }\n\n    function getAmountConverterSpent(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return amountConverterSpentEthWEI[converter];\n    }\n\n    function getAmountOfDonationTokensConverterReceived(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToAmountOfDonationTokensReceived[converter];\n    }\n\n}\n", "flattened_code": "pragma solidity ^0.4.24;\n\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address _who) public view returns (uint256);\n    function transfer(address _to, uint256 _value) public returns (bool);\n    function allowance(address _ocwner, address _spender) public view returns (uint256);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (_a == 0) {\n      return 0;\n    }\n\n    c = _a * _b;\n    require(c / _a == _b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = _a / _b;\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n    return _a / _b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n    require(_b <= _a);\n    return _a - _b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\n    c = _a + _b;\n    require(c >= _a);\n    return c;\n  }\n}\n\n/**\n * @author Nikola Madjarevic\n */\ncontract InvoiceTokenERC20 is ERC20 {\n\n    using SafeMath for uint256;\n\n    uint256 internal totalSupply_ = 10000000000000000000000000000;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    address public owner;\n\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n    mapping(address => uint256) internal balances;\n\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n\n    constructor(string _name, string _symbol, address _tokensOwner) public {\n        owner = _tokensOwner;\n        name = _name;\n        symbol = _symbol;\n        balances[_tokensOwner] = totalSupply_;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    public\n    returns (bool)\n    {\n        revert();\n    }\n\n    /**\n     * @dev approve is not supported regarding the specs\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        revert();\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n    public\n    view\n    returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param _to The address to transfer to.\n     * @param _value The amount to be transferred.\n     */\n    function transfer(address _to, uint256 _value) public onlyOwner returns (bool) {\n        require(_value <= balances[msg.sender]);\n        require(_to != address(0));\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\npragma solidity ^0.4.24;\n\n/**\n * @author Nikola Madjarevic\n */\ncontract TwoKeyConversionStates {\n    enum ConversionState {PENDING_APPROVAL, APPROVED, EXECUTED, REJECTED, CANCELLED_BY_CONVERTER}\n}\npragma solidity ^0.4.24;\n\ncontract TwoKeyConverterStates {\n    enum ConverterState {NOT_EXISTING, PENDING_APPROVAL, APPROVED, REJECTED}\n\n    /// @notice Function to convert converter state to it's bytes representation (Maybe we don't even need it)\n    /// @param state is conversion state\n    /// @return bytes32 (hex) representation of state\n    function convertConverterStateToBytes(\n        ConverterState state\n    )\n    internal\n    pure\n    returns (bytes32)\n    {\n        if(ConverterState.NOT_EXISTING == state) {\n            return bytes32(\"NOT_EXISTING\");\n        }\n        else if(ConverterState.PENDING_APPROVAL == state) {\n            return bytes32(\"PENDING_APPROVAL\");\n        }\n        else if(ConverterState.APPROVED == state) {\n            return bytes32(\"APPROVED\");\n        }\n        else if(ConverterState.REJECTED == state) {\n            return bytes32(\"REJECTED\");\n        }\n    }\n}\n\npragma solidity ^0.4.24;\n\ncontract ITwoKeyDonationCampaign {\n\n    function buyTokensForModeratorRewards(\n        uint moderatorFee\n    )\n    public;\n\n    function buyTokensAndDistributeReferrerRewards(\n        uint256 _maxReferralRewardETHWei,\n        address _converter,\n        uint _conversionId\n    )\n    public\n    returns (uint);\n\n    function getReferrerPlasmaBalance(address _influencer) public view returns (uint);\n    function updateReferrerPlasmaBalance(address _influencer, uint _balance) public;\n    function getReferrerCut(address me) public view returns (uint256);\n    function updateContractorProceeds(uint value) public;\n    function getReceivedFrom(address _receiver) public view returns (address);\n    function balanceOf(address _owner) public view returns (uint256);\n    function sendBackEthWhenConversionRejected(address _rejectedConverter, uint _conversionAmount) public;\n}\npragma solidity ^0.4.24;\n\n\ncontract ITwoKeyEventSource {\n    function ethereumOf(address me) public view returns (address);\n    function plasmaOf(address me) public view returns (address);\n    function isAddressMaintainer(address _maintainer) public view returns (bool);\n    function getTwoKeyDefaultIntegratorFeeFromAdmin() public view returns (uint);\n    function joined(address _campaign, address _from, address _to) external view;\n    function rejected(address _campaign, address _converter) external view;\n\n    function convertedAcquisitionV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _baseTokens,\n        uint256 _bonusTokens,\n        uint256 _conversionAmount,\n        bool _isFiatConversion,\n        uint _conversionId\n    )\n    external\n    view;\n\n    function getTwoKeyDefaultNetworkTaxPercent()\n    public\n    view\n    returns (uint);\n\n    function convertedDonationV2(\n        address _campaign,\n        address _converterPlasma,\n        uint256 _conversionAmount,\n        uint256 _conversionId\n    )\n    external\n    view;\n\n    function executedV1(\n        address _campaignAddress,\n        address _converterPlasmaAddress,\n        uint _conversionId,\n        uint tokens\n    )\n    external\n    view;\n\n}\npragma solidity ^0.4.24;\n/**\n * @author Nikola Madjarevic\n * Created at 2/7/19\n */\ncontract ITwoKeySingletoneRegistryFetchAddress {\n    function getContractProxyAddress(string _contractName) public view returns (address);\n    function getNonUpgradableContractAddress(string contractName) public view returns (address);\n    function getLatestContractVersion(string contractName) public view returns (string);\n}\npragma solidity ^0.4.24;\n/**\n * @author Nikola Madjarevic\n * Created at 2/4/19\n */\ncontract ITwoKeyBaseReputationRegistry {\n    function updateOnConversionExecutedEvent(address converter, address contractor, address acquisitionCampaign) public;\n    function updateOnConversionRejectedEvent(address converter, address contractor, address acquisitionCampaign) public;\n}\npragma solidity ^0.4.24;\n\ncontract ITwoKeyMaintainersRegistry {\n    function onlyMaintainer(address _sender) public view returns (bool);\n}\npragma solidity ^0.4.24;\n\n/**\n * @author Nikola Madjarevic\n */\ncontract ITwoKeyExchangeRateContract {\n    function getBaseToTargetRate(string _currency) public view returns (uint);\n}\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\n/**\n * @title IRegistry\n * @dev This contract represents the interface of a registry contract\n */\ninterface ITwoKeySingletonesRegistry {\n\n    /**\n    * @dev This event will be emitted every time a new proxy is created\n    * @param proxy representing the address of the proxy created\n    */\n    event ProxyCreated(address proxy);\n\n\n    /**\n    * @dev This event will be emitted every time a new implementation is registered\n    * @param version representing the version name of the registered implementation\n    * @param implementation representing the address of the registered implementation\n    */\n    event VersionAdded(string version, address implementation);\n\n    /**\n    * @dev Registers a new version with its implementation address\n    * @param version representing the version name of the new implementation to be registered\n    * @param implementation representing the address of the new implementation to be registered\n    */\n    function addVersion(string _contractName, string version, address implementation) public;\n\n    /**\n    * @dev Tells the address of the implementation for a given version\n    * @param _contractName is the name of the contract we're querying\n    * @param version to query the implementation of\n    * @return address of the implementation registered for the given version\n    */\n    function getVersion(string _contractName, string version) public view returns (address);\n}\n\ncontract UpgradeabilityCampaignStorage {\n    // Versions registry\n    ITwoKeySingletonesRegistry internal registry;\n\n    address internal twoKeyFactory;\n\n    // Address of the current implementation\n    address internal _implementation;\n\n    /**\n    * @dev Tells the address of the current implementation\n    * @return address of the current implementation\n    */\n    function implementation() public view returns (address) {\n        return _implementation;\n    }\n}\n\ncontract UpgradeableCampaign is UpgradeabilityCampaignStorage {\n\n}\n\n\ncontract TwoKeyDonationConversionHandler is UpgradeableCampaign, TwoKeyConversionStates, TwoKeyConverterStates {\n\n    using SafeMath for uint256; // Define lib necessary to handle uint operations\n    bool isCampaignInitialized; //defaults to false\n\n    Conversion [] public conversions;\n    InvoiceTokenERC20 public erc20InvoiceToken; // ERC20 token which will be issued as an invoice\n\n    ITwoKeyDonationCampaign twoKeyDonationCampaign;\n\n    event ConversionCreated(uint conversionId);\n\n    address twoKeySingletonRegistry;\n    address twoKeyEventSource;\n\n    string currency;\n    address contractor;\n    uint numberOfConversions;\n    /**\n     * This array will represent counter values where position will be index (which counter) and value will be actual counter value\n     * counters[0] = PENDING_CONVERSIONS\n     * counters[1] = APPROVED_CONVERSIONS\n     * counters[2] = REJECTED_CONVERSIONS\n     * counters[3] = EXECUTED_CONVERSIONS\n     * counters[4] = CANCELLED_CONVERSIONS\n     * counters[5] = UNIQUE_CONVERTERS\n     * counters[6] = RAISED_FUNDS_ETH_WEI\n     * counters[7] = TOKENS_SOLD\n     * counters[8] = TOTAL_BOUNTY\n     * counters[9] = RAISED_FUNDS_FIAT_WEI\n     */\n    uint [] counters; //Metrics counter\n\n\n    mapping(address => uint256) private amountConverterSpentEthWEI; // Amount converter put to the contract in Ether\n    mapping(address => uint256) private converterToAmountOfDonationTokensReceived;\n    mapping(bytes32 => address[]) stateToConverter; //State to all converters in that state\n    mapping(address => ConverterState) converterToState; // Converter to state\n    mapping(address => uint[]) converterToHisConversions;\n    mapping(address => bool) isConverterAnonymous;\n    mapping(address => bool) doesConverterHaveExecutedConversions;\n\n    //Struct to represent donation in Ether\n    struct Conversion {\n        address contractor; // Contractor (creator) of campaign\n        uint256 contractorProceedsETHWei; // How much contractor will receive for this conversion\n        address converter; // Converter is one who's buying tokens -> plasma address\n        ConversionState state;\n        uint256 conversionAmount; // Amount for conversion (In ETH / FIAT)\n        uint256 maxReferralRewardETHWei; // Total referral reward for the conversion\n        uint256 maxReferralReward2key;\n        uint256 moderatorFeeETHWei;\n        uint256 tokensBought;\n    }\n\n    event InvoiceTokenCreated(\n        address token,\n        string tokenName,\n        string tokenSymbol\n    );\n\n\n    modifier onlyContractorOrMaintainer {\n        address twoKeyMaintainersRegistry = getAddressFromTwoKeySingletonRegistry(\"TwoKeyMaintainersRegistry\");\n        require(msg.sender == contractor || ITwoKeyMaintainersRegistry(twoKeyMaintainersRegistry).onlyMaintainer(msg.sender));\n        _;\n    }\n\n\n    function setInitialParamsDonationConversionHandler(\n        string tokenName,\n        string tokenSymbol,\n        string _currency,\n        address _contractor,\n        address _twoKeyDonationCampaign,\n        address _twoKeySingletonRegistry\n    )\n    public\n    {\n        require(isCampaignInitialized == false);\n\n        counters = new uint[](10);\n        twoKeyDonationCampaign = ITwoKeyDonationCampaign(_twoKeyDonationCampaign);\n        twoKeySingletonRegistry = _twoKeySingletonRegistry;\n        twoKeyEventSource = getAddressFromTwoKeySingletonRegistry(\"TwoKeyEventSource\");\n        contractor = _contractor;\n        currency = _currency;\n        // Deploy an ERC20 token which will be used as the Invoice\n        erc20InvoiceToken = new InvoiceTokenERC20(tokenName,tokenSymbol,address(this));\n        // Emit an event with deployed token address, name, and symbol\n        emit InvoiceTokenCreated(address(erc20InvoiceToken), tokenName, tokenSymbol);\n        isCampaignInitialized = true;\n    }\n\n\n    // Internal function to fetch address from TwoKeyRegTwoistry\n    function getAddressFromTwoKeySingletonRegistry(string contractName) internal view returns (address) {\n        return ITwoKeySingletoneRegistryFetchAddress(twoKeySingletonRegistry)\n        .getContractProxyAddress(contractName);\n    }\n\n    /**\n     * given the total payout, calculates the moderator fee\n     * @param  _conversionAmountETHWei total payout for escrow\n     * @return moderator fee\n     */\n    function calculateModeratorFee(\n        uint256 _conversionAmountETHWei\n    )\n    private\n    view\n    returns (uint256)\n    {\n        uint256 fee = _conversionAmountETHWei.mul(ITwoKeyEventSource(twoKeyEventSource).getTwoKeyDefaultIntegratorFeeFromAdmin()).div(100);\n        return fee;\n    }\n\n    function emitConvertedEvent(\n        address converterAddress,\n        uint conversionAmount,\n        uint conversionId\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).convertedDonationV2(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(converterAddress),\n            conversionAmount,\n            conversionId\n        );\n    }\n\n    function emitExecutedEvent(\n        address _converterAddress,\n        uint conversionId,\n        uint tokens\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).executedV1(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress),\n            conversionId,\n            tokens\n        );\n    }\n\n    function emitRejectedEvent(\n        address _campaignAddress,\n        address _converterAddress\n    )\n    internal\n    view\n    {\n        ITwoKeyEventSource(twoKeyEventSource).rejected(\n            twoKeyDonationCampaign,\n            ITwoKeyEventSource(twoKeyEventSource).plasmaOf(_converterAddress)\n        );\n    }\n\n    /**\n     * @notice Function to calculate amount of donation tokens to be received\n     * @param _conversionAmountETHWei is the amount of conversion in WEI\n     */\n    function calculateAmountOfTokens(\n        uint _conversionAmountETHWei\n    )\n    internal\n    view\n    returns (uint)\n    {\n        if(keccak256(currency) == keccak256('ETH')) {\n            return _conversionAmountETHWei;\n        } else {\n            address twoKeyExchangeRateContract = getAddressFromTwoKeySingletonRegistry(\"TwoKeyExchangeRateContract\");\n            uint rate = ITwoKeyExchangeRateContract(twoKeyExchangeRateContract).getBaseToTargetRate(currency);\n            uint conversionAmountInFIAT = (_conversionAmountETHWei*rate).div(10**18);\n            return conversionAmountInFIAT;\n        }\n    }\n\n\n    function transferInvoiceToken(\n        address _converter,\n        uint _conversionAmountETHWei\n    )\n    internal\n    {\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmountETHWei);\n        converterToAmountOfDonationTokensReceived[_converter] = converterToAmountOfDonationTokensReceived[_converter].add(amountOfTokens);\n        erc20InvoiceToken.transfer(_converter, amountOfTokens);\n    }\n\n\n\n    /// @notice Function to move converter address from stateA to stateB\n    /// @param _converter is the address of converter\n    /// @param destinationState is the state we'd like to move converter to\n    function moveFromStateAToStateB(\n        address _converter,\n        bytes32 destinationState\n    )\n    internal\n    {\n        ConverterState state = converterToState[_converter];\n        bytes32 key = convertConverterStateToBytes(state);\n        address[] memory pending = stateToConverter[key];\n        for(uint i=0; i< pending.length; i++) {\n            if(pending[i] == _converter) {\n                stateToConverter[destinationState].push(_converter);\n                pending[i] = pending[pending.length-1];\n                delete pending[pending.length-1];\n                stateToConverter[key] = pending;\n                stateToConverter[key].length--;\n                break;\n            }\n        }\n    }\n\n    /// @notice Function where we can change state of converter to Approved\n    /// @dev Converter can only be approved if his previous state is pending or rejected\n    /// @param _converter is the address of converter\n    function moveFromPendingOrRejectedToApprovedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"APPROVED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.APPROVED;\n    }\n\n\n    /// @notice Function where we're going to move state of conversion from pending to rejected\n    /// @dev private function, will be executed in another one\n    /// @param _converter is the address of converter\n    function moveFromPendingToRejectedState(\n        address _converter\n    )\n    internal\n    {\n        bytes32 destination = bytes32(\"REJECTED\");\n        moveFromStateAToStateB(_converter, destination);\n        converterToState[_converter] = ConverterState.REJECTED;\n    }\n\n\n    /**\n     * @param _converterAddress is the one who calls join and donate function\n     */\n    function supportForCreateConversion(\n        address _converterAddress,\n        uint _conversionAmount,\n        uint _maxReferralRewardETHWei,\n        bool _isKYCRequired\n    )\n    public\n    returns (uint)\n    {\n        require(msg.sender == address(twoKeyDonationCampaign));\n        //If KYC is required, basic funnel executes and we require that converter is not previously rejected\n        if(_isKYCRequired == true) {\n            require(converterToState[_converterAddress] != ConverterState.REJECTED); // If converter is rejected then can't create conversion\n            // Checking the state for converter, if this is his 1st time, he goes initially to PENDING_APPROVAL\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.PENDING_APPROVAL;\n                stateToConverter[bytes32(\"PENDING_APPROVAL\")].push(_converterAddress);\n            }\n        } else {\n            //If KYC is not required converter is automatically approved\n            if(converterToState[_converterAddress] == ConverterState.NOT_EXISTING) {\n                converterToState[_converterAddress] = ConverterState.APPROVED;\n                stateToConverter[bytes32(\"APPROVED\")].push(_converterAddress);\n            }\n        }\n\n\n        uint256 _moderatorFeeETHWei = calculateModeratorFee(_conversionAmount);\n        uint256 _contractorProceeds = _conversionAmount.sub(_maxReferralRewardETHWei.add(_moderatorFeeETHWei));\n        counters[1] = counters[1].add(1);\n\n        uint amountOfTokens = calculateAmountOfTokens(_conversionAmount);\n\n        Conversion memory c = Conversion(\n            contractor,\n            _contractorProceeds,\n            _converterAddress,\n            ConversionState.APPROVED,\n            _conversionAmount,\n            _maxReferralRewardETHWei,\n            0,\n            _moderatorFeeETHWei,\n            amountOfTokens\n        );\n\n        conversions.push(c);\n        converterToHisConversions[_converterAddress].push(numberOfConversions);\n        emitConvertedEvent(_converterAddress, _conversionAmount, numberOfConversions);\n\n        emit ConversionCreated(numberOfConversions);\n        numberOfConversions = numberOfConversions.add(1);\n\n        return numberOfConversions-1;\n\n    }\n\n    function executeConversion(\n        uint _conversionId\n    )\n    public\n    {\n        Conversion conversion = conversions[_conversionId];\n        require(converterToState[conversion.converter] == ConverterState.APPROVED);\n        require(conversion.state == ConversionState.APPROVED);\n\n        counters[1] = counters[1].sub(1); //Decrease number of approved conversions\n\n//         Buy tokens from campaign and distribute rewards between referrers\n        uint totalReward2keys = twoKeyDonationCampaign.buyTokensAndDistributeReferrerRewards(\n            conversion.maxReferralRewardETHWei,\n            conversion.converter,\n            _conversionId\n        );\n\n\n        // Update reputation points in registry for conversion executed event\n//        ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionExecutedEvent(\n//            conversion.converter,\n//            contractor,\n//            twoKeyDonationCampaign\n//        );\n\n\n        amountConverterSpentEthWEI[conversion.converter] = amountConverterSpentEthWEI[conversion.converter].add(conversion.conversionAmount);\n        counters[8] = counters[8].add(totalReward2keys);\n        twoKeyDonationCampaign.buyTokensForModeratorRewards(conversion.moderatorFeeETHWei);\n        twoKeyDonationCampaign.updateContractorProceeds(conversion.contractorProceedsETHWei);\n\n        counters[6] = counters[6].add(conversion.conversionAmount);\n\n        if(doesConverterHaveExecutedConversions[conversion.converter] == false) {\n            counters[5] = counters[5].add(1); //increase number of unique converters\n            doesConverterHaveExecutedConversions[conversion.converter] = true;\n        }\n\n        conversion.maxReferralReward2key = totalReward2keys;\n        conversion.state = ConversionState.EXECUTED;\n        counters[3] = counters[3].add(1); //Increase number of executed conversions\n\n        transferInvoiceToken(conversion.converter, conversion.conversionAmount);\n        emitExecutedEvent(conversion.converter, _conversionId, conversion.tokensBought);\n    }\n\n\n    /// @notice Function where we are approving converter\n    /// @dev only maintainer or contractor can call this method\n    /// @param _converter is the address of converter\n    function approveConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingOrRejectedToApprovedState(_converter);\n    }\n\n    function rejectConverter(\n        address _converter\n    )\n    public\n    onlyContractorOrMaintainer\n    {\n        require(converterToState[_converter] == ConverterState.PENDING_APPROVAL);\n        moveFromPendingToRejectedState(_converter);\n\n        uint refundAmount = 0;\n        uint len = converterToHisConversions[_converter].length;\n\n        for(uint i=0; i<len; i++) {\n            uint conversionId = converterToHisConversions[_converter][i];\n            Conversion c = conversions[conversionId];\n\n            //In this case since we don't support FIAT, every conversion is auto approved\n            if(c.state == ConversionState.APPROVED) {\n                counters[1] = counters[1].sub(1); // Reduce number of approved conversions\n                counters[2] = counters[2].add(1); //Increase number of rejected conversions\n//                ITwoKeyBaseReputationRegistry(twoKeyBaseReputationRegistry).updateOnConversionRejectedEvent(_converter, contractor, twoKeyAcquisitionCampaignERC20);\n                c.state = ConversionState.REJECTED;\n                refundAmount = refundAmount.add(c.conversionAmount);\n            }\n        }\n\n        if(refundAmount > 0) {\n            twoKeyDonationCampaign.sendBackEthWhenConversionRejected(_converter, refundAmount);\n        }\n\n        emitRejectedEvent(twoKeyDonationCampaign, _converter);\n    }\n\n    /**\n     * @notice Function to get all conversion ids for the converter\n     * @param _converter is the address of the converter\n     * @return array of conversion ids\n     * @dev can only be called by converter itself or maintainer/contractor\n     */\n    function getConverterConversionIds(\n        address _converter\n    )\n    public\n    view\n    returns (uint[])\n    {\n        return converterToHisConversions[_converter];\n    }\n\n\n    function getLastConverterConversionId(\n        address _converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToHisConversions[_converter][converterToHisConversions[_converter].length - 1];\n    }\n\n    /**\n     * @notice Get's number of converters per type, and returns tuple, as well as total raised funds\n     getCampaignSummary\n     */\n    function getCampaignSummary()\n    public\n    view\n    returns (uint,uint,uint,uint[])\n    {\n        bytes32 pending = convertConverterStateToBytes(ConverterState.PENDING_APPROVAL);\n        bytes32 approved = convertConverterStateToBytes(ConverterState.APPROVED);\n        bytes32 rejected = convertConverterStateToBytes(ConverterState.REJECTED);\n\n        uint numberOfPending = stateToConverter[pending].length;\n        uint numberOfApproved = stateToConverter[approved].length;\n        uint numberOfRejected = stateToConverter[rejected].length;\n\n        return (\n        numberOfPending,\n        numberOfApproved,\n        numberOfRejected,\n        counters\n        );\n    }\n\n    /**\n     * @notice Function to get number of conversions\n     * @dev Can only be called by contractor or maintainer\n     */\n    function getNumberOfConversions()\n    external\n    view\n    returns (uint)\n    {\n        return numberOfConversions;\n    }\n\n    /**\n     * @notice Function to get converter state\n     * @param _converter is the address of the requested converter\n     * @return hexed string of the state\n     */\n    function getStateForConverter(\n        address _converter\n    )\n    external\n    view\n    returns (bytes32)\n    {\n        return convertConverterStateToBytes(converterToState[_converter]);\n    }\n\n\n    function getAllConvertersPerState(\n        bytes32 state\n    )\n    public\n    view\n    onlyContractorOrMaintainer\n    returns (address[])\n    {\n        return stateToConverter[state];\n    }\n\n    /**\n     * @notice Function to get conversion details by id\n     * @param conversionId is the id of conversion\n     */\n    function getConversion(\n        uint conversionId\n    )\n    external\n    view\n    returns (bytes)\n    {\n        Conversion memory conversion = conversions[conversionId];\n\n        address converter; // Defaults to 0x0\n\n        if(isConverterAnonymous[conversion.converter] == false) {\n            converter = conversion.converter;\n        }\n\n        return abi.encodePacked (\n            conversion.contractor,\n            converter,\n            conversion.contractorProceedsETHWei,\n            conversion.conversionAmount,\n            conversion.tokensBought,\n            conversion.maxReferralRewardETHWei,\n            conversion.maxReferralReward2key,\n            conversion.moderatorFeeETHWei,\n            conversion.state\n        );\n    }\n\n    function getAmountConverterSpent(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return amountConverterSpentEthWEI[converter];\n    }\n\n    function getAmountOfDonationTokensConverterReceived(\n        address converter\n    )\n    public\n    view\n    returns (uint)\n    {\n        return converterToAmountOfDonationTokensReceived[converter];\n    }\n\n}\n", "commit_id": "dbc64834a5e35c1eb4c3eb86df21e010d37bf0e6"}}