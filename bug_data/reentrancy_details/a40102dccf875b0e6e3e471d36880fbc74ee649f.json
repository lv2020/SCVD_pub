{"filename": "contracts/game_5/SingleTokenChallenge.sol", "patch": "@@ -2,9 +2,10 @@ pragma solidity 0.6.7;\n \n import \"./ZombieFarmChallengeInterface.sol\";\n import \"./../openzeppelin/contracts/token/ERC20/IERC20.sol\";\n+import \"./../openzeppelin/contracts/security/ReentrancyGuard.sol\";\n \n /// @notice Stake a one token, and earn another token\n-contract SingleTokenChallenge is ZombieFarmChallengeInterface {\n+contract SingleTokenChallenge is ZombieFarmChallengeInterface,  ReentrancyGuard  {\n \n     address stakeToken;\n     address earnToken;\n@@ -199,6 +200,7 @@ contract SingleTokenChallenge is ZombieFarmChallengeInterface {\n         external\n         override\n         onlyZombieFarm\n+        nonReentrant\n     {\n         /// General information regarding the Staking token and Earning token\n         Params storage challenge = challenges[challengeId];\n@@ -277,6 +279,7 @@ contract SingleTokenChallenge is ZombieFarmChallengeInterface {\n         external\n         override\n         onlyZombieFarm\n+        nonReentrant\n     {\n         /// General information regarding the Staking token and Earning token\n         Params storage challenge = challenges[challengeId];\n@@ -363,6 +366,7 @@ contract SingleTokenChallenge is ZombieFarmChallengeInterface {\n         external\n         override\n         onlyZombieFarm\n+        nonReentrant\n     {\n         /// General information regarding the Staking token and Earning token\n         Params storage challenge = challenges[challengeId];", "project_link": "https://github.com/blocklords/seascape-smartcontracts/commit/a40102dccf875b0e6e3e471d36880fbc74ee649f", "bug_version": {"raw_code": "pragma solidity 0.6.7;\n\nimport \"./ZombieFarmChallengeInterface.sol\";\nimport \"./../openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice Stake a one token, and earn another token\ncontract SingleTokenChallenge is ZombieFarmChallengeInterface {\n\n    address stakeToken;\n    address earnToken;\n    address zombieFarm;\n    /// @dev The account that keeps all ERC20 rewards\n    address public pool;\n\n    uint256 private constant scaler = 10**18;\n    uint256 private constant multiply = 10000; // The multiplier placement supports 0.00001\n\n    struct Params {\n        address stake;\n        address earn;\n    }\n\n    struct SessionChallenge {\n        uint8 levelId;\n        uint32 prevChallengeId;    // This is the previous challenge id if level is\n\n        uint256 totalReward;\n        uint256 stakeAmount;        // Required amount to pass the level\n        uint256 stakePeriod;        // Duration after which challenge considered to be completed.\n        uint256 multiplier;         // Increase the progress\n\n        uint256 startTime;     \t\t// session start in unixtimestamp\n        uint256 endTime;\n\n        uint256 claimed;       \t\t// amount of already claimed CWS\n        uint256 amount;        \t\t// total amount of deposited tokens to the session by users\n\n        uint256 rewardUnit;    \t\t// reward per second = totalReward/period\n        uint256 interestPerToken; \t// total earned interest per token since the beginning\n        \t\t\t\t\t\t\t// of the session\n        uint256 claimedPerToken;    // total amount of tokens earned by a one staked token,\n        \t\t\t\t\t\t\t// since the beginning of the session\n        uint256 lastInterestUpdate; // last time when claimedPerToken and interestPerToken\n    }\n\n    struct PlayerChallenge {\n        uint256 stakedTime;\n        uint256 stakedDuration;\n\n        uint256 amount;        \t\t// amount of deposited token\n        bool counted;               // whether its been counted in the session or not.\n        uint256 overStakeAmount;\n\n        uint256 claimed;\n        uint256 claimedTime;\n        uint256 claimedReward;\n\n        uint256 unpaidReward;       // Amount of token that contract should pay to user\n\n        bool completed;             // Was the challenge in the season completed by the player or not.\n    }\n\n    mapping(uint32 => Params) public challenges;\n    mapping(uint256 => mapping(uint32 => SessionChallenge)) public sessionChallenges;\n    // session id => challenge id => player address = PlayerChallenge\n    mapping(uint256 => mapping(uint32 => mapping (address => PlayerChallenge))) public playerParams;\n\n    modifier onlyZombieFarm () {\n\t      require(msg.sender == zombieFarm, \"only ZombieFarm can call\");\n\t      _;\n    }\n\n    event SaveReward(\n        uint256 indexed sessionId,\n        uint8 indexed rewardType,\n        address indexed token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event RewardNft(\n        uint256 indexed sessionId,\n        uint8 rewardType,\n        address indexed owner,\n        uint256 indexed nftId,\n        address token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event Stake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Unstake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Claim(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n\n    constructor (address _zombieFarm, address _pool) public {\n        require(_zombieFarm != address(0), \"invalid _zombieFarm address\");\n        require(_pool != address(0), \"invalid _pool address\");\n\n        zombieFarm = _zombieFarm;\n        pool = _pool;\n    }\n\n    /// @notice indicates that a new challenge of this challenge category is supported by Zombie Farm\n    function newChallenge(uint32 id, bytes calldata data) external override onlyZombieFarm {\n        require(challenges[id].stake == address(0), \"single token challenge exists\");\n\n        address _stake;\n        address _earn;\n\n        (_stake, _earn) = abi.decode(data, (address, address));\n        require(_stake != address(0), \"data.stake verification failed\");\n        require(_earn != address(0), \"data.earn verification failed\");\n\n        challenges[id] = Params(_stake, _earn);\n    }\n\n    /// @notice a new challenge of this challenge category was added to the Season.\n    function saveChallenge(\n        uint256 sessionId,\n        uint256 startTime,\n        uint256 period,\n        uint8 offset,\n        bytes calldata data\n    )\n        external\n        override\n        onlyZombieFarm\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        // multipliers could be 0.\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n        SessionChallenge storage session = sessionChallenges[sessionId][id[offset]];\n\n        // Challenge.stake is not null, means that Challenge.earn is not null too.\n        require(challenges[id[offset]].stake != address(0),\n            \"single token.challenge no exist\");\n        require(reward[offset] > 0, \"single token.reward==0\");\n        require(levelId[offset] > 0, \"single token.level==0\");\n        require(sessionId > 0, \"single token.session id==0\");\n        require(stakeAmount[offset] > 0, \"single token.stake amount==0\");\n        require(stakePeriod[offset] > 0, \"single token.stake period==0\");\n        require(session.totalReward == 0, \"challenge to level added before\");\n        require(startTime > 0 && period > 0, \"single token: session time==0\");\n        if (prevChallengeId[offset] > 0) {\n            require(challenges[prevChallengeId[offset]].stake != address(0),\n                \"previous challenge incomplete\");\n        }\n\n        session.levelId = levelId[offset];\n        session.totalReward = reward[offset];\n        session.stakeAmount = stakeAmount[offset];\n        session.stakePeriod = stakePeriod[offset];\n        session.multiplier = multiplier[offset];\n        session.startTime = startTime;\n        session.endTime = startTime + period;\n        session.rewardUnit = reward[offset] / period;\n        session.lastInterestUpdate = startTime;\n        session.prevChallengeId = prevChallengeId[offset];\n    }\n\n    function stake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"challange already completed\");\n\n        // Previous Challenge should be completed\n        if (sessionChallenge.prevChallengeId > 0) {\n            PlayerChallenge storage playerPrevChallenge = playerParams[sessionId][sessionChallenge\n                .prevChallengeId][staker];\n            require(playerPrevChallenge.completed ||\n                isCompleted(sessionChallenge, playerPrevChallenge, now),\n                \"last challenge not completed\");\n        }\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount > 0, \"single token:amount==0\");\n\n        require(!isCompleted(sessionChallenge, playerChallenge, block.timestamp),\n            \"time completed\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        /// Transfer tokens to the Smartcontract\n        /// TODO add stake holding option. The stake holding option earns a passive income\n        /// by user provided tokens.\n        IERC20 _token = IERC20(challenge.stake);\n        require(_token.balanceOf(staker) >= amount, \"not enough staking token\");\n        require(_token.transferFrom(staker, address(this), amount),\n            \"transferFrom staker failed\");\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n        }\n\n        uint256 total = amount + playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        // I add amount of deposits to session.amount\n        // we add to total stakes, if user deposited >= stakeAmount.\n        if (total >= sessionChallenge.stakeAmount && !playerChallenge.counted) {\n    \t      sessionChallenge.amount = sessionChallenge.amount + sessionChallenge.stakeAmount; // 10\n            playerChallenge.counted = true;\n\n            // Once the total stake amount has been increased, we update the earnings\n            updateInterestPerToken(sessionChallenge);\n        }\n\n        // Amount holds only max session.stakeAmount\n        // the remaining part goes to multiply\n        if (total < sessionChallenge.stakeAmount) {\n            playerChallenge.amount = total;\n        } else {\n            updateTimeProgress(sessionChallenge, playerChallenge);\n\n            playerChallenge.amount = sessionChallenge.stakeAmount;\n            playerChallenge.overStakeAmount = total - sessionChallenge.stakeAmount;\n            playerChallenge.stakedTime = block.timestamp;\n\n    \t\tupdateBalanceInterestPerToken(sessionChallenge.claimedPerToken, playerChallenge);\n        }\n\n\t\temit Stake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n    }\n\n    function unstake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake amount zero\");\n\n        uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount <= totalStake, \"single token:exceed stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n    \t\t    _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (!isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n            if (amount > playerChallenge.overStakeAmount) {\n                uint256 cut = amount - playerChallenge.overStakeAmount;\n                playerChallenge.amount = playerChallenge.amount - cut;\n\n                // player is removed from earning. so other users gets more.\n                if (playerChallenge.amount < sessionChallenge.stakeAmount) {\n                    sessionChallenge.amount = sessionChallenge\n                        .amount - sessionChallenge.stakeAmount;\n                    updateInterestPerToken(sessionChallenge);\n                }\n                playerChallenge.overStakeAmount = 0;\n                } else {\n                playerChallenge.overStakeAmount = playerChallenge.overStakeAmount - amount;\n            }\n            playerChallenge.stakedDuration = 0;\n            if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n                playerChallenge.stakedTime = now;\n            } else {\n                playerChallenge.stakedTime = 0;\n                playerChallenge.counted = false;\n            }\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= amount, \"insufficient contract balances\");\n            require(_token.transfer(staker, amount), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n        } else {\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake, \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    function claim(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake no stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n\n            uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake,\n                \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Claim(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    /// Set session as complete\n    function complete(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount >= sessionChallenge.stakeAmount, \"didnt stake enough\");\n\n        playerChallenge.completed = true;\n    }\n\n    /// @dev updateInterestPerToken set's up the amount of tokens earned since the beginning\n\t/// of the session to 1 token. It also updates the portion of it for the user.\n    /// @param sessionChallenge is this challenge\n    function updateInterestPerToken(SessionChallenge storage sessionChallenge)\n        internal\n        returns(bool)\n    {\n        uint256 sessionCap = getSessionCap(sessionChallenge.startTime, sessionChallenge.endTime);\n\n        // I calculate previous claimed rewards\n        // (session.claimedPerToken += (now - session.lastInterestUpdate) * session.interestPerToken)\n        sessionChallenge.claimedPerToken = sessionChallenge.claimedPerToken + (\n        (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // I record that interestPerToken is 0.1 CWS (rewardUnit/amount) in session.interestPerToken\n        // I update the session.lastInterestUpdate to now\n        if (sessionChallenge.amount == 0) {\n            sessionChallenge.interestPerToken = 0;\n        } else {\n            sessionChallenge.interestPerToken = (sessionChallenge\n                .rewardUnit * scaler) / sessionChallenge.amount; // 0.1\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        sessionChallenge.lastInterestUpdate = sessionCap;\n    }\n\n    function getSessionCap(uint256 startTime, uint256 endTime) internal view returns(uint256) {\n        if (!isActive(startTime, endTime)) {\n            return endTime;\n        }\n        return block.timestamp;\n    }\n\n    function isActive(uint256 startTime, uint256 endTime) internal view returns(bool) {\n        if (startTime == 0) {\n            return false;\n        }\n        return (now >= startTime && now <= endTime);\n    }\n\n    function isCompleted(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge,\n        uint256 currentTime\n    )\n        internal\n        view\n        returns(bool)\n    {\n        uint256 time = playerChallenge.stakedDuration;\n\n        if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n            if (playerChallenge.stakedTime > 0) {\n                uint256 duration = (currentTime - playerChallenge.stakedTime);\n                time = time + duration;\n\n                if (playerChallenge.overStakeAmount > 0) {\n                    time = time + (duration * ((playerChallenge\n                        .overStakeAmount * sessionChallenge.multiplier) / multiply) / scaler);\n                }\n            }\n        }\n        return time >= sessionChallenge.stakePeriod;\n    }\n\n    function isFullyCompleted(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        view\n        returns(bool)\n    {\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        if (playerChallenge.completed) {\n            return true;\n        }\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        return isCompleted(sessionChallenge, playerChallenge, block.timestamp);\n    }\n\n    function updateTimeProgress(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n    {\n        // update time progress\n        // previous stake time\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            playerChallenge.stakedTime > 0) {\n\n            uint256 time = block.timestamp - playerChallenge.stakedTime;\n\n            if (playerChallenge.overStakeAmount > 0) {\n                time = time + (time * ((playerChallenge.overStakeAmount * sessionChallenge\n                    .multiplier) / multiply) / scaler);\n            }\n\n            playerChallenge.stakedDuration = playerChallenge.stakedDuration + time;\n            if (playerChallenge.stakedDuration >= sessionChallenge.stakePeriod) {\n                playerChallenge.completed = true;\n            }\n        }\n    }\n\n    function updateBalanceInterestPerToken(\n        uint256 claimedPerToken,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n        returns(bool)\n    {\n        playerChallenge.claimedReward = claimedPerToken * playerChallenge.amount / scaler; // 0\n    }\n\n    function _claim(uint256 sessionId, uint32 challengeId, address staker) internal returns(bool) {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount > 0, \"didnt deposit enough\");\n\n        uint256 interest = calculateInterest(sessionId, challengeId, staker);\n        if (interest == 0) {\n            return false;\n        }\n\n        Params storage challenge = challenges[challengeId];\n\n        IERC20 _token = IERC20(challenge.earn);\n\n        uint256 contractBalance = _token.balanceOf(pool);\n\n        if (interest > 0 && contractBalance < interest) {\n            playerChallenge.unpaidReward = (interest - contractBalance) + playerChallenge\n                .unpaidReward;\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            playerChallenge.claimedTime = sessionChallenge.endTime;\n        } else {\n            playerChallenge.claimedTime = block.timestamp;\n        }\n        sessionChallenge.claimed = sessionChallenge.claimed + interest;\n        playerChallenge.claimed = playerChallenge.claimed + interest;\n\n        if (interest > contractBalance) {\n            _token.transferFrom(pool, staker, contractBalance);\n        } else {\n            _token.transferFrom(pool, staker, interest);\n        }\n\n        //emit Claimed(challenge.earn, staker, sessionId, challengeId, interest, block.timestamp);\n        return true;\n    }\n\n    function calculateInterest(uint256 sessionId, uint32 challengeId, address staker)\n        internal\n        view\n        returns(uint256)\n    {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n    \t\t// How much of total deposit is belong to player as a floating number\n    \t\tif (playerChallenge.amount == 0 || sessionChallenge.amount == 0) {\n            return 0;\n    \t\t}\n\n        uint256 sessionCap = block.timestamp;\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            sessionCap = sessionChallenge.endTime;\n\n          \t// claimed after session expire, means no any claimables\n          \tif (playerChallenge.claimedTime >= sessionCap) {\n                return 0;\n            }\n        }\n\n        uint256 claimedPerToken = sessionChallenge.claimedPerToken + (\n            (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // (balance * total claimable) - user deposit earned amount per token - balance.claimedTime\n        uint256 interest = ((playerChallenge\n            .amount * claimedPerToken) / scaler) - playerChallenge.claimedReward;\n\n        return interest;\n    }\n\n    function getIdAndLevel(uint8 offset, bytes calldata data)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint32, uint8)\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n\n        return (id[offset], levelId[offset]);\n    }\n\n    function getLevel(uint256 sessionId, uint32 challengeId)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint8)\n    {\n        return sessionChallenges[sessionId][challengeId].levelId;\n    }\n}\n", "flattened_code": "pragma solidity 0.6.7;\n\npragma solidity ^0.6.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface ZombieFarmChallengeInterface {\n    /**\n     * @dev Returns the validation of reward.\n     */\n    function newChallenge(uint32 id, bytes calldata data) external;\n\n    function saveChallenge(uint256 sessionId, uint256 startTime, uint256 period, uint8 offset, bytes calldata data) external;\n\n    function getIdAndLevel(uint8 offset, bytes calldata data) external view returns(uint32, uint8);\n\n    function getLevel(uint256 sessionId, uint32 challengeId) external view returns(uint8);\n\n    function isFullyCompleted(uint256 sessionId, uint32 challengeId, address staker) external view returns(bool);\n    function complete(uint256 sessionId, uint32 challengeId, address staker) external;\n\n    function stake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data) external;\n    function unstake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data) external;\n    function claim(uint256 sessionId, uint32 challengeId, address staker) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/// @notice Stake a one token, and earn another token\ncontract SingleTokenChallenge is ZombieFarmChallengeInterface {\n\n    address stakeToken;\n    address earnToken;\n    address zombieFarm;\n    /// @dev The account that keeps all ERC20 rewards\n    address public pool;\n\n    uint256 private constant scaler = 10**18;\n    uint256 private constant multiply = 10000; // The multiplier placement supports 0.00001\n\n    struct Params {\n        address stake;\n        address earn;\n    }\n\n    struct SessionChallenge {\n        uint8 levelId;\n        uint32 prevChallengeId;    // This is the previous challenge id if level is\n\n        uint256 totalReward;\n        uint256 stakeAmount;        // Required amount to pass the level\n        uint256 stakePeriod;        // Duration after which challenge considered to be completed.\n        uint256 multiplier;         // Increase the progress\n\n        uint256 startTime;     \t\t// session start in unixtimestamp\n        uint256 endTime;\n\n        uint256 claimed;       \t\t// amount of already claimed CWS\n        uint256 amount;        \t\t// total amount of deposited tokens to the session by users\n\n        uint256 rewardUnit;    \t\t// reward per second = totalReward/period\n        uint256 interestPerToken; \t// total earned interest per token since the beginning\n        \t\t\t\t\t\t\t// of the session\n        uint256 claimedPerToken;    // total amount of tokens earned by a one staked token,\n        \t\t\t\t\t\t\t// since the beginning of the session\n        uint256 lastInterestUpdate; // last time when claimedPerToken and interestPerToken\n    }\n\n    struct PlayerChallenge {\n        uint256 stakedTime;\n        uint256 stakedDuration;\n\n        uint256 amount;        \t\t// amount of deposited token\n        bool counted;               // whether its been counted in the session or not.\n        uint256 overStakeAmount;\n\n        uint256 claimed;\n        uint256 claimedTime;\n        uint256 claimedReward;\n\n        uint256 unpaidReward;       // Amount of token that contract should pay to user\n\n        bool completed;             // Was the challenge in the season completed by the player or not.\n    }\n\n    mapping(uint32 => Params) public challenges;\n    mapping(uint256 => mapping(uint32 => SessionChallenge)) public sessionChallenges;\n    // session id => challenge id => player address = PlayerChallenge\n    mapping(uint256 => mapping(uint32 => mapping (address => PlayerChallenge))) public playerParams;\n\n    modifier onlyZombieFarm () {\n\t      require(msg.sender == zombieFarm, \"only ZombieFarm can call\");\n\t      _;\n    }\n\n    event SaveReward(\n        uint256 indexed sessionId,\n        uint8 indexed rewardType,\n        address indexed token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event RewardNft(\n        uint256 indexed sessionId,\n        uint8 rewardType,\n        address indexed owner,\n        uint256 indexed nftId,\n        address token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event Stake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Unstake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Claim(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n\n    constructor (address _zombieFarm, address _pool) public {\n        require(_zombieFarm != address(0), \"invalid _zombieFarm address\");\n        require(_pool != address(0), \"invalid _pool address\");\n\n        zombieFarm = _zombieFarm;\n        pool = _pool;\n    }\n\n    /// @notice indicates that a new challenge of this challenge category is supported by Zombie Farm\n    function newChallenge(uint32 id, bytes calldata data) external override onlyZombieFarm {\n        require(challenges[id].stake == address(0), \"single token challenge exists\");\n\n        address _stake;\n        address _earn;\n\n        (_stake, _earn) = abi.decode(data, (address, address));\n        require(_stake != address(0), \"data.stake verification failed\");\n        require(_earn != address(0), \"data.earn verification failed\");\n\n        challenges[id] = Params(_stake, _earn);\n    }\n\n    /// @notice a new challenge of this challenge category was added to the Season.\n    function saveChallenge(\n        uint256 sessionId,\n        uint256 startTime,\n        uint256 period,\n        uint8 offset,\n        bytes calldata data\n    )\n        external\n        override\n        onlyZombieFarm\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        // multipliers could be 0.\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n        SessionChallenge storage session = sessionChallenges[sessionId][id[offset]];\n\n        // Challenge.stake is not null, means that Challenge.earn is not null too.\n        require(challenges[id[offset]].stake != address(0),\n            \"single token.challenge no exist\");\n        require(reward[offset] > 0, \"single token.reward==0\");\n        require(levelId[offset] > 0, \"single token.level==0\");\n        require(sessionId > 0, \"single token.session id==0\");\n        require(stakeAmount[offset] > 0, \"single token.stake amount==0\");\n        require(stakePeriod[offset] > 0, \"single token.stake period==0\");\n        require(session.totalReward == 0, \"challenge to level added before\");\n        require(startTime > 0 && period > 0, \"single token: session time==0\");\n        if (prevChallengeId[offset] > 0) {\n            require(challenges[prevChallengeId[offset]].stake != address(0),\n                \"previous challenge incomplete\");\n        }\n\n        session.levelId = levelId[offset];\n        session.totalReward = reward[offset];\n        session.stakeAmount = stakeAmount[offset];\n        session.stakePeriod = stakePeriod[offset];\n        session.multiplier = multiplier[offset];\n        session.startTime = startTime;\n        session.endTime = startTime + period;\n        session.rewardUnit = reward[offset] / period;\n        session.lastInterestUpdate = startTime;\n        session.prevChallengeId = prevChallengeId[offset];\n    }\n\n    function stake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"challange already completed\");\n\n        // Previous Challenge should be completed\n        if (sessionChallenge.prevChallengeId > 0) {\n            PlayerChallenge storage playerPrevChallenge = playerParams[sessionId][sessionChallenge\n                .prevChallengeId][staker];\n            require(playerPrevChallenge.completed ||\n                isCompleted(sessionChallenge, playerPrevChallenge, now),\n                \"last challenge not completed\");\n        }\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount > 0, \"single token:amount==0\");\n\n        require(!isCompleted(sessionChallenge, playerChallenge, block.timestamp),\n            \"time completed\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        /// Transfer tokens to the Smartcontract\n        /// TODO add stake holding option. The stake holding option earns a passive income\n        /// by user provided tokens.\n        IERC20 _token = IERC20(challenge.stake);\n        require(_token.balanceOf(staker) >= amount, \"not enough staking token\");\n        require(_token.transferFrom(staker, address(this), amount),\n            \"transferFrom staker failed\");\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n        }\n\n        uint256 total = amount + playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        // I add amount of deposits to session.amount\n        // we add to total stakes, if user deposited >= stakeAmount.\n        if (total >= sessionChallenge.stakeAmount && !playerChallenge.counted) {\n    \t      sessionChallenge.amount = sessionChallenge.amount + sessionChallenge.stakeAmount; // 10\n            playerChallenge.counted = true;\n\n            // Once the total stake amount has been increased, we update the earnings\n            updateInterestPerToken(sessionChallenge);\n        }\n\n        // Amount holds only max session.stakeAmount\n        // the remaining part goes to multiply\n        if (total < sessionChallenge.stakeAmount) {\n            playerChallenge.amount = total;\n        } else {\n            updateTimeProgress(sessionChallenge, playerChallenge);\n\n            playerChallenge.amount = sessionChallenge.stakeAmount;\n            playerChallenge.overStakeAmount = total - sessionChallenge.stakeAmount;\n            playerChallenge.stakedTime = block.timestamp;\n\n    \t\tupdateBalanceInterestPerToken(sessionChallenge.claimedPerToken, playerChallenge);\n        }\n\n\t\temit Stake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n    }\n\n    function unstake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake amount zero\");\n\n        uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount <= totalStake, \"single token:exceed stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n    \t\t    _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (!isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n            if (amount > playerChallenge.overStakeAmount) {\n                uint256 cut = amount - playerChallenge.overStakeAmount;\n                playerChallenge.amount = playerChallenge.amount - cut;\n\n                // player is removed from earning. so other users gets more.\n                if (playerChallenge.amount < sessionChallenge.stakeAmount) {\n                    sessionChallenge.amount = sessionChallenge\n                        .amount - sessionChallenge.stakeAmount;\n                    updateInterestPerToken(sessionChallenge);\n                }\n                playerChallenge.overStakeAmount = 0;\n                } else {\n                playerChallenge.overStakeAmount = playerChallenge.overStakeAmount - amount;\n            }\n            playerChallenge.stakedDuration = 0;\n            if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n                playerChallenge.stakedTime = now;\n            } else {\n                playerChallenge.stakedTime = 0;\n                playerChallenge.counted = false;\n            }\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= amount, \"insufficient contract balances\");\n            require(_token.transfer(staker, amount), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n        } else {\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake, \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    function claim(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake no stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n\n            uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake,\n                \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Claim(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    /// Set session as complete\n    function complete(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount >= sessionChallenge.stakeAmount, \"didnt stake enough\");\n\n        playerChallenge.completed = true;\n    }\n\n    /// @dev updateInterestPerToken set's up the amount of tokens earned since the beginning\n\t/// of the session to 1 token. It also updates the portion of it for the user.\n    /// @param sessionChallenge is this challenge\n    function updateInterestPerToken(SessionChallenge storage sessionChallenge)\n        internal\n        returns(bool)\n    {\n        uint256 sessionCap = getSessionCap(sessionChallenge.startTime, sessionChallenge.endTime);\n\n        // I calculate previous claimed rewards\n        // (session.claimedPerToken += (now - session.lastInterestUpdate) * session.interestPerToken)\n        sessionChallenge.claimedPerToken = sessionChallenge.claimedPerToken + (\n        (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // I record that interestPerToken is 0.1 CWS (rewardUnit/amount) in session.interestPerToken\n        // I update the session.lastInterestUpdate to now\n        if (sessionChallenge.amount == 0) {\n            sessionChallenge.interestPerToken = 0;\n        } else {\n            sessionChallenge.interestPerToken = (sessionChallenge\n                .rewardUnit * scaler) / sessionChallenge.amount; // 0.1\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        sessionChallenge.lastInterestUpdate = sessionCap;\n    }\n\n    function getSessionCap(uint256 startTime, uint256 endTime) internal view returns(uint256) {\n        if (!isActive(startTime, endTime)) {\n            return endTime;\n        }\n        return block.timestamp;\n    }\n\n    function isActive(uint256 startTime, uint256 endTime) internal view returns(bool) {\n        if (startTime == 0) {\n            return false;\n        }\n        return (now >= startTime && now <= endTime);\n    }\n\n    function isCompleted(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge,\n        uint256 currentTime\n    )\n        internal\n        view\n        returns(bool)\n    {\n        uint256 time = playerChallenge.stakedDuration;\n\n        if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n            if (playerChallenge.stakedTime > 0) {\n                uint256 duration = (currentTime - playerChallenge.stakedTime);\n                time = time + duration;\n\n                if (playerChallenge.overStakeAmount > 0) {\n                    time = time + (duration * ((playerChallenge\n                        .overStakeAmount * sessionChallenge.multiplier) / multiply) / scaler);\n                }\n            }\n        }\n        return time >= sessionChallenge.stakePeriod;\n    }\n\n    function isFullyCompleted(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        view\n        returns(bool)\n    {\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        if (playerChallenge.completed) {\n            return true;\n        }\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        return isCompleted(sessionChallenge, playerChallenge, block.timestamp);\n    }\n\n    function updateTimeProgress(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n    {\n        // update time progress\n        // previous stake time\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            playerChallenge.stakedTime > 0) {\n\n            uint256 time = block.timestamp - playerChallenge.stakedTime;\n\n            if (playerChallenge.overStakeAmount > 0) {\n                time = time + (time * ((playerChallenge.overStakeAmount * sessionChallenge\n                    .multiplier) / multiply) / scaler);\n            }\n\n            playerChallenge.stakedDuration = playerChallenge.stakedDuration + time;\n            if (playerChallenge.stakedDuration >= sessionChallenge.stakePeriod) {\n                playerChallenge.completed = true;\n            }\n        }\n    }\n\n    function updateBalanceInterestPerToken(\n        uint256 claimedPerToken,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n        returns(bool)\n    {\n        playerChallenge.claimedReward = claimedPerToken * playerChallenge.amount / scaler; // 0\n    }\n\n    function _claim(uint256 sessionId, uint32 challengeId, address staker) internal returns(bool) {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount > 0, \"didnt deposit enough\");\n\n        uint256 interest = calculateInterest(sessionId, challengeId, staker);\n        if (interest == 0) {\n            return false;\n        }\n\n        Params storage challenge = challenges[challengeId];\n\n        IERC20 _token = IERC20(challenge.earn);\n\n        uint256 contractBalance = _token.balanceOf(pool);\n\n        if (interest > 0 && contractBalance < interest) {\n            playerChallenge.unpaidReward = (interest - contractBalance) + playerChallenge\n                .unpaidReward;\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            playerChallenge.claimedTime = sessionChallenge.endTime;\n        } else {\n            playerChallenge.claimedTime = block.timestamp;\n        }\n        sessionChallenge.claimed = sessionChallenge.claimed + interest;\n        playerChallenge.claimed = playerChallenge.claimed + interest;\n\n        if (interest > contractBalance) {\n            _token.transferFrom(pool, staker, contractBalance);\n        } else {\n            _token.transferFrom(pool, staker, interest);\n        }\n\n        //emit Claimed(challenge.earn, staker, sessionId, challengeId, interest, block.timestamp);\n        return true;\n    }\n\n    function calculateInterest(uint256 sessionId, uint32 challengeId, address staker)\n        internal\n        view\n        returns(uint256)\n    {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n    \t\t// How much of total deposit is belong to player as a floating number\n    \t\tif (playerChallenge.amount == 0 || sessionChallenge.amount == 0) {\n            return 0;\n    \t\t}\n\n        uint256 sessionCap = block.timestamp;\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            sessionCap = sessionChallenge.endTime;\n\n          \t// claimed after session expire, means no any claimables\n          \tif (playerChallenge.claimedTime >= sessionCap) {\n                return 0;\n            }\n        }\n\n        uint256 claimedPerToken = sessionChallenge.claimedPerToken + (\n            (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // (balance * total claimable) - user deposit earned amount per token - balance.claimedTime\n        uint256 interest = ((playerChallenge\n            .amount * claimedPerToken) / scaler) - playerChallenge.claimedReward;\n\n        return interest;\n    }\n\n    function getIdAndLevel(uint8 offset, bytes calldata data)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint32, uint8)\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n\n        return (id[offset], levelId[offset]);\n    }\n\n    function getLevel(uint256 sessionId, uint32 challengeId)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint8)\n    {\n        return sessionChallenges[sessionId][challengeId].levelId;\n    }\n}\n", "commit_id": "330c8e269cc121d858252cbdab81572fc8c56b97"}, "fixed_version": {"raw_code": "pragma solidity 0.6.7;\n\nimport \"./ZombieFarmChallengeInterface.sol\";\nimport \"./../openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./../openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @notice Stake a one token, and earn another token\ncontract SingleTokenChallenge is ZombieFarmChallengeInterface,  ReentrancyGuard  {\n\n    address stakeToken;\n    address earnToken;\n    address zombieFarm;\n    /// @dev The account that keeps all ERC20 rewards\n    address public pool;\n\n    uint256 private constant scaler = 10**18;\n    uint256 private constant multiply = 10000; // The multiplier placement supports 0.00001\n\n    struct Params {\n        address stake;\n        address earn;\n    }\n\n    struct SessionChallenge {\n        uint8 levelId;\n        uint32 prevChallengeId;    // This is the previous challenge id if level is\n\n        uint256 totalReward;\n        uint256 stakeAmount;        // Required amount to pass the level\n        uint256 stakePeriod;        // Duration after which challenge considered to be completed.\n        uint256 multiplier;         // Increase the progress\n\n        uint256 startTime;     \t\t// session start in unixtimestamp\n        uint256 endTime;\n\n        uint256 claimed;       \t\t// amount of already claimed CWS\n        uint256 amount;        \t\t// total amount of deposited tokens to the session by users\n\n        uint256 rewardUnit;    \t\t// reward per second = totalReward/period\n        uint256 interestPerToken; \t// total earned interest per token since the beginning\n        \t\t\t\t\t\t\t// of the session\n        uint256 claimedPerToken;    // total amount of tokens earned by a one staked token,\n        \t\t\t\t\t\t\t// since the beginning of the session\n        uint256 lastInterestUpdate; // last time when claimedPerToken and interestPerToken\n    }\n\n    struct PlayerChallenge {\n        uint256 stakedTime;\n        uint256 stakedDuration;\n\n        uint256 amount;        \t\t// amount of deposited token\n        bool counted;               // whether its been counted in the session or not.\n        uint256 overStakeAmount;\n\n        uint256 claimed;\n        uint256 claimedTime;\n        uint256 claimedReward;\n\n        uint256 unpaidReward;       // Amount of token that contract should pay to user\n\n        bool completed;             // Was the challenge in the season completed by the player or not.\n    }\n\n    mapping(uint32 => Params) public challenges;\n    mapping(uint256 => mapping(uint32 => SessionChallenge)) public sessionChallenges;\n    // session id => challenge id => player address = PlayerChallenge\n    mapping(uint256 => mapping(uint32 => mapping (address => PlayerChallenge))) public playerParams;\n\n    modifier onlyZombieFarm () {\n\t      require(msg.sender == zombieFarm, \"only ZombieFarm can call\");\n\t      _;\n    }\n\n    event SaveReward(\n        uint256 indexed sessionId,\n        uint8 indexed rewardType,\n        address indexed token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event RewardNft(\n        uint256 indexed sessionId,\n        uint8 rewardType,\n        address indexed owner,\n        uint256 indexed nftId,\n        address token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event Stake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Unstake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Claim(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n\n    constructor (address _zombieFarm, address _pool) public {\n        require(_zombieFarm != address(0), \"invalid _zombieFarm address\");\n        require(_pool != address(0), \"invalid _pool address\");\n\n        zombieFarm = _zombieFarm;\n        pool = _pool;\n    }\n\n    /// @notice indicates that a new challenge of this challenge category is supported by Zombie Farm\n    function newChallenge(uint32 id, bytes calldata data) external override onlyZombieFarm {\n        require(challenges[id].stake == address(0), \"single token challenge exists\");\n\n        address _stake;\n        address _earn;\n\n        (_stake, _earn) = abi.decode(data, (address, address));\n        require(_stake != address(0), \"data.stake verification failed\");\n        require(_earn != address(0), \"data.earn verification failed\");\n\n        challenges[id] = Params(_stake, _earn);\n    }\n\n    /// @notice a new challenge of this challenge category was added to the Season.\n    function saveChallenge(\n        uint256 sessionId,\n        uint256 startTime,\n        uint256 period,\n        uint8 offset,\n        bytes calldata data\n    )\n        external\n        override\n        onlyZombieFarm\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        // multipliers could be 0.\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n        SessionChallenge storage session = sessionChallenges[sessionId][id[offset]];\n\n        // Challenge.stake is not null, means that Challenge.earn is not null too.\n        require(challenges[id[offset]].stake != address(0),\n            \"single token.challenge no exist\");\n        require(reward[offset] > 0, \"single token.reward==0\");\n        require(levelId[offset] > 0, \"single token.level==0\");\n        require(sessionId > 0, \"single token.session id==0\");\n        require(stakeAmount[offset] > 0, \"single token.stake amount==0\");\n        require(stakePeriod[offset] > 0, \"single token.stake period==0\");\n        require(session.totalReward == 0, \"challenge to level added before\");\n        require(startTime > 0 && period > 0, \"single token: session time==0\");\n        if (prevChallengeId[offset] > 0) {\n            require(challenges[prevChallengeId[offset]].stake != address(0),\n                \"previous challenge incomplete\");\n        }\n\n        session.levelId = levelId[offset];\n        session.totalReward = reward[offset];\n        session.stakeAmount = stakeAmount[offset];\n        session.stakePeriod = stakePeriod[offset];\n        session.multiplier = multiplier[offset];\n        session.startTime = startTime;\n        session.endTime = startTime + period;\n        session.rewardUnit = reward[offset] / period;\n        session.lastInterestUpdate = startTime;\n        session.prevChallengeId = prevChallengeId[offset];\n    }\n\n    function stake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n        nonReentrant\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"challange already completed\");\n\n        // Previous Challenge should be completed\n        if (sessionChallenge.prevChallengeId > 0) {\n            PlayerChallenge storage playerPrevChallenge = playerParams[sessionId][sessionChallenge\n                .prevChallengeId][staker];\n            require(playerPrevChallenge.completed ||\n                isCompleted(sessionChallenge, playerPrevChallenge, now),\n                \"last challenge not completed\");\n        }\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount > 0, \"single token:amount==0\");\n\n        require(!isCompleted(sessionChallenge, playerChallenge, block.timestamp),\n            \"time completed\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        /// Transfer tokens to the Smartcontract\n        /// TODO add stake holding option. The stake holding option earns a passive income\n        /// by user provided tokens.\n        IERC20 _token = IERC20(challenge.stake);\n        require(_token.balanceOf(staker) >= amount, \"not enough staking token\");\n        require(_token.transferFrom(staker, address(this), amount),\n            \"transferFrom staker failed\");\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n        }\n\n        uint256 total = amount + playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        // I add amount of deposits to session.amount\n        // we add to total stakes, if user deposited >= stakeAmount.\n        if (total >= sessionChallenge.stakeAmount && !playerChallenge.counted) {\n    \t      sessionChallenge.amount = sessionChallenge.amount + sessionChallenge.stakeAmount; // 10\n            playerChallenge.counted = true;\n\n            // Once the total stake amount has been increased, we update the earnings\n            updateInterestPerToken(sessionChallenge);\n        }\n\n        // Amount holds only max session.stakeAmount\n        // the remaining part goes to multiply\n        if (total < sessionChallenge.stakeAmount) {\n            playerChallenge.amount = total;\n        } else {\n            updateTimeProgress(sessionChallenge, playerChallenge);\n\n            playerChallenge.amount = sessionChallenge.stakeAmount;\n            playerChallenge.overStakeAmount = total - sessionChallenge.stakeAmount;\n            playerChallenge.stakedTime = block.timestamp;\n\n    \t\tupdateBalanceInterestPerToken(sessionChallenge.claimedPerToken, playerChallenge);\n        }\n\n\t\temit Stake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n    }\n\n    function unstake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n        nonReentrant\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake amount zero\");\n\n        uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount <= totalStake, \"single token:exceed stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n    \t\t    _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (!isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n            if (amount > playerChallenge.overStakeAmount) {\n                uint256 cut = amount - playerChallenge.overStakeAmount;\n                playerChallenge.amount = playerChallenge.amount - cut;\n\n                // player is removed from earning. so other users gets more.\n                if (playerChallenge.amount < sessionChallenge.stakeAmount) {\n                    sessionChallenge.amount = sessionChallenge\n                        .amount - sessionChallenge.stakeAmount;\n                    updateInterestPerToken(sessionChallenge);\n                }\n                playerChallenge.overStakeAmount = 0;\n                } else {\n                playerChallenge.overStakeAmount = playerChallenge.overStakeAmount - amount;\n            }\n            playerChallenge.stakedDuration = 0;\n            if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n                playerChallenge.stakedTime = now;\n            } else {\n                playerChallenge.stakedTime = 0;\n                playerChallenge.counted = false;\n            }\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= amount, \"insufficient contract balances\");\n            require(_token.transfer(staker, amount), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n        } else {\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake, \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    function claim(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n        nonReentrant\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake no stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n\n            uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake,\n                \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Claim(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    /// Set session as complete\n    function complete(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount >= sessionChallenge.stakeAmount, \"didnt stake enough\");\n\n        playerChallenge.completed = true;\n    }\n\n    /// @dev updateInterestPerToken set's up the amount of tokens earned since the beginning\n\t/// of the session to 1 token. It also updates the portion of it for the user.\n    /// @param sessionChallenge is this challenge\n    function updateInterestPerToken(SessionChallenge storage sessionChallenge)\n        internal\n        returns(bool)\n    {\n        uint256 sessionCap = getSessionCap(sessionChallenge.startTime, sessionChallenge.endTime);\n\n        // I calculate previous claimed rewards\n        // (session.claimedPerToken += (now - session.lastInterestUpdate) * session.interestPerToken)\n        sessionChallenge.claimedPerToken = sessionChallenge.claimedPerToken + (\n        (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // I record that interestPerToken is 0.1 CWS (rewardUnit/amount) in session.interestPerToken\n        // I update the session.lastInterestUpdate to now\n        if (sessionChallenge.amount == 0) {\n            sessionChallenge.interestPerToken = 0;\n        } else {\n            sessionChallenge.interestPerToken = (sessionChallenge\n                .rewardUnit * scaler) / sessionChallenge.amount; // 0.1\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        sessionChallenge.lastInterestUpdate = sessionCap;\n    }\n\n    function getSessionCap(uint256 startTime, uint256 endTime) internal view returns(uint256) {\n        if (!isActive(startTime, endTime)) {\n            return endTime;\n        }\n        return block.timestamp;\n    }\n\n    function isActive(uint256 startTime, uint256 endTime) internal view returns(bool) {\n        if (startTime == 0) {\n            return false;\n        }\n        return (now >= startTime && now <= endTime);\n    }\n\n    function isCompleted(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge,\n        uint256 currentTime\n    )\n        internal\n        view\n        returns(bool)\n    {\n        uint256 time = playerChallenge.stakedDuration;\n\n        if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n            if (playerChallenge.stakedTime > 0) {\n                uint256 duration = (currentTime - playerChallenge.stakedTime);\n                time = time + duration;\n\n                if (playerChallenge.overStakeAmount > 0) {\n                    time = time + (duration * ((playerChallenge\n                        .overStakeAmount * sessionChallenge.multiplier) / multiply) / scaler);\n                }\n            }\n        }\n        return time >= sessionChallenge.stakePeriod;\n    }\n\n    function isFullyCompleted(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        view\n        returns(bool)\n    {\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        if (playerChallenge.completed) {\n            return true;\n        }\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        return isCompleted(sessionChallenge, playerChallenge, block.timestamp);\n    }\n\n    function updateTimeProgress(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n    {\n        // update time progress\n        // previous stake time\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            playerChallenge.stakedTime > 0) {\n\n            uint256 time = block.timestamp - playerChallenge.stakedTime;\n\n            if (playerChallenge.overStakeAmount > 0) {\n                time = time + (time * ((playerChallenge.overStakeAmount * sessionChallenge\n                    .multiplier) / multiply) / scaler);\n            }\n\n            playerChallenge.stakedDuration = playerChallenge.stakedDuration + time;\n            if (playerChallenge.stakedDuration >= sessionChallenge.stakePeriod) {\n                playerChallenge.completed = true;\n            }\n        }\n    }\n\n    function updateBalanceInterestPerToken(\n        uint256 claimedPerToken,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n        returns(bool)\n    {\n        playerChallenge.claimedReward = claimedPerToken * playerChallenge.amount / scaler; // 0\n    }\n\n    function _claim(uint256 sessionId, uint32 challengeId, address staker) internal returns(bool) {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount > 0, \"didnt deposit enough\");\n\n        uint256 interest = calculateInterest(sessionId, challengeId, staker);\n        if (interest == 0) {\n            return false;\n        }\n\n        Params storage challenge = challenges[challengeId];\n\n        IERC20 _token = IERC20(challenge.earn);\n\n        uint256 contractBalance = _token.balanceOf(pool);\n\n        if (interest > 0 && contractBalance < interest) {\n            playerChallenge.unpaidReward = (interest - contractBalance) + playerChallenge\n                .unpaidReward;\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            playerChallenge.claimedTime = sessionChallenge.endTime;\n        } else {\n            playerChallenge.claimedTime = block.timestamp;\n        }\n        sessionChallenge.claimed = sessionChallenge.claimed + interest;\n        playerChallenge.claimed = playerChallenge.claimed + interest;\n\n        if (interest > contractBalance) {\n            _token.transferFrom(pool, staker, contractBalance);\n        } else {\n            _token.transferFrom(pool, staker, interest);\n        }\n\n        //emit Claimed(challenge.earn, staker, sessionId, challengeId, interest, block.timestamp);\n        return true;\n    }\n\n    function calculateInterest(uint256 sessionId, uint32 challengeId, address staker)\n        internal\n        view\n        returns(uint256)\n    {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n    \t\t// How much of total deposit is belong to player as a floating number\n    \t\tif (playerChallenge.amount == 0 || sessionChallenge.amount == 0) {\n            return 0;\n    \t\t}\n\n        uint256 sessionCap = block.timestamp;\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            sessionCap = sessionChallenge.endTime;\n\n          \t// claimed after session expire, means no any claimables\n          \tif (playerChallenge.claimedTime >= sessionCap) {\n                return 0;\n            }\n        }\n\n        uint256 claimedPerToken = sessionChallenge.claimedPerToken + (\n            (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // (balance * total claimable) - user deposit earned amount per token - balance.claimedTime\n        uint256 interest = ((playerChallenge\n            .amount * claimedPerToken) / scaler) - playerChallenge.claimedReward;\n\n        return interest;\n    }\n\n    function getIdAndLevel(uint8 offset, bytes calldata data)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint32, uint8)\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n\n        return (id[offset], levelId[offset]);\n    }\n\n    function getLevel(uint256 sessionId, uint32 challengeId)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint8)\n    {\n        return sessionChallenges[sessionId][challengeId].levelId;\n    }\n}\n", "flattened_code": "pragma solidity 0.6.7;\n\npragma solidity ^0.6.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface ZombieFarmChallengeInterface {\n    /**\n     * @dev Returns the validation of reward.\n     */\n    function newChallenge(uint32 id, bytes calldata data) external;\n\n    function saveChallenge(uint256 sessionId, uint256 startTime, uint256 period, uint8 offset, bytes calldata data) external;\n\n    function getIdAndLevel(uint8 offset, bytes calldata data) external view returns(uint32, uint8);\n\n    function getLevel(uint256 sessionId, uint32 challengeId) external view returns(uint8);\n\n    function isFullyCompleted(uint256 sessionId, uint32 challengeId, address staker) external view returns(bool);\n    function complete(uint256 sessionId, uint32 challengeId, address staker) external;\n\n    function stake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data) external;\n    function unstake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data) external;\n    function claim(uint256 sessionId, uint32 challengeId, address staker) external;\n}\n// IGNORE_LICENSE-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n// File: contracts/library/ReentrancyGuard.sol\n\npragma solidity ^0.6.7;\n\ncontract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    function initReentrancyStatus() internal {\n        _status = _NOT_ENTERED;\n    }\n}\n\n/// @notice Stake a one token, and earn another token\ncontract SingleTokenChallenge is ZombieFarmChallengeInterface,  ReentrancyGuard  {\n\n    address stakeToken;\n    address earnToken;\n    address zombieFarm;\n    /// @dev The account that keeps all ERC20 rewards\n    address public pool;\n\n    uint256 private constant scaler = 10**18;\n    uint256 private constant multiply = 10000; // The multiplier placement supports 0.00001\n\n    struct Params {\n        address stake;\n        address earn;\n    }\n\n    struct SessionChallenge {\n        uint8 levelId;\n        uint32 prevChallengeId;    // This is the previous challenge id if level is\n\n        uint256 totalReward;\n        uint256 stakeAmount;        // Required amount to pass the level\n        uint256 stakePeriod;        // Duration after which challenge considered to be completed.\n        uint256 multiplier;         // Increase the progress\n\n        uint256 startTime;     \t\t// session start in unixtimestamp\n        uint256 endTime;\n\n        uint256 claimed;       \t\t// amount of already claimed CWS\n        uint256 amount;        \t\t// total amount of deposited tokens to the session by users\n\n        uint256 rewardUnit;    \t\t// reward per second = totalReward/period\n        uint256 interestPerToken; \t// total earned interest per token since the beginning\n        \t\t\t\t\t\t\t// of the session\n        uint256 claimedPerToken;    // total amount of tokens earned by a one staked token,\n        \t\t\t\t\t\t\t// since the beginning of the session\n        uint256 lastInterestUpdate; // last time when claimedPerToken and interestPerToken\n    }\n\n    struct PlayerChallenge {\n        uint256 stakedTime;\n        uint256 stakedDuration;\n\n        uint256 amount;        \t\t// amount of deposited token\n        bool counted;               // whether its been counted in the session or not.\n        uint256 overStakeAmount;\n\n        uint256 claimed;\n        uint256 claimedTime;\n        uint256 claimedReward;\n\n        uint256 unpaidReward;       // Amount of token that contract should pay to user\n\n        bool completed;             // Was the challenge in the season completed by the player or not.\n    }\n\n    mapping(uint32 => Params) public challenges;\n    mapping(uint256 => mapping(uint32 => SessionChallenge)) public sessionChallenges;\n    // session id => challenge id => player address = PlayerChallenge\n    mapping(uint256 => mapping(uint32 => mapping (address => PlayerChallenge))) public playerParams;\n\n    modifier onlyZombieFarm () {\n\t      require(msg.sender == zombieFarm, \"only ZombieFarm can call\");\n\t      _;\n    }\n\n    event SaveReward(\n        uint256 indexed sessionId,\n        uint8 indexed rewardType,\n        address indexed token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event RewardNft(\n        uint256 indexed sessionId,\n        uint8 rewardType,\n        address indexed owner,\n        uint256 indexed nftId,\n        address token,\n        uint256 generation,\n        uint8 quality,\n        uint256 imgId,\n        uint256 amount\n    );\n    event Stake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Unstake(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n    event Claim(\n        address indexed staker,\n        uint256 indexed sessionId,\n        uint32 challengeId,\n        uint256 amount,\n        uint256 sessionAmount\n    );\n\n    constructor (address _zombieFarm, address _pool) public {\n        require(_zombieFarm != address(0), \"invalid _zombieFarm address\");\n        require(_pool != address(0), \"invalid _pool address\");\n\n        zombieFarm = _zombieFarm;\n        pool = _pool;\n    }\n\n    /// @notice indicates that a new challenge of this challenge category is supported by Zombie Farm\n    function newChallenge(uint32 id, bytes calldata data) external override onlyZombieFarm {\n        require(challenges[id].stake == address(0), \"single token challenge exists\");\n\n        address _stake;\n        address _earn;\n\n        (_stake, _earn) = abi.decode(data, (address, address));\n        require(_stake != address(0), \"data.stake verification failed\");\n        require(_earn != address(0), \"data.earn verification failed\");\n\n        challenges[id] = Params(_stake, _earn);\n    }\n\n    /// @notice a new challenge of this challenge category was added to the Season.\n    function saveChallenge(\n        uint256 sessionId,\n        uint256 startTime,\n        uint256 period,\n        uint8 offset,\n        bytes calldata data\n    )\n        external\n        override\n        onlyZombieFarm\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        // multipliers could be 0.\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n        SessionChallenge storage session = sessionChallenges[sessionId][id[offset]];\n\n        // Challenge.stake is not null, means that Challenge.earn is not null too.\n        require(challenges[id[offset]].stake != address(0),\n            \"single token.challenge no exist\");\n        require(reward[offset] > 0, \"single token.reward==0\");\n        require(levelId[offset] > 0, \"single token.level==0\");\n        require(sessionId > 0, \"single token.session id==0\");\n        require(stakeAmount[offset] > 0, \"single token.stake amount==0\");\n        require(stakePeriod[offset] > 0, \"single token.stake period==0\");\n        require(session.totalReward == 0, \"challenge to level added before\");\n        require(startTime > 0 && period > 0, \"single token: session time==0\");\n        if (prevChallengeId[offset] > 0) {\n            require(challenges[prevChallengeId[offset]].stake != address(0),\n                \"previous challenge incomplete\");\n        }\n\n        session.levelId = levelId[offset];\n        session.totalReward = reward[offset];\n        session.stakeAmount = stakeAmount[offset];\n        session.stakePeriod = stakePeriod[offset];\n        session.multiplier = multiplier[offset];\n        session.startTime = startTime;\n        session.endTime = startTime + period;\n        session.rewardUnit = reward[offset] / period;\n        session.lastInterestUpdate = startTime;\n        session.prevChallengeId = prevChallengeId[offset];\n    }\n\n    function stake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n        nonReentrant\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"challange already completed\");\n\n        // Previous Challenge should be completed\n        if (sessionChallenge.prevChallengeId > 0) {\n            PlayerChallenge storage playerPrevChallenge = playerParams[sessionId][sessionChallenge\n                .prevChallengeId][staker];\n            require(playerPrevChallenge.completed ||\n                isCompleted(sessionChallenge, playerPrevChallenge, now),\n                \"last challenge not completed\");\n        }\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount > 0, \"single token:amount==0\");\n\n        require(!isCompleted(sessionChallenge, playerChallenge, block.timestamp),\n            \"time completed\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        /// Transfer tokens to the Smartcontract\n        /// TODO add stake holding option. The stake holding option earns a passive income\n        /// by user provided tokens.\n        IERC20 _token = IERC20(challenge.stake);\n        require(_token.balanceOf(staker) >= amount, \"not enough staking token\");\n        require(_token.transferFrom(staker, address(this), amount),\n            \"transferFrom staker failed\");\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n        }\n\n        uint256 total = amount + playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        // I add amount of deposits to session.amount\n        // we add to total stakes, if user deposited >= stakeAmount.\n        if (total >= sessionChallenge.stakeAmount && !playerChallenge.counted) {\n    \t      sessionChallenge.amount = sessionChallenge.amount + sessionChallenge.stakeAmount; // 10\n            playerChallenge.counted = true;\n\n            // Once the total stake amount has been increased, we update the earnings\n            updateInterestPerToken(sessionChallenge);\n        }\n\n        // Amount holds only max session.stakeAmount\n        // the remaining part goes to multiply\n        if (total < sessionChallenge.stakeAmount) {\n            playerChallenge.amount = total;\n        } else {\n            updateTimeProgress(sessionChallenge, playerChallenge);\n\n            playerChallenge.amount = sessionChallenge.stakeAmount;\n            playerChallenge.overStakeAmount = total - sessionChallenge.stakeAmount;\n            playerChallenge.stakedTime = block.timestamp;\n\n    \t\tupdateBalanceInterestPerToken(sessionChallenge.claimedPerToken, playerChallenge);\n        }\n\n\t\temit Stake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n    }\n\n    function unstake(uint256 sessionId, uint32 challengeId, address staker, bytes calldata data)\n        external\n        override\n        onlyZombieFarm\n        nonReentrant\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake amount zero\");\n\n        uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n        /// Staking amount\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n        require(amount <= totalStake, \"single token:exceed stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n    \t\t    _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (!isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n            if (amount > playerChallenge.overStakeAmount) {\n                uint256 cut = amount - playerChallenge.overStakeAmount;\n                playerChallenge.amount = playerChallenge.amount - cut;\n\n                // player is removed from earning. so other users gets more.\n                if (playerChallenge.amount < sessionChallenge.stakeAmount) {\n                    sessionChallenge.amount = sessionChallenge\n                        .amount - sessionChallenge.stakeAmount;\n                    updateInterestPerToken(sessionChallenge);\n                }\n                playerChallenge.overStakeAmount = 0;\n                } else {\n                playerChallenge.overStakeAmount = playerChallenge.overStakeAmount - amount;\n            }\n            playerChallenge.stakedDuration = 0;\n            if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n                playerChallenge.stakedTime = now;\n            } else {\n                playerChallenge.stakedTime = 0;\n                playerChallenge.counted = false;\n            }\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= amount, \"insufficient contract balances\");\n            require(_token.transfer(staker, amount), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, amount, sessionChallenge.amount);\n        } else {\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake, \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Unstake(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    function claim(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n        nonReentrant\n    {\n        /// General information regarding the Staking token and Earning token\n        Params storage challenge = challenges[challengeId];\n\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        require(sessionChallenge.levelId > 0, \"single token: session not exist\");\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n        require(!playerChallenge.completed, \"already completed and claimed\");\n        require(playerChallenge.amount > 0, \"stake no stake\");\n\n        updateInterestPerToken(sessionChallenge);\n\n        // before updating player's challenge parameters, we auto-claim earned tokens till now.\n    \t\tif (playerChallenge.amount >= sessionChallenge.stakeAmount) {\n            _claim(sessionId, challengeId, staker);\n            playerChallenge.claimedTime = block.timestamp;\n    \t\t}\n\n        IERC20 _token = IERC20(challenge.stake);\n\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            isCompleted(sessionChallenge, playerChallenge, block.timestamp)) {\n\n            uint256 totalStake = playerChallenge.amount + playerChallenge.overStakeAmount;\n\n            playerChallenge.amount = 0;\n            playerChallenge.overStakeAmount = 0;\n            playerChallenge.stakedTime = 0;\n            playerChallenge.stakedDuration = 0;\n\n            playerChallenge.completed = true;\n\n            sessionChallenge.amount = sessionChallenge.amount - sessionChallenge.stakeAmount;\n\n            updateInterestPerToken(sessionChallenge);\n\n            /// Transfer tokens to the Smartcontract\n            /// TODO add stake holding option. The stake holding option earns a passive income\n            /// by user provided tokens.\n            require(_token.balanceOf(address(this)) >= totalStake,\n                \"insufficient contract balances\");\n            require(_token.transfer(staker, totalStake), \"transfer to staker failed\");\n\n            emit Claim(staker, sessionId, challengeId, totalStake, sessionChallenge.amount);\n        }\n    }\n\n    /// Set session as complete\n    function complete(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        onlyZombieFarm\n    {\n        /// Session Parameters\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        /// Player parameters\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount >= sessionChallenge.stakeAmount, \"didnt stake enough\");\n\n        playerChallenge.completed = true;\n    }\n\n    /// @dev updateInterestPerToken set's up the amount of tokens earned since the beginning\n\t/// of the session to 1 token. It also updates the portion of it for the user.\n    /// @param sessionChallenge is this challenge\n    function updateInterestPerToken(SessionChallenge storage sessionChallenge)\n        internal\n        returns(bool)\n    {\n        uint256 sessionCap = getSessionCap(sessionChallenge.startTime, sessionChallenge.endTime);\n\n        // I calculate previous claimed rewards\n        // (session.claimedPerToken += (now - session.lastInterestUpdate) * session.interestPerToken)\n        sessionChallenge.claimedPerToken = sessionChallenge.claimedPerToken + (\n        (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // I record that interestPerToken is 0.1 CWS (rewardUnit/amount) in session.interestPerToken\n        // I update the session.lastInterestUpdate to now\n        if (sessionChallenge.amount == 0) {\n            sessionChallenge.interestPerToken = 0;\n        } else {\n            sessionChallenge.interestPerToken = (sessionChallenge\n                .rewardUnit * scaler) / sessionChallenge.amount; // 0.1\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        sessionChallenge.lastInterestUpdate = sessionCap;\n    }\n\n    function getSessionCap(uint256 startTime, uint256 endTime) internal view returns(uint256) {\n        if (!isActive(startTime, endTime)) {\n            return endTime;\n        }\n        return block.timestamp;\n    }\n\n    function isActive(uint256 startTime, uint256 endTime) internal view returns(bool) {\n        if (startTime == 0) {\n            return false;\n        }\n        return (now >= startTime && now <= endTime);\n    }\n\n    function isCompleted(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge,\n        uint256 currentTime\n    )\n        internal\n        view\n        returns(bool)\n    {\n        uint256 time = playerChallenge.stakedDuration;\n\n        if (playerChallenge.amount == sessionChallenge.stakeAmount) {\n            if (playerChallenge.stakedTime > 0) {\n                uint256 duration = (currentTime - playerChallenge.stakedTime);\n                time = time + duration;\n\n                if (playerChallenge.overStakeAmount > 0) {\n                    time = time + (duration * ((playerChallenge\n                        .overStakeAmount * sessionChallenge.multiplier) / multiply) / scaler);\n                }\n            }\n        }\n        return time >= sessionChallenge.stakePeriod;\n    }\n\n    function isFullyCompleted(uint256 sessionId, uint32 challengeId, address staker)\n        external\n        override\n        view\n        returns(bool)\n    {\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        if (playerChallenge.completed) {\n            return true;\n        }\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n\n        return isCompleted(sessionChallenge, playerChallenge, block.timestamp);\n    }\n\n    function updateTimeProgress(\n        SessionChallenge storage sessionChallenge,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n    {\n        // update time progress\n        // previous stake time\n        if (playerChallenge.amount >= sessionChallenge.stakeAmount &&\n            playerChallenge.stakedTime > 0) {\n\n            uint256 time = block.timestamp - playerChallenge.stakedTime;\n\n            if (playerChallenge.overStakeAmount > 0) {\n                time = time + (time * ((playerChallenge.overStakeAmount * sessionChallenge\n                    .multiplier) / multiply) / scaler);\n            }\n\n            playerChallenge.stakedDuration = playerChallenge.stakedDuration + time;\n            if (playerChallenge.stakedDuration >= sessionChallenge.stakePeriod) {\n                playerChallenge.completed = true;\n            }\n        }\n    }\n\n    function updateBalanceInterestPerToken(\n        uint256 claimedPerToken,\n        PlayerChallenge storage playerChallenge\n    )\n        internal\n        returns(bool)\n    {\n        playerChallenge.claimedReward = claimedPerToken * playerChallenge.amount / scaler; // 0\n    }\n\n    function _claim(uint256 sessionId, uint32 challengeId, address staker) internal returns(bool) {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n        require(playerChallenge.amount > 0, \"didnt deposit enough\");\n\n        uint256 interest = calculateInterest(sessionId, challengeId, staker);\n        if (interest == 0) {\n            return false;\n        }\n\n        Params storage challenge = challenges[challengeId];\n\n        IERC20 _token = IERC20(challenge.earn);\n\n        uint256 contractBalance = _token.balanceOf(pool);\n\n        if (interest > 0 && contractBalance < interest) {\n            playerChallenge.unpaidReward = (interest - contractBalance) + playerChallenge\n                .unpaidReward;\n        }\n\n        // we avoid sub. underflow, for calulating session.claimedPerToken\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            playerChallenge.claimedTime = sessionChallenge.endTime;\n        } else {\n            playerChallenge.claimedTime = block.timestamp;\n        }\n        sessionChallenge.claimed = sessionChallenge.claimed + interest;\n        playerChallenge.claimed = playerChallenge.claimed + interest;\n\n        if (interest > contractBalance) {\n            _token.transferFrom(pool, staker, contractBalance);\n        } else {\n            _token.transferFrom(pool, staker, interest);\n        }\n\n        //emit Claimed(challenge.earn, staker, sessionId, challengeId, interest, block.timestamp);\n        return true;\n    }\n\n    function calculateInterest(uint256 sessionId, uint32 challengeId, address staker)\n        internal\n        view\n        returns(uint256)\n    {\n        SessionChallenge storage sessionChallenge = sessionChallenges[sessionId][challengeId];\n        PlayerChallenge storage playerChallenge = playerParams[sessionId][challengeId][staker];\n\n    \t\t// How much of total deposit is belong to player as a floating number\n    \t\tif (playerChallenge.amount == 0 || sessionChallenge.amount == 0) {\n            return 0;\n    \t\t}\n\n        uint256 sessionCap = block.timestamp;\n        if (isActive(sessionChallenge.startTime, sessionChallenge.endTime) == false) {\n            sessionCap = sessionChallenge.endTime;\n\n          \t// claimed after session expire, means no any claimables\n          \tif (playerChallenge.claimedTime >= sessionCap) {\n                return 0;\n            }\n        }\n\n        uint256 claimedPerToken = sessionChallenge.claimedPerToken + (\n            (sessionCap - sessionChallenge.lastInterestUpdate) * sessionChallenge.interestPerToken);\n\n        // (balance * total claimable) - user deposit earned amount per token - balance.claimedTime\n        uint256 interest = ((playerChallenge\n            .amount * claimedPerToken) / scaler) - playerChallenge.claimedReward;\n\n        return interest;\n    }\n\n    function getIdAndLevel(uint8 offset, bytes calldata data)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint32, uint8)\n    {\n        uint32[5] memory id;\n        uint8[5] memory levelId;\n        uint256[5] memory reward;\n        uint256[5] memory stakeAmount;\n        uint256[5] memory stakePeriod;\n        uint256[5] memory multiplier;\n        uint32[5] memory prevChallengeId;\n\n        (id, levelId, reward, stakeAmount, stakePeriod, multiplier, prevChallengeId) = abi\n            .decode(data, (\n            uint32[5],\n            uint8[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint256[5],\n            uint32[5]\n            ));\n\n\n        return (id[offset], levelId[offset]);\n    }\n\n    function getLevel(uint256 sessionId, uint32 challengeId)\n        external\n        override\n        view\n        onlyZombieFarm\n        returns(uint8)\n    {\n        return sessionChallenges[sessionId][challengeId].levelId;\n    }\n}\n", "commit_id": "a40102dccf875b0e6e3e471d36880fbc74ee649f"}}