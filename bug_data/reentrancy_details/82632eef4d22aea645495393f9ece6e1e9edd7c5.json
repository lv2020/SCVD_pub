{"filename": "contracts/AnyswapV4CallProxy.sol", "patch": "@@ -25,9 +25,6 @@ contract AnyCallProxy {\n     // Delay for ownership transfer\n     uint256 constant TRANSFER_DELAY = 2 days;\n \n-    // reentrancy lock starts at 1 so it costs less overtime\n-    uint256 private _locked = 1;\n-\n     address public mpc;\n     TransferData private _transferData;\n \n@@ -88,14 +85,6 @@ contract AnyCallProxy {\n         emit UpdatePremium(0, _premium);\n     }\n \n-    /// @dev Reentrancy Guard taken from solmate https://github.com/Rari-Capital/solmate\n-    modifier nonreentrant() {\n-       require(_locked == 1); // dev: reentrancy\n-       _locked = 2;\n-       _;\n-       _locked = 1;\n-    }\n-\n     modifier onlyMPC() {\n         require(msg.sender == mpc); // dev: only MPC\n         _;\n@@ -107,7 +96,7 @@ contract AnyCallProxy {\n         uint256 totalCost = (gasUsed - gasleft()) * (tx.gasprice + _feeData.premium);\n \n         executionBudget[_from] -= totalCost;\n-        _feeData.accruedFees += totalCost;\n+        _feeData.accruedFees += uint128(totalCost);\n     }\n \n     /**\n@@ -123,7 +112,7 @@ contract AnyCallProxy {\n         bytes calldata _data,\n         address _callback,\n         uint256 _toChainID\n-    ) external nonreentrant {\n+    ) external {\n         require(!blacklist[msg.sender]); // dev: caller is blacklisted\n         require(whitelist[msg.sender][_to][_toChainID]); // dev: request denied\n \n@@ -136,38 +125,14 @@ contract AnyCallProxy {\n         bytes calldata _data,\n         address _callback,\n         uint256 _fromChainID\n-    ) external charge(_from) nonreentrant onlyMPC {\n+    ) external charge(_from) onlyMPC {\n         context = Context({sender: _from, fromChainID: _fromChainID});\n         (bool success, bytes memory result) = _to.call(_data);\n         context = Context({sender: address(0), fromChainID: 0});\n \n         emit AnyExec(_from, _to, _data, success, result, _callback, _fromChainID);\n     }\n \n-    function anyCallback(\n-        address _from,\n-        address _to,\n-        bytes calldata _data,\n-        bool _success,\n-        bytes calldata _result,\n-        address _callback,\n-        uint256 _toChainID\n-    ) external charge(_from) nonreentrant onlyMPC {\n-        (bool success, bytes memory result) = _callback.call(\n-            abi.encodeWithSignature(\n-                \"callback(address,address,bytes,bool,bytes,uint256)\",\n-                _from,\n-                _to,\n-                _data,\n-                _success,\n-                _result,\n-                _toChainID\n-            )\n-        );\n-\n-        emit AnyCallback(_from, _to, _data, _success, _result, _toChainID, success, result);\n-    }\n-\n     function deposit(address _account) external payable {\n         executionBudget[_account] += msg.value;\n         emit Deposit(_account, msg.value);\n@@ -176,13 +141,13 @@ contract AnyCallProxy {\n     function withdraw(uint256 _amount) external {\n         executionBudget[msg.sender] -= _amount;\n         emit Withdrawl(msg.sender, _amount);\n-        (bool s, bytes memory r) = msg.sender.call{value: _amount}(\"\");\n+        msg.sender.call{value: _amount}(\"\");\n     }\n \n     function withdrawAccruedFees() external {\n         uint256 fees = _feeData.accruedFees;\n         _feeData.accruedFees = 0;\n-        (bool s, bytes memory r) = mpc.call{value: fees}(\"\");\n+        mpc.call{value: fees}(\"\");\n     }\n \n     function setWhitelist(", "project_link": "https://github.com/cryptobuks1/anyswap-v1-core/commit/82632eef4d22aea645495393f9ece6e1e9edd7c5", "bug_version": {"raw_code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\ncontract AnyCallProxy {\n    // Context information for destination chain targets\n    struct Context {\n        address sender;\n        uint256 fromChainID;\n    }\n\n    // Packed fee information (only 1 storage slot)\n    struct FeeData {\n        uint128 accruedFees;\n        uint128 premium;\n    }\n\n    // Packed MPC transfer info (only 1 storage slot)\n    struct TransferData {\n        uint96 effectiveTime;\n        address pendingMPC;\n    }\n\n    // Extra cost of execution (SSTOREs.SLOADs,ADDs,etc..)\n    uint256 constant EXECUTION_OVERHEAD = 100000;\n    // Delay for ownership transfer\n    uint256 constant TRANSFER_DELAY = 2 days;\n\n    // reentrancy lock starts at 1 so it costs less overtime\n    uint256 private _locked = 1;\n\n    address public mpc;\n    TransferData private _transferData;\n\n    mapping(address => bool) public blacklist;\n    mapping(address => mapping(address => mapping(uint256 => bool))) public whitelist;\n    \n    Context public context;\n\n    mapping(address => uint256) public executionBudget;\n    FeeData private _feeData;\n\n    event AnyCall(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        address callback,\n        uint256 indexed toChainID\n    );\n\n    event AnyExec(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        address callback,\n        uint256 indexed fromChainID\n    );\n\n    event AnyCallback(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        uint256 indexed toChainID,\n        bool callbackSuccess,\n        bytes callbackResult\n    );\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawl(address indexed account, uint256 amount);\n    event SetBlacklist(address indexed account, bool flag);\n    event SetWhitelist(\n        address indexed from,\n        address indexed to,\n        uint256 indexed toChainID,\n        bool flag\n    );\n    event TransferMPC(address oldMPC, address newMPC, uint256 effectiveTime);\n    event UpdatePremium(uint256 oldPremium, uint256 newPremium);\n\n    constructor(address _mpc, uint128 _premium) {\n        mpc = _mpc;\n        _feeData.premium = _premium;\n\n        emit TransferMPC(address(0), _mpc, block.timestamp);\n        emit UpdatePremium(0, _premium);\n    }\n\n    /// @dev Reentrancy Guard taken from solmate https://github.com/Rari-Capital/solmate\n    modifier nonreentrant() {\n       require(_locked == 1); // dev: reentrancy\n       _locked = 2;\n       _;\n       _locked = 1;\n    }\n\n    modifier onlyMPC() {\n        require(msg.sender == mpc); // dev: only MPC\n        _;\n    }\n\n    modifier charge(address _from) {\n        uint256 gasUsed = gasleft() + EXECUTION_OVERHEAD;\n        _;\n        uint256 totalCost = (gasUsed - gasleft()) * (tx.gasprice + _feeData.premium);\n\n        executionBudget[_from] -= totalCost;\n        _feeData.accruedFees += totalCost;\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _callback The address to call back on the originating chain\n            with execution information about the cross chain interaction\n        @param _toChainID The target chain id to interact with\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _toChainID\n    ) external nonreentrant {\n        require(!blacklist[msg.sender]); // dev: caller is blacklisted\n        require(whitelist[msg.sender][_to][_toChainID]); // dev: request denied\n\n        emit AnyCall(msg.sender, _to, _data, _callback, _toChainID);\n    }\n\n    function anyExec(\n        address _from,\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _fromChainID\n    ) external charge(_from) nonreentrant onlyMPC {\n        context = Context({sender: _from, fromChainID: _fromChainID});\n        (bool success, bytes memory result) = _to.call(_data);\n        context = Context({sender: address(0), fromChainID: 0});\n\n        emit AnyExec(_from, _to, _data, success, result, _callback, _fromChainID);\n    }\n\n    function anyCallback(\n        address _from,\n        address _to,\n        bytes calldata _data,\n        bool _success,\n        bytes calldata _result,\n        address _callback,\n        uint256 _toChainID\n    ) external charge(_from) nonreentrant onlyMPC {\n        (bool success, bytes memory result) = _callback.call(\n            abi.encodeWithSignature(\n                \"callback(address,address,bytes,bool,bytes,uint256)\",\n                _from,\n                _to,\n                _data,\n                _success,\n                _result,\n                _toChainID\n            )\n        );\n\n        emit AnyCallback(_from, _to, _data, _success, _result, _toChainID, success, result);\n    }\n\n    function deposit(address _account) external payable {\n        executionBudget[_account] += msg.value;\n        emit Deposit(_account, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        executionBudget[msg.sender] -= _amount;\n        emit Withdrawl(msg.sender, _amount);\n        (bool s, bytes memory r) = msg.sender.call{value: _amount}(\"\");\n    }\n\n    function withdrawAccruedFees() external {\n        uint256 fees = _feeData.accruedFees;\n        _feeData.accruedFees = 0;\n        (bool s, bytes memory r) = mpc.call{value: fees}(\"\");\n    }\n\n    function setWhitelist(\n        address _from,\n        address _to,\n        uint256 _toChainID,\n        bool _flag\n    ) external onlyMPC {\n        whitelist[_from][_to][_toChainID] = _flag;\n        emit SetWhitelist(_from, _to, _toChainID, _flag);\n    }\n\n    function setBlacklist(address _account, bool _flag) external onlyMPC {\n        blacklist[_account] = _flag;\n        emit SetBlacklist(_account, _flag);\n    }\n\n    function setPremium(uint128 _premium) external onlyMPC {\n        emit UpdatePremium(_feeData.premium, _premium);\n        _feeData.premium = _premium;\n    }\n\n    function changeMPC(address _newMPC) external onlyMPC {\n        _transferData = TransferData({\n            effectiveTime: uint96(block.timestamp + TRANSFER_DELAY),\n            pendingMPC: _newMPC\n        });\n        emit TransferMPC(mpc, _newMPC, block.timestamp + TRANSFER_DELAY);\n    }\n\n    function accruedFees() external view returns(uint128) {\n        return _feeData.accruedFees;\n    }\n\n    function premium() external view returns(uint128) {\n        return _feeData.premium;\n    }\n\n    function effectiveTime() external view returns(uint256) {\n        return _transferData.effectiveTime;\n    }\n    \n    function pendingMPC() external view returns(address) {\n        return _transferData.pendingMPC;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\ncontract AnyCallProxy {\n    // Context information for destination chain targets\n    struct Context {\n        address sender;\n        uint256 fromChainID;\n    }\n\n    // Packed fee information (only 1 storage slot)\n    struct FeeData {\n        uint128 accruedFees;\n        uint128 premium;\n    }\n\n    // Packed MPC transfer info (only 1 storage slot)\n    struct TransferData {\n        uint96 effectiveTime;\n        address pendingMPC;\n    }\n\n    // Extra cost of execution (SSTOREs.SLOADs,ADDs,etc..)\n    uint256 constant EXECUTION_OVERHEAD = 100000;\n    // Delay for ownership transfer\n    uint256 constant TRANSFER_DELAY = 2 days;\n\n    // reentrancy lock starts at 1 so it costs less overtime\n    uint256 private _locked = 1;\n\n    address public mpc;\n    TransferData private _transferData;\n\n    mapping(address => bool) public blacklist;\n    mapping(address => mapping(address => mapping(uint256 => bool))) public whitelist;\n    \n    Context public context;\n\n    mapping(address => uint256) public executionBudget;\n    FeeData private _feeData;\n\n    event AnyCall(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        address callback,\n        uint256 indexed toChainID\n    );\n\n    event AnyExec(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        address callback,\n        uint256 indexed fromChainID\n    );\n\n    event AnyCallback(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        uint256 indexed toChainID,\n        bool callbackSuccess,\n        bytes callbackResult\n    );\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawl(address indexed account, uint256 amount);\n    event SetBlacklist(address indexed account, bool flag);\n    event SetWhitelist(\n        address indexed from,\n        address indexed to,\n        uint256 indexed toChainID,\n        bool flag\n    );\n    event TransferMPC(address oldMPC, address newMPC, uint256 effectiveTime);\n    event UpdatePremium(uint256 oldPremium, uint256 newPremium);\n\n    constructor(address _mpc, uint128 _premium) {\n        mpc = _mpc;\n        _feeData.premium = _premium;\n\n        emit TransferMPC(address(0), _mpc, block.timestamp);\n        emit UpdatePremium(0, _premium);\n    }\n\n    /// @dev Reentrancy Guard taken from solmate https://github.com/Rari-Capital/solmate\n    modifier nonreentrant() {\n       require(_locked == 1); // dev: reentrancy\n       _locked = 2;\n       _;\n       _locked = 1;\n    }\n\n    modifier onlyMPC() {\n        require(msg.sender == mpc); // dev: only MPC\n        _;\n    }\n\n    modifier charge(address _from) {\n        uint256 gasUsed = gasleft() + EXECUTION_OVERHEAD;\n        _;\n        uint256 totalCost = (gasUsed - gasleft()) * (tx.gasprice + _feeData.premium);\n\n        executionBudget[_from] -= totalCost;\n        _feeData.accruedFees += totalCost;\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _callback The address to call back on the originating chain\n            with execution information about the cross chain interaction\n        @param _toChainID The target chain id to interact with\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _toChainID\n    ) external nonreentrant {\n        require(!blacklist[msg.sender]); // dev: caller is blacklisted\n        require(whitelist[msg.sender][_to][_toChainID]); // dev: request denied\n\n        emit AnyCall(msg.sender, _to, _data, _callback, _toChainID);\n    }\n\n    function anyExec(\n        address _from,\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _fromChainID\n    ) external charge(_from) nonreentrant onlyMPC {\n        context = Context({sender: _from, fromChainID: _fromChainID});\n        (bool success, bytes memory result) = _to.call(_data);\n        context = Context({sender: address(0), fromChainID: 0});\n\n        emit AnyExec(_from, _to, _data, success, result, _callback, _fromChainID);\n    }\n\n    function anyCallback(\n        address _from,\n        address _to,\n        bytes calldata _data,\n        bool _success,\n        bytes calldata _result,\n        address _callback,\n        uint256 _toChainID\n    ) external charge(_from) nonreentrant onlyMPC {\n        (bool success, bytes memory result) = _callback.call(\n            abi.encodeWithSignature(\n                \"callback(address,address,bytes,bool,bytes,uint256)\",\n                _from,\n                _to,\n                _data,\n                _success,\n                _result,\n                _toChainID\n            )\n        );\n\n        emit AnyCallback(_from, _to, _data, _success, _result, _toChainID, success, result);\n    }\n\n    function deposit(address _account) external payable {\n        executionBudget[_account] += msg.value;\n        emit Deposit(_account, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        executionBudget[msg.sender] -= _amount;\n        emit Withdrawl(msg.sender, _amount);\n        (bool s, bytes memory r) = msg.sender.call{value: _amount}(\"\");\n    }\n\n    function withdrawAccruedFees() external {\n        uint256 fees = _feeData.accruedFees;\n        _feeData.accruedFees = 0;\n        (bool s, bytes memory r) = mpc.call{value: fees}(\"\");\n    }\n\n    function setWhitelist(\n        address _from,\n        address _to,\n        uint256 _toChainID,\n        bool _flag\n    ) external onlyMPC {\n        whitelist[_from][_to][_toChainID] = _flag;\n        emit SetWhitelist(_from, _to, _toChainID, _flag);\n    }\n\n    function setBlacklist(address _account, bool _flag) external onlyMPC {\n        blacklist[_account] = _flag;\n        emit SetBlacklist(_account, _flag);\n    }\n\n    function setPremium(uint128 _premium) external onlyMPC {\n        emit UpdatePremium(_feeData.premium, _premium);\n        _feeData.premium = _premium;\n    }\n\n    function changeMPC(address _newMPC) external onlyMPC {\n        _transferData = TransferData({\n            effectiveTime: uint96(block.timestamp + TRANSFER_DELAY),\n            pendingMPC: _newMPC\n        });\n        emit TransferMPC(mpc, _newMPC, block.timestamp + TRANSFER_DELAY);\n    }\n\n    function accruedFees() external view returns(uint128) {\n        return _feeData.accruedFees;\n    }\n\n    function premium() external view returns(uint128) {\n        return _feeData.premium;\n    }\n\n    function effectiveTime() external view returns(uint256) {\n        return _transferData.effectiveTime;\n    }\n    \n    function pendingMPC() external view returns(address) {\n        return _transferData.pendingMPC;\n    }\n}\n", "commit_id": "0f2ddacd9fdad98e61bb4af0f5be645206c3cd4f"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\ncontract AnyCallProxy {\n    // Context information for destination chain targets\n    struct Context {\n        address sender;\n        uint256 fromChainID;\n    }\n\n    // Packed fee information (only 1 storage slot)\n    struct FeeData {\n        uint128 accruedFees;\n        uint128 premium;\n    }\n\n    // Packed MPC transfer info (only 1 storage slot)\n    struct TransferData {\n        uint96 effectiveTime;\n        address pendingMPC;\n    }\n\n    // Extra cost of execution (SSTOREs.SLOADs,ADDs,etc..)\n    uint256 constant EXECUTION_OVERHEAD = 100000;\n    // Delay for ownership transfer\n    uint256 constant TRANSFER_DELAY = 2 days;\n\n    address public mpc;\n    TransferData private _transferData;\n\n    mapping(address => bool) public blacklist;\n    mapping(address => mapping(address => mapping(uint256 => bool))) public whitelist;\n    \n    Context public context;\n\n    mapping(address => uint256) public executionBudget;\n    FeeData private _feeData;\n\n    event AnyCall(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        address callback,\n        uint256 indexed toChainID\n    );\n\n    event AnyExec(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        address callback,\n        uint256 indexed fromChainID\n    );\n\n    event AnyCallback(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        uint256 indexed toChainID,\n        bool callbackSuccess,\n        bytes callbackResult\n    );\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawl(address indexed account, uint256 amount);\n    event SetBlacklist(address indexed account, bool flag);\n    event SetWhitelist(\n        address indexed from,\n        address indexed to,\n        uint256 indexed toChainID,\n        bool flag\n    );\n    event TransferMPC(address oldMPC, address newMPC, uint256 effectiveTime);\n    event UpdatePremium(uint256 oldPremium, uint256 newPremium);\n\n    constructor(address _mpc, uint128 _premium) {\n        mpc = _mpc;\n        _feeData.premium = _premium;\n\n        emit TransferMPC(address(0), _mpc, block.timestamp);\n        emit UpdatePremium(0, _premium);\n    }\n\n    modifier onlyMPC() {\n        require(msg.sender == mpc); // dev: only MPC\n        _;\n    }\n\n    modifier charge(address _from) {\n        uint256 gasUsed = gasleft() + EXECUTION_OVERHEAD;\n        _;\n        uint256 totalCost = (gasUsed - gasleft()) * (tx.gasprice + _feeData.premium);\n\n        executionBudget[_from] -= totalCost;\n        _feeData.accruedFees += uint128(totalCost);\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _callback The address to call back on the originating chain\n            with execution information about the cross chain interaction\n        @param _toChainID The target chain id to interact with\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _toChainID\n    ) external {\n        require(!blacklist[msg.sender]); // dev: caller is blacklisted\n        require(whitelist[msg.sender][_to][_toChainID]); // dev: request denied\n\n        emit AnyCall(msg.sender, _to, _data, _callback, _toChainID);\n    }\n\n    function anyExec(\n        address _from,\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _fromChainID\n    ) external charge(_from) onlyMPC {\n        context = Context({sender: _from, fromChainID: _fromChainID});\n        (bool success, bytes memory result) = _to.call(_data);\n        context = Context({sender: address(0), fromChainID: 0});\n\n        emit AnyExec(_from, _to, _data, success, result, _callback, _fromChainID);\n    }\n\n    function deposit(address _account) external payable {\n        executionBudget[_account] += msg.value;\n        emit Deposit(_account, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        executionBudget[msg.sender] -= _amount;\n        emit Withdrawl(msg.sender, _amount);\n        msg.sender.call{value: _amount}(\"\");\n    }\n\n    function withdrawAccruedFees() external {\n        uint256 fees = _feeData.accruedFees;\n        _feeData.accruedFees = 0;\n        mpc.call{value: fees}(\"\");\n    }\n\n    function setWhitelist(\n        address _from,\n        address _to,\n        uint256 _toChainID,\n        bool _flag\n    ) external onlyMPC {\n        whitelist[_from][_to][_toChainID] = _flag;\n        emit SetWhitelist(_from, _to, _toChainID, _flag);\n    }\n\n    function setBlacklist(address _account, bool _flag) external onlyMPC {\n        blacklist[_account] = _flag;\n        emit SetBlacklist(_account, _flag);\n    }\n\n    function setPremium(uint128 _premium) external onlyMPC {\n        emit UpdatePremium(_feeData.premium, _premium);\n        _feeData.premium = _premium;\n    }\n\n    function changeMPC(address _newMPC) external onlyMPC {\n        _transferData = TransferData({\n            effectiveTime: uint96(block.timestamp + TRANSFER_DELAY),\n            pendingMPC: _newMPC\n        });\n        emit TransferMPC(mpc, _newMPC, block.timestamp + TRANSFER_DELAY);\n    }\n\n    function accruedFees() external view returns(uint128) {\n        return _feeData.accruedFees;\n    }\n\n    function premium() external view returns(uint128) {\n        return _feeData.premium;\n    }\n\n    function effectiveTime() external view returns(uint256) {\n        return _transferData.effectiveTime;\n    }\n    \n    function pendingMPC() external view returns(address) {\n        return _transferData.pendingMPC;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.6;\n\ncontract AnyCallProxy {\n    // Context information for destination chain targets\n    struct Context {\n        address sender;\n        uint256 fromChainID;\n    }\n\n    // Packed fee information (only 1 storage slot)\n    struct FeeData {\n        uint128 accruedFees;\n        uint128 premium;\n    }\n\n    // Packed MPC transfer info (only 1 storage slot)\n    struct TransferData {\n        uint96 effectiveTime;\n        address pendingMPC;\n    }\n\n    // Extra cost of execution (SSTOREs.SLOADs,ADDs,etc..)\n    uint256 constant EXECUTION_OVERHEAD = 100000;\n    // Delay for ownership transfer\n    uint256 constant TRANSFER_DELAY = 2 days;\n\n    address public mpc;\n    TransferData private _transferData;\n\n    mapping(address => bool) public blacklist;\n    mapping(address => mapping(address => mapping(uint256 => bool))) public whitelist;\n    \n    Context public context;\n\n    mapping(address => uint256) public executionBudget;\n    FeeData private _feeData;\n\n    event AnyCall(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        address callback,\n        uint256 indexed toChainID\n    );\n\n    event AnyExec(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        address callback,\n        uint256 indexed fromChainID\n    );\n\n    event AnyCallback(\n        address indexed from,\n        address indexed to,\n        bytes data,\n        bool success,\n        bytes result,\n        uint256 indexed toChainID,\n        bool callbackSuccess,\n        bytes callbackResult\n    );\n\n    event Deposit(address indexed account, uint256 amount);\n    event Withdrawl(address indexed account, uint256 amount);\n    event SetBlacklist(address indexed account, bool flag);\n    event SetWhitelist(\n        address indexed from,\n        address indexed to,\n        uint256 indexed toChainID,\n        bool flag\n    );\n    event TransferMPC(address oldMPC, address newMPC, uint256 effectiveTime);\n    event UpdatePremium(uint256 oldPremium, uint256 newPremium);\n\n    constructor(address _mpc, uint128 _premium) {\n        mpc = _mpc;\n        _feeData.premium = _premium;\n\n        emit TransferMPC(address(0), _mpc, block.timestamp);\n        emit UpdatePremium(0, _premium);\n    }\n\n    modifier onlyMPC() {\n        require(msg.sender == mpc); // dev: only MPC\n        _;\n    }\n\n    modifier charge(address _from) {\n        uint256 gasUsed = gasleft() + EXECUTION_OVERHEAD;\n        _;\n        uint256 totalCost = (gasUsed - gasleft()) * (tx.gasprice + _feeData.premium);\n\n        executionBudget[_from] -= totalCost;\n        _feeData.accruedFees += uint128(totalCost);\n    }\n\n    /**\n        @notice Submit a request for a cross chain interaction\n        @param _to The target to interact with on `_toChainID`\n        @param _data The calldata supplied for the interaction with `_to`\n        @param _callback The address to call back on the originating chain\n            with execution information about the cross chain interaction\n        @param _toChainID The target chain id to interact with\n    */\n    function anyCall(\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _toChainID\n    ) external {\n        require(!blacklist[msg.sender]); // dev: caller is blacklisted\n        require(whitelist[msg.sender][_to][_toChainID]); // dev: request denied\n\n        emit AnyCall(msg.sender, _to, _data, _callback, _toChainID);\n    }\n\n    function anyExec(\n        address _from,\n        address _to,\n        bytes calldata _data,\n        address _callback,\n        uint256 _fromChainID\n    ) external charge(_from) onlyMPC {\n        context = Context({sender: _from, fromChainID: _fromChainID});\n        (bool success, bytes memory result) = _to.call(_data);\n        context = Context({sender: address(0), fromChainID: 0});\n\n        emit AnyExec(_from, _to, _data, success, result, _callback, _fromChainID);\n    }\n\n    function deposit(address _account) external payable {\n        executionBudget[_account] += msg.value;\n        emit Deposit(_account, msg.value);\n    }\n\n    function withdraw(uint256 _amount) external {\n        executionBudget[msg.sender] -= _amount;\n        emit Withdrawl(msg.sender, _amount);\n        msg.sender.call{value: _amount}(\"\");\n    }\n\n    function withdrawAccruedFees() external {\n        uint256 fees = _feeData.accruedFees;\n        _feeData.accruedFees = 0;\n        mpc.call{value: fees}(\"\");\n    }\n\n    function setWhitelist(\n        address _from,\n        address _to,\n        uint256 _toChainID,\n        bool _flag\n    ) external onlyMPC {\n        whitelist[_from][_to][_toChainID] = _flag;\n        emit SetWhitelist(_from, _to, _toChainID, _flag);\n    }\n\n    function setBlacklist(address _account, bool _flag) external onlyMPC {\n        blacklist[_account] = _flag;\n        emit SetBlacklist(_account, _flag);\n    }\n\n    function setPremium(uint128 _premium) external onlyMPC {\n        emit UpdatePremium(_feeData.premium, _premium);\n        _feeData.premium = _premium;\n    }\n\n    function changeMPC(address _newMPC) external onlyMPC {\n        _transferData = TransferData({\n            effectiveTime: uint96(block.timestamp + TRANSFER_DELAY),\n            pendingMPC: _newMPC\n        });\n        emit TransferMPC(mpc, _newMPC, block.timestamp + TRANSFER_DELAY);\n    }\n\n    function accruedFees() external view returns(uint128) {\n        return _feeData.accruedFees;\n    }\n\n    function premium() external view returns(uint128) {\n        return _feeData.premium;\n    }\n\n    function effectiveTime() external view returns(uint256) {\n        return _transferData.effectiveTime;\n    }\n    \n    function pendingMPC() external view returns(address) {\n        return _transferData.pendingMPC;\n    }\n}\n", "commit_id": "82632eef4d22aea645495393f9ece6e1e9edd7c5"}}