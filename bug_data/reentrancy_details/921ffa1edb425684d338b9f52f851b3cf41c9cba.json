{"filename": "contracts/RewardsManager.sol", "patch": "@@ -4,6 +4,7 @@ pragma solidity 0.8.10;\n \n import {IERC20} from \"@oz/token/ERC20/IERC20.sol\";\n import {SafeERC20} from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n+import {ReentrancyGuard} from \"@oz/security/ReentrancyGuard.sol\";\n \n \n /// @title RewardsManager\n@@ -47,14 +48,14 @@ import {SafeERC20} from \"@oz/token/ERC20/utils/SafeERC20.sol\";\n /// CONCLUSION\n /// Given the points, knowing the rewards amounts to distribute, you know how to split them at the end of each epoch\n \n-contract RewardsManager {\n+contract RewardsManager is ReentrancyGuard {\n     using SafeERC20 for IERC20;\n \n     uint256 public constant SECONDS_PER_EPOCH = 604800; // One epoch is one week\n     // This allows to specify rewards on a per week basis, making it easier to interact with contract\n     \n \n-    uint256 public constant MAX_BPS = 10_000;\n+    uint256 public constant PRECISION = 1e18;\n     \n     mapping(uint256 => Epoch) public epochs; // Epoch data for each epoch epochs[epochId]\n     // id is implicit in the list\n@@ -229,8 +230,8 @@ contract RewardsManager {\n         uint256 totalAdditionalReward = rewards[epochId][vault][token];\n \n         // We multiply just to avoid rounding\n-        uint256 ratioForPointsLeft = MAX_BPS * pointsLeft / vaultTotalPoints;\n-        uint256 tokensForUser = totalAdditionalReward * ratioForPointsLeft / MAX_BPS;\n+        uint256 ratioForPointsLeft = PRECISION * pointsLeft / vaultTotalPoints;\n+        uint256 tokensForUser = totalAdditionalReward * ratioForPointsLeft / PRECISION;\n \n         pointsWithdrawn[epochId][vault][user][token] += pointsLeft;\n \n@@ -275,7 +276,7 @@ contract RewardsManager {\n             }\n \n             // We multiply just to avoid rounding\n-            uint256 ratioPoints = MAX_BPS * userPoints / vaultTotalPoints;\n+            uint256 ratioPoints = PRECISION * userPoints / vaultTotalPoints;\n \n             // Loop over the tokens and see the points here\n             for(uint256 i = 0; i < tokensLength; ++i){\n@@ -286,7 +287,7 @@ contract RewardsManager {\n \n                 // Use ratio to calculate tokens to send\n                 uint256 totalAdditionalReward = rewards[epochId][vault][tokens[i]];\n-                uint256 tokensForUser = totalAdditionalReward * ratioPoints / MAX_BPS;\n+                uint256 tokensForUser = totalAdditionalReward * ratioPoints / PRECISION;\n \n                 // pointsWithdrawn[epochId][vault][user][tokens[i]] == userPoints\n                 // Which means they claimed all points for that token\n@@ -343,7 +344,7 @@ contract RewardsManager {\n             }\n \n             // We multiply just to avoid rounding\n-            uint256 ratioPoints = MAX_BPS * userPoints / vaultTotalPoints;\n+            uint256 ratioPoints = PRECISION * userPoints / vaultTotalPoints;\n \n             // NOTE: We don't set the pointsWithdrawn here because we will set the user shares to 0 later\n             // While maintainingn lastAccrueTimestamp to now so they can't reaccrue\n@@ -357,7 +358,7 @@ contract RewardsManager {\n \n                 // Use ratio to calculate tokens to send\n                 uint256 totalAdditionalReward = rewards[epochId][vault][tokens[i]];\n-                uint256 tokensForUser = totalAdditionalReward * ratioPoints / MAX_BPS;\n+                uint256 tokensForUser = totalAdditionalReward * ratioPoints / PRECISION;\n \n                 amounts[i] += tokensForUser;\n                 unchecked { ++i; }\n@@ -411,7 +412,8 @@ contract RewardsManager {\n     /// @notice Add an additional reward for the current epoch\n     /// @notice No particular rationale as to why we wouldn't allow to send rewards for older epochs or future epochs\n     /// @notice The typical use case is for this contract to receive certain rewards that would be sent to the badgerTree\n-    function addReward(uint256 epochId, address vault, address token, uint256 amount) public {\n+    /// @notice nonReentrant because tokens could inflate rewards, this would only apply to the specific token, see reports for more\n+    function addReward(uint256 epochId, address vault, address token, uint256 amount) public nonReentrant {\n         require(epochId >= currentEpoch);\n \n         // Check change in balance to support `feeOnTransfer` tokens as well", "project_link": "https://github.com/GalloDaSballo/badger-onchain-rewards/commit/921ffa1edb425684d338b9f52f851b3cf41c9cba", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "da51245108322841feeb62a77e08ae69f7f44315"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "921ffa1edb425684d338b9f52f851b3cf41c9cba"}}