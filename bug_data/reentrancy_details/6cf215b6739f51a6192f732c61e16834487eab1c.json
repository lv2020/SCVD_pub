{"filename": "contracts/SingularityPool.sol", "patch": "@@ -456,10 +456,12 @@ contract SingularityPool is ISingularityPool, SingularityPoolToken, ReentrancyGu\n \n         if (protocolFees == 0) return;\n \n-        IERC20(token).safeTransfer(feeTo, protocolFees);\n+        uint256 protocolFeesToTransfer = protocolFees;\n         protocolFees = 0;\n \n-        emit CollectFees(protocolFees);\n+        IERC20(token).safeTransfer(feeTo, protocolFeesToTransfer);\n+\n+        emit CollectFees(protocolFeesToTransfer);\n     }\n \n     function setDepositCap(uint256 newDepositCap) external override {", "project_link": "https://github.com/revenant-finance/singularity-v2/commit/5dea908b44af0f02b20a49e5545a4b8e02fe1eeb", "bug_version": {"raw_code": "// SPDX-License-Identifier: No License\n\npragma solidity ^0.8.15;\n\nimport \"./SingularityPoolToken.sol\";\nimport \"./interfaces/ISingularityPool.sol\";\nimport \"./interfaces/ISingularityFactory.sol\";\nimport \"./interfaces/ISingularityOracle.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./utils/SafeERC20.sol\";\nimport \"./utils/FixedPointMathLib.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\n\n/**\n * @title Singularity Pool\n * @author Revenant Labs\n */\ncontract SingularityPool is ISingularityPool, SingularityPoolToken, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    bool public override paused;\n    bool public immutable override isStablecoin;\n    address public immutable override factory;\n    address public immutable override token;\n    uint256 public override depositCap;\n    uint256 public override assets;\n    uint256 public override liabilities;\n    uint256 public override baseFee;\n    uint256 public override protocolFees;\n\n    constructor() {\n        (factory, token, isStablecoin, baseFee) = ISingularityFactory(msg.sender).poolParams();\n        string memory tranche = ISingularityFactory(factory).tranche();\n        string memory tokenSymbol = IERC20(token).symbol();\n        name = string(abi.encodePacked(\"Singularity Pool Token-\", tokenSymbol, \" (\", tranche, \")\"));\n        symbol = string(abi.encodePacked(\"SPT-\", tokenSymbol, \" (\", tranche, \")\"));\n        decimals = IERC20(token).decimals();\n        _initialize();\n    }\n\n    /// @notice Deposit underlying tokens to LP\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param amount The amount of underlying tokens to deposit\n    /// @param to The address to mint LP tokens to\n    /// @return mintAmount The amount of LP tokens minted\n    function deposit(uint256 amount, address to) external override nonReentrant returns (uint256 mintAmount) {\n        _notPaused();\n        require(amount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Transfer token from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        if (liabilities == 0) {\n            mintAmount = amount;\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amount;\n            liabilities += amount;\n        } else {\n            // Apply deposit fee\n            uint256 depositFee = getDepositFee(amount);\n            protocolFees += depositFee;\n            uint256 amountPostFee = amount - depositFee;\n\n            // Calculate amount of LP tokens to mint\n            mintAmount = amountPostFee.divWadDown(getPricePerShare());\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amountPostFee;\n            liabilities += amountPostFee;\n        }\n\n        require(liabilities <= depositCap, \"SingularityPool: DEPOSIT_EXCEEDS_CAP\");\n\n        emit Deposit(msg.sender, amount, mintAmount, to);\n    }\n\n    /// @notice Withdraw underlying tokens through burning LP tokens\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param lpAmount The amount of LP tokens to burn\n    /// @param to The address to redeem underlying tokens to\n    /// @return withdrawalAmount The amount of underlying tokens withdrawn\n    function withdraw(uint256 lpAmount, address to) external override nonReentrant returns (uint256 withdrawalAmount) {\n        _notPaused();\n        require(lpAmount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Store current price-per-share\n        uint256 pricePerShare = getPricePerShare();\n\n        // Burn LP tokens\n        _burn(msg.sender, lpAmount);\n\n        // Calculate amount of underlying tokens to redeem\n        uint256 amount = lpAmount.mulWadDown(pricePerShare);\n\n        // Apply withdrawal fee\n        uint256 withdrawalFee = getWithdrawalFee(amount);\n        protocolFees += withdrawalFee;\n        withdrawalAmount = amount - withdrawalFee;\n\n        // Transfer tokens to `to`\n        IERC20(token).safeTransfer(to, withdrawalAmount);\n\n        // Update assets and liabilities\n        assets -= amount;\n        liabilities -= amount;\n\n        emit Withdraw(msg.sender, lpAmount, withdrawalAmount, to);\n    }\n\n    /// @notice Swap tokens in\n    /// @dev Slippage is positive (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @return amountOut The USD value of the swap in (post fees)\n    function swapIn(uint256 amountIn) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Apply slippage (+)\n        uint256 amountPostSlippage = amountIn + getSlippageIn(amountIn);\n\n        // Transfer tokens from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        // Update assets\n        assets += amountIn;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        uint256 amountPostFee = amountPostSlippage - totalFee;\n\n        // Convert amount to USD value\n        amountOut = getAmountToUSD(amountPostFee);\n\n        emit SwapIn(msg.sender, amountIn, amountOut);\n    }\n\n    /// @notice Swap tokens out\n    /// @dev Slippage is negative (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @param to The address to send tokens to\n    /// @return amountOut The amount of tokens being swapped out\n    function swapOut(uint256 amountIn, address to) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Convert USD value to amount\n        uint256 amount = getUSDToAmount(amountIn);\n\n        // Apply slippage (-)\n        uint256 slippage = getSlippageOut(amount);\n        require(amount > slippage, \"SingularityPool: SLIPPAPGE_EXCEEDS_AMOUNT\");\n        uint256 amountPostSlippage = amount - slippage;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        amountOut = amountPostSlippage - totalFee;\n\n        // Transfer tokens out\n        IERC20(token).safeTransfer(to, amountOut);\n\n        // Update assets\n        assets -= amountOut;\n\n        emit SwapOut(msg.sender, amountIn, amountOut, to);\n    }\n\n    /// @notice Calculates the price-per-share (PPS)\n    /// @dev PPS = 1 when pool is empty\n    /// @dev PPS is strictly increasing >= 1\n    /// @return pricePerShare The PPS of 1 LP token\n    function getPricePerShare() public view override returns (uint256 pricePerShare) {\n        if (totalSupply == 0) {\n            pricePerShare = 1 ether;\n        } else {\n            pricePerShare = liabilities.divWadDown(totalSupply);\n        }\n    }\n\n    /// @notice Get pool's collateralization ratio\n    /// @dev Collateralization ratio is 1 if pool not seeded\n    /// @return collateralizationRatio The collateralization ratio of the pool\n    function getCollateralizationRatio() public view override returns (uint256 collateralizationRatio) {\n        if (liabilities == 0) {\n            collateralizationRatio = 1 ether;\n        } else {\n            collateralizationRatio = assets.divWadDown(liabilities);\n        }\n    }\n\n    /// @notice Get the underlying token's oracle data\n    /// @return tokenPrice The price of the underlying token\n    /// @return updatedAt The timestamp of last oracle update\n    function getOracleData() public view override returns (uint256 tokenPrice, uint256 updatedAt) {\n        (tokenPrice, updatedAt) = ISingularityOracle(ISingularityFactory(factory).oracle()).getLatestRound(token);\n        require(tokenPrice != 0, \"SingularityPool: INVALID_ORACLE_PRICE\");\n    }\n\n    /// @notice Calculates the equivalent USD value of given the number of tokens\n    /// @dev USD value is in 1e18\n    /// @param amount The amount of tokens to calculate the value of\n    /// @return value The USD value equivalent to the number of tokens\n    function getAmountToUSD(uint256 amount) public view override returns (uint256 value) {\n        if (amount == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        value = amount.mulWadDown(tokenPrice);\n        if (decimals > 18) {\n            value /= 10**(decimals - 18);\n        } else {\n            value *= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the equivalent number of tokens given the USD value\n    /// @dev USD value is in 1e18\n    /// @param value The USD value of tokens to calculate the amount of\n    /// @return amount The number of tokens equivalent to the USD value\n    function getUSDToAmount(uint256 value) public view override returns (uint256 amount) {\n        if (value == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        amount = value.divWadDown(tokenPrice);\n        if (decimals > 18) {\n            amount *= 10**(decimals - 18);\n        } else {\n            amount /= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the fee charged for deposit\n    /// @param amount The amount of tokens being deposited\n    /// @return fee The fee charged for deposit\n    function getDepositFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || liabilities == 0 || amount + assets <= liabilities) return 0;\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio < 1 ether) {\n            amountToPayFees = amount - (liabilities - assets);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets + amountToPayFees,\n            liabilities + amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities + amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        fee = feeA - feeB;\n        require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n    }\n\n    /// @notice Calculates the fee charged for withdraw\n    /// @param amount The amount of tokens being withdrawn\n    /// @return fee The fee charged for withdraw\n    function getWithdrawalFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || amount >= liabilities || assets >= liabilities + amount) {\n            return _getG(1 ether).mulWadUp(amount);\n        }\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio > 1 ether) {\n            amountToPayFees = amount - (assets - liabilities);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets > amountToPayFees ? assets - amountToPayFees : 0,\n            liabilities - amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities - amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        // check underflow\n        if (feeA > feeB) {\n            fee = feeA - feeB;\n            require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n        } else {\n            fee = 0;\n        }\n    }\n\n    /// @notice Calculates the slippage for swap in\n    /// @param amount The amount being swapped in\n    /// @return slippageIn The slippage for swap in\n    function getSlippageIn(uint256 amount) public view override returns (uint256 slippageIn) {\n        if (amount == 0) return 0;\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets + amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(currentCollateralizationRatio) - _getG(afterCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadDown(afterCollateralizationRatio - currentCollateralizationRatio);\n\n        // Calculate slippage\n        slippageIn = amount.mulWadDown(gPrime);\n    }\n\n    /// @notice Calculates the slippage for swap out\n    /// @param amount The amount being swapped out\n    /// @return slippageOut The slippage for swap out\n    function getSlippageOut(uint256 amount) public view override returns (uint256 slippageOut) {\n        if (amount == 0) return 0;\n        require(amount < assets, \"SingularityPool: AMOUNT_EXCEEDS_ASSETS\");\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets - amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(afterCollateralizationRatio) - _getG(currentCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadUp(currentCollateralizationRatio - afterCollateralizationRatio);\n\n        // Calculate slippage\n        slippageOut = amount.mulWadUp(gPrime);\n    }\n\n    /// @notice Calculates the trading fee rate for a swap\n    /// @dev Trading fee rate is in 1e18\n    /// @return tradingFeeRate The fee rate charged\n    function getTradingFeeRate() public view override returns (uint256 tradingFeeRate) {\n        if (isStablecoin) {\n            return baseFee;\n        } else {\n            (, uint256 updatedAt) = getOracleData();\n            uint256 oracleSens = ISingularityFactory(factory).oracleSens();\n            uint256 timeSinceUpdate = block.timestamp - updatedAt;\n            if (timeSinceUpdate * 10 > oracleSens * 11) {\n                // Case: 1.1 * oracleSens < timeSinceUpdate\n\n                tradingFeeRate = type(uint256).max; // Revert later to allow viewability\n            } else if (timeSinceUpdate >= oracleSens) {\n                // Case: oracleSens <= timeSinceUpdate <= 1.1 * oracleSens\n\n                tradingFeeRate = baseFee * 2;\n            } else {\n                // Case: timeSinceUpdate < oracleSens\n\n                tradingFeeRate = baseFee + (baseFee * timeSinceUpdate) / oracleSens;\n            }\n        }\n    }\n\n    /// @notice Calculates trading fees applied for `amount`\n    /// @dev Total Fee = Protocol Fee + LP Fee\n    /// @param amount The amount of tokens being withdrawn\n    /// @return totalFee The sum of all fees applied\n    /// @return protocolFee The fee awarded to the protocol\n    /// @return lpFee The fee awarded to LPs\n    function getTradingFees(uint256 amount)\n        public\n        view\n        override\n        returns (\n            uint256 totalFee,\n            uint256 protocolFee,\n            uint256 lpFee\n        )\n    {\n        if (amount == 0) return (0, 0, 0);\n\n        uint256 tradingFeeRate = getTradingFeeRate();\n        if (tradingFeeRate == type(uint256).max) {\n            return (type(uint256).max, type(uint256).max, type(uint256).max);\n        }\n        totalFee = amount.mulWadUp(tradingFeeRate);\n        uint256 protocolFeeShare = ISingularityFactory(factory).protocolFeeShare();\n        protocolFee = (totalFee * protocolFeeShare) / 100;\n        lpFee = totalFee - protocolFee;\n    }\n\n    /* ========== INTERNAL/PURE FUNCTIONS ========== */\n\n    ///\n    ///     g = 3.63 - 10 * collateralizationRatio   { colleralizationRatio < 0.35 }\n    ///\n    ///                     0.00003\n    ///     g = -------------------------------      { 0.35 <= collateralizationRatio < 1.5 }\n    ///          (collateralizationRatio) ^ 8\n    ///\n    ///     g = 0                                    { collateralizationRatio >= 1.5 }\n    ///\n    function _getG(uint256 collateralizationRatio) internal pure returns (uint256 g) {\n        if (collateralizationRatio < 0.35 ether) {\n            return 3.63 ether - 10 * collateralizationRatio;\n        }\n\n        // handle overflow when computing exponent\n        if (collateralizationRatio >= 1.5 ether) {\n            return 0;\n        }\n\n        uint256 numerator = 0.00003 ether;\n        uint256 denominator = collateralizationRatio.rpow(8, 1 ether);\n        g = numerator.divWadUp(denominator);\n    }\n\n    function _calcCollatalizationRatio(uint256 _assets, uint256 _liabilities)\n        internal\n        pure\n        returns (uint256 afterCollateralizationRatio)\n    {\n        if (_liabilities == 0) {\n            afterCollateralizationRatio = 1 ether;\n        } else {\n            afterCollateralizationRatio = _assets.divWadDown(_liabilities);\n        }\n    }\n\n    function _notPaused() internal view {\n        require(!paused, \"SingularityPool: PAUSED\");\n    }\n\n    function _onlyFactory() internal view {\n        require(msg.sender == factory, \"SingularityPool: NOT_FACTORY\");\n    }\n\n    function _onlyRouter() internal view {\n        require(msg.sender == ISingularityFactory(factory).router(), \"SingularityPool: NOT_ROUTER\");\n    }\n\n    /* ========== FACTORY FUNCTIONS ========== */\n\n    function collectFees(address feeTo) external override {\n        _onlyFactory();\n\n        if (protocolFees == 0) return;\n\n        IERC20(token).safeTransfer(feeTo, protocolFees);\n        protocolFees = 0;\n\n        emit CollectFees(protocolFees);\n    }\n\n    function setDepositCap(uint256 newDepositCap) external override {\n        _onlyFactory();\n\n        emit SetDepositCap(depositCap, newDepositCap);\n        depositCap = newDepositCap;\n    }\n\n    function setBaseFee(uint256 newBaseFee) external override {\n        _onlyFactory();\n\n        emit SetBaseFee(baseFee, newBaseFee);\n        baseFee = newBaseFee;\n    }\n\n    function setPaused(bool state) external override {\n        _onlyFactory();\n\n        emit SetPaused(paused, state);\n        paused = state;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.15;\n\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface ISingularityPoolToken {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n/**\n * @title Singularity Pool Token\n * @author Revenant Labs\n * @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n */\nabstract contract SingularityPoolToken is ISingularityPoolToken {\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    uint256 internal INITIAL_CHAIN_ID;\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public override nonces;\n\n    function _initialize() internal {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        allowance[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        balanceOf[msg.sender] -= value;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - value;\n\n        balanceOf[from] -= value;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override {\n        require(deadline >= block.timestamp, \"SingularityPoolToken: EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                            ),\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"SingularityPoolToken: INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply += value;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] -= value;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\n\ninterface ISingularityPool is ISingularityPoolToken {\n    event Deposit(address indexed sender, uint256 indexed amountDeposited, uint256 mintAmount, address indexed to);\n    event Withdraw(address indexed sender, uint256 indexed amountBurned, uint256 withdrawalAmount, address indexed to);\n    event SwapIn(address indexed sender, uint256 amountIn, uint256 amountOut);\n    event SwapOut(address indexed sender, uint256 amountIn, uint256 amountOut, address indexed to);\n    event CollectFees(uint256 protocolFees);\n    event SetDepositCap(uint256 oldValue, uint256 newValue);\n    event SetBaseFee(uint256 oldValue, uint256 newValue);\n    event SetPaused(bool oldState, bool newState);\n\n    function paused() external view returns (bool);\n\n    function isStablecoin() external view returns (bool);\n\n    function factory() external view returns (address);\n\n    function token() external view returns (address);\n\n    function depositCap() external view returns (uint256);\n\n    function assets() external view returns (uint256);\n\n    function liabilities() external view returns (uint256);\n\n    function protocolFees() external view returns (uint256);\n\n    function baseFee() external view returns (uint256);\n\n    function deposit(uint256 amount, address to) external returns (uint256);\n\n    function withdraw(uint256 lpAmount, address to) external returns (uint256);\n\n    function swapIn(uint256 amountIn) external returns (uint256);\n\n    function swapOut(uint256 amountIn, address to) external returns (uint256);\n\n    function getPricePerShare() external view returns (uint256);\n\n    function getCollateralizationRatio() external view returns (uint256);\n\n    function getOracleData() external view returns (uint256, uint256);\n\n    function getAmountToUSD(uint256 amount) external view returns (uint256);\n\n    function getUSDToAmount(uint256 value) external view returns (uint256);\n\n    function getDepositFee(uint256 amount) external view returns (uint256);\n\n    function getWithdrawalFee(uint256 amount) external view returns (uint256);\n\n    function getSlippageIn(uint256 amount) external view returns (uint256);\n\n    function getSlippageOut(uint256 amount) external view returns (uint256);\n\n    function getTradingFeeRate() external view returns (uint256 tradingFeeRate);\n\n    function getTradingFees(uint256 amount)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function collectFees(address feeTo) external;\n\n    function setDepositCap(uint256 newDepositCap) external;\n\n    function setBaseFee(uint256 newBaseFee) external;\n\n    function setPaused(bool state) external;\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface ISingularityFactory {\n    struct PoolParams {\n        address factory;\n        address token;\n        bool isStablecoin;\n        uint256 baseFee;\n    }\n\n    event PoolCreated(address indexed token, bool isStablecoin, uint256 baseFee, address pool, uint256 index);\n\n    function tranche() external view returns (string memory);\n\n    function admin() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function feeTo() external view returns (address);\n\n    function router() external view returns (address);\n\n    function protocolFeeShare() external view returns (uint256);\n\n    function oracleSens() external view returns (uint256);\n\n    function poolParams()\n        external\n        view\n        returns (\n            address factory,\n            address token,\n            bool isStablecoin,\n            uint256 baseFee\n        );\n\n    function getPool(address token) external view returns (address pool);\n\n    function allPools(uint256) external view returns (address pool);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function poolCodeHash() external pure returns (bytes32);\n\n    function createPool(\n        address token,\n        bool isStablecoin,\n        uint256 baseFee\n    ) external returns (address pool);\n\n    function setAdmin(address _admin) external;\n\n    function setOracle(address _oracle) external;\n\n    function setFeeTo(address _feeTo) external;\n\n    function setRouter(address _router) external;\n\n    function setProtocolFeeShare(uint256 _protocolFeeShare) external;\n\n    function setOracleSens(uint256 _oracleSens) external;\n\n    function collectFees(address[] calldata tokens) external;\n\n    function setDepositCaps(address[] calldata tokens, uint256[] calldata caps) external;\n\n    function setBaseFees(address[] calldata tokens, uint256[] calldata baseFees) external;\n\n    function setPaused(address[] calldata tokens, bool[] calldata states) external;\n\n    function setPausedForAll(bool state) external;\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface ISingularityOracle {\n    function getLatestRound(address token) external view returns (uint256, uint256);\n\n    function getLatestRounds(address[] calldata tokens) external view returns (uint256[] memory, uint256[] memory);\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*///////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z)\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z)\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z)\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n\n/**\n * @title Singularity Pool\n * @author Revenant Labs\n */\ncontract SingularityPool is ISingularityPool, SingularityPoolToken, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    bool public override paused;\n    bool public immutable override isStablecoin;\n    address public immutable override factory;\n    address public immutable override token;\n    uint256 public override depositCap;\n    uint256 public override assets;\n    uint256 public override liabilities;\n    uint256 public override baseFee;\n    uint256 public override protocolFees;\n\n    constructor() {\n        (factory, token, isStablecoin, baseFee) = ISingularityFactory(msg.sender).poolParams();\n        string memory tranche = ISingularityFactory(factory).tranche();\n        string memory tokenSymbol = IERC20(token).symbol();\n        name = string(abi.encodePacked(\"Singularity Pool Token-\", tokenSymbol, \" (\", tranche, \")\"));\n        symbol = string(abi.encodePacked(\"SPT-\", tokenSymbol, \" (\", tranche, \")\"));\n        decimals = IERC20(token).decimals();\n        _initialize();\n    }\n\n    /// @notice Deposit underlying tokens to LP\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param amount The amount of underlying tokens to deposit\n    /// @param to The address to mint LP tokens to\n    /// @return mintAmount The amount of LP tokens minted\n    function deposit(uint256 amount, address to) external override nonReentrant returns (uint256 mintAmount) {\n        _notPaused();\n        require(amount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Transfer token from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        if (liabilities == 0) {\n            mintAmount = amount;\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amount;\n            liabilities += amount;\n        } else {\n            // Apply deposit fee\n            uint256 depositFee = getDepositFee(amount);\n            protocolFees += depositFee;\n            uint256 amountPostFee = amount - depositFee;\n\n            // Calculate amount of LP tokens to mint\n            mintAmount = amountPostFee.divWadDown(getPricePerShare());\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amountPostFee;\n            liabilities += amountPostFee;\n        }\n\n        require(liabilities <= depositCap, \"SingularityPool: DEPOSIT_EXCEEDS_CAP\");\n\n        emit Deposit(msg.sender, amount, mintAmount, to);\n    }\n\n    /// @notice Withdraw underlying tokens through burning LP tokens\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param lpAmount The amount of LP tokens to burn\n    /// @param to The address to redeem underlying tokens to\n    /// @return withdrawalAmount The amount of underlying tokens withdrawn\n    function withdraw(uint256 lpAmount, address to) external override nonReentrant returns (uint256 withdrawalAmount) {\n        _notPaused();\n        require(lpAmount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Store current price-per-share\n        uint256 pricePerShare = getPricePerShare();\n\n        // Burn LP tokens\n        _burn(msg.sender, lpAmount);\n\n        // Calculate amount of underlying tokens to redeem\n        uint256 amount = lpAmount.mulWadDown(pricePerShare);\n\n        // Apply withdrawal fee\n        uint256 withdrawalFee = getWithdrawalFee(amount);\n        protocolFees += withdrawalFee;\n        withdrawalAmount = amount - withdrawalFee;\n\n        // Transfer tokens to `to`\n        IERC20(token).safeTransfer(to, withdrawalAmount);\n\n        // Update assets and liabilities\n        assets -= amount;\n        liabilities -= amount;\n\n        emit Withdraw(msg.sender, lpAmount, withdrawalAmount, to);\n    }\n\n    /// @notice Swap tokens in\n    /// @dev Slippage is positive (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @return amountOut The USD value of the swap in (post fees)\n    function swapIn(uint256 amountIn) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Apply slippage (+)\n        uint256 amountPostSlippage = amountIn + getSlippageIn(amountIn);\n\n        // Transfer tokens from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        // Update assets\n        assets += amountIn;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        uint256 amountPostFee = amountPostSlippage - totalFee;\n\n        // Convert amount to USD value\n        amountOut = getAmountToUSD(amountPostFee);\n\n        emit SwapIn(msg.sender, amountIn, amountOut);\n    }\n\n    /// @notice Swap tokens out\n    /// @dev Slippage is negative (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @param to The address to send tokens to\n    /// @return amountOut The amount of tokens being swapped out\n    function swapOut(uint256 amountIn, address to) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Convert USD value to amount\n        uint256 amount = getUSDToAmount(amountIn);\n\n        // Apply slippage (-)\n        uint256 slippage = getSlippageOut(amount);\n        require(amount > slippage, \"SingularityPool: SLIPPAPGE_EXCEEDS_AMOUNT\");\n        uint256 amountPostSlippage = amount - slippage;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        amountOut = amountPostSlippage - totalFee;\n\n        // Transfer tokens out\n        IERC20(token).safeTransfer(to, amountOut);\n\n        // Update assets\n        assets -= amountOut;\n\n        emit SwapOut(msg.sender, amountIn, amountOut, to);\n    }\n\n    /// @notice Calculates the price-per-share (PPS)\n    /// @dev PPS = 1 when pool is empty\n    /// @dev PPS is strictly increasing >= 1\n    /// @return pricePerShare The PPS of 1 LP token\n    function getPricePerShare() public view override returns (uint256 pricePerShare) {\n        if (totalSupply == 0) {\n            pricePerShare = 1 ether;\n        } else {\n            pricePerShare = liabilities.divWadDown(totalSupply);\n        }\n    }\n\n    /// @notice Get pool's collateralization ratio\n    /// @dev Collateralization ratio is 1 if pool not seeded\n    /// @return collateralizationRatio The collateralization ratio of the pool\n    function getCollateralizationRatio() public view override returns (uint256 collateralizationRatio) {\n        if (liabilities == 0) {\n            collateralizationRatio = 1 ether;\n        } else {\n            collateralizationRatio = assets.divWadDown(liabilities);\n        }\n    }\n\n    /// @notice Get the underlying token's oracle data\n    /// @return tokenPrice The price of the underlying token\n    /// @return updatedAt The timestamp of last oracle update\n    function getOracleData() public view override returns (uint256 tokenPrice, uint256 updatedAt) {\n        (tokenPrice, updatedAt) = ISingularityOracle(ISingularityFactory(factory).oracle()).getLatestRound(token);\n        require(tokenPrice != 0, \"SingularityPool: INVALID_ORACLE_PRICE\");\n    }\n\n    /// @notice Calculates the equivalent USD value of given the number of tokens\n    /// @dev USD value is in 1e18\n    /// @param amount The amount of tokens to calculate the value of\n    /// @return value The USD value equivalent to the number of tokens\n    function getAmountToUSD(uint256 amount) public view override returns (uint256 value) {\n        if (amount == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        value = amount.mulWadDown(tokenPrice);\n        if (decimals > 18) {\n            value /= 10**(decimals - 18);\n        } else {\n            value *= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the equivalent number of tokens given the USD value\n    /// @dev USD value is in 1e18\n    /// @param value The USD value of tokens to calculate the amount of\n    /// @return amount The number of tokens equivalent to the USD value\n    function getUSDToAmount(uint256 value) public view override returns (uint256 amount) {\n        if (value == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        amount = value.divWadDown(tokenPrice);\n        if (decimals > 18) {\n            amount *= 10**(decimals - 18);\n        } else {\n            amount /= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the fee charged for deposit\n    /// @param amount The amount of tokens being deposited\n    /// @return fee The fee charged for deposit\n    function getDepositFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || liabilities == 0 || amount + assets <= liabilities) return 0;\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio < 1 ether) {\n            amountToPayFees = amount - (liabilities - assets);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets + amountToPayFees,\n            liabilities + amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities + amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        fee = feeA - feeB;\n        require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n    }\n\n    /// @notice Calculates the fee charged for withdraw\n    /// @param amount The amount of tokens being withdrawn\n    /// @return fee The fee charged for withdraw\n    function getWithdrawalFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || amount >= liabilities || assets >= liabilities + amount) {\n            return _getG(1 ether).mulWadUp(amount);\n        }\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio > 1 ether) {\n            amountToPayFees = amount - (assets - liabilities);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets > amountToPayFees ? assets - amountToPayFees : 0,\n            liabilities - amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities - amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        // check underflow\n        if (feeA > feeB) {\n            fee = feeA - feeB;\n            require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n        } else {\n            fee = 0;\n        }\n    }\n\n    /// @notice Calculates the slippage for swap in\n    /// @param amount The amount being swapped in\n    /// @return slippageIn The slippage for swap in\n    function getSlippageIn(uint256 amount) public view override returns (uint256 slippageIn) {\n        if (amount == 0) return 0;\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets + amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(currentCollateralizationRatio) - _getG(afterCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadDown(afterCollateralizationRatio - currentCollateralizationRatio);\n\n        // Calculate slippage\n        slippageIn = amount.mulWadDown(gPrime);\n    }\n\n    /// @notice Calculates the slippage for swap out\n    /// @param amount The amount being swapped out\n    /// @return slippageOut The slippage for swap out\n    function getSlippageOut(uint256 amount) public view override returns (uint256 slippageOut) {\n        if (amount == 0) return 0;\n        require(amount < assets, \"SingularityPool: AMOUNT_EXCEEDS_ASSETS\");\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets - amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(afterCollateralizationRatio) - _getG(currentCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadUp(currentCollateralizationRatio - afterCollateralizationRatio);\n\n        // Calculate slippage\n        slippageOut = amount.mulWadUp(gPrime);\n    }\n\n    /// @notice Calculates the trading fee rate for a swap\n    /// @dev Trading fee rate is in 1e18\n    /// @return tradingFeeRate The fee rate charged\n    function getTradingFeeRate() public view override returns (uint256 tradingFeeRate) {\n        if (isStablecoin) {\n            return baseFee;\n        } else {\n            (, uint256 updatedAt) = getOracleData();\n            uint256 oracleSens = ISingularityFactory(factory).oracleSens();\n            uint256 timeSinceUpdate = block.timestamp - updatedAt;\n            if (timeSinceUpdate * 10 > oracleSens * 11) {\n                // Case: 1.1 * oracleSens < timeSinceUpdate\n\n                tradingFeeRate = type(uint256).max; // Revert later to allow viewability\n            } else if (timeSinceUpdate >= oracleSens) {\n                // Case: oracleSens <= timeSinceUpdate <= 1.1 * oracleSens\n\n                tradingFeeRate = baseFee * 2;\n            } else {\n                // Case: timeSinceUpdate < oracleSens\n\n                tradingFeeRate = baseFee + (baseFee * timeSinceUpdate) / oracleSens;\n            }\n        }\n    }\n\n    /// @notice Calculates trading fees applied for `amount`\n    /// @dev Total Fee = Protocol Fee + LP Fee\n    /// @param amount The amount of tokens being withdrawn\n    /// @return totalFee The sum of all fees applied\n    /// @return protocolFee The fee awarded to the protocol\n    /// @return lpFee The fee awarded to LPs\n    function getTradingFees(uint256 amount)\n        public\n        view\n        override\n        returns (\n            uint256 totalFee,\n            uint256 protocolFee,\n            uint256 lpFee\n        )\n    {\n        if (amount == 0) return (0, 0, 0);\n\n        uint256 tradingFeeRate = getTradingFeeRate();\n        if (tradingFeeRate == type(uint256).max) {\n            return (type(uint256).max, type(uint256).max, type(uint256).max);\n        }\n        totalFee = amount.mulWadUp(tradingFeeRate);\n        uint256 protocolFeeShare = ISingularityFactory(factory).protocolFeeShare();\n        protocolFee = (totalFee * protocolFeeShare) / 100;\n        lpFee = totalFee - protocolFee;\n    }\n\n    /* ========== INTERNAL/PURE FUNCTIONS ========== */\n\n    ///\n    ///     g = 3.63 - 10 * collateralizationRatio   { colleralizationRatio < 0.35 }\n    ///\n    ///                     0.00003\n    ///     g = -------------------------------      { 0.35 <= collateralizationRatio < 1.5 }\n    ///          (collateralizationRatio) ^ 8\n    ///\n    ///     g = 0                                    { collateralizationRatio >= 1.5 }\n    ///\n    function _getG(uint256 collateralizationRatio) internal pure returns (uint256 g) {\n        if (collateralizationRatio < 0.35 ether) {\n            return 3.63 ether - 10 * collateralizationRatio;\n        }\n\n        // handle overflow when computing exponent\n        if (collateralizationRatio >= 1.5 ether) {\n            return 0;\n        }\n\n        uint256 numerator = 0.00003 ether;\n        uint256 denominator = collateralizationRatio.rpow(8, 1 ether);\n        g = numerator.divWadUp(denominator);\n    }\n\n    function _calcCollatalizationRatio(uint256 _assets, uint256 _liabilities)\n        internal\n        pure\n        returns (uint256 afterCollateralizationRatio)\n    {\n        if (_liabilities == 0) {\n            afterCollateralizationRatio = 1 ether;\n        } else {\n            afterCollateralizationRatio = _assets.divWadDown(_liabilities);\n        }\n    }\n\n    function _notPaused() internal view {\n        require(!paused, \"SingularityPool: PAUSED\");\n    }\n\n    function _onlyFactory() internal view {\n        require(msg.sender == factory, \"SingularityPool: NOT_FACTORY\");\n    }\n\n    function _onlyRouter() internal view {\n        require(msg.sender == ISingularityFactory(factory).router(), \"SingularityPool: NOT_ROUTER\");\n    }\n\n    /* ========== FACTORY FUNCTIONS ========== */\n\n    function collectFees(address feeTo) external override {\n        _onlyFactory();\n\n        if (protocolFees == 0) return;\n\n        IERC20(token).safeTransfer(feeTo, protocolFees);\n        protocolFees = 0;\n\n        emit CollectFees(protocolFees);\n    }\n\n    function setDepositCap(uint256 newDepositCap) external override {\n        _onlyFactory();\n\n        emit SetDepositCap(depositCap, newDepositCap);\n        depositCap = newDepositCap;\n    }\n\n    function setBaseFee(uint256 newBaseFee) external override {\n        _onlyFactory();\n\n        emit SetBaseFee(baseFee, newBaseFee);\n        baseFee = newBaseFee;\n    }\n\n    function setPaused(bool state) external override {\n        _onlyFactory();\n\n        emit SetPaused(paused, state);\n        paused = state;\n    }\n}\n", "commit_id": "6cf215b6739f51a6192f732c61e16834487eab1c"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: No License\n\npragma solidity ^0.8.15;\n\nimport \"./SingularityPoolToken.sol\";\nimport \"./interfaces/ISingularityPool.sol\";\nimport \"./interfaces/ISingularityFactory.sol\";\nimport \"./interfaces/ISingularityOracle.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./utils/SafeERC20.sol\";\nimport \"./utils/FixedPointMathLib.sol\";\nimport \"./utils/ReentrancyGuard.sol\";\n\n/**\n * @title Singularity Pool\n * @author Revenant Labs\n */\ncontract SingularityPool is ISingularityPool, SingularityPoolToken, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    bool public override paused;\n    bool public immutable override isStablecoin;\n    address public immutable override factory;\n    address public immutable override token;\n    uint256 public override depositCap;\n    uint256 public override assets;\n    uint256 public override liabilities;\n    uint256 public override baseFee;\n    uint256 public override protocolFees;\n\n    constructor() {\n        (factory, token, isStablecoin, baseFee) = ISingularityFactory(msg.sender).poolParams();\n        string memory tranche = ISingularityFactory(factory).tranche();\n        string memory tokenSymbol = IERC20(token).symbol();\n        name = string(abi.encodePacked(\"Singularity Pool Token-\", tokenSymbol, \" (\", tranche, \")\"));\n        symbol = string(abi.encodePacked(\"SPT-\", tokenSymbol, \" (\", tranche, \")\"));\n        decimals = IERC20(token).decimals();\n        _initialize();\n    }\n\n    /// @notice Deposit underlying tokens to LP\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param amount The amount of underlying tokens to deposit\n    /// @param to The address to mint LP tokens to\n    /// @return mintAmount The amount of LP tokens minted\n    function deposit(uint256 amount, address to) external override nonReentrant returns (uint256 mintAmount) {\n        _notPaused();\n        require(amount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Transfer token from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        if (liabilities == 0) {\n            mintAmount = amount;\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amount;\n            liabilities += amount;\n        } else {\n            // Apply deposit fee\n            uint256 depositFee = getDepositFee(amount);\n            protocolFees += depositFee;\n            uint256 amountPostFee = amount - depositFee;\n\n            // Calculate amount of LP tokens to mint\n            mintAmount = amountPostFee.divWadDown(getPricePerShare());\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amountPostFee;\n            liabilities += amountPostFee;\n        }\n\n        require(liabilities <= depositCap, \"SingularityPool: DEPOSIT_EXCEEDS_CAP\");\n\n        emit Deposit(msg.sender, amount, mintAmount, to);\n    }\n\n    /// @notice Withdraw underlying tokens through burning LP tokens\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param lpAmount The amount of LP tokens to burn\n    /// @param to The address to redeem underlying tokens to\n    /// @return withdrawalAmount The amount of underlying tokens withdrawn\n    function withdraw(uint256 lpAmount, address to) external override nonReentrant returns (uint256 withdrawalAmount) {\n        _notPaused();\n        require(lpAmount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Store current price-per-share\n        uint256 pricePerShare = getPricePerShare();\n\n        // Burn LP tokens\n        _burn(msg.sender, lpAmount);\n\n        // Calculate amount of underlying tokens to redeem\n        uint256 amount = lpAmount.mulWadDown(pricePerShare);\n\n        // Apply withdrawal fee\n        uint256 withdrawalFee = getWithdrawalFee(amount);\n        protocolFees += withdrawalFee;\n        withdrawalAmount = amount - withdrawalFee;\n\n        // Transfer tokens to `to`\n        IERC20(token).safeTransfer(to, withdrawalAmount);\n\n        // Update assets and liabilities\n        assets -= amount;\n        liabilities -= amount;\n\n        emit Withdraw(msg.sender, lpAmount, withdrawalAmount, to);\n    }\n\n    /// @notice Swap tokens in\n    /// @dev Slippage is positive (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @return amountOut The USD value of the swap in (post fees)\n    function swapIn(uint256 amountIn) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Apply slippage (+)\n        uint256 amountPostSlippage = amountIn + getSlippageIn(amountIn);\n\n        // Transfer tokens from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        // Update assets\n        assets += amountIn;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        uint256 amountPostFee = amountPostSlippage - totalFee;\n\n        // Convert amount to USD value\n        amountOut = getAmountToUSD(amountPostFee);\n\n        emit SwapIn(msg.sender, amountIn, amountOut);\n    }\n\n    /// @notice Swap tokens out\n    /// @dev Slippage is negative (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @param to The address to send tokens to\n    /// @return amountOut The amount of tokens being swapped out\n    function swapOut(uint256 amountIn, address to) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Convert USD value to amount\n        uint256 amount = getUSDToAmount(amountIn);\n\n        // Apply slippage (-)\n        uint256 slippage = getSlippageOut(amount);\n        require(amount > slippage, \"SingularityPool: SLIPPAPGE_EXCEEDS_AMOUNT\");\n        uint256 amountPostSlippage = amount - slippage;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        amountOut = amountPostSlippage - totalFee;\n\n        // Transfer tokens out\n        IERC20(token).safeTransfer(to, amountOut);\n\n        // Update assets\n        assets -= amountOut;\n\n        emit SwapOut(msg.sender, amountIn, amountOut, to);\n    }\n\n    /// @notice Calculates the price-per-share (PPS)\n    /// @dev PPS = 1 when pool is empty\n    /// @dev PPS is strictly increasing >= 1\n    /// @return pricePerShare The PPS of 1 LP token\n    function getPricePerShare() public view override returns (uint256 pricePerShare) {\n        if (totalSupply == 0) {\n            pricePerShare = 1 ether;\n        } else {\n            pricePerShare = liabilities.divWadDown(totalSupply);\n        }\n    }\n\n    /// @notice Get pool's collateralization ratio\n    /// @dev Collateralization ratio is 1 if pool not seeded\n    /// @return collateralizationRatio The collateralization ratio of the pool\n    function getCollateralizationRatio() public view override returns (uint256 collateralizationRatio) {\n        if (liabilities == 0) {\n            collateralizationRatio = 1 ether;\n        } else {\n            collateralizationRatio = assets.divWadDown(liabilities);\n        }\n    }\n\n    /// @notice Get the underlying token's oracle data\n    /// @return tokenPrice The price of the underlying token\n    /// @return updatedAt The timestamp of last oracle update\n    function getOracleData() public view override returns (uint256 tokenPrice, uint256 updatedAt) {\n        (tokenPrice, updatedAt) = ISingularityOracle(ISingularityFactory(factory).oracle()).getLatestRound(token);\n        require(tokenPrice != 0, \"SingularityPool: INVALID_ORACLE_PRICE\");\n    }\n\n    /// @notice Calculates the equivalent USD value of given the number of tokens\n    /// @dev USD value is in 1e18\n    /// @param amount The amount of tokens to calculate the value of\n    /// @return value The USD value equivalent to the number of tokens\n    function getAmountToUSD(uint256 amount) public view override returns (uint256 value) {\n        if (amount == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        value = amount.mulWadDown(tokenPrice);\n        if (decimals > 18) {\n            value /= 10**(decimals - 18);\n        } else {\n            value *= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the equivalent number of tokens given the USD value\n    /// @dev USD value is in 1e18\n    /// @param value The USD value of tokens to calculate the amount of\n    /// @return amount The number of tokens equivalent to the USD value\n    function getUSDToAmount(uint256 value) public view override returns (uint256 amount) {\n        if (value == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        amount = value.divWadDown(tokenPrice);\n        if (decimals > 18) {\n            amount *= 10**(decimals - 18);\n        } else {\n            amount /= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the fee charged for deposit\n    /// @param amount The amount of tokens being deposited\n    /// @return fee The fee charged for deposit\n    function getDepositFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || liabilities == 0 || amount + assets <= liabilities) return 0;\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio < 1 ether) {\n            amountToPayFees = amount - (liabilities - assets);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets + amountToPayFees,\n            liabilities + amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities + amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        fee = feeA - feeB;\n        require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n    }\n\n    /// @notice Calculates the fee charged for withdraw\n    /// @param amount The amount of tokens being withdrawn\n    /// @return fee The fee charged for withdraw\n    function getWithdrawalFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || amount >= liabilities || assets >= liabilities + amount) {\n            return _getG(1 ether).mulWadUp(amount);\n        }\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio > 1 ether) {\n            amountToPayFees = amount - (assets - liabilities);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets > amountToPayFees ? assets - amountToPayFees : 0,\n            liabilities - amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities - amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        // check underflow\n        if (feeA > feeB) {\n            fee = feeA - feeB;\n            require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n        } else {\n            fee = 0;\n        }\n    }\n\n    /// @notice Calculates the slippage for swap in\n    /// @param amount The amount being swapped in\n    /// @return slippageIn The slippage for swap in\n    function getSlippageIn(uint256 amount) public view override returns (uint256 slippageIn) {\n        if (amount == 0) return 0;\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets + amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(currentCollateralizationRatio) - _getG(afterCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadDown(afterCollateralizationRatio - currentCollateralizationRatio);\n\n        // Calculate slippage\n        slippageIn = amount.mulWadDown(gPrime);\n    }\n\n    /// @notice Calculates the slippage for swap out\n    /// @param amount The amount being swapped out\n    /// @return slippageOut The slippage for swap out\n    function getSlippageOut(uint256 amount) public view override returns (uint256 slippageOut) {\n        if (amount == 0) return 0;\n        require(amount < assets, \"SingularityPool: AMOUNT_EXCEEDS_ASSETS\");\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets - amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(afterCollateralizationRatio) - _getG(currentCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadUp(currentCollateralizationRatio - afterCollateralizationRatio);\n\n        // Calculate slippage\n        slippageOut = amount.mulWadUp(gPrime);\n    }\n\n    /// @notice Calculates the trading fee rate for a swap\n    /// @dev Trading fee rate is in 1e18\n    /// @return tradingFeeRate The fee rate charged\n    function getTradingFeeRate() public view override returns (uint256 tradingFeeRate) {\n        if (isStablecoin) {\n            return baseFee;\n        } else {\n            (, uint256 updatedAt) = getOracleData();\n            uint256 oracleSens = ISingularityFactory(factory).oracleSens();\n            uint256 timeSinceUpdate = block.timestamp - updatedAt;\n            if (timeSinceUpdate * 10 > oracleSens * 11) {\n                // Case: 1.1 * oracleSens < timeSinceUpdate\n\n                tradingFeeRate = type(uint256).max; // Revert later to allow viewability\n            } else if (timeSinceUpdate >= oracleSens) {\n                // Case: oracleSens <= timeSinceUpdate <= 1.1 * oracleSens\n\n                tradingFeeRate = baseFee * 2;\n            } else {\n                // Case: timeSinceUpdate < oracleSens\n\n                tradingFeeRate = baseFee + (baseFee * timeSinceUpdate) / oracleSens;\n            }\n        }\n    }\n\n    /// @notice Calculates trading fees applied for `amount`\n    /// @dev Total Fee = Protocol Fee + LP Fee\n    /// @param amount The amount of tokens being withdrawn\n    /// @return totalFee The sum of all fees applied\n    /// @return protocolFee The fee awarded to the protocol\n    /// @return lpFee The fee awarded to LPs\n    function getTradingFees(uint256 amount)\n        public\n        view\n        override\n        returns (\n            uint256 totalFee,\n            uint256 protocolFee,\n            uint256 lpFee\n        )\n    {\n        if (amount == 0) return (0, 0, 0);\n\n        uint256 tradingFeeRate = getTradingFeeRate();\n        if (tradingFeeRate == type(uint256).max) {\n            return (type(uint256).max, type(uint256).max, type(uint256).max);\n        }\n        totalFee = amount.mulWadUp(tradingFeeRate);\n        uint256 protocolFeeShare = ISingularityFactory(factory).protocolFeeShare();\n        protocolFee = (totalFee * protocolFeeShare) / 100;\n        lpFee = totalFee - protocolFee;\n    }\n\n    /* ========== INTERNAL/PURE FUNCTIONS ========== */\n\n    ///\n    ///     g = 3.63 - 10 * collateralizationRatio   { colleralizationRatio < 0.35 }\n    ///\n    ///                     0.00003\n    ///     g = -------------------------------      { 0.35 <= collateralizationRatio < 1.5 }\n    ///          (collateralizationRatio) ^ 8\n    ///\n    ///     g = 0                                    { collateralizationRatio >= 1.5 }\n    ///\n    function _getG(uint256 collateralizationRatio) internal pure returns (uint256 g) {\n        if (collateralizationRatio < 0.35 ether) {\n            return 3.63 ether - 10 * collateralizationRatio;\n        }\n\n        // handle overflow when computing exponent\n        if (collateralizationRatio >= 1.5 ether) {\n            return 0;\n        }\n\n        uint256 numerator = 0.00003 ether;\n        uint256 denominator = collateralizationRatio.rpow(8, 1 ether);\n        g = numerator.divWadUp(denominator);\n    }\n\n    function _calcCollatalizationRatio(uint256 _assets, uint256 _liabilities)\n        internal\n        pure\n        returns (uint256 afterCollateralizationRatio)\n    {\n        if (_liabilities == 0) {\n            afterCollateralizationRatio = 1 ether;\n        } else {\n            afterCollateralizationRatio = _assets.divWadDown(_liabilities);\n        }\n    }\n\n    function _notPaused() internal view {\n        require(!paused, \"SingularityPool: PAUSED\");\n    }\n\n    function _onlyFactory() internal view {\n        require(msg.sender == factory, \"SingularityPool: NOT_FACTORY\");\n    }\n\n    function _onlyRouter() internal view {\n        require(msg.sender == ISingularityFactory(factory).router(), \"SingularityPool: NOT_ROUTER\");\n    }\n\n    /* ========== FACTORY FUNCTIONS ========== */\n\n    function collectFees(address feeTo) external override {\n        _onlyFactory();\n\n        if (protocolFees == 0) return;\n\n        uint256 protocolFeesToTransfer = protocolFees;\n        protocolFees = 0;\n\n        IERC20(token).safeTransfer(feeTo, protocolFeesToTransfer);\n\n        emit CollectFees(protocolFeesToTransfer);\n    }\n\n    function setDepositCap(uint256 newDepositCap) external override {\n        _onlyFactory();\n\n        emit SetDepositCap(depositCap, newDepositCap);\n        depositCap = newDepositCap;\n    }\n\n    function setBaseFee(uint256 newBaseFee) external override {\n        _onlyFactory();\n\n        emit SetBaseFee(baseFee, newBaseFee);\n        baseFee = newBaseFee;\n    }\n\n    function setPaused(bool state) external override {\n        _onlyFactory();\n\n        emit SetPaused(paused, state);\n        paused = state;\n    }\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\n\npragma solidity ^0.8.15;\n\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface ISingularityPoolToken {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n/**\n * @title Singularity Pool Token\n * @author Revenant Labs\n * @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\n */\nabstract contract SingularityPoolToken is ISingularityPoolToken {\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n\n    uint256 public override totalSupply;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    uint256 internal INITIAL_CHAIN_ID;\n    bytes32 internal INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public override nonces;\n\n    function _initialize() internal {\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        allowance[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 value) external override returns (bool) {\n        balanceOf[msg.sender] -= value;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external override returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - value;\n\n        balanceOf[from] -= value;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public override {\n        require(deadline >= block.timestamp, \"SingularityPoolToken: EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            bytes32 digest = keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR(),\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                            ),\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(\n                recoveredAddress != address(0) && recoveredAddress == owner,\n                \"SingularityPoolToken: INVALID_SIGNER\"\n            );\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    function _mint(address to, uint256 value) internal {\n        totalSupply += value;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint256 value) internal {\n        balanceOf[from] -= value;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\n\ninterface ISingularityPool is ISingularityPoolToken {\n    event Deposit(address indexed sender, uint256 indexed amountDeposited, uint256 mintAmount, address indexed to);\n    event Withdraw(address indexed sender, uint256 indexed amountBurned, uint256 withdrawalAmount, address indexed to);\n    event SwapIn(address indexed sender, uint256 amountIn, uint256 amountOut);\n    event SwapOut(address indexed sender, uint256 amountIn, uint256 amountOut, address indexed to);\n    event CollectFees(uint256 protocolFees);\n    event SetDepositCap(uint256 oldValue, uint256 newValue);\n    event SetBaseFee(uint256 oldValue, uint256 newValue);\n    event SetPaused(bool oldState, bool newState);\n\n    function paused() external view returns (bool);\n\n    function isStablecoin() external view returns (bool);\n\n    function factory() external view returns (address);\n\n    function token() external view returns (address);\n\n    function depositCap() external view returns (uint256);\n\n    function assets() external view returns (uint256);\n\n    function liabilities() external view returns (uint256);\n\n    function protocolFees() external view returns (uint256);\n\n    function baseFee() external view returns (uint256);\n\n    function deposit(uint256 amount, address to) external returns (uint256);\n\n    function withdraw(uint256 lpAmount, address to) external returns (uint256);\n\n    function swapIn(uint256 amountIn) external returns (uint256);\n\n    function swapOut(uint256 amountIn, address to) external returns (uint256);\n\n    function getPricePerShare() external view returns (uint256);\n\n    function getCollateralizationRatio() external view returns (uint256);\n\n    function getOracleData() external view returns (uint256, uint256);\n\n    function getAmountToUSD(uint256 amount) external view returns (uint256);\n\n    function getUSDToAmount(uint256 value) external view returns (uint256);\n\n    function getDepositFee(uint256 amount) external view returns (uint256);\n\n    function getWithdrawalFee(uint256 amount) external view returns (uint256);\n\n    function getSlippageIn(uint256 amount) external view returns (uint256);\n\n    function getSlippageOut(uint256 amount) external view returns (uint256);\n\n    function getTradingFeeRate() external view returns (uint256 tradingFeeRate);\n\n    function getTradingFees(uint256 amount)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function collectFees(address feeTo) external;\n\n    function setDepositCap(uint256 newDepositCap) external;\n\n    function setBaseFee(uint256 newBaseFee) external;\n\n    function setPaused(bool state) external;\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface ISingularityFactory {\n    struct PoolParams {\n        address factory;\n        address token;\n        bool isStablecoin;\n        uint256 baseFee;\n    }\n\n    event PoolCreated(address indexed token, bool isStablecoin, uint256 baseFee, address pool, uint256 index);\n\n    function tranche() external view returns (string memory);\n\n    function admin() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function feeTo() external view returns (address);\n\n    function router() external view returns (address);\n\n    function protocolFeeShare() external view returns (uint256);\n\n    function oracleSens() external view returns (uint256);\n\n    function poolParams()\n        external\n        view\n        returns (\n            address factory,\n            address token,\n            bool isStablecoin,\n            uint256 baseFee\n        );\n\n    function getPool(address token) external view returns (address pool);\n\n    function allPools(uint256) external view returns (address pool);\n\n    function allPoolsLength() external view returns (uint256);\n\n    function poolCodeHash() external pure returns (bytes32);\n\n    function createPool(\n        address token,\n        bool isStablecoin,\n        uint256 baseFee\n    ) external returns (address pool);\n\n    function setAdmin(address _admin) external;\n\n    function setOracle(address _oracle) external;\n\n    function setFeeTo(address _feeTo) external;\n\n    function setRouter(address _router) external;\n\n    function setProtocolFeeShare(uint256 _protocolFeeShare) external;\n\n    function setOracleSens(uint256 _oracleSens) external;\n\n    function collectFees(address[] calldata tokens) external;\n\n    function setDepositCaps(address[] calldata tokens, uint256[] calldata caps) external;\n\n    function setBaseFees(address[] calldata tokens, uint256[] calldata baseFees) external;\n\n    function setPaused(address[] calldata tokens, bool[] calldata states) external;\n\n    function setPausedForAll(bool state) external;\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface ISingularityOracle {\n    function getLatestRound(address token) external view returns (uint256, uint256);\n\n    function getLatestRounds(address[] calldata tokens) external view returns (uint256[] memory, uint256[] memory);\n}\n// IGNORE_LICENSE-Identifier: No License\n\npragma solidity ^0.8.15;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n}\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*///////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            // Start off with z at 1.\n            z := 1\n\n            // Used below to help find a nearby power of 2.\n            let y := x\n\n            // Find the lowest power of 2 that is at least sqrt(x).\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\n                y := shr(128, y) // Like dividing by 2 ** 128.\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x10000000000000000)) {\n                y := shr(64, y) // Like dividing by 2 ** 64.\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x100000000)) {\n                y := shr(32, y) // Like dividing by 2 ** 32.\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x10000)) {\n                y := shr(16, y) // Like dividing by 2 ** 16.\n                z := shl(8, z)\n            }\n            if iszero(lt(y, 0x100)) {\n                y := shr(8, y) // Like dividing by 2 ** 8.\n                z := shl(4, z)\n            }\n            if iszero(lt(y, 0x10)) {\n                y := shr(4, y) // Like dividing by 2 ** 4.\n                z := shl(2, z)\n            }\n            if iszero(lt(y, 0x8)) {\n                // Equivalent to 2 ** z.\n                z := shl(1, z)\n            }\n\n            // Shifting right by 1 is like dividing by 2.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // Compute a rounded down version of z.\n            let zRoundDown := div(x, z)\n\n            // If zRoundDown is smaller, use it.\n            if lt(zRoundDown, z) {\n                z := zRoundDown\n            }\n        }\n    }\n}\n// IGNORE_LICENSE-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    uint256 private locked = 1;\n\n    modifier nonReentrant() {\n        require(locked == 1, \"REENTRANCY\");\n\n        locked = 2;\n\n        _;\n\n        locked = 1;\n    }\n}\n\n/**\n * @title Singularity Pool\n * @author Revenant Labs\n */\ncontract SingularityPool is ISingularityPool, SingularityPoolToken, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using FixedPointMathLib for uint256;\n\n    bool public override paused;\n    bool public immutable override isStablecoin;\n    address public immutable override factory;\n    address public immutable override token;\n    uint256 public override depositCap;\n    uint256 public override assets;\n    uint256 public override liabilities;\n    uint256 public override baseFee;\n    uint256 public override protocolFees;\n\n    constructor() {\n        (factory, token, isStablecoin, baseFee) = ISingularityFactory(msg.sender).poolParams();\n        string memory tranche = ISingularityFactory(factory).tranche();\n        string memory tokenSymbol = IERC20(token).symbol();\n        name = string(abi.encodePacked(\"Singularity Pool Token-\", tokenSymbol, \" (\", tranche, \")\"));\n        symbol = string(abi.encodePacked(\"SPT-\", tokenSymbol, \" (\", tranche, \")\"));\n        decimals = IERC20(token).decimals();\n        _initialize();\n    }\n\n    /// @notice Deposit underlying tokens to LP\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param amount The amount of underlying tokens to deposit\n    /// @param to The address to mint LP tokens to\n    /// @return mintAmount The amount of LP tokens minted\n    function deposit(uint256 amount, address to) external override nonReentrant returns (uint256 mintAmount) {\n        _notPaused();\n        require(amount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Transfer token from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        if (liabilities == 0) {\n            mintAmount = amount;\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amount;\n            liabilities += amount;\n        } else {\n            // Apply deposit fee\n            uint256 depositFee = getDepositFee(amount);\n            protocolFees += depositFee;\n            uint256 amountPostFee = amount - depositFee;\n\n            // Calculate amount of LP tokens to mint\n            mintAmount = amountPostFee.divWadDown(getPricePerShare());\n\n            // Mint LP tokens to `to`\n            _mint(to, mintAmount);\n\n            // Update assets and liabilities\n            assets += amountPostFee;\n            liabilities += amountPostFee;\n        }\n\n        require(liabilities <= depositCap, \"SingularityPool: DEPOSIT_EXCEEDS_CAP\");\n\n        emit Deposit(msg.sender, amount, mintAmount, to);\n    }\n\n    /// @notice Withdraw underlying tokens through burning LP tokens\n    /// @dev Low-level call (no slippage protection) that should be called from router\n    /// @param lpAmount The amount of LP tokens to burn\n    /// @param to The address to redeem underlying tokens to\n    /// @return withdrawalAmount The amount of underlying tokens withdrawn\n    function withdraw(uint256 lpAmount, address to) external override nonReentrant returns (uint256 withdrawalAmount) {\n        _notPaused();\n        require(lpAmount != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Store current price-per-share\n        uint256 pricePerShare = getPricePerShare();\n\n        // Burn LP tokens\n        _burn(msg.sender, lpAmount);\n\n        // Calculate amount of underlying tokens to redeem\n        uint256 amount = lpAmount.mulWadDown(pricePerShare);\n\n        // Apply withdrawal fee\n        uint256 withdrawalFee = getWithdrawalFee(amount);\n        protocolFees += withdrawalFee;\n        withdrawalAmount = amount - withdrawalFee;\n\n        // Transfer tokens to `to`\n        IERC20(token).safeTransfer(to, withdrawalAmount);\n\n        // Update assets and liabilities\n        assets -= amount;\n        liabilities -= amount;\n\n        emit Withdraw(msg.sender, lpAmount, withdrawalAmount, to);\n    }\n\n    /// @notice Swap tokens in\n    /// @dev Slippage is positive (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @return amountOut The USD value of the swap in (post fees)\n    function swapIn(uint256 amountIn) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Apply slippage (+)\n        uint256 amountPostSlippage = amountIn + getSlippageIn(amountIn);\n\n        // Transfer tokens from sender\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amountIn);\n\n        // Update assets\n        assets += amountIn;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        uint256 amountPostFee = amountPostSlippage - totalFee;\n\n        // Convert amount to USD value\n        amountOut = getAmountToUSD(amountPostFee);\n\n        emit SwapIn(msg.sender, amountIn, amountOut);\n    }\n\n    /// @notice Swap tokens out\n    /// @dev Slippage is negative (or zero)\n    /// @param amountIn The amount of underlying tokens being swapped in\n    /// @param to The address to send tokens to\n    /// @return amountOut The amount of tokens being swapped out\n    function swapOut(uint256 amountIn, address to) external override nonReentrant returns (uint256 amountOut) {\n        _notPaused();\n        _onlyRouter();\n        require(amountIn != 0, \"SingularityPool: AMOUNT_IS_0\");\n\n        // Convert USD value to amount\n        uint256 amount = getUSDToAmount(amountIn);\n\n        // Apply slippage (-)\n        uint256 slippage = getSlippageOut(amount);\n        require(amount > slippage, \"SingularityPool: SLIPPAPGE_EXCEEDS_AMOUNT\");\n        uint256 amountPostSlippage = amount - slippage;\n\n        // Apply trading fees\n        (uint256 totalFee, uint256 protocolFee, uint256 lpFee) = getTradingFees(amountPostSlippage);\n        require(totalFee != type(uint256).max, \"SingularityPool: STALE_ORACLE\");\n        protocolFees += protocolFee;\n        assets -= protocolFee;\n        liabilities += lpFee;\n        amountOut = amountPostSlippage - totalFee;\n\n        // Transfer tokens out\n        IERC20(token).safeTransfer(to, amountOut);\n\n        // Update assets\n        assets -= amountOut;\n\n        emit SwapOut(msg.sender, amountIn, amountOut, to);\n    }\n\n    /// @notice Calculates the price-per-share (PPS)\n    /// @dev PPS = 1 when pool is empty\n    /// @dev PPS is strictly increasing >= 1\n    /// @return pricePerShare The PPS of 1 LP token\n    function getPricePerShare() public view override returns (uint256 pricePerShare) {\n        if (totalSupply == 0) {\n            pricePerShare = 1 ether;\n        } else {\n            pricePerShare = liabilities.divWadDown(totalSupply);\n        }\n    }\n\n    /// @notice Get pool's collateralization ratio\n    /// @dev Collateralization ratio is 1 if pool not seeded\n    /// @return collateralizationRatio The collateralization ratio of the pool\n    function getCollateralizationRatio() public view override returns (uint256 collateralizationRatio) {\n        if (liabilities == 0) {\n            collateralizationRatio = 1 ether;\n        } else {\n            collateralizationRatio = assets.divWadDown(liabilities);\n        }\n    }\n\n    /// @notice Get the underlying token's oracle data\n    /// @return tokenPrice The price of the underlying token\n    /// @return updatedAt The timestamp of last oracle update\n    function getOracleData() public view override returns (uint256 tokenPrice, uint256 updatedAt) {\n        (tokenPrice, updatedAt) = ISingularityOracle(ISingularityFactory(factory).oracle()).getLatestRound(token);\n        require(tokenPrice != 0, \"SingularityPool: INVALID_ORACLE_PRICE\");\n    }\n\n    /// @notice Calculates the equivalent USD value of given the number of tokens\n    /// @dev USD value is in 1e18\n    /// @param amount The amount of tokens to calculate the value of\n    /// @return value The USD value equivalent to the number of tokens\n    function getAmountToUSD(uint256 amount) public view override returns (uint256 value) {\n        if (amount == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        value = amount.mulWadDown(tokenPrice);\n        if (decimals > 18) {\n            value /= 10**(decimals - 18);\n        } else {\n            value *= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the equivalent number of tokens given the USD value\n    /// @dev USD value is in 1e18\n    /// @param value The USD value of tokens to calculate the amount of\n    /// @return amount The number of tokens equivalent to the USD value\n    function getUSDToAmount(uint256 value) public view override returns (uint256 amount) {\n        if (value == 0) return 0;\n\n        (uint256 tokenPrice, ) = getOracleData();\n        amount = value.divWadDown(tokenPrice);\n        if (decimals > 18) {\n            amount *= 10**(decimals - 18);\n        } else {\n            amount /= 10**(18 - decimals);\n        }\n    }\n\n    /// @notice Calculates the fee charged for deposit\n    /// @param amount The amount of tokens being deposited\n    /// @return fee The fee charged for deposit\n    function getDepositFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || liabilities == 0 || amount + assets <= liabilities) return 0;\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio < 1 ether) {\n            amountToPayFees = amount - (liabilities - assets);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets + amountToPayFees,\n            liabilities + amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities + amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        fee = feeA - feeB;\n        require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n    }\n\n    /// @notice Calculates the fee charged for withdraw\n    /// @param amount The amount of tokens being withdrawn\n    /// @return fee The fee charged for withdraw\n    function getWithdrawalFee(uint256 amount) public view override returns (uint256 fee) {\n        if (amount == 0 || amount >= liabilities || assets >= liabilities + amount) {\n            return _getG(1 ether).mulWadUp(amount);\n        }\n\n        uint256 amountToPayFees = amount;\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        if (currentCollateralizationRatio > 1 ether) {\n            amountToPayFees = amount - (assets - liabilities);\n        }\n\n        uint256 gCurrent = _getG(currentCollateralizationRatio);\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(\n            assets > amountToPayFees ? assets - amountToPayFees : 0,\n            liabilities - amountToPayFees\n        );\n        uint256 gAfter = _getG(afterCollateralizationRatio);\n\n        uint256 feeA = _getG(1 ether).mulWadUp(amountToPayFees) + gAfter.mulWadUp(liabilities - amountToPayFees);\n        uint256 feeB = gCurrent.mulWadDown(liabilities);\n\n        // check underflow\n        if (feeA > feeB) {\n            fee = feeA - feeB;\n            require(fee < amountToPayFees, \"SingularityPool: FEE_EXCEEDS_AMOUNT\");\n        } else {\n            fee = 0;\n        }\n    }\n\n    /// @notice Calculates the slippage for swap in\n    /// @param amount The amount being swapped in\n    /// @return slippageIn The slippage for swap in\n    function getSlippageIn(uint256 amount) public view override returns (uint256 slippageIn) {\n        if (amount == 0) return 0;\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets + amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(currentCollateralizationRatio) - _getG(afterCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadDown(afterCollateralizationRatio - currentCollateralizationRatio);\n\n        // Calculate slippage\n        slippageIn = amount.mulWadDown(gPrime);\n    }\n\n    /// @notice Calculates the slippage for swap out\n    /// @param amount The amount being swapped out\n    /// @return slippageOut The slippage for swap out\n    function getSlippageOut(uint256 amount) public view override returns (uint256 slippageOut) {\n        if (amount == 0) return 0;\n        require(amount < assets, \"SingularityPool: AMOUNT_EXCEEDS_ASSETS\");\n\n        uint256 currentCollateralizationRatio = getCollateralizationRatio();\n        uint256 afterCollateralizationRatio = _calcCollatalizationRatio(assets - amount, liabilities);\n        if (currentCollateralizationRatio == afterCollateralizationRatio) {\n            return 0;\n        }\n\n        // Calculate G'\n        uint256 gDiff = _getG(afterCollateralizationRatio) - _getG(currentCollateralizationRatio);\n        uint256 gPrime = gDiff.divWadUp(currentCollateralizationRatio - afterCollateralizationRatio);\n\n        // Calculate slippage\n        slippageOut = amount.mulWadUp(gPrime);\n    }\n\n    /// @notice Calculates the trading fee rate for a swap\n    /// @dev Trading fee rate is in 1e18\n    /// @return tradingFeeRate The fee rate charged\n    function getTradingFeeRate() public view override returns (uint256 tradingFeeRate) {\n        if (isStablecoin) {\n            return baseFee;\n        } else {\n            (, uint256 updatedAt) = getOracleData();\n            uint256 oracleSens = ISingularityFactory(factory).oracleSens();\n            uint256 timeSinceUpdate = block.timestamp - updatedAt;\n            if (timeSinceUpdate * 10 > oracleSens * 11) {\n                // Case: 1.1 * oracleSens < timeSinceUpdate\n\n                tradingFeeRate = type(uint256).max; // Revert later to allow viewability\n            } else if (timeSinceUpdate >= oracleSens) {\n                // Case: oracleSens <= timeSinceUpdate <= 1.1 * oracleSens\n\n                tradingFeeRate = baseFee * 2;\n            } else {\n                // Case: timeSinceUpdate < oracleSens\n\n                tradingFeeRate = baseFee + (baseFee * timeSinceUpdate) / oracleSens;\n            }\n        }\n    }\n\n    /// @notice Calculates trading fees applied for `amount`\n    /// @dev Total Fee = Protocol Fee + LP Fee\n    /// @param amount The amount of tokens being withdrawn\n    /// @return totalFee The sum of all fees applied\n    /// @return protocolFee The fee awarded to the protocol\n    /// @return lpFee The fee awarded to LPs\n    function getTradingFees(uint256 amount)\n        public\n        view\n        override\n        returns (\n            uint256 totalFee,\n            uint256 protocolFee,\n            uint256 lpFee\n        )\n    {\n        if (amount == 0) return (0, 0, 0);\n\n        uint256 tradingFeeRate = getTradingFeeRate();\n        if (tradingFeeRate == type(uint256).max) {\n            return (type(uint256).max, type(uint256).max, type(uint256).max);\n        }\n        totalFee = amount.mulWadUp(tradingFeeRate);\n        uint256 protocolFeeShare = ISingularityFactory(factory).protocolFeeShare();\n        protocolFee = (totalFee * protocolFeeShare) / 100;\n        lpFee = totalFee - protocolFee;\n    }\n\n    /* ========== INTERNAL/PURE FUNCTIONS ========== */\n\n    ///\n    ///     g = 3.63 - 10 * collateralizationRatio   { colleralizationRatio < 0.35 }\n    ///\n    ///                     0.00003\n    ///     g = -------------------------------      { 0.35 <= collateralizationRatio < 1.5 }\n    ///          (collateralizationRatio) ^ 8\n    ///\n    ///     g = 0                                    { collateralizationRatio >= 1.5 }\n    ///\n    function _getG(uint256 collateralizationRatio) internal pure returns (uint256 g) {\n        if (collateralizationRatio < 0.35 ether) {\n            return 3.63 ether - 10 * collateralizationRatio;\n        }\n\n        // handle overflow when computing exponent\n        if (collateralizationRatio >= 1.5 ether) {\n            return 0;\n        }\n\n        uint256 numerator = 0.00003 ether;\n        uint256 denominator = collateralizationRatio.rpow(8, 1 ether);\n        g = numerator.divWadUp(denominator);\n    }\n\n    function _calcCollatalizationRatio(uint256 _assets, uint256 _liabilities)\n        internal\n        pure\n        returns (uint256 afterCollateralizationRatio)\n    {\n        if (_liabilities == 0) {\n            afterCollateralizationRatio = 1 ether;\n        } else {\n            afterCollateralizationRatio = _assets.divWadDown(_liabilities);\n        }\n    }\n\n    function _notPaused() internal view {\n        require(!paused, \"SingularityPool: PAUSED\");\n    }\n\n    function _onlyFactory() internal view {\n        require(msg.sender == factory, \"SingularityPool: NOT_FACTORY\");\n    }\n\n    function _onlyRouter() internal view {\n        require(msg.sender == ISingularityFactory(factory).router(), \"SingularityPool: NOT_ROUTER\");\n    }\n\n    /* ========== FACTORY FUNCTIONS ========== */\n\n    function collectFees(address feeTo) external override {\n        _onlyFactory();\n\n        if (protocolFees == 0) return;\n\n        uint256 protocolFeesToTransfer = protocolFees;\n        protocolFees = 0;\n\n        IERC20(token).safeTransfer(feeTo, protocolFeesToTransfer);\n\n        emit CollectFees(protocolFeesToTransfer);\n    }\n\n    function setDepositCap(uint256 newDepositCap) external override {\n        _onlyFactory();\n\n        emit SetDepositCap(depositCap, newDepositCap);\n        depositCap = newDepositCap;\n    }\n\n    function setBaseFee(uint256 newBaseFee) external override {\n        _onlyFactory();\n\n        emit SetBaseFee(baseFee, newBaseFee);\n        baseFee = newBaseFee;\n    }\n\n    function setPaused(bool state) external override {\n        _onlyFactory();\n\n        emit SetPaused(paused, state);\n        paused = state;\n    }\n}\n", "commit_id": "5dea908b44af0f02b20a49e5545a4b8e02fe1eeb"}}