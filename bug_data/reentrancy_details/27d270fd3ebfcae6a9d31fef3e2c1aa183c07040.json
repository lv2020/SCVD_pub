{"filename": "ethereum/contracts/icco/conductor/Conductor.sol", "patch": "@@ -331,7 +331,7 @@ contract Conductor is ConductorGovernance, ConductorEvents, ReentrancyGuard {\n                 conSealed.contributions[i].contributed\n             );\n         }\n-    } \n+    }\n \n     /**\n      * @dev sealSale serves to determine if a sale was successful or not. \n@@ -456,12 +456,21 @@ contract Conductor is ConductorGovernance, ConductorEvents, ReentrancyGuard {\n             accounting.saleTokenRefund = sale.tokenAmount - accounting.totalAllocated;\n \n             if (accounting.saleTokenRefund > 0) {\n-                SafeERC20.safeTransfer(\n-                    IERC20(sale.localTokenAddress), \n-                    address(uint160(uint256(sale.refundRecipient))), \n-                    accounting.saleTokenRefund\n+                /// @dev using low-level call instead of safeTransfer to fetch success boolean\n+                (bool success, ) = sale.localTokenAddress.call(\n+                    abi.encodeWithSelector(\n+                        IERC20(sale.localTokenAddress).transfer.selector,\n+                        address(uint160(uint256(sale.refundRecipient))), \n+                        accounting.saleTokenRefund\n+                    )\n                 );\n-            }\n+\n+                /// @dev if this fails, it's due to an attempted reentrancy attack\n+                if (!success) {\n+                    wormholeSequence = abortSale(saleId, false);\n+                    return (wormholeSequence, 0);\n+                } \n+            } \n \n             require(accounting.valueSent >= accounting.messageFee, \"insufficient wormhole messaging fees\");\n             accounting.valueSent -= accounting.messageFee; \n@@ -501,28 +510,48 @@ contract Conductor is ConductorGovernance, ConductorEvents, ReentrancyGuard {\n             /// emit EventSealSale event.\n             emit EventSealSale(saleId); \n         } else {\n-            /// set saleAborted\n-            setSaleAborted(sale.saleID);\n+            wormholeSequence = abortSale(saleId, true);\n+            return (wormholeSequence, 0);\n+        }\n+    }\n \n-            /// @dev send encoded SaleAborted message to Contributor contracts\n-            wormholeSequence = wormhole.publishMessage{\n-                value : msg.value\n-            }(0, ICCOStructs.encodeSaleAborted(ICCOStructs.SaleAborted({\n-                payloadID : 4,\n-                saleID : saleId\n-            })), consistencyLevel());\n+    /**\n+     * @dev abortSale serves to mark the sale as aborted.\n+     * - it sends a SaleAborted VAA\n+     * - it sends the refundRecipient a refund if the minRaise is not met\n+     * - it does not send the refund if a prior transfer to the refundRecipient fails \n+     * - it emits an EventAbortSale event\n+     * - it should only be called from within the sealSale function\n+     */\n+    function abortSale(uint256 saleId, bool sendRefund) internal returns (uint256 wormholeSequence) {\n+        /// set saleAborted\n+        setSaleAborted(saleId);\n+\n+        /// cache wormhole instance\n+        IWormhole wormhole = wormhole();\n+\n+        /// @dev send encoded SaleAborted message to Contributor contracts\n+        wormholeSequence = wormhole.publishMessage{\n+            value : wormhole.messageFee()\n+        }(0, ICCOStructs.encodeSaleAborted(ICCOStructs.SaleAborted({\n+            payloadID : 4,\n+            saleID : saleId\n+        })), consistencyLevel());\n+\n+        /// @dev refund the sale tokens to refund recipient if sendRefund is true\n+        if (sendRefund) {\n+            ConductorStructs.Sale memory sale = sales(saleId);\n \n-            /// @dev refund the sale tokens to refund recipient\n             SafeERC20.safeTransfer(\n                 IERC20(sale.localTokenAddress), \n                 address(uint160(uint256(sale.refundRecipient))), \n                 sale.tokenAmount \n             );\n-\n-            /// emit EventAbortSale event.\n-            emit EventAbortSale(saleId);\n         }\n-    } \n+\n+        /// emit EventAbortSale event.\n+        emit EventAbortSale(saleId);\n+    }\n  \n     /// @dev useSaleId serves to update the current saleId in the Conductor state\n     function useSaleId() internal returns(uint256 saleId) {\n@@ -531,7 +560,7 @@ contract Conductor is ConductorGovernance, ConductorEvents, ReentrancyGuard {\n     }\n \n     /// @dev verifyContributorVM serves to validate VMs by checking against known Contributor contracts    \n-    function verifyContributorVM(IWormhole.VM memory vm) internal view returns (bool){\n+    function verifyContributorVM(IWormhole.VM memory vm) internal view returns (bool) {\n         if (contributorContracts(vm.emitterChainId) == vm.emitterAddress) {\n             return true;\n         }", "project_link": "https://github.com/certusone/wormhole-icco/commit/256b4c7a61949ee2ee6516cdfc23cdf7b6cb1bed", "solc_version": "0.8.13", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "27d270fd3ebfcae6a9d31fef3e2c1aa183c07040"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "256b4c7a61949ee2ee6516cdfc23cdf7b6cb1bed"}}