{"filename": "contracts/staking/SimpleStaking.sol", "patch": "@@ -181,7 +181,7 @@ abstract contract SimpleStaking is\n \t\tuint256 _amount,\n \t\tuint256 _donationPer,\n \t\tbool _inInterestToken\n-\t) external virtual {\n+\t) external virtual nonReentrant {\n \t\trequire(isPaused == false, \"Staking is paused\");\n \t\trequire(\n \t\t\t_donationPer == 0 || _donationPer == 100,\n@@ -201,8 +201,12 @@ abstract contract SimpleStaking is\n \t\t\tmintInterestToken(_amount); //mint iToken\n \t\t}\n \t\t_mint(_msgSender(), _amount); // mint Staking token for staker\n-\t\t(uint32 rewardsPerBlock, uint64 blockStart, uint64 blockEnd, ) =\n-\t\t\tGoodFundManager(nameService.getAddress(\"FUND_MANAGER\"))\n+\t\t(\n+\t\t\tuint32 rewardsPerBlock,\n+\t\t\tuint64 blockStart,\n+\t\t\tuint64 blockEnd,\n+\n+\t\t) = GoodFundManager(nameService.getAddress(\"FUND_MANAGER\"))\n \t\t\t\t.rewardsForStakingContract(address(this));\n \t\t_increaseProductivity(\n \t\t\t_msgSender(),\n@@ -214,13 +218,13 @@ abstract contract SimpleStaking is\n \t\t);\n \n \t\t//notify GDAO distrbution for stakers\n-\t\tStakersDistribution sd =\n-\t\t\tStakersDistribution(nameService.getAddress(\"GDAO_STAKERS\"));\n+\t\tStakersDistribution sd = StakersDistribution(\n+\t\t\tnameService.getAddress(\"GDAO_STAKERS\")\n+\t\t);\n \t\tif (address(sd) != address(0)) {\n-\t\t\tuint256 stakeAmountInEighteenDecimals =\n-\t\t\t\ttoken.decimals() == 18\n-\t\t\t\t\t? _amount\n-\t\t\t\t\t: _amount * 10**(18 - token.decimals());\n+\t\t\tuint256 stakeAmountInEighteenDecimals = token.decimals() == 18\n+\t\t\t\t? _amount\n+\t\t\t\t: _amount * 10**(18 - token.decimals());\n \t\t\tsd.userStaked(_msgSender(), stakeAmountInEighteenDecimals);\n \t\t}\n \n@@ -261,14 +265,15 @@ abstract contract SimpleStaking is\n \t\t\t);\n \t\t}\n \n-\t\tGoodFundManager fm =\n-\t\t\tGoodFundManager(nameService.getAddress(\"FUND_MANAGER\"));\n+\t\tGoodFundManager fm = GoodFundManager(\n+\t\t\tnameService.getAddress(\"FUND_MANAGER\")\n+\t\t);\n \n \t\t//this will revert in case user doesnt have enough productivity to withdraw _amount, as productivity=staking tokens amount\n \t\t_burn(msg.sender, _amount); // burn their staking tokens\n \n-\t\t(uint32 rewardsPerBlock, uint64 blockStart, uint64 blockEnd, ) =\n-\t\t\tfm.rewardsForStakingContract(address(this));\n+\t\t(uint32 rewardsPerBlock, uint64 blockStart, uint64 blockEnd, ) = fm\n+\t\t\t.rewardsForStakingContract(address(this));\n \n \t\t_decreaseProductivity(\n \t\t\t_msgSender(),\n@@ -280,13 +285,13 @@ abstract contract SimpleStaking is\n \t\tfm.mintReward(nameService.getAddress(\"CDAI\"), _msgSender()); // send rewards to user and use cDAI address since reserve in cDAI\n \n \t\t//notify GDAO distrbution for stakers\n-\t\tStakersDistribution sd =\n-\t\t\tStakersDistribution(nameService.getAddress(\"GDAO_STAKERS\"));\n+\t\tStakersDistribution sd = StakersDistribution(\n+\t\t\tnameService.getAddress(\"GDAO_STAKERS\")\n+\t\t);\n \t\tif (address(sd) != address(0)) {\n-\t\t\tuint256 withdrawAmountInEighteenDecimals =\n-\t\t\t\ttoken.decimals() == 18\n-\t\t\t\t\t? _amount\n-\t\t\t\t\t: _amount * 10**(18 - token.decimals());\n+\t\t\tuint256 withdrawAmountInEighteenDecimals = token.decimals() == 18\n+\t\t\t\t? _amount\n+\t\t\t\t: _amount * 10**(18 - token.decimals());\n \t\t\tsd.userWithdraw(_msgSender(), withdrawAmountInEighteenDecimals);\n \t\t}\n \n@@ -298,8 +303,9 @@ abstract contract SimpleStaking is\n \t * withdrawing rewards resets the multiplier! so if user just want GDAO he should use claimReputation()\n \t */\n \tfunction withdrawRewards() external nonReentrant {\n-\t\tGoodFundManager fm =\n-\t\t\tGoodFundManager(nameService.getAddress(\"FUND_MANAGER\"));\n+\t\tGoodFundManager fm = GoodFundManager(\n+\t\t\tnameService.getAddress(\"FUND_MANAGER\")\n+\t\t);\n \t\tfm.mintReward(nameService.getAddress(\"CDAI\"), _msgSender()); // send rewards to user and use cDAI address since reserve in cDAI\n \t\tclaimReputation();\n \t}\n@@ -309,8 +315,9 @@ abstract contract SimpleStaking is\n \t */\n \tfunction claimReputation() public {\n \t\t//claim reputation rewards\n-\t\tStakersDistribution sd =\n-\t\t\tStakersDistribution(nameService.getAddress(\"GDAO_STAKERS\"));\n+\t\tStakersDistribution sd = StakersDistribution(\n+\t\t\tnameService.getAddress(\"GDAO_STAKERS\")\n+\t\t);\n \t\tif (address(sd) != address(0)) {\n \t\t\taddress[] memory contracts = new address[](1);\n \t\t\tcontracts[0] = (address(this));\n@@ -328,10 +335,15 @@ abstract contract SimpleStaking is\n \t) internal override {\n \t\tsuper._transfer(_from, _to, _value);\n \n-\t\tStakersDistribution sd =\n-\t\t\tStakersDistribution(nameService.getAddress(\"GDAO_STAKERS\"));\n-\t\t(uint32 rewardsPerBlock, uint64 blockStart, uint64 blockEnd, ) =\n-\t\t\tGoodFundManager(nameService.getAddress(\"FUND_MANAGER\"))\n+\t\tStakersDistribution sd = StakersDistribution(\n+\t\t\tnameService.getAddress(\"GDAO_STAKERS\")\n+\t\t);\n+\t\t(\n+\t\t\tuint32 rewardsPerBlock,\n+\t\t\tuint64 blockStart,\n+\t\t\tuint64 blockEnd,\n+\n+\t\t) = GoodFundManager(nameService.getAddress(\"FUND_MANAGER\"))\n \t\t\t\t.rewardsForStakingContract(address(this));\n \n \t\t_decreaseProductivity(\n@@ -365,10 +377,9 @@ abstract contract SimpleStaking is\n \tfunction tokenDecimalPrecision() internal view returns (uint256, bool) {\n \t\tuint256 _tokenDecimal = tokenDecimal();\n \t\tuint256 _iTokenDecimal = iTokenDecimal();\n-\t\tuint256 decimalDifference =\n-\t\t\t_tokenDecimal > _iTokenDecimal\n-\t\t\t\t? _tokenDecimal - _iTokenDecimal\n-\t\t\t\t: _iTokenDecimal - _tokenDecimal;\n+\t\tuint256 decimalDifference = _tokenDecimal > _iTokenDecimal\n+\t\t\t? _tokenDecimal - _iTokenDecimal\n+\t\t\t: _iTokenDecimal - _tokenDecimal;\n \t\treturn (decimalDifference, _tokenDecimal > _iTokenDecimal);\n \t}\n \n@@ -410,11 +421,18 @@ abstract contract SimpleStaking is\n \t\t\t_recipient != address(this),\n \t\t\t\"Recipient cannot be the staking contract\"\n \t\t);\n-\t\t(uint256 iTokenGains, uint256 tokenGains, , , uint256 usdGains) =\n-\t\t\tcurrentGains(false, true);\n-\n-\t\t(address redeemedToken, uint256 redeemedAmount) =\n-\t\t\tredeemUnderlyingToDAI(iTokenGains, _recipient);\n+\t\t(\n+\t\t\tuint256 iTokenGains,\n+\t\t\tuint256 tokenGains,\n+\t\t\t,\n+\t\t\t,\n+\t\t\tuint256 usdGains\n+\t\t) = currentGains(false, true);\n+\n+\t\t(address redeemedToken, uint256 redeemedAmount) = redeemUnderlyingToDAI(\n+\t\t\tiTokenGains,\n+\t\t\t_recipient\n+\t\t);\n \t\tif (\n \t\t\tredeemedToken == nameService.getAddress(\"CDAI\") &&\n \t\t\tredeemedAmount > 0\n@@ -492,17 +510,20 @@ abstract contract SimpleStaking is\n \t\tview\n \t\treturns (uint256, uint256)\n \t{\n-\t\t(uint32 rewardsPerBlock, uint64 blockStart, uint64 blockEnd, ) =\n-\t\t\tGoodFundManager(nameService.getAddress(\"FUND_MANAGER\"))\n+\t\t(\n+\t\t\tuint32 rewardsPerBlock,\n+\t\t\tuint64 blockStart,\n+\t\t\tuint64 blockEnd,\n+\n+\t\t) = GoodFundManager(nameService.getAddress(\"FUND_MANAGER\"))\n \t\t\t\t.rewardsForStakingContract(address(this));\n \n-\t\tuint256 pending =\n-\t\t\tgetUserPendingReward(\n-\t\t\t\t_staker,\n-\t\t\t\trewardsPerBlock,\n-\t\t\t\tblockStart,\n-\t\t\t\tblockEnd\n-\t\t\t);\n+\t\tuint256 pending = getUserPendingReward(\n+\t\t\t_staker,\n+\t\t\trewardsPerBlock,\n+\t\t\tblockStart,\n+\t\t\tblockEnd\n+\t\t);\n \t\treturn (users[_staker].rewardMinted, pending);\n \t}\n }", "project_link": "https://github.com/GoodDollar/GoodProtocol/commit/63294e5055bfb52d10dadbb916c286997a38c648", "solc_version": "0.8.5", "packages": "", "bug_version": {"raw_code": "", "flattened_code": "", "commit_id": "13102b0d860f291825f29f2a55dcda4d27d07d03"}, "fixed_version": {"raw_code": "", "flattened_code": "", "commit_id": "63294e5055bfb52d10dadbb916c286997a38c648"}}