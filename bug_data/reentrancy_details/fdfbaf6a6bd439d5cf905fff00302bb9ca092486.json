{"filename": "contracts/FixedReentrancy.sol", "patch": "@@ -0,0 +1,65 @@\n+//SPDX-License-Identifier: MIT\n+pragma solidity 0.8.4;\n+\n+import \"@openzeppelin/contracts/access/Ownable.sol\";\n+import 'hardhat/console.sol';\n+\n+// There are couple of ways to prevent reentrancy attacks\n+// 1. Use the transfer(forwards 2300 gas, which isn't enough for re entering the contract.) \n+// method instead of CALL(forwards all available gas) whenever possible,\n+// 2. Use the check-effect-interaction pattern. That is first check all the conditions, then change\n+// the necessary states, and finally do the interactions. In the reentrancy attack, this pattern is violated\n+// and the state change is delayed and interaction is done before leading to the attack.\n+// 3. Use a mutex to lock the contract during code execution, so that reentrancy calls are avoided.\n+\n+contract FixedReentrancy is Ownable {\n+    mapping (address=>uint) public balances;\n+\n+    // 3. mutex solution\n+    bool reEntrancyMutex = false;\n+\n+    constructor() public payable {\n+        balances[msg.sender] = msg.value;\n+    }\n+\n+    function donate(address _to) public payable {\n+        unchecked {\n+            balances[_to] += msg.value;\n+\n+        }\n+    }\n+\n+    function balanceOf(address _who) public view returns(uint balance){\n+        return balances[_who];\n+    }\n+\n+\n+    function withdraw(uint _amount) public {\n+        // 3. mutex solution\n+        require(!reEntrancyMutex, 'One transaction is already in process');\n+\n+        // 2. Check-effect-interactions pattern\n+        require(balances[msg.sender] >= _amount, \"Account does not have enough balance\");\n+    \n+        // 1. use of transfer instead of CALL solution.\n+        reEntrancyMutex = true;\n+        payable(msg.sender).transfer(_amount);\n+\n+        // (bool success, bytes memory data) = msg.sender.call{value:_amount}(\"\");\n+        // if (success) {\n+        //     unchecked{\n+        //         balances[msg.sender] -= _amount;\n+        //     }\n+\n+        // } else {\n+        //     revert('Transaction failed');\n+        // }\n+\n+        reEntrancyMutex = false;\n+        \n+    }\n+\n+    function kill(address _target) public onlyOwner {\n+        selfdestruct(payable(_target));\n+    }\n+}\n\\ No newline at end of file", "project_link": "https://github.com/Kankan-0/solidity-security/commit/fdfbaf6a6bd439d5cf905fff00302bb9ca092486", "bug_version": {"raw_code": "", "commit_id": "f13fd75eb509dbffd8658a2b65e1d60fbfa39c55"}, "fixed_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport 'hardhat/console.sol';\n\n// There are couple of ways to prevent reentrancy attacks\n// 1. Use the transfer(forwards 2300 gas, which isn't enough for re entering the contract.) \n// method instead of CALL(forwards all available gas) whenever possible,\n// 2. Use the check-effect-interaction pattern. That is first check all the conditions, then change\n// the necessary states, and finally do the interactions. In the reentrancy attack, this pattern is violated\n// and the state change is delayed and interaction is done before leading to the attack.\n// 3. Use a mutex to lock the contract during code execution, so that reentrancy calls are avoided.\n\ncontract FixedReentrancy is Ownable {\n    mapping (address=>uint) public balances;\n\n    // 3. mutex solution\n    bool reEntrancyMutex = false;\n\n    constructor() public payable {\n        balances[msg.sender] = msg.value;\n    }\n\n    function donate(address _to) public payable {\n        unchecked {\n            balances[_to] += msg.value;\n\n        }\n    }\n\n    function balanceOf(address _who) public view returns(uint balance){\n        return balances[_who];\n    }\n\n\n    function withdraw(uint _amount) public {\n        // 3. mutex solution\n        require(!reEntrancyMutex, 'One transaction is already in process');\n\n        // 2. Check-effect-interactions pattern\n        require(balances[msg.sender] >= _amount, \"Account does not have enough balance\");\n    \n        // 1. use of transfer instead of CALL solution.\n        reEntrancyMutex = true;\n        payable(msg.sender).transfer(_amount);\n\n        // (bool success, bytes memory data) = msg.sender.call{value:_amount}(\"\");\n        // if (success) {\n        //     unchecked{\n        //         balances[msg.sender] -= _amount;\n        //     }\n\n        // } else {\n        //     revert('Transaction failed');\n        // }\n\n        reEntrancyMutex = false;\n        \n    }\n\n    function kill(address _target) public onlyOwner {\n        selfdestruct(payable(_target));\n    }\n}", "commit_id": "fdfbaf6a6bd439d5cf905fff00302bb9ca092486"}}