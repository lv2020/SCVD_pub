{"filename": "contracts/identity/Identity.sol", "patch": "@@ -14,12 +14,13 @@ contract Identity is ERC725, ERC735 {\n     mapping (bytes32 => uint256) indexes;\n     mapping (uint => Transaction) txx;\n     mapping (uint256 => uint256) minimumApprovalsByKeyPurpose;\n-    bytes32[] pendingTransactions;\n+    \n     uint nonce = 0;\n     address recoveryContract;\n     address recoveryManager;\n \n     struct Transaction {\n+        bool valid;\n         address to;\n         uint value;\n         bytes data;\n@@ -455,6 +456,7 @@ contract Identity is ERC725, ERC735 {\n         executionId = nonce;\n         nonce++;\n         txx[executionId] = Transaction({\n+            valid: true,\n             to: _to,\n             value: _value,\n             data: _data,\n@@ -473,29 +475,30 @@ contract Identity is ERC725, ERC735 {\n         returns(bool success) //(?) should return approved instead of success?\n     {\n         \n-        Transaction storage trx = txx[_id];\n+        Transaction memory trx = txx[_id];\n+        require(trx.valid);\n+        uint256 requiredKeyPurpose = trx.to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n+        require(isKeyPurpose(_key, requiredKeyPurpose));\n+        bytes32 keyHash = keccak256(_key, requiredKeyPurpose);\n+        require(txx[_id].approvals[keyHash] != _approval);\n         \n-        uint256 approvalCount;\n-        uint256 requiredKeyPurpose;\n-\n-        if (trx.to == address(this)) {\n-            require(isKeyPurpose(_key, MANAGEMENT_KEY));\n-            bytes32 managerKeyHash = keccak256(_key, MANAGEMENT_KEY);\n-            requiredKeyPurpose = MANAGEMENT_KEY;\n-            approvalCount = _calculateApprovals(managerKeyHash, _approval, trx);\n+        if (_approval) {\n+            trx.approverCount++;\n         } else {\n-            require(isKeyPurpose(_key, ACTION_KEY));\n-            bytes32 actorKeyHash = keccak256(_key, ACTION_KEY);\n-            requiredKeyPurpose = ACTION_KEY;\n-            approvalCount = _calculateApprovals(actorKeyHash, _approval, trx);\n+            trx.approverCount--;\n         }\n-\n+    \n         emit Approved(_id, _approval);\n \n-        if (approvalCount >= minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n+        if (trx.approverCount < minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n+            txx[_id].approvals[keyHash] = _approval;\n+            txx[_id] = trx;\n+        } else {\n+            delete txx[_id];\n             //(?) success should be included in event?\n-            success = trx.to.call.value(trx.value)(trx.data);\n+            success = address(trx.to).call.value(trx.value)(trx.data);\n             emit Executed(_id, trx.to, trx.value, trx.data);\n+            \n         }\n     }\n \n@@ -541,31 +544,10 @@ contract Identity is ERC725, ERC735 {\n \n         delete indexes[keyHash];\n         delete keys[keyHash];\n-        \n-        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n-    }\n-\n-    function _calculateApprovals(\n-        bytes32 _keyHash,\n-        bool _approval,\n-        Transaction storage trx\n-    )\n-        private \n-        returns (uint256 approvalCount) \n-    {\n-        require(trx.approvals[_keyHash] != _approval);\n \n-        trx.approvals[_keyHash] = _approval;\n-        if (_approval) {\n-            trx.approverCount++;\n-        } else {\n-            trx.approverCount--;\n-        }\n-        \n-        return trx.approverCount;\n+        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n     }\n \n-    \n     function _includeClaim(\n         bytes32 _claimHash,\n         uint256 _claimType,", "project_link": "https://github.com/status-im/contracts/commit/8752bd114f51ea24047fd4c131c9fc6629f10953", "bug_version": {"raw_code": "pragma solidity ^0.4.17;\n\nimport \"./ERC725.sol\";\nimport \"./ERC735.sol\";\n\n\ncontract Identity is ERC725, ERC735 {\n\n    mapping (bytes32 => Key) keys;\n    mapping (uint256 => bytes32[]) keysByPurpose;\n    mapping (bytes32 => Claim) claims;\n    mapping (uint256 => bytes32[]) claimsByType;\n\n    mapping (bytes32 => uint256) indexes;\n    mapping (uint => Transaction) txx;\n    mapping (uint256 => uint256) minimumApprovalsByKeyPurpose;\n    bytes32[] pendingTransactions;\n    uint nonce = 0;\n    address recoveryContract;\n    address recoveryManager;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n        uint nonce;\n        uint approverCount;\n        mapping(bytes32 => bool) approvals;\n    }\n\n    modifier managerOnly {\n        require(\n            isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY)\n        );\n        _;\n    }\n\n    modifier managementOnly {\n        if(msg.sender == address(this)) {\n            _;\n        } else {\n            require(isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY));\n            if (minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 1) {\n                _;\n            } else {\n                execute(address(this), 0, msg.data);\n            }\n        }\n    }\n    modifier recoveryOnly {\n        require(\n            recoveryContract != address(0) && \n            msg.sender == address(recoveryContract)\n        );\n        _;\n    }\n\n    modifier keyPurposeOnly(bytes32 _key, uint256 _purpose) {\n        require(isKeyPurpose(_key, _purpose));\n        _;\n    }\n    \n    modifier managerOrActor(bytes32 _key) {\n        require(\n            isKeyPurpose(_key, MANAGEMENT_KEY) || \n            isKeyPurpose(_key, ACTION_KEY)\n        );\n        _;\n    }\n    \n    modifier validECDSAKey (\n        bytes32 _key, \n        bytes32 _signHash, \n        uint8 _v, \n        bytes32 _r,\n        bytes32 _s\n    ) \n    {\n        require(\n            address(_key) == ecrecover(\n                keccak256(\"\\x19Ethereum Signed Message:\\n32\", _signHash),\n                _v,\n                _r,\n                _s\n                )\n            );\n        require(keys[_key].purpose != 0);\n        _;\n    }\n\n    function Identity() public {\n        _constructIdentity(msg.sender);\n    }    \n\n    function () \n        public \n        payable \n    {\n\n    }\n\n    function managerReset(address _newKey) \n        public \n        recoveryOnly\n    {\n        recoveryManager = _newKey;\n        _addKey(bytes32(recoveryManager), MANAGEMENT_KEY, 0);\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = keysByPurpose[MANAGEMENT_KEY].length;\n    }\n    \n    function processManagerReset(uint256 _limit) \n        public \n    {\n        require(recoveryManager != address(0));\n        uint limit = _limit;\n        bytes32 newKey = bytes32(recoveryManager);\n        bytes32[] memory managers = keysByPurpose[MANAGEMENT_KEY];\n        uint256 totalManagers = managers.length;\n        \n        if (limit == 0) {\n            limit = totalManagers;\n        }\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = totalManagers - limit + 1;\n        for (uint256 i = 0; i < limit; i++) {\n            bytes32 manager = managers[i];\n            if (manager != newKey) {\n                _removeKey(manager, MANAGEMENT_KEY);\n                totalManagers--;\n            }\n        }\n\n        if (totalManagers == 1) {\n            recoveryManager = address(0);\n        }\n    }\n\n    function addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {   \n        _addKey(_key, _purpose, _type);\n        return true;\n    }\n\n    function replaceKey(\n        bytes32 _oldKey,\n        bytes32 _newKey,\n        uint256 _newType\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        uint256 purpose = keys[_oldKey].purpose;\n        _addKey(_newKey, purpose, _newType);\n        _removeKey(_oldKey, purpose);\n        return true;\n    } \n\n    function removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        _removeKey(_key, _purpose);\n        return true;\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        public \n        returns (uint256 executionId)\n    {\n        uint256 requiredKey = _to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n        if (minimumApprovalsByKeyPurpose[requiredKey] == 1) {\n            executionId = nonce; //(?) useless in this case\n            nonce++; //(?) should increment\n            require(isKeyPurpose(bytes32(msg.sender), requiredKey));\n            _to.call.value(_value)(_data); //(?) success not used\n            emit Executed(executionId, _to, _value, _data); //no information on success\n        } else {\n            executionId = _execute(_to, _value, _data);\n            approve(executionId, true);\n        }\n        \n    }\n\n    function approve(uint256 _id, bool _approval) \n        public \n        managerOrActor(bytes32(msg.sender))\n        returns (bool success)\n    {   \n        return _approve(bytes32(msg.sender), _id, _approval);\n    }\n\n    function setMinimumApprovalsByKeyType(\n        uint256 _purpose,\n        uint256 _minimumApprovals\n    ) \n        public \n        managementOnly\n    {\n        require(_minimumApprovals > 0);\n        require(_minimumApprovals <= keysByPurpose[_purpose].length);\n        minimumApprovalsByKeyPurpose[_purpose] = _minimumApprovals;\n    }\n    \n    \n    function addClaim(\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        public \n        returns (bytes32 claimHash)\n    {\n        claimHash = keccak256(_issuer, _claimType);\n        if (msg.sender == address(this)) {\n            if (claims[claimHash].claimType > 0) {\n                _modifyClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            } else {\n                _includeClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            }\n        } else {\n            require(_issuer == msg.sender);\n            require(isKeyPurpose(bytes32(msg.sender), CLAIM_SIGNER_KEY));\n            _execute(address(this), 0, msg.data);\n            emit ClaimRequested(\n                claimHash,\n                _claimType,\n                _scheme,\n                _issuer,\n                _signature,\n                _data,\n                _uri\n            );\n        }\n    }\n    \n    function removeClaim(bytes32 _claimId) \n        public \n        returns (bool success) \n    {\n        Claim memory c = claims[_claimId];\n        \n        require(\n            msg.sender == c.issuer ||\n            msg.sender == address(this)\n            );\n        \n        // MUST only be done by the issuer of the claim, or KEYS OF PURPOSE 1, or the identity itself.\n        // TODO If its the identity itself, the approval process will determine its approval.\n        \n        uint claimIdTypePos = indexes[_claimId];\n        delete indexes[_claimId];\n        bytes32[] storage claimsTypeArr = claimsByType[c.claimType];\n        bytes32 replacer = claimsTypeArr[claimsTypeArr.length-1];\n        claimsTypeArr[claimIdTypePos] = replacer;\n        indexes[replacer] = claimIdTypePos;\n        delete claims[_claimId];\n        claimsTypeArr.length--;\n        return true;\n    }\n\n    function getKey(\n        bytes32 _key,\n        uint256 _purpose\n    ) \n        public \n        constant \n        returns(uint256 purpose, uint256 keyType, bytes32 key) \n    {\n        Key storage myKey = keys[keccak256(_key, _purpose)];\n        return (myKey.purpose, myKey.keyType, myKey.key);\n    }\n    \n    function isKeyPurpose(bytes32 _key, uint256 _type) \n        public\n        constant \n        returns (bool)\n    {\n        return keys[keccak256(_key, _type)].purpose == _type;\n    }\n\n    function getKeyPurpose(bytes32 _key)\n        public \n        constant \n        returns(uint256[] purpose)\n    {\n        \n        uint256[] memory purposeHolder = new uint256[](4);\n        uint8 counter = 0;\n        \n        if (isKeyPurpose(_key, MANAGEMENT_KEY)) {\n            purposeHolder[counter] = MANAGEMENT_KEY;\n            counter++;\n        }\n        \n        if (isKeyPurpose(_key, ACTION_KEY)) {\n            purposeHolder[counter] = ACTION_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, CLAIM_SIGNER_KEY)) {\n            purposeHolder[counter] = CLAIM_SIGNER_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, ENCRYPTION_KEY)) {\n            purposeHolder[counter] = ENCRYPTION_KEY;\n            counter++;\n        }\n        \n        uint256[] memory result = new uint256[](counter);\n        for (uint8 i = 0; i < counter; i++) {\n            result[i] = purposeHolder[i];\n        }\n        \n        return result;\n    }\n    \n    function getKeysByPurpose(uint256 _purpose)\n        public\n        constant\n        returns(bytes32[])\n    {\n        return keysByPurpose[_purpose];\n    }\n    \n    function getClaim(bytes32 _claimId)\n        public\n        constant \n        returns(\n            uint256 claimType,\n            uint256 scheme,\n            address issuer,\n            bytes signature,\n            bytes data,\n            string uri\n            ) \n    {\n        Claim memory _claim = claims[_claimId];\n        return (_claim.claimType, _claim.scheme, _claim.issuer, _claim.signature, _claim.data, _claim.uri);\n    }\n    \n    function getClaimIdsByType(uint256 _claimType)\n        public\n        constant\n        returns(bytes32[] claimIds)\n    {\n        return claimsByType[_claimType];\n    }\n\n    function approveECDSA(\n        uint256 _id,\n        bool _approval,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this),\n                bytes4(keccak256(\"approve(uint256,bool)\")),\n                _id,\n                _approval\n                ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (bool success)\n    {   \n        return _approve(_key, _id, _approval);\n    }\n    \n    function executeECDSA(\n        address _to,\n        uint256 _value,\n        bytes _data,\n        uint _nonce,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this), \n                bytes4(keccak256(\"execute(address,uint256,bytes)\")), \n                _to,\n                _value,\n                _data,\n                _nonce\n            ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (uint256 executionId)\n    {\n        executionId = _execute(_to, _value, _data);\n        _approve(_key, executionId, true);\n    }\n\n    function setupRecovery(address _recoveryContract) \n        public\n        managementOnly\n    {\n        require(recoveryContract == address(0));\n        recoveryContract = _recoveryContract;\n    }\n    \n    function _constructIdentity(address _manager)\n        internal \n    {\n        require(keysByPurpose[MANAGEMENT_KEY].length == 0);\n        require(minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 0);\n        _addKey(bytes32(_manager), MANAGEMENT_KEY, 0);\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = 1;\n        minimumApprovalsByKeyPurpose[ACTION_KEY] = 1;\n    }\n\n    function _execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        private\n        returns (uint256 executionId)\n    {\n        executionId = nonce;\n        nonce++;\n        txx[executionId] = Transaction({\n            to: _to,\n            value: _value,\n            data: _data,\n            nonce: nonce,\n            approverCount: 0\n        });            \n        emit ExecutionRequested(executionId, _to, _value, _data);\n    }\n    \n    function _approve(\n        bytes32 _key,\n        uint256 _id,\n        bool _approval\n    ) \n        private \n        returns(bool success) //(?) should return approved instead of success?\n    {\n        \n        Transaction storage trx = txx[_id];\n        \n        uint256 approvalCount;\n        uint256 requiredKeyPurpose;\n\n        if (trx.to == address(this)) {\n            require(isKeyPurpose(_key, MANAGEMENT_KEY));\n            bytes32 managerKeyHash = keccak256(_key, MANAGEMENT_KEY);\n            requiredKeyPurpose = MANAGEMENT_KEY;\n            approvalCount = _calculateApprovals(managerKeyHash, _approval, trx);\n        } else {\n            require(isKeyPurpose(_key, ACTION_KEY));\n            bytes32 actorKeyHash = keccak256(_key, ACTION_KEY);\n            requiredKeyPurpose = ACTION_KEY;\n            approvalCount = _calculateApprovals(actorKeyHash, _approval, trx);\n        }\n\n        emit Approved(_id, _approval);\n\n        if (approvalCount >= minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n            //(?) success should be included in event?\n            success = trx.to.call.value(trx.value)(trx.data);\n            emit Executed(_id, trx.to, trx.value, trx.data);\n        }\n    }\n\n    function _addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    ) \n        private\n    {\n        bytes32 keyHash = keccak256(_key, _purpose);\n        \n        require(keys[keyHash].purpose == 0);\n        require(\n            _purpose == MANAGEMENT_KEY ||\n            _purpose == ACTION_KEY ||\n            _purpose == CLAIM_SIGNER_KEY ||\n            _purpose == ENCRYPTION_KEY\n        );\n        keys[keyHash] = Key(_purpose, _type, _key);\n        indexes[keyHash] = keysByPurpose[_purpose].push(_key) - 1;\n        emit KeyAdded(_key, _purpose, _type);\n    }\n\n    function _removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        private \n    {\n        if (_purpose == MANAGEMENT_KEY) {\n            require(keysByPurpose[MANAGEMENT_KEY].length > minimumApprovalsByKeyPurpose[MANAGEMENT_KEY]);\n        }\n\n        bytes32 keyHash = keccak256(_key, _purpose);\n        Key memory myKey = keys[keyHash];\n        uint index = indexes[keyHash];\n        bytes32 indexReplacer = keysByPurpose[_purpose][keysByPurpose[_purpose].length - 1];\n        \n        keysByPurpose[_purpose][index] = indexReplacer;\n        indexes[keccak256(indexReplacer, _purpose)] = index;\n        keysByPurpose[_purpose].length--;\n\n        delete indexes[keyHash];\n        delete keys[keyHash];\n        \n        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n    }\n\n    function _calculateApprovals(\n        bytes32 _keyHash,\n        bool _approval,\n        Transaction storage trx\n    )\n        private \n        returns (uint256 approvalCount) \n    {\n        require(trx.approvals[_keyHash] != _approval);\n\n        trx.approvals[_keyHash] = _approval;\n        if (_approval) {\n            trx.approverCount++;\n        } else {\n            trx.approverCount--;\n        }\n        \n        return trx.approverCount;\n    }\n\n    \n    function _includeClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        claims[_claimHash] = Claim(\n            {\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n            }\n        );\n        indexes[_claimHash] = claimsByType[_claimType].length;\n        claimsByType[_claimType].push(_claimHash);\n        emit ClaimAdded(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n    function _modifyClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        require(msg.sender == _issuer);\n        claims[_claimHash] = Claim({\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n        });\n        emit ClaimChanged(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n}\n\n", "flattened_code": "pragma solidity ^0.4.17;\n\npragma solidity ^0.4.18;\n\ncontract ERC725 {\n\n    uint256 constant MANAGEMENT_KEY = 1;\n    uint256 constant ACTION_KEY = 2;\n    uint256 constant CLAIM_SIGNER_KEY = 3;\n    uint256 constant ENCRYPTION_KEY = 4;\n    \n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256 purpose; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    function getKey(bytes32 _key, uint256 _purpose) public constant returns(uint256 purpose, uint256 keyType, bytes32 key);\n    function getKeyPurpose(bytes32 _key) public constant returns(uint256[] purpose);\n    function getKeysByPurpose(uint256 _purpose) public constant returns(bytes32[] keys);\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) public returns (bool success);\n    function removeKey(bytes32 _key, uint256 _purpose) public returns (bool success);\n    function execute(address _to, uint256 _value, bytes _data) public returns (uint256 executionId);\n    function approve(uint256 _id, bool _approve) public returns (bool success);\n}\npragma solidity ^0.4.18;\n\ncontract ERC735 {\n\n    event ClaimRequested(bytes32 indexed claimRequestId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);   \n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    struct Claim {\n        uint256 claimType;\n        uint256 scheme;\n        address issuer; // msg.sender\n        bytes signature; // this.address + claimType + data\n        bytes data;\n        string uri;\n    }\n\n    function getClaim(bytes32 _claimId) public constant returns(uint256 claimType, uint256 scheme, address issuer, bytes signature, bytes data, string uri);\n    function getClaimIdsByType(uint256 _claimType) public constant returns(bytes32[] claimIds);\n    function addClaim(uint256 _claimType, uint256 _scheme, address _issuer, bytes _signature, bytes _data, string _uri) public returns (bytes32 claimRequestId);\n    function removeClaim(bytes32 _claimId) public returns (bool success);\n}\n\n\ncontract Identity is ERC725, ERC735 {\n\n    mapping (bytes32 => Key) keys;\n    mapping (uint256 => bytes32[]) keysByPurpose;\n    mapping (bytes32 => Claim) claims;\n    mapping (uint256 => bytes32[]) claimsByType;\n\n    mapping (bytes32 => uint256) indexes;\n    mapping (uint => Transaction) txx;\n    mapping (uint256 => uint256) minimumApprovalsByKeyPurpose;\n    bytes32[] pendingTransactions;\n    uint nonce = 0;\n    address recoveryContract;\n    address recoveryManager;\n\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n        uint nonce;\n        uint approverCount;\n        mapping(bytes32 => bool) approvals;\n    }\n\n    modifier managerOnly {\n        require(\n            isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY)\n        );\n        _;\n    }\n\n    modifier managementOnly {\n        if(msg.sender == address(this)) {\n            _;\n        } else {\n            require(isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY));\n            if (minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 1) {\n                _;\n            } else {\n                execute(address(this), 0, msg.data);\n            }\n        }\n    }\n    modifier recoveryOnly {\n        require(\n            recoveryContract != address(0) && \n            msg.sender == address(recoveryContract)\n        );\n        _;\n    }\n\n    modifier keyPurposeOnly(bytes32 _key, uint256 _purpose) {\n        require(isKeyPurpose(_key, _purpose));\n        _;\n    }\n    \n    modifier managerOrActor(bytes32 _key) {\n        require(\n            isKeyPurpose(_key, MANAGEMENT_KEY) || \n            isKeyPurpose(_key, ACTION_KEY)\n        );\n        _;\n    }\n    \n    modifier validECDSAKey (\n        bytes32 _key, \n        bytes32 _signHash, \n        uint8 _v, \n        bytes32 _r,\n        bytes32 _s\n    ) \n    {\n        require(\n            address(_key) == ecrecover(\n                keccak256(\"\\x19Ethereum Signed Message:\\n32\", _signHash),\n                _v,\n                _r,\n                _s\n                )\n            );\n        require(keys[_key].purpose != 0);\n        _;\n    }\n\n    function Identity() public {\n        _constructIdentity(msg.sender);\n    }    \n\n    function () \n        public \n        payable \n    {\n\n    }\n\n    function managerReset(address _newKey) \n        public \n        recoveryOnly\n    {\n        recoveryManager = _newKey;\n        _addKey(bytes32(recoveryManager), MANAGEMENT_KEY, 0);\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = keysByPurpose[MANAGEMENT_KEY].length;\n    }\n    \n    function processManagerReset(uint256 _limit) \n        public \n    {\n        require(recoveryManager != address(0));\n        uint limit = _limit;\n        bytes32 newKey = bytes32(recoveryManager);\n        bytes32[] memory managers = keysByPurpose[MANAGEMENT_KEY];\n        uint256 totalManagers = managers.length;\n        \n        if (limit == 0) {\n            limit = totalManagers;\n        }\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = totalManagers - limit + 1;\n        for (uint256 i = 0; i < limit; i++) {\n            bytes32 manager = managers[i];\n            if (manager != newKey) {\n                _removeKey(manager, MANAGEMENT_KEY);\n                totalManagers--;\n            }\n        }\n\n        if (totalManagers == 1) {\n            recoveryManager = address(0);\n        }\n    }\n\n    function addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {   \n        _addKey(_key, _purpose, _type);\n        return true;\n    }\n\n    function replaceKey(\n        bytes32 _oldKey,\n        bytes32 _newKey,\n        uint256 _newType\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        uint256 purpose = keys[_oldKey].purpose;\n        _addKey(_newKey, purpose, _newType);\n        _removeKey(_oldKey, purpose);\n        return true;\n    } \n\n    function removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        _removeKey(_key, _purpose);\n        return true;\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        public \n        returns (uint256 executionId)\n    {\n        uint256 requiredKey = _to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n        if (minimumApprovalsByKeyPurpose[requiredKey] == 1) {\n            executionId = nonce; //(?) useless in this case\n            nonce++; //(?) should increment\n            require(isKeyPurpose(bytes32(msg.sender), requiredKey));\n            _to.call.value(_value)(_data); //(?) success not used\n            emit Executed(executionId, _to, _value, _data); //no information on success\n        } else {\n            executionId = _execute(_to, _value, _data);\n            approve(executionId, true);\n        }\n        \n    }\n\n    function approve(uint256 _id, bool _approval) \n        public \n        managerOrActor(bytes32(msg.sender))\n        returns (bool success)\n    {   \n        return _approve(bytes32(msg.sender), _id, _approval);\n    }\n\n    function setMinimumApprovalsByKeyType(\n        uint256 _purpose,\n        uint256 _minimumApprovals\n    ) \n        public \n        managementOnly\n    {\n        require(_minimumApprovals > 0);\n        require(_minimumApprovals <= keysByPurpose[_purpose].length);\n        minimumApprovalsByKeyPurpose[_purpose] = _minimumApprovals;\n    }\n    \n    \n    function addClaim(\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        public \n        returns (bytes32 claimHash)\n    {\n        claimHash = keccak256(_issuer, _claimType);\n        if (msg.sender == address(this)) {\n            if (claims[claimHash].claimType > 0) {\n                _modifyClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            } else {\n                _includeClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            }\n        } else {\n            require(_issuer == msg.sender);\n            require(isKeyPurpose(bytes32(msg.sender), CLAIM_SIGNER_KEY));\n            _execute(address(this), 0, msg.data);\n            emit ClaimRequested(\n                claimHash,\n                _claimType,\n                _scheme,\n                _issuer,\n                _signature,\n                _data,\n                _uri\n            );\n        }\n    }\n    \n    function removeClaim(bytes32 _claimId) \n        public \n        returns (bool success) \n    {\n        Claim memory c = claims[_claimId];\n        \n        require(\n            msg.sender == c.issuer ||\n            msg.sender == address(this)\n            );\n        \n        // MUST only be done by the issuer of the claim, or KEYS OF PURPOSE 1, or the identity itself.\n        // TODO If its the identity itself, the approval process will determine its approval.\n        \n        uint claimIdTypePos = indexes[_claimId];\n        delete indexes[_claimId];\n        bytes32[] storage claimsTypeArr = claimsByType[c.claimType];\n        bytes32 replacer = claimsTypeArr[claimsTypeArr.length-1];\n        claimsTypeArr[claimIdTypePos] = replacer;\n        indexes[replacer] = claimIdTypePos;\n        delete claims[_claimId];\n        claimsTypeArr.length--;\n        return true;\n    }\n\n    function getKey(\n        bytes32 _key,\n        uint256 _purpose\n    ) \n        public \n        constant \n        returns(uint256 purpose, uint256 keyType, bytes32 key) \n    {\n        Key storage myKey = keys[keccak256(_key, _purpose)];\n        return (myKey.purpose, myKey.keyType, myKey.key);\n    }\n    \n    function isKeyPurpose(bytes32 _key, uint256 _type) \n        public\n        constant \n        returns (bool)\n    {\n        return keys[keccak256(_key, _type)].purpose == _type;\n    }\n\n    function getKeyPurpose(bytes32 _key)\n        public \n        constant \n        returns(uint256[] purpose)\n    {\n        \n        uint256[] memory purposeHolder = new uint256[](4);\n        uint8 counter = 0;\n        \n        if (isKeyPurpose(_key, MANAGEMENT_KEY)) {\n            purposeHolder[counter] = MANAGEMENT_KEY;\n            counter++;\n        }\n        \n        if (isKeyPurpose(_key, ACTION_KEY)) {\n            purposeHolder[counter] = ACTION_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, CLAIM_SIGNER_KEY)) {\n            purposeHolder[counter] = CLAIM_SIGNER_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, ENCRYPTION_KEY)) {\n            purposeHolder[counter] = ENCRYPTION_KEY;\n            counter++;\n        }\n        \n        uint256[] memory result = new uint256[](counter);\n        for (uint8 i = 0; i < counter; i++) {\n            result[i] = purposeHolder[i];\n        }\n        \n        return result;\n    }\n    \n    function getKeysByPurpose(uint256 _purpose)\n        public\n        constant\n        returns(bytes32[])\n    {\n        return keysByPurpose[_purpose];\n    }\n    \n    function getClaim(bytes32 _claimId)\n        public\n        constant \n        returns(\n            uint256 claimType,\n            uint256 scheme,\n            address issuer,\n            bytes signature,\n            bytes data,\n            string uri\n            ) \n    {\n        Claim memory _claim = claims[_claimId];\n        return (_claim.claimType, _claim.scheme, _claim.issuer, _claim.signature, _claim.data, _claim.uri);\n    }\n    \n    function getClaimIdsByType(uint256 _claimType)\n        public\n        constant\n        returns(bytes32[] claimIds)\n    {\n        return claimsByType[_claimType];\n    }\n\n    function approveECDSA(\n        uint256 _id,\n        bool _approval,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this),\n                bytes4(keccak256(\"approve(uint256,bool)\")),\n                _id,\n                _approval\n                ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (bool success)\n    {   \n        return _approve(_key, _id, _approval);\n    }\n    \n    function executeECDSA(\n        address _to,\n        uint256 _value,\n        bytes _data,\n        uint _nonce,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this), \n                bytes4(keccak256(\"execute(address,uint256,bytes)\")), \n                _to,\n                _value,\n                _data,\n                _nonce\n            ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (uint256 executionId)\n    {\n        executionId = _execute(_to, _value, _data);\n        _approve(_key, executionId, true);\n    }\n\n    function setupRecovery(address _recoveryContract) \n        public\n        managementOnly\n    {\n        require(recoveryContract == address(0));\n        recoveryContract = _recoveryContract;\n    }\n    \n    function _constructIdentity(address _manager)\n        internal \n    {\n        require(keysByPurpose[MANAGEMENT_KEY].length == 0);\n        require(minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 0);\n        _addKey(bytes32(_manager), MANAGEMENT_KEY, 0);\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = 1;\n        minimumApprovalsByKeyPurpose[ACTION_KEY] = 1;\n    }\n\n    function _execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        private\n        returns (uint256 executionId)\n    {\n        executionId = nonce;\n        nonce++;\n        txx[executionId] = Transaction({\n            to: _to,\n            value: _value,\n            data: _data,\n            nonce: nonce,\n            approverCount: 0\n        });            \n        emit ExecutionRequested(executionId, _to, _value, _data);\n    }\n    \n    function _approve(\n        bytes32 _key,\n        uint256 _id,\n        bool _approval\n    ) \n        private \n        returns(bool success) //(?) should return approved instead of success?\n    {\n        \n        Transaction storage trx = txx[_id];\n        \n        uint256 approvalCount;\n        uint256 requiredKeyPurpose;\n\n        if (trx.to == address(this)) {\n            require(isKeyPurpose(_key, MANAGEMENT_KEY));\n            bytes32 managerKeyHash = keccak256(_key, MANAGEMENT_KEY);\n            requiredKeyPurpose = MANAGEMENT_KEY;\n            approvalCount = _calculateApprovals(managerKeyHash, _approval, trx);\n        } else {\n            require(isKeyPurpose(_key, ACTION_KEY));\n            bytes32 actorKeyHash = keccak256(_key, ACTION_KEY);\n            requiredKeyPurpose = ACTION_KEY;\n            approvalCount = _calculateApprovals(actorKeyHash, _approval, trx);\n        }\n\n        emit Approved(_id, _approval);\n\n        if (approvalCount >= minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n            //(?) success should be included in event?\n            success = trx.to.call.value(trx.value)(trx.data);\n            emit Executed(_id, trx.to, trx.value, trx.data);\n        }\n    }\n\n    function _addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    ) \n        private\n    {\n        bytes32 keyHash = keccak256(_key, _purpose);\n        \n        require(keys[keyHash].purpose == 0);\n        require(\n            _purpose == MANAGEMENT_KEY ||\n            _purpose == ACTION_KEY ||\n            _purpose == CLAIM_SIGNER_KEY ||\n            _purpose == ENCRYPTION_KEY\n        );\n        keys[keyHash] = Key(_purpose, _type, _key);\n        indexes[keyHash] = keysByPurpose[_purpose].push(_key) - 1;\n        emit KeyAdded(_key, _purpose, _type);\n    }\n\n    function _removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        private \n    {\n        if (_purpose == MANAGEMENT_KEY) {\n            require(keysByPurpose[MANAGEMENT_KEY].length > minimumApprovalsByKeyPurpose[MANAGEMENT_KEY]);\n        }\n\n        bytes32 keyHash = keccak256(_key, _purpose);\n        Key memory myKey = keys[keyHash];\n        uint index = indexes[keyHash];\n        bytes32 indexReplacer = keysByPurpose[_purpose][keysByPurpose[_purpose].length - 1];\n        \n        keysByPurpose[_purpose][index] = indexReplacer;\n        indexes[keccak256(indexReplacer, _purpose)] = index;\n        keysByPurpose[_purpose].length--;\n\n        delete indexes[keyHash];\n        delete keys[keyHash];\n        \n        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n    }\n\n    function _calculateApprovals(\n        bytes32 _keyHash,\n        bool _approval,\n        Transaction storage trx\n    )\n        private \n        returns (uint256 approvalCount) \n    {\n        require(trx.approvals[_keyHash] != _approval);\n\n        trx.approvals[_keyHash] = _approval;\n        if (_approval) {\n            trx.approverCount++;\n        } else {\n            trx.approverCount--;\n        }\n        \n        return trx.approverCount;\n    }\n\n    \n    function _includeClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        claims[_claimHash] = Claim(\n            {\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n            }\n        );\n        indexes[_claimHash] = claimsByType[_claimType].length;\n        claimsByType[_claimType].push(_claimHash);\n        emit ClaimAdded(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n    function _modifyClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        require(msg.sender == _issuer);\n        claims[_claimHash] = Claim({\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n        });\n        emit ClaimChanged(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n}\n\n", "commit_id": "aa317d9f6e7fc0362e0af6bdec6b68028c4e62ac"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.17;\n\nimport \"./ERC725.sol\";\nimport \"./ERC735.sol\";\n\n\ncontract Identity is ERC725, ERC735 {\n\n    mapping (bytes32 => Key) keys;\n    mapping (uint256 => bytes32[]) keysByPurpose;\n    mapping (bytes32 => Claim) claims;\n    mapping (uint256 => bytes32[]) claimsByType;\n\n    mapping (bytes32 => uint256) indexes;\n    mapping (uint => Transaction) txx;\n    mapping (uint256 => uint256) minimumApprovalsByKeyPurpose;\n    \n    uint nonce = 0;\n    address recoveryContract;\n    address recoveryManager;\n\n    struct Transaction {\n        bool valid;\n        address to;\n        uint value;\n        bytes data;\n        uint nonce;\n        uint approverCount;\n        mapping(bytes32 => bool) approvals;\n    }\n\n    modifier managerOnly {\n        require(\n            isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY)\n        );\n        _;\n    }\n\n    modifier managementOnly {\n        if(msg.sender == address(this)) {\n            _;\n        } else {\n            require(isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY));\n            if (minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 1) {\n                _;\n            } else {\n                execute(address(this), 0, msg.data);\n            }\n        }\n    }\n    modifier recoveryOnly {\n        require(\n            recoveryContract != address(0) && \n            msg.sender == address(recoveryContract)\n        );\n        _;\n    }\n\n    modifier keyPurposeOnly(bytes32 _key, uint256 _purpose) {\n        require(isKeyPurpose(_key, _purpose));\n        _;\n    }\n    \n    modifier managerOrActor(bytes32 _key) {\n        require(\n            isKeyPurpose(_key, MANAGEMENT_KEY) || \n            isKeyPurpose(_key, ACTION_KEY)\n        );\n        _;\n    }\n    \n    modifier validECDSAKey (\n        bytes32 _key, \n        bytes32 _signHash, \n        uint8 _v, \n        bytes32 _r,\n        bytes32 _s\n    ) \n    {\n        require(\n            address(_key) == ecrecover(\n                keccak256(\"\\x19Ethereum Signed Message:\\n32\", _signHash),\n                _v,\n                _r,\n                _s\n                )\n            );\n        require(keys[_key].purpose != 0);\n        _;\n    }\n\n    function Identity() public {\n        _constructIdentity(msg.sender);\n    }    \n\n    function () \n        public \n        payable \n    {\n\n    }\n\n    function managerReset(address _newKey) \n        public \n        recoveryOnly\n    {\n        recoveryManager = _newKey;\n        _addKey(bytes32(recoveryManager), MANAGEMENT_KEY, 0);\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = keysByPurpose[MANAGEMENT_KEY].length;\n    }\n    \n    function processManagerReset(uint256 _limit) \n        public \n    {\n        require(recoveryManager != address(0));\n        uint limit = _limit;\n        bytes32 newKey = bytes32(recoveryManager);\n        bytes32[] memory managers = keysByPurpose[MANAGEMENT_KEY];\n        uint256 totalManagers = managers.length;\n        \n        if (limit == 0) {\n            limit = totalManagers;\n        }\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = totalManagers - limit + 1;\n        for (uint256 i = 0; i < limit; i++) {\n            bytes32 manager = managers[i];\n            if (manager != newKey) {\n                _removeKey(manager, MANAGEMENT_KEY);\n                totalManagers--;\n            }\n        }\n\n        if (totalManagers == 1) {\n            recoveryManager = address(0);\n        }\n    }\n\n    function addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {   \n        _addKey(_key, _purpose, _type);\n        return true;\n    }\n\n    function replaceKey(\n        bytes32 _oldKey,\n        bytes32 _newKey,\n        uint256 _newType\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        uint256 purpose = keys[_oldKey].purpose;\n        _addKey(_newKey, purpose, _newType);\n        _removeKey(_oldKey, purpose);\n        return true;\n    } \n\n    function removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        _removeKey(_key, _purpose);\n        return true;\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        public \n        returns (uint256 executionId)\n    {\n        uint256 requiredKey = _to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n        if (minimumApprovalsByKeyPurpose[requiredKey] == 1) {\n            executionId = nonce; //(?) useless in this case\n            nonce++; //(?) should increment\n            require(isKeyPurpose(bytes32(msg.sender), requiredKey));\n            _to.call.value(_value)(_data); //(?) success not used\n            emit Executed(executionId, _to, _value, _data); //no information on success\n        } else {\n            executionId = _execute(_to, _value, _data);\n            approve(executionId, true);\n        }\n        \n    }\n\n    function approve(uint256 _id, bool _approval) \n        public \n        managerOrActor(bytes32(msg.sender))\n        returns (bool success)\n    {   \n        return _approve(bytes32(msg.sender), _id, _approval);\n    }\n\n    function setMinimumApprovalsByKeyType(\n        uint256 _purpose,\n        uint256 _minimumApprovals\n    ) \n        public \n        managementOnly\n    {\n        require(_minimumApprovals > 0);\n        require(_minimumApprovals <= keysByPurpose[_purpose].length);\n        minimumApprovalsByKeyPurpose[_purpose] = _minimumApprovals;\n    }\n    \n    \n    function addClaim(\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        public \n        returns (bytes32 claimHash)\n    {\n        claimHash = keccak256(_issuer, _claimType);\n        if (msg.sender == address(this)) {\n            if (claims[claimHash].claimType > 0) {\n                _modifyClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            } else {\n                _includeClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            }\n        } else {\n            require(_issuer == msg.sender);\n            require(isKeyPurpose(bytes32(msg.sender), CLAIM_SIGNER_KEY));\n            _execute(address(this), 0, msg.data);\n            emit ClaimRequested(\n                claimHash,\n                _claimType,\n                _scheme,\n                _issuer,\n                _signature,\n                _data,\n                _uri\n            );\n        }\n    }\n    \n    function removeClaim(bytes32 _claimId) \n        public \n        returns (bool success) \n    {\n        Claim memory c = claims[_claimId];\n        \n        require(\n            msg.sender == c.issuer ||\n            msg.sender == address(this)\n            );\n        \n        // MUST only be done by the issuer of the claim, or KEYS OF PURPOSE 1, or the identity itself.\n        // TODO If its the identity itself, the approval process will determine its approval.\n        \n        uint claimIdTypePos = indexes[_claimId];\n        delete indexes[_claimId];\n        bytes32[] storage claimsTypeArr = claimsByType[c.claimType];\n        bytes32 replacer = claimsTypeArr[claimsTypeArr.length-1];\n        claimsTypeArr[claimIdTypePos] = replacer;\n        indexes[replacer] = claimIdTypePos;\n        delete claims[_claimId];\n        claimsTypeArr.length--;\n        return true;\n    }\n\n    function getKey(\n        bytes32 _key,\n        uint256 _purpose\n    ) \n        public \n        constant \n        returns(uint256 purpose, uint256 keyType, bytes32 key) \n    {\n        Key storage myKey = keys[keccak256(_key, _purpose)];\n        return (myKey.purpose, myKey.keyType, myKey.key);\n    }\n    \n    function isKeyPurpose(bytes32 _key, uint256 _type) \n        public\n        constant \n        returns (bool)\n    {\n        return keys[keccak256(_key, _type)].purpose == _type;\n    }\n\n    function getKeyPurpose(bytes32 _key)\n        public \n        constant \n        returns(uint256[] purpose)\n    {\n        \n        uint256[] memory purposeHolder = new uint256[](4);\n        uint8 counter = 0;\n        \n        if (isKeyPurpose(_key, MANAGEMENT_KEY)) {\n            purposeHolder[counter] = MANAGEMENT_KEY;\n            counter++;\n        }\n        \n        if (isKeyPurpose(_key, ACTION_KEY)) {\n            purposeHolder[counter] = ACTION_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, CLAIM_SIGNER_KEY)) {\n            purposeHolder[counter] = CLAIM_SIGNER_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, ENCRYPTION_KEY)) {\n            purposeHolder[counter] = ENCRYPTION_KEY;\n            counter++;\n        }\n        \n        uint256[] memory result = new uint256[](counter);\n        for (uint8 i = 0; i < counter; i++) {\n            result[i] = purposeHolder[i];\n        }\n        \n        return result;\n    }\n    \n    function getKeysByPurpose(uint256 _purpose)\n        public\n        constant\n        returns(bytes32[])\n    {\n        return keysByPurpose[_purpose];\n    }\n    \n    function getClaim(bytes32 _claimId)\n        public\n        constant \n        returns(\n            uint256 claimType,\n            uint256 scheme,\n            address issuer,\n            bytes signature,\n            bytes data,\n            string uri\n            ) \n    {\n        Claim memory _claim = claims[_claimId];\n        return (_claim.claimType, _claim.scheme, _claim.issuer, _claim.signature, _claim.data, _claim.uri);\n    }\n    \n    function getClaimIdsByType(uint256 _claimType)\n        public\n        constant\n        returns(bytes32[] claimIds)\n    {\n        return claimsByType[_claimType];\n    }\n\n    function approveECDSA(\n        uint256 _id,\n        bool _approval,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this),\n                bytes4(keccak256(\"approve(uint256,bool)\")),\n                _id,\n                _approval\n                ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (bool success)\n    {   \n        return _approve(_key, _id, _approval);\n    }\n    \n    function executeECDSA(\n        address _to,\n        uint256 _value,\n        bytes _data,\n        uint _nonce,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this), \n                bytes4(keccak256(\"execute(address,uint256,bytes)\")), \n                _to,\n                _value,\n                _data,\n                _nonce\n            ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (uint256 executionId)\n    {\n        executionId = _execute(_to, _value, _data);\n        _approve(_key, executionId, true);\n    }\n\n    function setupRecovery(address _recoveryContract) \n        public\n        managementOnly\n    {\n        require(recoveryContract == address(0));\n        recoveryContract = _recoveryContract;\n    }\n    \n    function _constructIdentity(address _manager)\n        internal \n    {\n        require(keysByPurpose[MANAGEMENT_KEY].length == 0);\n        require(minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 0);\n        _addKey(bytes32(_manager), MANAGEMENT_KEY, 0);\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = 1;\n        minimumApprovalsByKeyPurpose[ACTION_KEY] = 1;\n    }\n\n    function _execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        private\n        returns (uint256 executionId)\n    {\n        executionId = nonce;\n        nonce++;\n        txx[executionId] = Transaction({\n            valid: true,\n            to: _to,\n            value: _value,\n            data: _data,\n            nonce: nonce,\n            approverCount: 0\n        });            \n        emit ExecutionRequested(executionId, _to, _value, _data);\n    }\n    \n    function _approve(\n        bytes32 _key,\n        uint256 _id,\n        bool _approval\n    ) \n        private \n        returns(bool success) //(?) should return approved instead of success?\n    {\n        \n        Transaction memory trx = txx[_id];\n        require(trx.valid);\n        uint256 requiredKeyPurpose = trx.to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n        require(isKeyPurpose(_key, requiredKeyPurpose));\n        bytes32 keyHash = keccak256(_key, requiredKeyPurpose);\n        require(txx[_id].approvals[keyHash] != _approval);\n        \n        if (_approval) {\n            trx.approverCount++;\n        } else {\n            trx.approverCount--;\n        }\n    \n        emit Approved(_id, _approval);\n\n        if (trx.approverCount < minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n            txx[_id].approvals[keyHash] = _approval;\n            txx[_id] = trx;\n        } else {\n            delete txx[_id];\n            //(?) success should be included in event?\n            success = address(trx.to).call.value(trx.value)(trx.data);\n            emit Executed(_id, trx.to, trx.value, trx.data);\n            \n        }\n    }\n\n    function _addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    ) \n        private\n    {\n        bytes32 keyHash = keccak256(_key, _purpose);\n        \n        require(keys[keyHash].purpose == 0);\n        require(\n            _purpose == MANAGEMENT_KEY ||\n            _purpose == ACTION_KEY ||\n            _purpose == CLAIM_SIGNER_KEY ||\n            _purpose == ENCRYPTION_KEY\n        );\n        keys[keyHash] = Key(_purpose, _type, _key);\n        indexes[keyHash] = keysByPurpose[_purpose].push(_key) - 1;\n        emit KeyAdded(_key, _purpose, _type);\n    }\n\n    function _removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        private \n    {\n        if (_purpose == MANAGEMENT_KEY) {\n            require(keysByPurpose[MANAGEMENT_KEY].length > minimumApprovalsByKeyPurpose[MANAGEMENT_KEY]);\n        }\n\n        bytes32 keyHash = keccak256(_key, _purpose);\n        Key memory myKey = keys[keyHash];\n        uint index = indexes[keyHash];\n        bytes32 indexReplacer = keysByPurpose[_purpose][keysByPurpose[_purpose].length - 1];\n        \n        keysByPurpose[_purpose][index] = indexReplacer;\n        indexes[keccak256(indexReplacer, _purpose)] = index;\n        keysByPurpose[_purpose].length--;\n\n        delete indexes[keyHash];\n        delete keys[keyHash];\n\n        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n    }\n\n    function _includeClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        claims[_claimHash] = Claim(\n            {\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n            }\n        );\n        indexes[_claimHash] = claimsByType[_claimType].length;\n        claimsByType[_claimType].push(_claimHash);\n        emit ClaimAdded(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n    function _modifyClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        require(msg.sender == _issuer);\n        claims[_claimHash] = Claim({\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n        });\n        emit ClaimChanged(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n}\n\n", "flattened_code": "pragma solidity ^0.4.17;\n\npragma solidity ^0.4.18;\n\ncontract ERC725 {\n\n    uint256 constant MANAGEMENT_KEY = 1;\n    uint256 constant ACTION_KEY = 2;\n    uint256 constant CLAIM_SIGNER_KEY = 3;\n    uint256 constant ENCRYPTION_KEY = 4;\n    \n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256 purpose; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    function getKey(bytes32 _key, uint256 _purpose) public constant returns(uint256 purpose, uint256 keyType, bytes32 key);\n    function getKeyPurpose(bytes32 _key) public constant returns(uint256[] purpose);\n    function getKeysByPurpose(uint256 _purpose) public constant returns(bytes32[] keys);\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) public returns (bool success);\n    function removeKey(bytes32 _key, uint256 _purpose) public returns (bool success);\n    function execute(address _to, uint256 _value, bytes _data) public returns (uint256 executionId);\n    function approve(uint256 _id, bool _approve) public returns (bool success);\n}\npragma solidity ^0.4.18;\n\ncontract ERC735 {\n\n    event ClaimRequested(bytes32 indexed claimRequestId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);   \n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed claimType, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    struct Claim {\n        uint256 claimType;\n        uint256 scheme;\n        address issuer; // msg.sender\n        bytes signature; // this.address + claimType + data\n        bytes data;\n        string uri;\n    }\n\n    function getClaim(bytes32 _claimId) public constant returns(uint256 claimType, uint256 scheme, address issuer, bytes signature, bytes data, string uri);\n    function getClaimIdsByType(uint256 _claimType) public constant returns(bytes32[] claimIds);\n    function addClaim(uint256 _claimType, uint256 _scheme, address _issuer, bytes _signature, bytes _data, string _uri) public returns (bytes32 claimRequestId);\n    function removeClaim(bytes32 _claimId) public returns (bool success);\n}\n\n\ncontract Identity is ERC725, ERC735 {\n\n    mapping (bytes32 => Key) keys;\n    mapping (uint256 => bytes32[]) keysByPurpose;\n    mapping (bytes32 => Claim) claims;\n    mapping (uint256 => bytes32[]) claimsByType;\n\n    mapping (bytes32 => uint256) indexes;\n    mapping (uint => Transaction) txx;\n    mapping (uint256 => uint256) minimumApprovalsByKeyPurpose;\n    \n    uint nonce = 0;\n    address recoveryContract;\n    address recoveryManager;\n\n    struct Transaction {\n        bool valid;\n        address to;\n        uint value;\n        bytes data;\n        uint nonce;\n        uint approverCount;\n        mapping(bytes32 => bool) approvals;\n    }\n\n    modifier managerOnly {\n        require(\n            isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY)\n        );\n        _;\n    }\n\n    modifier managementOnly {\n        if(msg.sender == address(this)) {\n            _;\n        } else {\n            require(isKeyPurpose(bytes32(msg.sender), MANAGEMENT_KEY));\n            if (minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 1) {\n                _;\n            } else {\n                execute(address(this), 0, msg.data);\n            }\n        }\n    }\n    modifier recoveryOnly {\n        require(\n            recoveryContract != address(0) && \n            msg.sender == address(recoveryContract)\n        );\n        _;\n    }\n\n    modifier keyPurposeOnly(bytes32 _key, uint256 _purpose) {\n        require(isKeyPurpose(_key, _purpose));\n        _;\n    }\n    \n    modifier managerOrActor(bytes32 _key) {\n        require(\n            isKeyPurpose(_key, MANAGEMENT_KEY) || \n            isKeyPurpose(_key, ACTION_KEY)\n        );\n        _;\n    }\n    \n    modifier validECDSAKey (\n        bytes32 _key, \n        bytes32 _signHash, \n        uint8 _v, \n        bytes32 _r,\n        bytes32 _s\n    ) \n    {\n        require(\n            address(_key) == ecrecover(\n                keccak256(\"\\x19Ethereum Signed Message:\\n32\", _signHash),\n                _v,\n                _r,\n                _s\n                )\n            );\n        require(keys[_key].purpose != 0);\n        _;\n    }\n\n    function Identity() public {\n        _constructIdentity(msg.sender);\n    }    \n\n    function () \n        public \n        payable \n    {\n\n    }\n\n    function managerReset(address _newKey) \n        public \n        recoveryOnly\n    {\n        recoveryManager = _newKey;\n        _addKey(bytes32(recoveryManager), MANAGEMENT_KEY, 0);\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = keysByPurpose[MANAGEMENT_KEY].length;\n    }\n    \n    function processManagerReset(uint256 _limit) \n        public \n    {\n        require(recoveryManager != address(0));\n        uint limit = _limit;\n        bytes32 newKey = bytes32(recoveryManager);\n        bytes32[] memory managers = keysByPurpose[MANAGEMENT_KEY];\n        uint256 totalManagers = managers.length;\n        \n        if (limit == 0) {\n            limit = totalManagers;\n        }\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = totalManagers - limit + 1;\n        for (uint256 i = 0; i < limit; i++) {\n            bytes32 manager = managers[i];\n            if (manager != newKey) {\n                _removeKey(manager, MANAGEMENT_KEY);\n                totalManagers--;\n            }\n        }\n\n        if (totalManagers == 1) {\n            recoveryManager = address(0);\n        }\n    }\n\n    function addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {   \n        _addKey(_key, _purpose, _type);\n        return true;\n    }\n\n    function replaceKey(\n        bytes32 _oldKey,\n        bytes32 _newKey,\n        uint256 _newType\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        uint256 purpose = keys[_oldKey].purpose;\n        _addKey(_newKey, purpose, _newType);\n        _removeKey(_oldKey, purpose);\n        return true;\n    } \n\n    function removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        public\n        managementOnly\n        returns (bool success)\n    {\n        _removeKey(_key, _purpose);\n        return true;\n    }\n\n    function execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        public \n        returns (uint256 executionId)\n    {\n        uint256 requiredKey = _to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n        if (minimumApprovalsByKeyPurpose[requiredKey] == 1) {\n            executionId = nonce; //(?) useless in this case\n            nonce++; //(?) should increment\n            require(isKeyPurpose(bytes32(msg.sender), requiredKey));\n            _to.call.value(_value)(_data); //(?) success not used\n            emit Executed(executionId, _to, _value, _data); //no information on success\n        } else {\n            executionId = _execute(_to, _value, _data);\n            approve(executionId, true);\n        }\n        \n    }\n\n    function approve(uint256 _id, bool _approval) \n        public \n        managerOrActor(bytes32(msg.sender))\n        returns (bool success)\n    {   \n        return _approve(bytes32(msg.sender), _id, _approval);\n    }\n\n    function setMinimumApprovalsByKeyType(\n        uint256 _purpose,\n        uint256 _minimumApprovals\n    ) \n        public \n        managementOnly\n    {\n        require(_minimumApprovals > 0);\n        require(_minimumApprovals <= keysByPurpose[_purpose].length);\n        minimumApprovalsByKeyPurpose[_purpose] = _minimumApprovals;\n    }\n    \n    \n    function addClaim(\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        public \n        returns (bytes32 claimHash)\n    {\n        claimHash = keccak256(_issuer, _claimType);\n        if (msg.sender == address(this)) {\n            if (claims[claimHash].claimType > 0) {\n                _modifyClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            } else {\n                _includeClaim(claimHash, _claimType, _scheme, _issuer, _signature, _data, _uri);\n            }\n        } else {\n            require(_issuer == msg.sender);\n            require(isKeyPurpose(bytes32(msg.sender), CLAIM_SIGNER_KEY));\n            _execute(address(this), 0, msg.data);\n            emit ClaimRequested(\n                claimHash,\n                _claimType,\n                _scheme,\n                _issuer,\n                _signature,\n                _data,\n                _uri\n            );\n        }\n    }\n    \n    function removeClaim(bytes32 _claimId) \n        public \n        returns (bool success) \n    {\n        Claim memory c = claims[_claimId];\n        \n        require(\n            msg.sender == c.issuer ||\n            msg.sender == address(this)\n            );\n        \n        // MUST only be done by the issuer of the claim, or KEYS OF PURPOSE 1, or the identity itself.\n        // TODO If its the identity itself, the approval process will determine its approval.\n        \n        uint claimIdTypePos = indexes[_claimId];\n        delete indexes[_claimId];\n        bytes32[] storage claimsTypeArr = claimsByType[c.claimType];\n        bytes32 replacer = claimsTypeArr[claimsTypeArr.length-1];\n        claimsTypeArr[claimIdTypePos] = replacer;\n        indexes[replacer] = claimIdTypePos;\n        delete claims[_claimId];\n        claimsTypeArr.length--;\n        return true;\n    }\n\n    function getKey(\n        bytes32 _key,\n        uint256 _purpose\n    ) \n        public \n        constant \n        returns(uint256 purpose, uint256 keyType, bytes32 key) \n    {\n        Key storage myKey = keys[keccak256(_key, _purpose)];\n        return (myKey.purpose, myKey.keyType, myKey.key);\n    }\n    \n    function isKeyPurpose(bytes32 _key, uint256 _type) \n        public\n        constant \n        returns (bool)\n    {\n        return keys[keccak256(_key, _type)].purpose == _type;\n    }\n\n    function getKeyPurpose(bytes32 _key)\n        public \n        constant \n        returns(uint256[] purpose)\n    {\n        \n        uint256[] memory purposeHolder = new uint256[](4);\n        uint8 counter = 0;\n        \n        if (isKeyPurpose(_key, MANAGEMENT_KEY)) {\n            purposeHolder[counter] = MANAGEMENT_KEY;\n            counter++;\n        }\n        \n        if (isKeyPurpose(_key, ACTION_KEY)) {\n            purposeHolder[counter] = ACTION_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, CLAIM_SIGNER_KEY)) {\n            purposeHolder[counter] = CLAIM_SIGNER_KEY;\n            counter++;\n        }\n            \n        if (isKeyPurpose(_key, ENCRYPTION_KEY)) {\n            purposeHolder[counter] = ENCRYPTION_KEY;\n            counter++;\n        }\n        \n        uint256[] memory result = new uint256[](counter);\n        for (uint8 i = 0; i < counter; i++) {\n            result[i] = purposeHolder[i];\n        }\n        \n        return result;\n    }\n    \n    function getKeysByPurpose(uint256 _purpose)\n        public\n        constant\n        returns(bytes32[])\n    {\n        return keysByPurpose[_purpose];\n    }\n    \n    function getClaim(bytes32 _claimId)\n        public\n        constant \n        returns(\n            uint256 claimType,\n            uint256 scheme,\n            address issuer,\n            bytes signature,\n            bytes data,\n            string uri\n            ) \n    {\n        Claim memory _claim = claims[_claimId];\n        return (_claim.claimType, _claim.scheme, _claim.issuer, _claim.signature, _claim.data, _claim.uri);\n    }\n    \n    function getClaimIdsByType(uint256 _claimType)\n        public\n        constant\n        returns(bytes32[] claimIds)\n    {\n        return claimsByType[_claimType];\n    }\n\n    function approveECDSA(\n        uint256 _id,\n        bool _approval,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this),\n                bytes4(keccak256(\"approve(uint256,bool)\")),\n                _id,\n                _approval\n                ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (bool success)\n    {   \n        return _approve(_key, _id, _approval);\n    }\n    \n    function executeECDSA(\n        address _to,\n        uint256 _value,\n        bytes _data,\n        uint _nonce,\n        bytes32 _key, \n        uint8 _v, \n        bytes32 _r, \n        bytes32 _s\n    ) \n        public \n        validECDSAKey(\n            _key,\n            keccak256(\n                address(this), \n                bytes4(keccak256(\"execute(address,uint256,bytes)\")), \n                _to,\n                _value,\n                _data,\n                _nonce\n            ),\n            _v,\n            _r,\n            _s\n        )\n        managerOrActor(_key)\n        returns (uint256 executionId)\n    {\n        executionId = _execute(_to, _value, _data);\n        _approve(_key, executionId, true);\n    }\n\n    function setupRecovery(address _recoveryContract) \n        public\n        managementOnly\n    {\n        require(recoveryContract == address(0));\n        recoveryContract = _recoveryContract;\n    }\n    \n    function _constructIdentity(address _manager)\n        internal \n    {\n        require(keysByPurpose[MANAGEMENT_KEY].length == 0);\n        require(minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] == 0);\n        _addKey(bytes32(_manager), MANAGEMENT_KEY, 0);\n\n        minimumApprovalsByKeyPurpose[MANAGEMENT_KEY] = 1;\n        minimumApprovalsByKeyPurpose[ACTION_KEY] = 1;\n    }\n\n    function _execute(\n        address _to,\n        uint256 _value,\n        bytes _data\n    ) \n        private\n        returns (uint256 executionId)\n    {\n        executionId = nonce;\n        nonce++;\n        txx[executionId] = Transaction({\n            valid: true,\n            to: _to,\n            value: _value,\n            data: _data,\n            nonce: nonce,\n            approverCount: 0\n        });            \n        emit ExecutionRequested(executionId, _to, _value, _data);\n    }\n    \n    function _approve(\n        bytes32 _key,\n        uint256 _id,\n        bool _approval\n    ) \n        private \n        returns(bool success) //(?) should return approved instead of success?\n    {\n        \n        Transaction memory trx = txx[_id];\n        require(trx.valid);\n        uint256 requiredKeyPurpose = trx.to == address(this) ? MANAGEMENT_KEY : ACTION_KEY;\n        require(isKeyPurpose(_key, requiredKeyPurpose));\n        bytes32 keyHash = keccak256(_key, requiredKeyPurpose);\n        require(txx[_id].approvals[keyHash] != _approval);\n        \n        if (_approval) {\n            trx.approverCount++;\n        } else {\n            trx.approverCount--;\n        }\n    \n        emit Approved(_id, _approval);\n\n        if (trx.approverCount < minimumApprovalsByKeyPurpose[requiredKeyPurpose]) {\n            txx[_id].approvals[keyHash] = _approval;\n            txx[_id] = trx;\n        } else {\n            delete txx[_id];\n            //(?) success should be included in event?\n            success = address(trx.to).call.value(trx.value)(trx.data);\n            emit Executed(_id, trx.to, trx.value, trx.data);\n            \n        }\n    }\n\n    function _addKey(\n        bytes32 _key,\n        uint256 _purpose,\n        uint256 _type\n    ) \n        private\n    {\n        bytes32 keyHash = keccak256(_key, _purpose);\n        \n        require(keys[keyHash].purpose == 0);\n        require(\n            _purpose == MANAGEMENT_KEY ||\n            _purpose == ACTION_KEY ||\n            _purpose == CLAIM_SIGNER_KEY ||\n            _purpose == ENCRYPTION_KEY\n        );\n        keys[keyHash] = Key(_purpose, _type, _key);\n        indexes[keyHash] = keysByPurpose[_purpose].push(_key) - 1;\n        emit KeyAdded(_key, _purpose, _type);\n    }\n\n    function _removeKey(\n        bytes32 _key,\n        uint256 _purpose\n    )\n        private \n    {\n        if (_purpose == MANAGEMENT_KEY) {\n            require(keysByPurpose[MANAGEMENT_KEY].length > minimumApprovalsByKeyPurpose[MANAGEMENT_KEY]);\n        }\n\n        bytes32 keyHash = keccak256(_key, _purpose);\n        Key memory myKey = keys[keyHash];\n        uint index = indexes[keyHash];\n        bytes32 indexReplacer = keysByPurpose[_purpose][keysByPurpose[_purpose].length - 1];\n        \n        keysByPurpose[_purpose][index] = indexReplacer;\n        indexes[keccak256(indexReplacer, _purpose)] = index;\n        keysByPurpose[_purpose].length--;\n\n        delete indexes[keyHash];\n        delete keys[keyHash];\n\n        emit KeyRemoved(myKey.key, myKey.purpose, myKey.keyType);\n    }\n\n    function _includeClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        claims[_claimHash] = Claim(\n            {\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n            }\n        );\n        indexes[_claimHash] = claimsByType[_claimType].length;\n        claimsByType[_claimType].push(_claimHash);\n        emit ClaimAdded(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n    function _modifyClaim(\n        bytes32 _claimHash,\n        uint256 _claimType,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    ) \n        private\n    {\n        require(msg.sender == _issuer);\n        claims[_claimHash] = Claim({\n            claimType: _claimType,\n            scheme: _scheme,\n            issuer: _issuer,\n            signature: _signature,\n            data: _data,\n            uri: _uri\n        });\n        emit ClaimChanged(\n            _claimHash,\n            _claimType,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n\n}\n\n", "commit_id": "8752bd114f51ea24047fd4c131c9fc6629f10953"}}