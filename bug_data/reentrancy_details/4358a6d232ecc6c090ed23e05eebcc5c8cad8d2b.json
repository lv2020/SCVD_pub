{"filename": "contracts/Marketplace.sol", "patch": "@@ -228,8 +228,8 @@ contract Marketplace is Ownable {\n     }\n     \n     function cashoutCommission() public payable onlyOwner {\n-        owner.transfer(commission);\n         commission = 0;\n+        owner.transfer(commission);\n     }\n     \n     function viewCommission() public view onlyOwner returns (uint) {\n@@ -241,7 +241,7 @@ contract Marketplace is Ownable {\n     }\n     \n     function removeItemForSale(address sellerAddress, uint index)\n-        private\n+        internal\n     {\n         Item memory item = users[sellerAddress].itemsForSale[index];\n ", "project_link": "https://github.com/jech320/marketplace/commit/fe455ae4e14cb0750c080591216f0de8359cd5ac", "bug_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport { Ownable } from \"./Ownable.sol\";\nimport { SafeMathLib } from \"./SafeMathLib.sol\";\n\ncontract Marketplace is Ownable {\n    event LogUserRegistration(\n      address indexed userAddress,\n      uint role,\n      string contactEmail,\n      string contactNumber\n    );\n    event LogItemForSaleAddition(\n      address indexed sellerAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageAddition(\n      address indexed sellerAddress,\n      uint index,\n      string imageIpfsHash\n    );\n    event LogItemForSaleUpdate(\n      address indexed sellerAddress,\n      uint index,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleDeletion(\n      address indexed userAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageDeletion(\n      address indexed sellerAddress,\n      string imageIpfsHash\n    );\n    event LogItemPurchase(\n      address indexed buyerAddress,\n      address sellerAddress,\n      string name,\n      string description,\n      uint cutPrice,\n      uint commission\n    );\n\n    enum Role { Buyer, Seller }\n    uint private commission;\n    string[] public roles;\n    address[] public userAddressIndices;\n    mapping (address => User) private users;\n    \n    constructor() public payable {\n        roles.push(\"Buyer\");\n        roles.push(\"Seller\");\n    }\n    \n    struct User {\n        bool isExist;\n        Role role;\n        Contact contact;\n        Item[] itemsBought;\n        Item[] itemsForSale;\n    }\n    \n    struct Contact {\n        string email;\n        string number;\n    }\n    \n    struct Item {\n        string name;\n        string description;\n        string[] imageIpfsHashes;\n        uint price;\n    }\n    \n    modifier onlySeller() {\n        require(users[msg.sender].role == Role.Seller,\n            \"Error: Seller only\");\n        _;\n    }\n    \n    modifier onlyBuyer() {\n        require(users[msg.sender].isExist\n          && users[msg.sender].role == Role.Buyer,\n            \"Error: Buyer only\");\n        _;\n    }\n    \n    modifier onlyRegistered() {\n        require(users[msg.sender].isExist,\n            \"Error: Registered users only\");\n        _;\n    }\n    \n    function registerUser(Role role, string email, string number) public {\n        users[msg.sender].role = role;\n        users[msg.sender].isExist = true;\n        users[msg.sender].contact.email = email;\n        users[msg.sender].contact.number = number;\n        userAddressIndices.push(msg.sender);\n        \n        emit LogUserRegistration(msg.sender, uint(role), email, number);\n    }\n\n    function getUserAddress(uint index) public view returns (address) {\n      return userAddressIndices[index];\n    }\n\n    function getUserAddressIndicesCount() public view returns (uint) {\n      return userAddressIndices.length;\n    }\n    \n    function addItemForSale(string name, string description, uint price)\n        public\n        onlySeller\n    {\n        string[] memory imageIpfsHashes;\n\n        require(price > 0,\n          \"Item price should be at least 1\");\n\n        Item memory item = Item({\n            name: name,\n            description: description,\n            imageIpfsHashes: imageIpfsHashes,\n            price: price\n        });\n\n        users[msg.sender].itemsForSale.push(item);\n\n        emit LogItemForSaleAddition(\n          msg.sender,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function addImageForItemForSale(uint index, string imageIpfsHash)\n        public\n        onlySeller\n    {\n        users[msg.sender].itemsForSale[index].imageIpfsHashes.push(imageIpfsHash);\n\n        emit LogItemForSaleImageAddition(\n          msg.sender,\n          index,\n          imageIpfsHash\n        );\n    }\n    \n    function getItemForSaleCount(address sellerAddress)\n        public\n        view\n        returns (uint)\n    {\n        return users[sellerAddress].itemsForSale.length;\n    }\n    \n    function getItemForSale(address sellerAddress, uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[sellerAddress].itemsForSale[index].name,    \n            users[sellerAddress].itemsForSale[index].description,\n            users[sellerAddress].itemsForSale[index].price\n        );\n    }\n    \n    function getItemForSaleImageCount(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemForSaleImage(\n        address sellerAddress,\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n\n    function purchaseItem(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        payable\n        onlyBuyer\n    {\n        Item memory item = users[sellerAddress].itemsForSale[itemIndex];\n\n        require(msg.value == item.price,\n            \"Input exact amount of item price to purchase\");\n        \n        uint cutPrice = SafeMathLib.divide(SafeMathLib.multiply(item.price, 95), 100);\n        uint itemCommission = SafeMathLib.subtract(item.price, cutPrice);\n        commission = SafeMathLib.add(commission, itemCommission);\n        sellerAddress.transfer(cutPrice);\n        removeItemForSale(sellerAddress, itemIndex);\n        users[msg.sender].itemsBought.push(item);\n\n        emit LogItemPurchase(\n          msg.sender,\n          sellerAddress,\n          item.name,\n          item.description,\n          cutPrice,\n          commission\n        );\n    }\n    \n    function cashoutCommission() public payable onlyOwner {\n        owner.transfer(commission);\n        commission = 0;\n    }\n    \n    function viewCommission() public view onlyOwner returns (uint) {\n        return commission;\n    }\n    \n    function removeItemForSaleBySeller(uint index) public onlySeller {\n        removeItemForSale(msg.sender, index);\n    }\n    \n    function removeItemForSale(address sellerAddress, uint index)\n        private\n    {\n        Item memory item = users[sellerAddress].itemsForSale[index];\n\n        emit LogItemForSaleDeletion(\n          msg.sender,\n          item.name,\n          item.description,\n          item.price\n        );\n\n        uint arrLength = users[sellerAddress].itemsForSale.length;\n        users[sellerAddress].itemsForSale[index] = users[sellerAddress].itemsForSale[arrLength - 1];\n        users[sellerAddress].itemsForSale.length--;\n    }\n    \n    function updateItemForSale(\n        uint index,\n        string name,\n        string description,\n        uint price\n    ) public onlySeller {\n        users[msg.sender].itemsForSale[index].name = name;\n        users[msg.sender].itemsForSale[index].description = description;\n        users[msg.sender].itemsForSale[index].price = price;\n    \n        emit LogItemForSaleUpdate(\n          msg.sender,\n          index,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function removeItemForSaleImage(uint itemIndex, uint imageIndex)\n        public\n        onlySeller\n    {\n        string memory imageIpfsHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex];\n\n        emit LogItemForSaleImageDeletion(msg.sender, imageIpfsHash);\n\n        uint arrLength = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length;\n        string memory lastImageHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[arrLength - 1];\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex] = lastImageHash;\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length--;\n    }\n    \n    function getSellerContact(address sellerAddress)\n        public\n        view\n        onlyRegistered\n        returns (string, string)\n    {\n        Contact memory sellerContact = users[sellerAddress].contact;\n        return (sellerContact.email, sellerContact.number);\n    }\n    \n    function getItemBought(uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[msg.sender].itemsBought[index].name,    \n            users[msg.sender].itemsBought[index].description,\n            users[msg.sender].itemsBought[index].price\n        );\n    }\n\n    function itemsBoughtCount()\n      public\n      view\n      returns (uint)\n    {\n      return users[msg.sender].itemsBought.length;\n    }\n    \n    function getItemBoughtImageCount(\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemBoughtImage(\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n}", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\ncontract Ownable {\n    event LogChangeOfOwnership(\n      address indexed owner,\n      address newOwner\n    );\n\n    address public owner;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        owner = newOwner;\n\n        emit LogChangeOfOwnership(owner, newOwner);\n    }\n}\npragma solidity ^0.4.24;\n\nlibrary SafeMathLib {\n    function multiply(uint a, uint b) public pure returns (uint) {\n        if (a == 0) {\n          return 0;\n        }\n        \n        uint c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function subtract(uint a, uint b) public pure returns (uint) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint a, uint b) public pure returns (uint) {\n        uint c = a + b;\n        require(c >= a && c >= b);\n        return c;\n    }\n    \n    function divide(uint a, uint b) public pure returns (uint256) {\n        uint c = a / b;\n        return c;\n    }\n}\n\ncontract Marketplace is Ownable {\n    event LogUserRegistration(\n      address indexed userAddress,\n      uint role,\n      string contactEmail,\n      string contactNumber\n    );\n    event LogItemForSaleAddition(\n      address indexed sellerAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageAddition(\n      address indexed sellerAddress,\n      uint index,\n      string imageIpfsHash\n    );\n    event LogItemForSaleUpdate(\n      address indexed sellerAddress,\n      uint index,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleDeletion(\n      address indexed userAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageDeletion(\n      address indexed sellerAddress,\n      string imageIpfsHash\n    );\n    event LogItemPurchase(\n      address indexed buyerAddress,\n      address sellerAddress,\n      string name,\n      string description,\n      uint cutPrice,\n      uint commission\n    );\n\n    enum Role { Buyer, Seller }\n    uint private commission;\n    string[] public roles;\n    address[] public userAddressIndices;\n    mapping (address => User) private users;\n    \n    constructor() public payable {\n        roles.push(\"Buyer\");\n        roles.push(\"Seller\");\n    }\n    \n    struct User {\n        bool isExist;\n        Role role;\n        Contact contact;\n        Item[] itemsBought;\n        Item[] itemsForSale;\n    }\n    \n    struct Contact {\n        string email;\n        string number;\n    }\n    \n    struct Item {\n        string name;\n        string description;\n        string[] imageIpfsHashes;\n        uint price;\n    }\n    \n    modifier onlySeller() {\n        require(users[msg.sender].role == Role.Seller,\n            \"Error: Seller only\");\n        _;\n    }\n    \n    modifier onlyBuyer() {\n        require(users[msg.sender].isExist\n          && users[msg.sender].role == Role.Buyer,\n            \"Error: Buyer only\");\n        _;\n    }\n    \n    modifier onlyRegistered() {\n        require(users[msg.sender].isExist,\n            \"Error: Registered users only\");\n        _;\n    }\n    \n    function registerUser(Role role, string email, string number) public {\n        users[msg.sender].role = role;\n        users[msg.sender].isExist = true;\n        users[msg.sender].contact.email = email;\n        users[msg.sender].contact.number = number;\n        userAddressIndices.push(msg.sender);\n        \n        emit LogUserRegistration(msg.sender, uint(role), email, number);\n    }\n\n    function getUserAddress(uint index) public view returns (address) {\n      return userAddressIndices[index];\n    }\n\n    function getUserAddressIndicesCount() public view returns (uint) {\n      return userAddressIndices.length;\n    }\n    \n    function addItemForSale(string name, string description, uint price)\n        public\n        onlySeller\n    {\n        string[] memory imageIpfsHashes;\n\n        require(price > 0,\n          \"Item price should be at least 1\");\n\n        Item memory item = Item({\n            name: name,\n            description: description,\n            imageIpfsHashes: imageIpfsHashes,\n            price: price\n        });\n\n        users[msg.sender].itemsForSale.push(item);\n\n        emit LogItemForSaleAddition(\n          msg.sender,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function addImageForItemForSale(uint index, string imageIpfsHash)\n        public\n        onlySeller\n    {\n        users[msg.sender].itemsForSale[index].imageIpfsHashes.push(imageIpfsHash);\n\n        emit LogItemForSaleImageAddition(\n          msg.sender,\n          index,\n          imageIpfsHash\n        );\n    }\n    \n    function getItemForSaleCount(address sellerAddress)\n        public\n        view\n        returns (uint)\n    {\n        return users[sellerAddress].itemsForSale.length;\n    }\n    \n    function getItemForSale(address sellerAddress, uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[sellerAddress].itemsForSale[index].name,    \n            users[sellerAddress].itemsForSale[index].description,\n            users[sellerAddress].itemsForSale[index].price\n        );\n    }\n    \n    function getItemForSaleImageCount(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemForSaleImage(\n        address sellerAddress,\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n\n    function purchaseItem(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        payable\n        onlyBuyer\n    {\n        Item memory item = users[sellerAddress].itemsForSale[itemIndex];\n\n        require(msg.value == item.price,\n            \"Input exact amount of item price to purchase\");\n        \n        uint cutPrice = SafeMathLib.divide(SafeMathLib.multiply(item.price, 95), 100);\n        uint itemCommission = SafeMathLib.subtract(item.price, cutPrice);\n        commission = SafeMathLib.add(commission, itemCommission);\n        sellerAddress.transfer(cutPrice);\n        removeItemForSale(sellerAddress, itemIndex);\n        users[msg.sender].itemsBought.push(item);\n\n        emit LogItemPurchase(\n          msg.sender,\n          sellerAddress,\n          item.name,\n          item.description,\n          cutPrice,\n          commission\n        );\n    }\n    \n    function cashoutCommission() public payable onlyOwner {\n        owner.transfer(commission);\n        commission = 0;\n    }\n    \n    function viewCommission() public view onlyOwner returns (uint) {\n        return commission;\n    }\n    \n    function removeItemForSaleBySeller(uint index) public onlySeller {\n        removeItemForSale(msg.sender, index);\n    }\n    \n    function removeItemForSale(address sellerAddress, uint index)\n        private\n    {\n        Item memory item = users[sellerAddress].itemsForSale[index];\n\n        emit LogItemForSaleDeletion(\n          msg.sender,\n          item.name,\n          item.description,\n          item.price\n        );\n\n        uint arrLength = users[sellerAddress].itemsForSale.length;\n        users[sellerAddress].itemsForSale[index] = users[sellerAddress].itemsForSale[arrLength - 1];\n        users[sellerAddress].itemsForSale.length--;\n    }\n    \n    function updateItemForSale(\n        uint index,\n        string name,\n        string description,\n        uint price\n    ) public onlySeller {\n        users[msg.sender].itemsForSale[index].name = name;\n        users[msg.sender].itemsForSale[index].description = description;\n        users[msg.sender].itemsForSale[index].price = price;\n    \n        emit LogItemForSaleUpdate(\n          msg.sender,\n          index,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function removeItemForSaleImage(uint itemIndex, uint imageIndex)\n        public\n        onlySeller\n    {\n        string memory imageIpfsHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex];\n\n        emit LogItemForSaleImageDeletion(msg.sender, imageIpfsHash);\n\n        uint arrLength = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length;\n        string memory lastImageHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[arrLength - 1];\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex] = lastImageHash;\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length--;\n    }\n    \n    function getSellerContact(address sellerAddress)\n        public\n        view\n        onlyRegistered\n        returns (string, string)\n    {\n        Contact memory sellerContact = users[sellerAddress].contact;\n        return (sellerContact.email, sellerContact.number);\n    }\n    \n    function getItemBought(uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[msg.sender].itemsBought[index].name,    \n            users[msg.sender].itemsBought[index].description,\n            users[msg.sender].itemsBought[index].price\n        );\n    }\n\n    function itemsBoughtCount()\n      public\n      view\n      returns (uint)\n    {\n      return users[msg.sender].itemsBought.length;\n    }\n    \n    function getItemBoughtImageCount(\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemBoughtImage(\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n}\n", "commit_id": "4358a6d232ecc6c090ed23e05eebcc5c8cad8d2b"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.24;\n\nimport { Ownable } from \"./Ownable.sol\";\nimport { SafeMathLib } from \"./SafeMathLib.sol\";\n\ncontract Marketplace is Ownable {\n    event LogUserRegistration(\n      address indexed userAddress,\n      uint role,\n      string contactEmail,\n      string contactNumber\n    );\n    event LogItemForSaleAddition(\n      address indexed sellerAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageAddition(\n      address indexed sellerAddress,\n      uint index,\n      string imageIpfsHash\n    );\n    event LogItemForSaleUpdate(\n      address indexed sellerAddress,\n      uint index,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleDeletion(\n      address indexed userAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageDeletion(\n      address indexed sellerAddress,\n      string imageIpfsHash\n    );\n    event LogItemPurchase(\n      address indexed buyerAddress,\n      address sellerAddress,\n      string name,\n      string description,\n      uint cutPrice,\n      uint commission\n    );\n\n    enum Role { Buyer, Seller }\n    uint private commission;\n    string[] public roles;\n    address[] public userAddressIndices;\n    mapping (address => User) private users;\n    \n    constructor() public payable {\n        roles.push(\"Buyer\");\n        roles.push(\"Seller\");\n    }\n    \n    struct User {\n        bool isExist;\n        Role role;\n        Contact contact;\n        Item[] itemsBought;\n        Item[] itemsForSale;\n    }\n    \n    struct Contact {\n        string email;\n        string number;\n    }\n    \n    struct Item {\n        string name;\n        string description;\n        string[] imageIpfsHashes;\n        uint price;\n    }\n    \n    modifier onlySeller() {\n        require(users[msg.sender].role == Role.Seller,\n            \"Error: Seller only\");\n        _;\n    }\n    \n    modifier onlyBuyer() {\n        require(users[msg.sender].isExist\n          && users[msg.sender].role == Role.Buyer,\n            \"Error: Buyer only\");\n        _;\n    }\n    \n    modifier onlyRegistered() {\n        require(users[msg.sender].isExist,\n            \"Error: Registered users only\");\n        _;\n    }\n    \n    function registerUser(Role role, string email, string number) public {\n        users[msg.sender].role = role;\n        users[msg.sender].isExist = true;\n        users[msg.sender].contact.email = email;\n        users[msg.sender].contact.number = number;\n        userAddressIndices.push(msg.sender);\n        \n        emit LogUserRegistration(msg.sender, uint(role), email, number);\n    }\n\n    function getUserAddress(uint index) public view returns (address) {\n      return userAddressIndices[index];\n    }\n\n    function getUserAddressIndicesCount() public view returns (uint) {\n      return userAddressIndices.length;\n    }\n    \n    function addItemForSale(string name, string description, uint price)\n        public\n        onlySeller\n    {\n        string[] memory imageIpfsHashes;\n\n        require(price > 0,\n          \"Item price should be at least 1\");\n\n        Item memory item = Item({\n            name: name,\n            description: description,\n            imageIpfsHashes: imageIpfsHashes,\n            price: price\n        });\n\n        users[msg.sender].itemsForSale.push(item);\n\n        emit LogItemForSaleAddition(\n          msg.sender,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function addImageForItemForSale(uint index, string imageIpfsHash)\n        public\n        onlySeller\n    {\n        users[msg.sender].itemsForSale[index].imageIpfsHashes.push(imageIpfsHash);\n\n        emit LogItemForSaleImageAddition(\n          msg.sender,\n          index,\n          imageIpfsHash\n        );\n    }\n    \n    function getItemForSaleCount(address sellerAddress)\n        public\n        view\n        returns (uint)\n    {\n        return users[sellerAddress].itemsForSale.length;\n    }\n    \n    function getItemForSale(address sellerAddress, uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[sellerAddress].itemsForSale[index].name,    \n            users[sellerAddress].itemsForSale[index].description,\n            users[sellerAddress].itemsForSale[index].price\n        );\n    }\n    \n    function getItemForSaleImageCount(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemForSaleImage(\n        address sellerAddress,\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n\n    function purchaseItem(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        payable\n        onlyBuyer\n    {\n        Item memory item = users[sellerAddress].itemsForSale[itemIndex];\n\n        require(msg.value == item.price,\n            \"Input exact amount of item price to purchase\");\n        \n        uint cutPrice = SafeMathLib.divide(SafeMathLib.multiply(item.price, 95), 100);\n        uint itemCommission = SafeMathLib.subtract(item.price, cutPrice);\n        commission = SafeMathLib.add(commission, itemCommission);\n        sellerAddress.transfer(cutPrice);\n        removeItemForSale(sellerAddress, itemIndex);\n        users[msg.sender].itemsBought.push(item);\n\n        emit LogItemPurchase(\n          msg.sender,\n          sellerAddress,\n          item.name,\n          item.description,\n          cutPrice,\n          commission\n        );\n    }\n    \n    function cashoutCommission() public payable onlyOwner {\n        commission = 0;\n        owner.transfer(commission);\n    }\n    \n    function viewCommission() public view onlyOwner returns (uint) {\n        return commission;\n    }\n    \n    function removeItemForSaleBySeller(uint index) public onlySeller {\n        removeItemForSale(msg.sender, index);\n    }\n    \n    function removeItemForSale(address sellerAddress, uint index)\n        internal\n    {\n        Item memory item = users[sellerAddress].itemsForSale[index];\n\n        emit LogItemForSaleDeletion(\n          msg.sender,\n          item.name,\n          item.description,\n          item.price\n        );\n\n        uint arrLength = users[sellerAddress].itemsForSale.length;\n        users[sellerAddress].itemsForSale[index] = users[sellerAddress].itemsForSale[arrLength - 1];\n        users[sellerAddress].itemsForSale.length--;\n    }\n    \n    function updateItemForSale(\n        uint index,\n        string name,\n        string description,\n        uint price\n    ) public onlySeller {\n        users[msg.sender].itemsForSale[index].name = name;\n        users[msg.sender].itemsForSale[index].description = description;\n        users[msg.sender].itemsForSale[index].price = price;\n    \n        emit LogItemForSaleUpdate(\n          msg.sender,\n          index,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function removeItemForSaleImage(uint itemIndex, uint imageIndex)\n        public\n        onlySeller\n    {\n        string memory imageIpfsHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex];\n\n        emit LogItemForSaleImageDeletion(msg.sender, imageIpfsHash);\n\n        uint arrLength = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length;\n        string memory lastImageHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[arrLength - 1];\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex] = lastImageHash;\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length--;\n    }\n    \n    function getSellerContact(address sellerAddress)\n        public\n        view\n        onlyRegistered\n        returns (string, string)\n    {\n        Contact memory sellerContact = users[sellerAddress].contact;\n        return (sellerContact.email, sellerContact.number);\n    }\n    \n    function getItemBought(uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[msg.sender].itemsBought[index].name,    \n            users[msg.sender].itemsBought[index].description,\n            users[msg.sender].itemsBought[index].price\n        );\n    }\n\n    function itemsBoughtCount()\n      public\n      view\n      returns (uint)\n    {\n      return users[msg.sender].itemsBought.length;\n    }\n    \n    function getItemBoughtImageCount(\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemBoughtImage(\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n}", "flattened_code": "pragma solidity ^0.4.24;\n\npragma solidity ^0.4.24;\n\ncontract Ownable {\n    event LogChangeOfOwnership(\n      address indexed owner,\n      address newOwner\n    );\n\n    address public owner;\n    \n    constructor() public {\n        owner = msg.sender;\n    }\n    \n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n    \n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        owner = newOwner;\n\n        emit LogChangeOfOwnership(owner, newOwner);\n    }\n}\npragma solidity ^0.4.24;\n\nlibrary SafeMathLib {\n    function multiply(uint a, uint b) public pure returns (uint) {\n        if (a == 0) {\n          return 0;\n        }\n        \n        uint c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    function subtract(uint a, uint b) public pure returns (uint) {\n        require(b <= a);\n        return a - b;\n    }\n\n    function add(uint a, uint b) public pure returns (uint) {\n        uint c = a + b;\n        require(c >= a && c >= b);\n        return c;\n    }\n    \n    function divide(uint a, uint b) public pure returns (uint256) {\n        uint c = a / b;\n        return c;\n    }\n}\n\ncontract Marketplace is Ownable {\n    event LogUserRegistration(\n      address indexed userAddress,\n      uint role,\n      string contactEmail,\n      string contactNumber\n    );\n    event LogItemForSaleAddition(\n      address indexed sellerAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageAddition(\n      address indexed sellerAddress,\n      uint index,\n      string imageIpfsHash\n    );\n    event LogItemForSaleUpdate(\n      address indexed sellerAddress,\n      uint index,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleDeletion(\n      address indexed userAddress,\n      string name,\n      string description,\n      uint price\n    );\n    event LogItemForSaleImageDeletion(\n      address indexed sellerAddress,\n      string imageIpfsHash\n    );\n    event LogItemPurchase(\n      address indexed buyerAddress,\n      address sellerAddress,\n      string name,\n      string description,\n      uint cutPrice,\n      uint commission\n    );\n\n    enum Role { Buyer, Seller }\n    uint private commission;\n    string[] public roles;\n    address[] public userAddressIndices;\n    mapping (address => User) private users;\n    \n    constructor() public payable {\n        roles.push(\"Buyer\");\n        roles.push(\"Seller\");\n    }\n    \n    struct User {\n        bool isExist;\n        Role role;\n        Contact contact;\n        Item[] itemsBought;\n        Item[] itemsForSale;\n    }\n    \n    struct Contact {\n        string email;\n        string number;\n    }\n    \n    struct Item {\n        string name;\n        string description;\n        string[] imageIpfsHashes;\n        uint price;\n    }\n    \n    modifier onlySeller() {\n        require(users[msg.sender].role == Role.Seller,\n            \"Error: Seller only\");\n        _;\n    }\n    \n    modifier onlyBuyer() {\n        require(users[msg.sender].isExist\n          && users[msg.sender].role == Role.Buyer,\n            \"Error: Buyer only\");\n        _;\n    }\n    \n    modifier onlyRegistered() {\n        require(users[msg.sender].isExist,\n            \"Error: Registered users only\");\n        _;\n    }\n    \n    function registerUser(Role role, string email, string number) public {\n        users[msg.sender].role = role;\n        users[msg.sender].isExist = true;\n        users[msg.sender].contact.email = email;\n        users[msg.sender].contact.number = number;\n        userAddressIndices.push(msg.sender);\n        \n        emit LogUserRegistration(msg.sender, uint(role), email, number);\n    }\n\n    function getUserAddress(uint index) public view returns (address) {\n      return userAddressIndices[index];\n    }\n\n    function getUserAddressIndicesCount() public view returns (uint) {\n      return userAddressIndices.length;\n    }\n    \n    function addItemForSale(string name, string description, uint price)\n        public\n        onlySeller\n    {\n        string[] memory imageIpfsHashes;\n\n        require(price > 0,\n          \"Item price should be at least 1\");\n\n        Item memory item = Item({\n            name: name,\n            description: description,\n            imageIpfsHashes: imageIpfsHashes,\n            price: price\n        });\n\n        users[msg.sender].itemsForSale.push(item);\n\n        emit LogItemForSaleAddition(\n          msg.sender,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function addImageForItemForSale(uint index, string imageIpfsHash)\n        public\n        onlySeller\n    {\n        users[msg.sender].itemsForSale[index].imageIpfsHashes.push(imageIpfsHash);\n\n        emit LogItemForSaleImageAddition(\n          msg.sender,\n          index,\n          imageIpfsHash\n        );\n    }\n    \n    function getItemForSaleCount(address sellerAddress)\n        public\n        view\n        returns (uint)\n    {\n        return users[sellerAddress].itemsForSale.length;\n    }\n    \n    function getItemForSale(address sellerAddress, uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[sellerAddress].itemsForSale[index].name,    \n            users[sellerAddress].itemsForSale[index].description,\n            users[sellerAddress].itemsForSale[index].price\n        );\n    }\n    \n    function getItemForSaleImageCount(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemForSaleImage(\n        address sellerAddress,\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[sellerAddress].itemsForSale[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n\n    function purchaseItem(\n        address sellerAddress,\n        uint itemIndex\n    )\n        public\n        payable\n        onlyBuyer\n    {\n        Item memory item = users[sellerAddress].itemsForSale[itemIndex];\n\n        require(msg.value == item.price,\n            \"Input exact amount of item price to purchase\");\n        \n        uint cutPrice = SafeMathLib.divide(SafeMathLib.multiply(item.price, 95), 100);\n        uint itemCommission = SafeMathLib.subtract(item.price, cutPrice);\n        commission = SafeMathLib.add(commission, itemCommission);\n        sellerAddress.transfer(cutPrice);\n        removeItemForSale(sellerAddress, itemIndex);\n        users[msg.sender].itemsBought.push(item);\n\n        emit LogItemPurchase(\n          msg.sender,\n          sellerAddress,\n          item.name,\n          item.description,\n          cutPrice,\n          commission\n        );\n    }\n    \n    function cashoutCommission() public payable onlyOwner {\n        commission = 0;\n        owner.transfer(commission);\n    }\n    \n    function viewCommission() public view onlyOwner returns (uint) {\n        return commission;\n    }\n    \n    function removeItemForSaleBySeller(uint index) public onlySeller {\n        removeItemForSale(msg.sender, index);\n    }\n    \n    function removeItemForSale(address sellerAddress, uint index)\n        internal\n    {\n        Item memory item = users[sellerAddress].itemsForSale[index];\n\n        emit LogItemForSaleDeletion(\n          msg.sender,\n          item.name,\n          item.description,\n          item.price\n        );\n\n        uint arrLength = users[sellerAddress].itemsForSale.length;\n        users[sellerAddress].itemsForSale[index] = users[sellerAddress].itemsForSale[arrLength - 1];\n        users[sellerAddress].itemsForSale.length--;\n    }\n    \n    function updateItemForSale(\n        uint index,\n        string name,\n        string description,\n        uint price\n    ) public onlySeller {\n        users[msg.sender].itemsForSale[index].name = name;\n        users[msg.sender].itemsForSale[index].description = description;\n        users[msg.sender].itemsForSale[index].price = price;\n    \n        emit LogItemForSaleUpdate(\n          msg.sender,\n          index,\n          name,\n          description,\n          price\n        );\n    }\n    \n    function removeItemForSaleImage(uint itemIndex, uint imageIndex)\n        public\n        onlySeller\n    {\n        string memory imageIpfsHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex];\n\n        emit LogItemForSaleImageDeletion(msg.sender, imageIpfsHash);\n\n        uint arrLength = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length;\n        string memory lastImageHash = users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[arrLength - 1];\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes[imageIndex] = lastImageHash;\n        users[msg.sender].itemsForSale[itemIndex].imageIpfsHashes.length--;\n    }\n    \n    function getSellerContact(address sellerAddress)\n        public\n        view\n        onlyRegistered\n        returns (string, string)\n    {\n        Contact memory sellerContact = users[sellerAddress].contact;\n        return (sellerContact.email, sellerContact.number);\n    }\n    \n    function getItemBought(uint index)\n        public\n        view\n        returns (string, string, uint)\n    {\n        return (\n            users[msg.sender].itemsBought[index].name,    \n            users[msg.sender].itemsBought[index].description,\n            users[msg.sender].itemsBought[index].price\n        );\n    }\n\n    function itemsBoughtCount()\n      public\n      view\n      returns (uint)\n    {\n      return users[msg.sender].itemsBought.length;\n    }\n    \n    function getItemBoughtImageCount(\n        uint itemIndex\n    )\n        public\n        view\n        returns (uint)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes.length);\n    }\n    \n    function getItemBoughtImage(\n        uint itemIndex,\n        uint imageIndex\n    )\n        public\n        view\n        returns (string)\n    {\n        return (users[msg.sender].itemsBought[itemIndex].imageIpfsHashes[imageIndex]);\n    }\n}\n", "commit_id": "fe455ae4e14cb0750c080591216f0de8359cd5ac"}}