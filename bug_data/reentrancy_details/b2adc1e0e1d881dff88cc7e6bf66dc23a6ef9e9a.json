{"filename": "contracts/Harvest.sol", "patch": "@@ -34,12 +34,11 @@ contract Harvest {\n             isStakable[_collection],\r\n             \"Harvest.harvest: collection isn't stakable\"\r\n         );\r\n-\r\n         require(paidFee[_user], \"Harvest.harvest: fee not paid\");\r\n \r\n-        llth.mint(_user, _rewards * (10**18));\r\n-\r\n         paidFee[_user] = false;\r\n+\r\n+        llth.mint(_user, _rewards * (10**18));\r\n     }\r\n \r\n     function setCollection(address _collection, bool _isStakable)\r", "project_link": "https://github.com/Cryptodemonz-Github/polygon-harvest/commit/b2adc1e0e1d881dff88cc7e6bf66dc23a6ef9e9a", "bug_version": {"raw_code": "pragma solidity ^0.8.12;\n\nimport \"./mocks/interfaces/IxLLTH.sol\";\n\ncontract Harvest {\n    IxLLTH public llth;\n    uint256 public currentHarvestFee;\n\n    mapping(address => bool) public isStakable;\n    mapping(address => bool) public paidFee;\n    mapping(address => bool) public managers;\n\n    modifier onlyManager() {\n        require(managers[msg.sender], \"msg.sender isn't manager\");\n        _;\n    }\n\n    constructor(IxLLTH _llth) {\n        llth = _llth;\n        managers[msg.sender] = true;\n    }    \n\n    function payFee() public payable {\n        require(msg.value >= currentHarvestFee, \"Harvest.payFee: Fee not paid\");\n        paidFee[msg.sender] = true;\n    }\n\n    function harvest(\n        address _collection,\n        uint256 _rewards,\n        address _user\n    ) public onlyManager {\n        require(\n            isStakable[_collection],\n            \"Harvest.harvest: collection isn't stakable\"\n        );\n\n        require(paidFee[_user], \"Harvest.harvest: fee not paid\");\n\n        llth.mint(_user, _rewards * (10**18));\n\n        paidFee[_user] = false;\n    }\n\n    function setCollection(address _collection, bool _isStakable)\n        public\n        onlyManager\n    {\n        isStakable[_collection] = _isStakable;\n    }\n\n    function setManager(address _manager, bool _value) public onlyManager {\n        managers[_manager] = _value;\n    }\n\n    function setFee(uint256 _value) public onlyManager {\n        currentHarvestFee = _value;\n    }\n\n    function setLlth(IxLLTH _newLlth) public onlyManager {\n        llth = _newLlth;\n    }\n}\n", "flattened_code": "pragma solidity ^0.8.12;\n\npragma solidity ^0.8.11;\n\ninterface IxLLTH {\n    function mint(address user, uint256 amount) external;\n}\n\ncontract Harvest {\n    IxLLTH public llth;\n    uint256 public currentHarvestFee;\n\n    mapping(address => bool) public isStakable;\n    mapping(address => bool) public paidFee;\n    mapping(address => bool) public managers;\n\n    modifier onlyManager() {\n        require(managers[msg.sender], \"msg.sender isn't manager\");\n        _;\n    }\n\n    constructor(IxLLTH _llth) {\n        llth = _llth;\n        managers[msg.sender] = true;\n    }    \n\n    function payFee() public payable {\n        require(msg.value >= currentHarvestFee, \"Harvest.payFee: Fee not paid\");\n        paidFee[msg.sender] = true;\n    }\n\n    function harvest(\n        address _collection,\n        uint256 _rewards,\n        address _user\n    ) public onlyManager {\n        require(\n            isStakable[_collection],\n            \"Harvest.harvest: collection isn't stakable\"\n        );\n\n        require(paidFee[_user], \"Harvest.harvest: fee not paid\");\n\n        llth.mint(_user, _rewards * (10**18));\n\n        paidFee[_user] = false;\n    }\n\n    function setCollection(address _collection, bool _isStakable)\n        public\n        onlyManager\n    {\n        isStakable[_collection] = _isStakable;\n    }\n\n    function setManager(address _manager, bool _value) public onlyManager {\n        managers[_manager] = _value;\n    }\n\n    function setFee(uint256 _value) public onlyManager {\n        currentHarvestFee = _value;\n    }\n\n    function setLlth(IxLLTH _newLlth) public onlyManager {\n        llth = _newLlth;\n    }\n}\n", "commit_id": "7519197d349cbbd979fddd787e0af1fb00706dc1"}, "fixed_version": {"raw_code": "pragma solidity ^0.8.12;\n\nimport \"./mocks/interfaces/IxLLTH.sol\";\n\ncontract Harvest {\n    IxLLTH public llth;\n    uint256 public currentHarvestFee;\n\n    mapping(address => bool) public isStakable;\n    mapping(address => bool) public paidFee;\n    mapping(address => bool) public managers;\n\n    modifier onlyManager() {\n        require(managers[msg.sender], \"msg.sender isn't manager\");\n        _;\n    }\n\n    constructor(IxLLTH _llth) {\n        llth = _llth;\n        managers[msg.sender] = true;\n    }    \n\n    function payFee() public payable {\n        require(msg.value >= currentHarvestFee, \"Harvest.payFee: Fee not paid\");\n        paidFee[msg.sender] = true;\n    }\n\n    function harvest(\n        address _collection,\n        uint256 _rewards,\n        address _user\n    ) public onlyManager {\n        require(\n            isStakable[_collection],\n            \"Harvest.harvest: collection isn't stakable\"\n        );\n        require(paidFee[_user], \"Harvest.harvest: fee not paid\");\n\n        paidFee[_user] = false;\n\n        llth.mint(_user, _rewards * (10**18));\n    }\n\n    function setCollection(address _collection, bool _isStakable)\n        public\n        onlyManager\n    {\n        isStakable[_collection] = _isStakable;\n    }\n\n    function setManager(address _manager, bool _value) public onlyManager {\n        managers[_manager] = _value;\n    }\n\n    function setFee(uint256 _value) public onlyManager {\n        currentHarvestFee = _value;\n    }\n\n    function setLlth(IxLLTH _newLlth) public onlyManager {\n        llth = _newLlth;\n    }\n}\n", "flattened_code": "pragma solidity ^0.8.12;\n\npragma solidity ^0.8.11;\n\ninterface IxLLTH {\n    function mint(address user, uint256 amount) external;\n}\n\ncontract Harvest {\n    IxLLTH public llth;\n    uint256 public currentHarvestFee;\n\n    mapping(address => bool) public isStakable;\n    mapping(address => bool) public paidFee;\n    mapping(address => bool) public managers;\n\n    modifier onlyManager() {\n        require(managers[msg.sender], \"msg.sender isn't manager\");\n        _;\n    }\n\n    constructor(IxLLTH _llth) {\n        llth = _llth;\n        managers[msg.sender] = true;\n    }    \n\n    function payFee() public payable {\n        require(msg.value >= currentHarvestFee, \"Harvest.payFee: Fee not paid\");\n        paidFee[msg.sender] = true;\n    }\n\n    function harvest(\n        address _collection,\n        uint256 _rewards,\n        address _user\n    ) public onlyManager {\n        require(\n            isStakable[_collection],\n            \"Harvest.harvest: collection isn't stakable\"\n        );\n        require(paidFee[_user], \"Harvest.harvest: fee not paid\");\n\n        paidFee[_user] = false;\n\n        llth.mint(_user, _rewards * (10**18));\n    }\n\n    function setCollection(address _collection, bool _isStakable)\n        public\n        onlyManager\n    {\n        isStakable[_collection] = _isStakable;\n    }\n\n    function setManager(address _manager, bool _value) public onlyManager {\n        managers[_manager] = _value;\n    }\n\n    function setFee(uint256 _value) public onlyManager {\n        currentHarvestFee = _value;\n    }\n\n    function setLlth(IxLLTH _newLlth) public onlyManager {\n        llth = _newLlth;\n    }\n}\n", "commit_id": "b2adc1e0e1d881dff88cc7e6bf66dc23a6ef9e9a"}}