{"filename": "contracts/SimpleBank.sol", "patch": "@@ -1,7 +1,9 @@\n // SPDX-License-Identifier: UNLICENSED\n pragma solidity ^0.8.4;\n \n-contract SimpleBank {\n+import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n+\n+contract SimpleBank is ReentrancyGuard {\n     //\n     // State variables\n     //\n@@ -82,8 +84,6 @@ contract SimpleBank {\n     function withdraw(uint _withdrawAmount)\n       external\n       isEnrolled\n-      amountIsGreaterZero(_withdrawAmount)\n-      hasAmountForWithdraw(_withdrawAmount)\n       returns (uint)\n     {\n       bool result = _withdraw(_withdrawAmount);\n@@ -98,7 +98,6 @@ contract SimpleBank {\n     function withdrawAll()\n       external\n       isEnrolled\n-      amountIsGreaterZero(balances[msg.sender])\n       returns (bool)\n     {\n       bool result = _withdraw(balances[msg.sender]);\n@@ -108,9 +107,10 @@ contract SimpleBank {\n \n     function _withdraw(uint _withdrawAmount)\n       private\n+      nonReentrant\n       isEnrolled\n-      hasAmountForWithdraw(_withdrawAmount)\n       amountIsGreaterZero(_withdrawAmount)\n+      hasAmountForWithdraw(_withdrawAmount)\n       returns(bool)\n     {\n       uint newBalance = balances[msg.sender] - _withdrawAmount;", "project_link": "https://github.com/fkmurphy/SimpleBank/commit/eee8e44ab6bdd598dcf9a65a33d9d8a59a0d9e5e", "bug_version": {"raw_code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ncontract SimpleBank {\n    //\n    // State variables\n    //\n\n    /* We want to protect our users balance from other contracts */\n    mapping(address => uint) balances;\n\n    /* We want to create a getter function and allow\n    contracts to be able to see if a user is enrolled.  */\n    mapping(address => bool) enrolled;\n\n    /* Let's make sure everyone knows who owns the bank. */\n    address immutable public owner;\n\n    //\n    // Events\n    //\n\n    event LogEnrolled(address indexed newCustomer);\n\n    event LogDepositMade(address indexed customer, uint indexed amount);\n\n    event LogWithdraw(address indexed customer, uint indexed amount, uint indexed balance);\n\n\n\n    //\n    // Functions\n    //\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n\n    // Function to receive Ether\n    receive() external payable {}\n\n\n    /// @notice Get balance\n    /// @return The balance of the user\n    function getBalance() external view isEnrolled returns(uint){\n      return balances[msg.sender];\n    }\n\n    /// @notice Enroll a customer with the bank\n    /// @return The users enrolled status\n    // Emit the appropriate event\n    function enroll() public returns (bool) {\n        require(!enrolled[msg.sender], \"User already enrolled\");\n        emit LogEnrolled(msg.sender);\n        enrolled[msg.sender] = true;\n\n        return true;\n    }\n\n    /// @notice Deposit ether into bank\n    /// @return The balance of the user after the deposit is made\n    // This function can receive ether\n    // Users should be enrolled before they can make deposits\n    function deposit()\n      external\n      payable\n      isEnrolled\n      amountIsGreaterZero(msg.value)\n      returns (uint)\n    {\n      emit LogDepositMade(msg.sender, msg.value);\n      balances[msg.sender] += msg.value;\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw ether from bank\n    /// @param _withdrawAmount amount you want to withdraw\n    /// @return The balance remaining for the user\n    // Emit the appropriate event\n    function withdraw(uint _withdrawAmount)\n      external\n      isEnrolled\n      amountIsGreaterZero(_withdrawAmount)\n      hasAmountForWithdraw(_withdrawAmount)\n      returns (uint)\n    {\n      bool result = _withdraw(_withdrawAmount);\n      require(result, \"Failed withdraw amount\");\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw remaining ether from bank\n    /// @return bool transaction success\n    // Emit the appropriate event\n    function withdrawAll()\n      external\n      isEnrolled\n      amountIsGreaterZero(balances[msg.sender])\n      returns (bool)\n    {\n      bool result = _withdraw(balances[msg.sender]);\n      require(result, \"Failed withdraw all amount\");\n      return result;\n    }\n\n    function _withdraw(uint _withdrawAmount)\n      private\n      isEnrolled\n      hasAmountForWithdraw(_withdrawAmount)\n      amountIsGreaterZero(_withdrawAmount)\n      returns(bool)\n    {\n      uint newBalance = balances[msg.sender] - _withdrawAmount;\n      emit LogWithdraw(msg.sender, _withdrawAmount, newBalance);\n      balances[msg.sender] = newBalance;\n      (bool result,) = msg.sender.call{value: _withdrawAmount}(\"\");\n      require(result, \"Failed withdraw amount\");\n      return result;\n    }\n\n    modifier isEnrolled() {\n      require(enrolled[msg.sender], 'need enrollment');\n      _;\n    }\n\n    modifier hasAmountForWithdraw(uint _withdrawAmount) {\n      require(balances[msg.sender] >= _withdrawAmount, \"Insufficient balance\");\n      _;\n    }\n    \n    modifier amountIsGreaterZero(uint _amount) {\n      require(_amount > 0, \"Amount must be > 0\");\n      _;\n    }\n\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\ncontract SimpleBank {\n    //\n    // State variables\n    //\n\n    /* We want to protect our users balance from other contracts */\n    mapping(address => uint) balances;\n\n    /* We want to create a getter function and allow\n    contracts to be able to see if a user is enrolled.  */\n    mapping(address => bool) enrolled;\n\n    /* Let's make sure everyone knows who owns the bank. */\n    address immutable public owner;\n\n    //\n    // Events\n    //\n\n    event LogEnrolled(address indexed newCustomer);\n\n    event LogDepositMade(address indexed customer, uint indexed amount);\n\n    event LogWithdraw(address indexed customer, uint indexed amount, uint indexed balance);\n\n\n\n    //\n    // Functions\n    //\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n\n    // Function to receive Ether\n    receive() external payable {}\n\n\n    /// @notice Get balance\n    /// @return The balance of the user\n    function getBalance() external view isEnrolled returns(uint){\n      return balances[msg.sender];\n    }\n\n    /// @notice Enroll a customer with the bank\n    /// @return The users enrolled status\n    // Emit the appropriate event\n    function enroll() public returns (bool) {\n        require(!enrolled[msg.sender], \"User already enrolled\");\n        emit LogEnrolled(msg.sender);\n        enrolled[msg.sender] = true;\n\n        return true;\n    }\n\n    /// @notice Deposit ether into bank\n    /// @return The balance of the user after the deposit is made\n    // This function can receive ether\n    // Users should be enrolled before they can make deposits\n    function deposit()\n      external\n      payable\n      isEnrolled\n      amountIsGreaterZero(msg.value)\n      returns (uint)\n    {\n      emit LogDepositMade(msg.sender, msg.value);\n      balances[msg.sender] += msg.value;\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw ether from bank\n    /// @param _withdrawAmount amount you want to withdraw\n    /// @return The balance remaining for the user\n    // Emit the appropriate event\n    function withdraw(uint _withdrawAmount)\n      external\n      isEnrolled\n      amountIsGreaterZero(_withdrawAmount)\n      hasAmountForWithdraw(_withdrawAmount)\n      returns (uint)\n    {\n      bool result = _withdraw(_withdrawAmount);\n      require(result, \"Failed withdraw amount\");\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw remaining ether from bank\n    /// @return bool transaction success\n    // Emit the appropriate event\n    function withdrawAll()\n      external\n      isEnrolled\n      amountIsGreaterZero(balances[msg.sender])\n      returns (bool)\n    {\n      bool result = _withdraw(balances[msg.sender]);\n      require(result, \"Failed withdraw all amount\");\n      return result;\n    }\n\n    function _withdraw(uint _withdrawAmount)\n      private\n      isEnrolled\n      hasAmountForWithdraw(_withdrawAmount)\n      amountIsGreaterZero(_withdrawAmount)\n      returns(bool)\n    {\n      uint newBalance = balances[msg.sender] - _withdrawAmount;\n      emit LogWithdraw(msg.sender, _withdrawAmount, newBalance);\n      balances[msg.sender] = newBalance;\n      (bool result,) = msg.sender.call{value: _withdrawAmount}(\"\");\n      require(result, \"Failed withdraw amount\");\n      return result;\n    }\n\n    modifier isEnrolled() {\n      require(enrolled[msg.sender], 'need enrollment');\n      _;\n    }\n\n    modifier hasAmountForWithdraw(uint _withdrawAmount) {\n      require(balances[msg.sender] >= _withdrawAmount, \"Insufficient balance\");\n      _;\n    }\n    \n    modifier amountIsGreaterZero(uint _amount) {\n      require(_amount > 0, \"Amount must be > 0\");\n      _;\n    }\n\n}\n", "commit_id": "93cdcf57e2061c6ea8840933c71c8e616bf69bb2"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SimpleBank is ReentrancyGuard {\n    //\n    // State variables\n    //\n\n    /* We want to protect our users balance from other contracts */\n    mapping(address => uint) balances;\n\n    /* We want to create a getter function and allow\n    contracts to be able to see if a user is enrolled.  */\n    mapping(address => bool) enrolled;\n\n    /* Let's make sure everyone knows who owns the bank. */\n    address immutable public owner;\n\n    //\n    // Events\n    //\n\n    event LogEnrolled(address indexed newCustomer);\n\n    event LogDepositMade(address indexed customer, uint indexed amount);\n\n    event LogWithdraw(address indexed customer, uint indexed amount, uint indexed balance);\n\n\n\n    //\n    // Functions\n    //\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n\n    // Function to receive Ether\n    receive() external payable {}\n\n\n    /// @notice Get balance\n    /// @return The balance of the user\n    function getBalance() external view isEnrolled returns(uint){\n      return balances[msg.sender];\n    }\n\n    /// @notice Enroll a customer with the bank\n    /// @return The users enrolled status\n    // Emit the appropriate event\n    function enroll() public returns (bool) {\n        require(!enrolled[msg.sender], \"User already enrolled\");\n        emit LogEnrolled(msg.sender);\n        enrolled[msg.sender] = true;\n\n        return true;\n    }\n\n    /// @notice Deposit ether into bank\n    /// @return The balance of the user after the deposit is made\n    // This function can receive ether\n    // Users should be enrolled before they can make deposits\n    function deposit()\n      external\n      payable\n      isEnrolled\n      amountIsGreaterZero(msg.value)\n      returns (uint)\n    {\n      emit LogDepositMade(msg.sender, msg.value);\n      balances[msg.sender] += msg.value;\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw ether from bank\n    /// @param _withdrawAmount amount you want to withdraw\n    /// @return The balance remaining for the user\n    // Emit the appropriate event\n    function withdraw(uint _withdrawAmount)\n      external\n      isEnrolled\n      returns (uint)\n    {\n      bool result = _withdraw(_withdrawAmount);\n      require(result, \"Failed withdraw amount\");\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw remaining ether from bank\n    /// @return bool transaction success\n    // Emit the appropriate event\n    function withdrawAll()\n      external\n      isEnrolled\n      returns (bool)\n    {\n      bool result = _withdraw(balances[msg.sender]);\n      require(result, \"Failed withdraw all amount\");\n      return result;\n    }\n\n    function _withdraw(uint _withdrawAmount)\n      private\n      nonReentrant\n      isEnrolled\n      amountIsGreaterZero(_withdrawAmount)\n      hasAmountForWithdraw(_withdrawAmount)\n      returns(bool)\n    {\n      uint newBalance = balances[msg.sender] - _withdrawAmount;\n      emit LogWithdraw(msg.sender, _withdrawAmount, newBalance);\n      balances[msg.sender] = newBalance;\n      (bool result,) = msg.sender.call{value: _withdrawAmount}(\"\");\n      require(result, \"Failed withdraw amount\");\n      return result;\n    }\n\n    modifier isEnrolled() {\n      require(enrolled[msg.sender], 'need enrollment');\n      _;\n    }\n\n    modifier hasAmountForWithdraw(uint _withdrawAmount) {\n      require(balances[msg.sender] >= _withdrawAmount, \"Insufficient balance\");\n      _;\n    }\n    \n    modifier amountIsGreaterZero(uint _amount) {\n      require(_amount > 0, \"Amount must be > 0\");\n      _;\n    }\n\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n// IGNORE_LICENSE-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n\ncontract SimpleBank is ReentrancyGuard {\n    //\n    // State variables\n    //\n\n    /* We want to protect our users balance from other contracts */\n    mapping(address => uint) balances;\n\n    /* We want to create a getter function and allow\n    contracts to be able to see if a user is enrolled.  */\n    mapping(address => bool) enrolled;\n\n    /* Let's make sure everyone knows who owns the bank. */\n    address immutable public owner;\n\n    //\n    // Events\n    //\n\n    event LogEnrolled(address indexed newCustomer);\n\n    event LogDepositMade(address indexed customer, uint indexed amount);\n\n    event LogWithdraw(address indexed customer, uint indexed amount, uint indexed balance);\n\n\n\n    //\n    // Functions\n    //\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n\n    // Function to receive Ether\n    receive() external payable {}\n\n\n    /// @notice Get balance\n    /// @return The balance of the user\n    function getBalance() external view isEnrolled returns(uint){\n      return balances[msg.sender];\n    }\n\n    /// @notice Enroll a customer with the bank\n    /// @return The users enrolled status\n    // Emit the appropriate event\n    function enroll() public returns (bool) {\n        require(!enrolled[msg.sender], \"User already enrolled\");\n        emit LogEnrolled(msg.sender);\n        enrolled[msg.sender] = true;\n\n        return true;\n    }\n\n    /// @notice Deposit ether into bank\n    /// @return The balance of the user after the deposit is made\n    // This function can receive ether\n    // Users should be enrolled before they can make deposits\n    function deposit()\n      external\n      payable\n      isEnrolled\n      amountIsGreaterZero(msg.value)\n      returns (uint)\n    {\n      emit LogDepositMade(msg.sender, msg.value);\n      balances[msg.sender] += msg.value;\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw ether from bank\n    /// @param _withdrawAmount amount you want to withdraw\n    /// @return The balance remaining for the user\n    // Emit the appropriate event\n    function withdraw(uint _withdrawAmount)\n      external\n      isEnrolled\n      returns (uint)\n    {\n      bool result = _withdraw(_withdrawAmount);\n      require(result, \"Failed withdraw amount\");\n\n      return balances[msg.sender];\n    }\n\n    /// @notice Withdraw remaining ether from bank\n    /// @return bool transaction success\n    // Emit the appropriate event\n    function withdrawAll()\n      external\n      isEnrolled\n      returns (bool)\n    {\n      bool result = _withdraw(balances[msg.sender]);\n      require(result, \"Failed withdraw all amount\");\n      return result;\n    }\n\n    function _withdraw(uint _withdrawAmount)\n      private\n      nonReentrant\n      isEnrolled\n      amountIsGreaterZero(_withdrawAmount)\n      hasAmountForWithdraw(_withdrawAmount)\n      returns(bool)\n    {\n      uint newBalance = balances[msg.sender] - _withdrawAmount;\n      emit LogWithdraw(msg.sender, _withdrawAmount, newBalance);\n      balances[msg.sender] = newBalance;\n      (bool result,) = msg.sender.call{value: _withdrawAmount}(\"\");\n      require(result, \"Failed withdraw amount\");\n      return result;\n    }\n\n    modifier isEnrolled() {\n      require(enrolled[msg.sender], 'need enrollment');\n      _;\n    }\n\n    modifier hasAmountForWithdraw(uint _withdrawAmount) {\n      require(balances[msg.sender] >= _withdrawAmount, \"Insufficient balance\");\n      _;\n    }\n    \n    modifier amountIsGreaterZero(uint _amount) {\n      require(_amount > 0, \"Amount must be > 0\");\n      _;\n    }\n\n}\n", "commit_id": "eee8e44ab6bdd598dcf9a65a33d9d8a59a0d9e5e"}}