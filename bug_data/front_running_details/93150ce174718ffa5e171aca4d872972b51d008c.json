{"filename": "contracts/identity/FriendsRecovery.sol", "patch": "@@ -134,7 +134,7 @@ contract FriendsRecovery {\n         require(_friendList.length >= threshold);\n         require(keccak256(identity, _revealedSecret) == secret);\n         revealed[_newSecret] = true;\n-        bytes32 _secretHash = keccak256(identity, _revealedSecret, _dest, _data);\n+        bytes32 _secretHash = keccak256(identity, _revealedSecret, _dest, _data, _newSecret, _newFriendsHashes);\n         \n         for (uint256 i = 0; i < threshold; i++) {\n             address friend = _friendList[i];", "project_link": "https://github.com/status-im/contracts/commit/341c0ae442678afc920a4a052043150065b72c64", "solc_version": "0.4.18", "packages": "", "bug_version": {"raw_code": "pragma solidity ^0.4.17;\n\ncontract FriendsRecovery {\n    \n    address private identity;\n    bytes32 private secret;\n    uint256 private threshold;\n    uint256 private setupDelay;\n    mapping(bytes32 => bool) private friendAllowed;\n    mapping(bytes32 => bool) private revealed;\n    mapping(bytes32 => mapping(address => bool)) private signed;\n    NewRecovery private pendingSetup;\n\n    struct NewRecovery {\n        uint256 addition;\n        bytes32 secret;\n        uint256 threshold;\n        uint256 setupDelay;\n        bytes32[] friends;\n    }\n\n    event SetupRequested(uint256 activation);\n    event Activated();\n    event Approved(bytes32 indexed secretHash, address approver);\n    event Execution(bool success);\n\n    modifier identityOnly() {\n        require(msg.sender == identity);\n        _;\n    }\n    modifier notRevealed(bytes32 secretHash) {\n        require(!revealed[secretHash]);\n        _;\n    }\n\n    function FriendsRecovery(\n        address _identity,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32 _secret,\n        bytes32[] _friendHashes\n        ) \n        public \n    {\n        identity = _identity;\n        threshold = _threshold;\n        secret = _secret;\n        setupDelay = _setupDelay;\n        addFriends(_friendHashes);\n    }\n\n    function withdraw() \n        external\n        identityOnly\n    {\n        identity.transfer(this.balance);\n    }\n\n    function cancelSetup() \n        external \n        identityOnly \n    {\n        delete pendingSetup;\n        SetupRequested(0);\n    }\n\n    function setup(\n        bytes32 _newSecret,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32[] _newFriendsHashes\n        )\n        external \n        identityOnly\n        notRevealed(_newSecret)\n    {\n        pendingSetup.addition = block.timestamp;\n        pendingSetup.secret = _newSecret;\n        pendingSetup.friends = _newFriendsHashes;\n        pendingSetup.threshold = _threshold;\n        pendingSetup.setupDelay = _setupDelay;\n        SetupRequested(block.timestamp + setupDelay);\n    }\n\n    function activate()\n        external\n    {\n        require(pendingSetup.addition > 0);\n        require(pendingSetup.addition + setupDelay <= block.timestamp);\n        threshold = pendingSetup.threshold;\n        setupDelay = pendingSetup.setupDelay;\n        secret = pendingSetup.secret;\n        addFriends(pendingSetup.friends);\n        delete pendingSetup;\n        Activated();\n    }\n\n    function approve(bytes32 _secretHash) \n        external \n    {\n        require(!signed[_secretHash][msg.sender]);\n        signed[_secretHash][msg.sender] = true;\n        Approved(_secretHash, msg.sender);\n    }\n\n    function approvePreSigned(bytes32 _secretHash, uint8[] _v, bytes32[] _r, bytes32[] _s) \n        external \n    {\n        uint256 len = _v.length;\n        require (_r.length == len);\n        require (_s.length == len);    \n        require (_v.length == len);    \n        bytes32 signatureHash = getSignHash(_secretHash); \n        for (uint256 i = 0; i < len; i++) {\n            address recovered = ecrecover(signatureHash, _v[i], _r[i], _s[i]);\n            require(!signed[_secretHash][recovered]);\n            require(recovered != address(0));\n            signed[_secretHash][recovered] = true;\n            Approved(_secretHash, recovered);\n        }        \n    }\n\n    function execute(\n        bytes32 _revealedSecret,\n        address _dest,\n        bytes _data,\n        address[] _friendList,\n        bytes32 _newSecret,\n        bytes32[] _newFriendsHashes\n        ) \n        external \n        notRevealed(_newSecret)\n    {\n        require(_friendList.length >= threshold);\n        require(keccak256(identity, _revealedSecret) == secret);\n        revealed[_newSecret] = true;\n        bytes32 _secretHash = keccak256(identity, _revealedSecret, _dest, _data);\n        \n        for (uint256 i = 0; i < threshold; i++) {\n            address friend = _friendList[i];\n            require(friend != address(0));\n            require(friendAllowed[keccak256(identity, _revealedSecret, friend)]);\n            require(signed[_secretHash][friend]);\n            delete signed[_secretHash][friend];\n        }\n\n        secret = _newSecret;\n        addFriends(_newFriendsHashes);\n\n        Execution(_dest.call(_data));\n    }\n\n    function addFriends(bytes32[] _newFriendsHashes) private {\n        uint256 len = _newFriendsHashes.length;\n        require(len >= threshold);\n        for (uint256 i = 0; i < len; i++) {\n            friendAllowed[_newFriendsHashes[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Hash a hash with `\"\\x19Ethereum Signed Message:\\n32\"`\n     * @param _hash Sign to hash.\n     * @return signHash Hash to be signed.\n     */\n    function getSignHash(\n        bytes32 _hash\n    )\n        pure\n        public\n        returns(bytes32 signHash)\n    {\n        signHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n    }\n\n   \n}", "flattened_code": "pragma solidity ^0.4.17;\n\ncontract FriendsRecovery {\n    \n    address private identity;\n    bytes32 private secret;\n    uint256 private threshold;\n    uint256 private setupDelay;\n    mapping(bytes32 => bool) private friendAllowed;\n    mapping(bytes32 => bool) private revealed;\n    mapping(bytes32 => mapping(address => bool)) private signed;\n    NewRecovery private pendingSetup;\n\n    struct NewRecovery {\n        uint256 addition;\n        bytes32 secret;\n        uint256 threshold;\n        uint256 setupDelay;\n        bytes32[] friends;\n    }\n\n    event SetupRequested(uint256 activation);\n    event Activated();\n    event Approved(bytes32 indexed secretHash, address approver);\n    event Execution(bool success);\n\n    modifier identityOnly() {\n        require(msg.sender == identity);\n        _;\n    }\n    modifier notRevealed(bytes32 secretHash) {\n        require(!revealed[secretHash]);\n        _;\n    }\n\n    function FriendsRecovery(\n        address _identity,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32 _secret,\n        bytes32[] _friendHashes\n        ) \n        public \n    {\n        identity = _identity;\n        threshold = _threshold;\n        secret = _secret;\n        setupDelay = _setupDelay;\n        addFriends(_friendHashes);\n    }\n\n    function withdraw() \n        external\n        identityOnly\n    {\n        identity.transfer(this.balance);\n    }\n\n    function cancelSetup() \n        external \n        identityOnly \n    {\n        delete pendingSetup;\n        SetupRequested(0);\n    }\n\n    function setup(\n        bytes32 _newSecret,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32[] _newFriendsHashes\n        )\n        external \n        identityOnly\n        notRevealed(_newSecret)\n    {\n        pendingSetup.addition = block.timestamp;\n        pendingSetup.secret = _newSecret;\n        pendingSetup.friends = _newFriendsHashes;\n        pendingSetup.threshold = _threshold;\n        pendingSetup.setupDelay = _setupDelay;\n        SetupRequested(block.timestamp + setupDelay);\n    }\n\n    function activate()\n        external\n    {\n        require(pendingSetup.addition > 0);\n        require(pendingSetup.addition + setupDelay <= block.timestamp);\n        threshold = pendingSetup.threshold;\n        setupDelay = pendingSetup.setupDelay;\n        secret = pendingSetup.secret;\n        addFriends(pendingSetup.friends);\n        delete pendingSetup;\n        Activated();\n    }\n\n    function approve(bytes32 _secretHash) \n        external \n    {\n        require(!signed[_secretHash][msg.sender]);\n        signed[_secretHash][msg.sender] = true;\n        Approved(_secretHash, msg.sender);\n    }\n\n    function approvePreSigned(bytes32 _secretHash, uint8[] _v, bytes32[] _r, bytes32[] _s) \n        external \n    {\n        uint256 len = _v.length;\n        require (_r.length == len);\n        require (_s.length == len);    \n        require (_v.length == len);    \n        bytes32 signatureHash = getSignHash(_secretHash); \n        for (uint256 i = 0; i < len; i++) {\n            address recovered = ecrecover(signatureHash, _v[i], _r[i], _s[i]);\n            require(!signed[_secretHash][recovered]);\n            require(recovered != address(0));\n            signed[_secretHash][recovered] = true;\n            Approved(_secretHash, recovered);\n        }        \n    }\n\n    function execute(\n        bytes32 _revealedSecret,\n        address _dest,\n        bytes _data,\n        address[] _friendList,\n        bytes32 _newSecret,\n        bytes32[] _newFriendsHashes\n        ) \n        external \n        notRevealed(_newSecret)\n    {\n        require(_friendList.length >= threshold);\n        require(keccak256(identity, _revealedSecret) == secret);\n        revealed[_newSecret] = true;\n        bytes32 _secretHash = keccak256(identity, _revealedSecret, _dest, _data);\n        \n        for (uint256 i = 0; i < threshold; i++) {\n            address friend = _friendList[i];\n            require(friend != address(0));\n            require(friendAllowed[keccak256(identity, _revealedSecret, friend)]);\n            require(signed[_secretHash][friend]);\n            delete signed[_secretHash][friend];\n        }\n\n        secret = _newSecret;\n        addFriends(_newFriendsHashes);\n\n        Execution(_dest.call(_data));\n    }\n\n    function addFriends(bytes32[] _newFriendsHashes) private {\n        uint256 len = _newFriendsHashes.length;\n        require(len >= threshold);\n        for (uint256 i = 0; i < len; i++) {\n            friendAllowed[_newFriendsHashes[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Hash a hash with `\"\\x19Ethereum Signed Message:\\n32\"`\n     * @param _hash Sign to hash.\n     * @return signHash Hash to be signed.\n     */\n    function getSignHash(\n        bytes32 _hash\n    )\n        pure\n        public\n        returns(bytes32 signHash)\n    {\n        signHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n    }\n\n   \n}\n", "commit_id": "93150ce174718ffa5e171aca4d872972b51d008c"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.17;\n\ncontract FriendsRecovery {\n    \n    address private identity;\n    bytes32 private secret;\n    uint256 private threshold;\n    uint256 private setupDelay;\n    mapping(bytes32 => bool) private friendAllowed;\n    mapping(bytes32 => bool) private revealed;\n    mapping(bytes32 => mapping(address => bool)) private signed;\n    NewRecovery private pendingSetup;\n\n    struct NewRecovery {\n        uint256 addition;\n        bytes32 secret;\n        uint256 threshold;\n        uint256 setupDelay;\n        bytes32[] friends;\n    }\n\n    event SetupRequested(uint256 activation);\n    event Activated();\n    event Approved(bytes32 indexed secretHash, address approver);\n    event Execution(bool success);\n\n    modifier identityOnly() {\n        require(msg.sender == identity);\n        _;\n    }\n    modifier notRevealed(bytes32 secretHash) {\n        require(!revealed[secretHash]);\n        _;\n    }\n\n    function FriendsRecovery(\n        address _identity,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32 _secret,\n        bytes32[] _friendHashes\n        ) \n        public \n    {\n        identity = _identity;\n        threshold = _threshold;\n        secret = _secret;\n        setupDelay = _setupDelay;\n        addFriends(_friendHashes);\n    }\n\n    function withdraw() \n        external\n        identityOnly\n    {\n        identity.transfer(this.balance);\n    }\n\n    function cancelSetup() \n        external \n        identityOnly \n    {\n        delete pendingSetup;\n        SetupRequested(0);\n    }\n\n    function setup(\n        bytes32 _newSecret,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32[] _newFriendsHashes\n        )\n        external \n        identityOnly\n        notRevealed(_newSecret)\n    {\n        pendingSetup.addition = block.timestamp;\n        pendingSetup.secret = _newSecret;\n        pendingSetup.friends = _newFriendsHashes;\n        pendingSetup.threshold = _threshold;\n        pendingSetup.setupDelay = _setupDelay;\n        SetupRequested(block.timestamp + setupDelay);\n    }\n\n    function activate()\n        external\n    {\n        require(pendingSetup.addition > 0);\n        require(pendingSetup.addition + setupDelay <= block.timestamp);\n        threshold = pendingSetup.threshold;\n        setupDelay = pendingSetup.setupDelay;\n        secret = pendingSetup.secret;\n        addFriends(pendingSetup.friends);\n        delete pendingSetup;\n        Activated();\n    }\n\n    function approve(bytes32 _secretHash) \n        external \n    {\n        require(!signed[_secretHash][msg.sender]);\n        signed[_secretHash][msg.sender] = true;\n        Approved(_secretHash, msg.sender);\n    }\n\n    function approvePreSigned(bytes32 _secretHash, uint8[] _v, bytes32[] _r, bytes32[] _s) \n        external \n    {\n        uint256 len = _v.length;\n        require (_r.length == len);\n        require (_s.length == len);    \n        require (_v.length == len);    \n        bytes32 signatureHash = getSignHash(_secretHash); \n        for (uint256 i = 0; i < len; i++) {\n            address recovered = ecrecover(signatureHash, _v[i], _r[i], _s[i]);\n            require(!signed[_secretHash][recovered]);\n            require(recovered != address(0));\n            signed[_secretHash][recovered] = true;\n            Approved(_secretHash, recovered);\n        }        \n    }\n\n    function execute(\n        bytes32 _revealedSecret,\n        address _dest,\n        bytes _data,\n        address[] _friendList,\n        bytes32 _newSecret,\n        bytes32[] _newFriendsHashes\n        ) \n        external \n        notRevealed(_newSecret)\n    {\n        require(_friendList.length >= threshold);\n        require(keccak256(identity, _revealedSecret) == secret);\n        revealed[_newSecret] = true;\n        bytes32 _secretHash = keccak256(identity, _revealedSecret, _dest, _data, _newSecret, _newFriendsHashes);\n        \n        for (uint256 i = 0; i < threshold; i++) {\n            address friend = _friendList[i];\n            require(friend != address(0));\n            require(friendAllowed[keccak256(identity, _revealedSecret, friend)]);\n            require(signed[_secretHash][friend]);\n            delete signed[_secretHash][friend];\n        }\n\n        secret = _newSecret;\n        addFriends(_newFriendsHashes);\n\n        Execution(_dest.call(_data));\n    }\n\n    function addFriends(bytes32[] _newFriendsHashes) private {\n        uint256 len = _newFriendsHashes.length;\n        require(len >= threshold);\n        for (uint256 i = 0; i < len; i++) {\n            friendAllowed[_newFriendsHashes[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Hash a hash with `\"\\x19Ethereum Signed Message:\\n32\"`\n     * @param _hash Sign to hash.\n     * @return signHash Hash to be signed.\n     */\n    function getSignHash(\n        bytes32 _hash\n    )\n        pure\n        public\n        returns(bytes32 signHash)\n    {\n        signHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n    }\n\n   \n}", "flattened_code": "pragma solidity ^0.4.17;\n\ncontract FriendsRecovery {\n    \n    address private identity;\n    bytes32 private secret;\n    uint256 private threshold;\n    uint256 private setupDelay;\n    mapping(bytes32 => bool) private friendAllowed;\n    mapping(bytes32 => bool) private revealed;\n    mapping(bytes32 => mapping(address => bool)) private signed;\n    NewRecovery private pendingSetup;\n\n    struct NewRecovery {\n        uint256 addition;\n        bytes32 secret;\n        uint256 threshold;\n        uint256 setupDelay;\n        bytes32[] friends;\n    }\n\n    event SetupRequested(uint256 activation);\n    event Activated();\n    event Approved(bytes32 indexed secretHash, address approver);\n    event Execution(bool success);\n\n    modifier identityOnly() {\n        require(msg.sender == identity);\n        _;\n    }\n    modifier notRevealed(bytes32 secretHash) {\n        require(!revealed[secretHash]);\n        _;\n    }\n\n    function FriendsRecovery(\n        address _identity,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32 _secret,\n        bytes32[] _friendHashes\n        ) \n        public \n    {\n        identity = _identity;\n        threshold = _threshold;\n        secret = _secret;\n        setupDelay = _setupDelay;\n        addFriends(_friendHashes);\n    }\n\n    function withdraw() \n        external\n        identityOnly\n    {\n        identity.transfer(this.balance);\n    }\n\n    function cancelSetup() \n        external \n        identityOnly \n    {\n        delete pendingSetup;\n        SetupRequested(0);\n    }\n\n    function setup(\n        bytes32 _newSecret,\n        uint256 _setupDelay,\n        uint256 _threshold,\n        bytes32[] _newFriendsHashes\n        )\n        external \n        identityOnly\n        notRevealed(_newSecret)\n    {\n        pendingSetup.addition = block.timestamp;\n        pendingSetup.secret = _newSecret;\n        pendingSetup.friends = _newFriendsHashes;\n        pendingSetup.threshold = _threshold;\n        pendingSetup.setupDelay = _setupDelay;\n        SetupRequested(block.timestamp + setupDelay);\n    }\n\n    function activate()\n        external\n    {\n        require(pendingSetup.addition > 0);\n        require(pendingSetup.addition + setupDelay <= block.timestamp);\n        threshold = pendingSetup.threshold;\n        setupDelay = pendingSetup.setupDelay;\n        secret = pendingSetup.secret;\n        addFriends(pendingSetup.friends);\n        delete pendingSetup;\n        Activated();\n    }\n\n    function approve(bytes32 _secretHash) \n        external \n    {\n        require(!signed[_secretHash][msg.sender]);\n        signed[_secretHash][msg.sender] = true;\n        Approved(_secretHash, msg.sender);\n    }\n\n    function approvePreSigned(bytes32 _secretHash, uint8[] _v, bytes32[] _r, bytes32[] _s) \n        external \n    {\n        uint256 len = _v.length;\n        require (_r.length == len);\n        require (_s.length == len);    \n        require (_v.length == len);    \n        bytes32 signatureHash = getSignHash(_secretHash); \n        for (uint256 i = 0; i < len; i++) {\n            address recovered = ecrecover(signatureHash, _v[i], _r[i], _s[i]);\n            require(!signed[_secretHash][recovered]);\n            require(recovered != address(0));\n            signed[_secretHash][recovered] = true;\n            Approved(_secretHash, recovered);\n        }        \n    }\n\n    function execute(\n        bytes32 _revealedSecret,\n        address _dest,\n        bytes _data,\n        address[] _friendList,\n        bytes32 _newSecret,\n        bytes32[] _newFriendsHashes\n        ) \n        external \n        notRevealed(_newSecret)\n    {\n        require(_friendList.length >= threshold);\n        require(keccak256(identity, _revealedSecret) == secret);\n        revealed[_newSecret] = true;\n        bytes32 _secretHash = keccak256(identity, _revealedSecret, _dest, _data, _newSecret, _newFriendsHashes);\n        \n        for (uint256 i = 0; i < threshold; i++) {\n            address friend = _friendList[i];\n            require(friend != address(0));\n            require(friendAllowed[keccak256(identity, _revealedSecret, friend)]);\n            require(signed[_secretHash][friend]);\n            delete signed[_secretHash][friend];\n        }\n\n        secret = _newSecret;\n        addFriends(_newFriendsHashes);\n\n        Execution(_dest.call(_data));\n    }\n\n    function addFriends(bytes32[] _newFriendsHashes) private {\n        uint256 len = _newFriendsHashes.length;\n        require(len >= threshold);\n        for (uint256 i = 0; i < len; i++) {\n            friendAllowed[_newFriendsHashes[i]] = true;\n        }\n    }\n\n    /**\n     * @notice Hash a hash with `\"\\x19Ethereum Signed Message:\\n32\"`\n     * @param _hash Sign to hash.\n     * @return signHash Hash to be signed.\n     */\n    function getSignHash(\n        bytes32 _hash\n    )\n        pure\n        public\n        returns(bytes32 signHash)\n    {\n        signHash = keccak256(\"\\x19Ethereum Signed Message:\\n32\", _hash);\n    }\n\n   \n}\n", "commit_id": "341c0ae442678afc920a4a052043150065b72c64"}}