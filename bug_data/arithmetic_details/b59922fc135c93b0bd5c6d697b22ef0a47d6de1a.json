{"filename": "contracts/CrowdvillaTokenSale.sol", "patch": "@@ -176,7 +176,7 @@ contract CrowdvillaTokenSale is Owners(true) {\n       earlyRegistrantBonus = 1;\n \n     for (uint i=0; i<=currentStretchGoal; i++) {\n-      val += (contributions[_contributor][i] * crvPerEth * (100 + ((currentStretchGoal-i + earlyRegistrantBonus) * 10))/100) / 1 ether;\n+      val = val.add((contributions[_contributor][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i).mul(earlyRegistrantBonus)).mul(10)).add(100)).div(100)).div(1 ether));\n     }\n     return val;\n   }\n@@ -204,10 +204,10 @@ contract CrowdvillaTokenSale is Owners(true) {\n     //contributionsPerStretchGoal index 1 is for earlyRegistrant\n     uint val;\n     for (uint i=0; i<=currentStretchGoal; i++) {\n-      val += (contributionsPerStretchGoal[0][i] * crvPerEth * (100 + ((currentStretchGoal-i) * 10))/100) / 1 ether;\n+      val = val.add((contributionsPerStretchGoal[0][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i)).mul(10)).add(100)).div(100)).div(1 ether));\n     }\n     for (i=0; i<=currentStretchGoal; i++) {\n-      val += (contributionsPerStretchGoal[1][i] * crvPerEth * (100 + ((currentStretchGoal-i + 1) * 10))/100) / 1 ether;\n+      val = val.add((contributionsPerStretchGoal[1][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i).add(1)).mul(10)).add(100)).div(100)).div(1 ether));\n     }\n     uint total = (val.mul(100)).div(100 - mgmtFeePercentage);\n     val = total.sub(val);", "project_link": "https://github.com/REIDAO/crowdvilla-token-sale/commit/d4bd83385452ceeeac7596c6d02b321f7bd20ffb", "solc_version": "0.8.9", "packages": "", "bug_version": {"raw_code": "pragma solidity ^0.4.18;\n\nimport './math/SafeMath.sol';\nimport \"./tokens/REIDAOMintableBurnableLockableToken.sol\";\nimport \"./tokens/REIDAOMintableToken.sol\";\n\ncontract CrowdvillaTokenSale is Owners(true) {\n  using SafeMath for uint256;\n  //TODO use safemath for all\n\n  uint public totalFund;\n  uint public uniqueContributors;\n  uint public currentStretchGoal;\n  uint public minContribution;\n  uint public crvPerEth;\n  uint public reiPerEth;\n  uint public mgmtFeePercentage;\n  uint public saleEndBlock;\n  uint public totalReferralMultisig;\n  uint[] public stretchGoals;\n\n  address public deployer;\n  address public opsAdmin;\n  address public crowdvillaWallet;\n  address public reidaoWallet;\n  address public crvTokenAddr;\n  address public crpTokenAddr;\n  address public reiTokenAddr;\n  mapping (address => Whitelist) public whitelist;\n  mapping (bytes32 => address) public referralMultisig;\n  mapping (uint => mapping (uint => uint)) public contributionsPerStretchGoal; //earlyRegistrant => stretch-goals => value\n  mapping (address => uint) public contributionsPerAddress;\n  mapping (address => mapping (uint => uint)) public contributions;\n  mapping (address => uint) public contributorIndex;\n  mapping (uint => address) public reversedContributorIndex;\n  mapping (address => bool) public tokensCollected;\n  mapping (bytes32 => uint) public referralContribution;\n\n  event Contribute(uint blkNo, uint blkTs, address indexed contributor, address indexed tokensale, uint amount, bytes32 referralCode);\n  event Whitelisted(uint blkNo, uint blkTs, address indexed contributor, bool isEarlyRegistrant, bytes32 referralCode);\n  event WhitelistChanged(address indexed _old, address indexed _new);\n\n  enum State { TokenSale, End, Collection }\n  State public state;\n\n  REIDAOMintableBurnableLockableToken crvToken;\n  REIDAOMintableBurnableLockableToken crpToken;\n  REIDAOMintableToken reiToken;\n\n  struct Whitelist {\n    bool whitelisted;\n    bool isEarlyRegistrant;\n    bytes32 referralCode;\n  }\n\n  /**\n   * @dev initializes contract\n   * @param _stretchGoal1 uint the stretch goal 1 amount in ETH\n   * @param _stretchGoal2 uint the stretch goal 2 amount in ETH\n   * @param _stretchGoal3 uint the stretch goal 3 amount in ETH\n   * @param _opsAdmin address the address of operation admin\n   * @param _crowdvillaWallet address the address of Crowdvilla's wallet\n   * @param _reidaoWallet address the address of REIDAO's wallet\n   * @param _crvTokenAddr address the address of CRVToken contract\n   * @param _crpTokenAddr address the address of CRPToken contract\n   * @param _reiTokenAddr address the address of REIToken contract\n   */\n  function CrowdvillaTokenSale(\n      uint _stretchGoal1,\n      uint _stretchGoal2,\n      uint _stretchGoal3,\n      address _opsAdmin,\n      address _crowdvillaWallet,\n      address _reidaoWallet,\n      address _crvTokenAddr,\n      address _crpTokenAddr,\n      address _reiTokenAddr) public {\n    deployer = msg.sender;\n    state = State.TokenSale;\n\n    opsAdmin = address(_opsAdmin);\n    crowdvillaWallet = address(_crowdvillaWallet);\n    reidaoWallet = address(_reidaoWallet);\n    crvTokenAddr = address(_crvTokenAddr);\n    crpTokenAddr = address(_crpTokenAddr);\n    reiTokenAddr = address(_reiTokenAddr);\n    crvToken = REIDAOMintableBurnableLockableToken(crvTokenAddr);\n    crpToken = REIDAOMintableBurnableLockableToken(crpTokenAddr);\n    reiToken = REIDAOMintableToken(reiTokenAddr);\n\n    minContribution = 1 ether;\n    crvPerEth = 400 * (10**crvToken.decimals());\n    reiPerEth = 5 * (10**reiToken.decimals());\n    mgmtFeePercentage = 20;\n    saleEndBlock = 5280000; //appox end of Mar 2018\n    stretchGoals = [_stretchGoal1 * 1 ether, _stretchGoal2 * 1 ether, _stretchGoal3 * 1 ether];\n  }\n\n\n  // public - START ------------------------------------------------------------\n  /**\n   * @dev accepts ether, records contributions, and splits payment if referral code exists.\n   *   contributor must be whitelisted, and sends the min ETH required.\n   */\n  function () public payable {\n    if (msg.value>0) {\n      // for accepting fund\n      require(isInWhitelist(msg.sender));\n      require(msg.value >= minContribution);\n      require(state == State.TokenSale);\n      require(block.number < saleEndBlock);\n      require(currentStretchGoal < stretchGoals.length);\n\n      totalFund = totalFund.add(msg.value);\n\n      uint earlyRegistrantIndex = 0;\n      if (whitelist[msg.sender].isEarlyRegistrant) {\n        earlyRegistrantIndex = 1;\n      }\n\n      contributions[msg.sender][currentStretchGoal] = contributions[msg.sender][currentStretchGoal].add(msg.value);\n\n      contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal] = contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal].add(msg.value);\n      contributionsPerAddress[msg.sender] = contributionsPerAddress[msg.sender].add(msg.value);\n      bytes32 referralCode = whitelist[msg.sender].referralCode;\n      referralContribution[referralCode] = referralContribution[referralCode].add(msg.value);\n      logContributeEvent(msg.sender, msg.value, referralCode);\n\n      if (referralCode == bytes32(0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563)) {\n        //no referral code\n        crowdvillaWallet.transfer(msg.value);\n      } else {\n        //referral code exist, sending 99% to our wallet. 1% to multisig with arbiter\n        uint crowdvillaAmount = (msg.value.mul(99)).div(100);\n        crowdvillaWallet.transfer(crowdvillaAmount);\n        referralMultisig[referralCode].transfer(msg.value.sub(crowdvillaAmount));\n      }\n\n      // to increase the currentStrechGoal targetted if the current one has been reached.\n      //  also safe-guard if multiple stretch goals reached with a single contribution.\n      // to end the token sale if it has reached the last stretch goal.\n      for (uint currGoal = currentStretchGoal; currGoal < stretchGoals.length; currGoal++) {\n        if (totalFund >= stretchGoals[currGoal] && currentStretchGoal != stretchGoals.length) {\n          currentStretchGoal++;\n        }\n      }\n\n      if (contributorIndex[msg.sender]==0) {\n        uniqueContributors++;\n        contributorIndex[msg.sender] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = msg.sender;\n      }\n    } else {\n      // for tokens collection\n      require(state == State.Collection);\n      require(!tokensCollected[msg.sender]);\n      uint promisedCRVToken = getPromisedCRVTokenAmount(msg.sender);\n      require(promisedCRVToken>0);\n      require(crvToken.mint(msg.sender, promisedCRVToken));\n      require(crpToken.mint(msg.sender, promisedCRVToken));\n      require(reiToken.mint(msg.sender, getPromisedREITokenAmount(msg.sender)));\n      tokensCollected[msg.sender] = true;\n    }\n  }\n\n  /**\n   * @dev calculates the amount of CRV tokens allocated to `_contributor`, with\n   *   stretch goal calculation.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedCRVTokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n\n    uint earlyRegistrantBonus = 0;\n    if (whitelist[_contributor].isEarlyRegistrant)\n      earlyRegistrantBonus = 1;\n\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val += (contributions[_contributor][i] * crvPerEth * (100 + ((currentStretchGoal-i + earlyRegistrantBonus) * 10))/100) / 1 ether;\n    }\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to `_contributor. 5 REI per ETH.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedREITokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n    uint totalEthContributions;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      totalEthContributions = totalEthContributions.add(contributions[_contributor][i]);\n    }\n    val = (totalEthContributions.mul(reiPerEth)).div(1 ether);\n\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to REIDAO\n   */\n  function getREIDAODistributionTokenAmount() public constant returns (uint) {\n    //contributionsPerStretchGoal index 0 is for non-earlyRegistrant\n    //contributionsPerStretchGoal index 1 is for earlyRegistrant\n    uint val;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val += (contributionsPerStretchGoal[0][i] * crvPerEth * (100 + ((currentStretchGoal-i) * 10))/100) / 1 ether;\n    }\n    for (i=0; i<=currentStretchGoal; i++) {\n      val += (contributionsPerStretchGoal[1][i] * crvPerEth * (100 + ((currentStretchGoal-i + 1) * 10))/100) / 1 ether;\n    }\n    uint total = (val.mul(100)).div(100 - mgmtFeePercentage);\n    val = total.sub(val);\n    return val;\n  }\n\n  /**\n   * @dev Checks if `_contributor` is in the whitelist.\n   * @param _contributor address The address of contributor.\n   */\n  function isInWhitelist(address _contributor) public constant returns (bool) {\n    return (whitelist[_contributor].whitelisted == true);\n  }\n  // public - END --------------------------------------------------------------\n\n\n  // ownerOnly - START ---------------------------------------------------------\n  /**\n   * @dev collects tokens distribution allocated to REIDAO\n   */\n  function collectREIDAODistribution() public ownerOnly {\n    require(!tokensCollected[reidaoWallet]);\n    uint tokenAmount = getREIDAODistributionTokenAmount();\n    require(crvToken.mint(reidaoWallet, tokenAmount));\n    require(crpToken.mint(reidaoWallet, tokenAmount));\n    tokensCollected[reidaoWallet] = true;\n  }\n\n  /**\n   * @dev updates sale end block\n   * @param _saleEndBlock uint block number denotes end of sale\n   */\n  function updateSaleEndBlock(uint _saleEndBlock) public ownerOnly {\n    saleEndBlock = _saleEndBlock;\n  }\n\n  /**\n   * @dev ends token sale\n   */\n  function endTokenSale() public ownerOnly {\n    setEndState();\n  }\n\n  /**\n   * @dev sets state as Collection\n   */\n  function startCollection() public ownerOnly {\n    state = State.Collection;\n  }\n\n  /**\n   * @dev Allows owners to update `_opsAdmin` as new opsAdmin.\n   * @param _opsAdmin address The address of new opsAdmin.\n   */\n  function updateOpsAdmin(address _opsAdmin) public ownerOnly {\n    opsAdmin = _opsAdmin;\n  }\n\n  /**\n   * @dev Allows authorized signatories to update contributor address.\n   * @param _old address the old contributor address.\n   * @param _new address the new contributor address.\n   */\n  function updateContributorAddress(address _old, address _new) public ownerOnly {\n    require (state != State.Collection);\n    whitelist[_new] = Whitelist(whitelist[_old].whitelisted, whitelist[_old].isEarlyRegistrant, whitelist[_old].referralCode);\n    uint currentContribution;\n\n    bool contributionFound;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      currentContribution = contributions[_old][i];\n      if (currentContribution > 0) {\n        contributions[_old][i] = 0;\n        contributions[_new][i] += currentContribution;\n        contributionsPerAddress[_old] -= currentContribution;\n        contributionsPerAddress[_new] += currentContribution;\n        logContributeEvent(_new, currentContribution, whitelist[_old].referralCode);\n\n        contributionFound = true;\n      }\n    }\n    removeFromWhitelist(_old);\n\n    if (contributionFound) {\n      if (contributorIndex[_new]==0) {\n        uniqueContributors++;\n        contributorIndex[_new] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = _new;\n      }\n    }\n    WhitelistChanged(_old, _new);\n  }\n  // ownerOnly - END -----------------------------------------------------------\n\n\n  // opsAdmin - START ----------------------------------------------------------\n  /**\n   * @dev Allows opsAdmin to add `_contributor` to the whitelist.\n   * @param _contributor address The address of contributor.\n   * @param _earlyRegistrant bool If contributor is early registrant (registered before public sale).\n   * @param _referralCode bytes32 The referral code. Empty String if not provided.\n   */\n  function addToWhitelist(address _contributor, bool _earlyRegistrant, bytes32 _referralCode) public opsAdminOnly {\n    whitelist[_contributor] = Whitelist(true, _earlyRegistrant, keccak256(_referralCode));\n    Whitelisted(block.number, block.timestamp, _contributor, _earlyRegistrant, keccak256(_referralCode));\n  }\n\n  /**\n   * @dev Allows opsAdmin to register `_multisigAddr` as multisig wallet address for referral code `_referralCode`.\n   * @param _referralCode bytes32 The referral code. Should not be empty since it should have value.\n   * @param _multisigAddr address The address of multisig wallet.\n   */\n  function registerReferralMultisig(bytes32 _referralCode, address _multisigAddr) public opsAdminOnly {\n    referralMultisig[keccak256(_referralCode)] = _multisigAddr;\n    totalReferralMultisig++;\n  }\n  // opsAdmin - END ------------------------------------------------------------\n\n\n  // internal - START ----------------------------------------------------------\n  /**\n   * @dev sets state as End\n   */\n  function setEndState() internal {\n    state = State.End;\n  }\n\n  /**\n   * @dev Allows authorized signatories to remove `_contributor` from the whitelist.\n   * @param _contributor address address of contributor.\n   */\n  function removeFromWhitelist(address _contributor) internal {\n    whitelist[_contributor].whitelisted = false;\n    whitelist[_contributor].isEarlyRegistrant = false;\n  }\n\n  /**\n   * @dev logs contribution event\n   * @param _contributor address address of contributor\n   * @param _amount uint contribution amount\n   * @param _referralCode bytes32 referral code from the contribution. Empty string if none.\n   */\n  function logContributeEvent(address _contributor, uint _amount, bytes32 _referralCode) internal {\n    Contribute(block.number, block.timestamp, _contributor, this, _amount, _referralCode);\n  }\n  // internal - END ------------------------------------------------------------\n\n\n  // modifier - START ----------------------------------------------------------\n  /**\n   * @dev throws if sender is not opsAdmin.\n   */\n  modifier opsAdminOnly {\n    require(msg.sender == opsAdmin);\n    _;\n  }\n  // modifier - END ------------------------------------------------------------\n}\n", "flattened_code": "pragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\n\npragma solidity ^0.4.18;\n\n\npragma solidity ^0.4.18;\n\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n   * @dev Fix for the ERC20 short address attack.\n   */\n  modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length == size + 4);\n    _;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\npragma solidity ^0.4.18;\n\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   */\n  function increaseApproval(address _spender, uint _addedValue) public onlyPayloadSize(2 * 32) returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public onlyPayloadSize(2 * 32) returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\npragma solidity ^0.4.18;\n\ncontract Owners {\n\n  mapping (address => bool) public owners;\n  uint public ownersCount;\n  uint public minOwnersRequired = 2;\n\n  event OwnerAdded(address indexed owner);\n  event OwnerRemoved(address indexed owner);\n\n  /**\n   * @dev initializes contract\n   * @param withDeployer bool indicates whether deployer is part of owners\n   */\n  function Owners(bool withDeployer) public {\n    if (withDeployer) {\n      ownersCount++;\n      owners[msg.sender] = true;\n    }\n    owners[0x23B599A0949C6147E05C267909C16506C7eFF229] = true;\n    owners[0x286A70B3E938FCa244208a78B1823938E8e5C174] = true;\n    ownersCount = ownersCount + 2;\n  }\n\n  /**\n   * @dev adds owner, can only by done by owners only\n   * @param _address address the address to be added\n   */\n  function addOwner(address _address) public ownerOnly {\n    owners[_address] = true;\n    ownersCount++;\n    OwnerAdded(_address);\n  }\n\n  /**\n   * @dev removes owner, can only by done by owners only\n   * @param _address address the address to be removed\n   */\n  function removeOwner(address _address) public ownerOnly notOwnerItself(_address) minOwners {\n    owners[_address] = false;\n    OwnerRemoved(_address);\n  }\n\n  /**\n   * @dev checks if sender is owner\n   */\n  modifier ownerOnly {\n    require(owners[msg.sender]);\n    _;\n  }\n\n  modifier notOwnerItself(address _owner) {\n    require(msg.sender != _owner);\n    _;\n  }\n\n  modifier minOwners {\n    require(ownersCount > minOwnersRequired);\n    _;\n  }\n\n}\n\n\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\n\ncontract MintableToken is StandardToken, Owners(true) {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n  event MintStarted();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(address _to, uint256 _amount) ownerOnly canMint onlyPayloadSize(2 * 32) public returns (bool) {\n    totalSupply = totalSupply.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    Mint(_to, _amount);\n    Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() ownerOnly canMint public returns (bool) {\n    mintingFinished = true;\n    MintFinished();\n    return true;\n  }\n\n  /**\n   * @dev Function to start minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function startMinting() ownerOnly public returns (bool) {\n    mintingFinished = false;\n    MintStarted();\n    return true;\n  }\n}\n\ncontract REIDAOMintableToken is MintableToken {\n\n  uint public decimals = 8;\n\n  bool public tradingStarted = false;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) public canTrade returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint _value) public canTrade returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  /**\n   * @dev modifier that throws if trading has not started yet\n   */\n  modifier canTrade() {\n    require(tradingStarted);\n    _;\n  }\n\n  /**\n   * @dev Allows the owner to enable the trading. Done only once.\n   */\n  function startTrading() public ownerOnly {\n    tradingStarted = true;\n  }\n}\n\ncontract REIDAOMintableLockableToken is REIDAOMintableToken {\n\n  struct TokenLock {\n    uint256 value;\n    uint lockedUntil;\n  }\n\n  mapping (address => TokenLock[]) public locks;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) public canTransfer(msg.sender, _value) returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint _value) public canTransfer(msg.sender, _value) returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  /**\n   * @dev Allows authorized callers to lock `_value` tokens belong to `_to` until timestamp `_lockUntil`.\n   * This function can be called independently of transferAndLockTokens(), hence the double checking of timestamp.\n   * @param _to address The address to be locked.\n   * @param _value uint The amout of tokens to be locked.\n   * @param _lockUntil uint The UNIX timestamp tokens are locked until.\n   */\n  function lockTokens(address _to, uint256 _value, uint256 _lockUntil) public ownerOnly {\n    require(_value <= balanceOf(_to));\n    require(_lockUntil > now);\n    locks[_to].push(TokenLock(_value, _lockUntil));\n  }\n\n  /**\n   * @dev Allows authorized callers to mint `_value` tokens for `_to`, and lock them until timestamp `_lockUntil`.\n   * @param _to address The address to which tokens to be minted and locked.\n   * @param _value uint The amout of tokens to be minted and locked.\n   * @param _lockUntil uint The UNIX timestamp tokens are locked until.\n   */\n  function mintAndLockTokens(address _to, uint256 _value, uint256 _lockUntil) public ownerOnly {\n    require(_lockUntil > now);\n    mint(_to, _value);\n    lockTokens(_to, _value, _lockUntil);\n  }\n\n  /**\n   * @dev Checks the amount of transferable tokens belongs to `_holder`.\n   * @param _holder address The address to be checked.\n   */\n  function transferableTokens(address _holder) public constant returns (uint256) {\n    uint256 lockedTokens = getLockedTokens(_holder);\n    if (lockedTokens==0) {\n      return balanceOf(_holder);\n    } else {\n      return balanceOf(_holder).sub(lockedTokens);\n    }\n  }\n\n  /**\n   * @dev Retrieves the amount of locked tokens `_holder` has.\n   * @param _holder address The address to be checked.\n   */\n  function getLockedTokens(address _holder) public constant returns (uint256) {\n    uint256 numLocks = getTokenLocksCount(_holder);\n\n    // shortcut for holder without locks\n    if (numLocks == 0) return 0;\n\n    // Iterate through all the locks the holder has\n    uint256 lockedTokens = 0;\n    for (uint256 i = 0; i < numLocks; i++) {\n      if (locks[_holder][i].lockedUntil >= now) {\n        lockedTokens = lockedTokens.add(locks[_holder][i].value);\n      }\n    }\n\n    return lockedTokens;\n  }\n\n  /**\n   * @dev Retrieves the number of token locks `_holder` has.\n   * @param _holder address The address the token locks belongs to.\n   * @return A uint256 representing the total number of locks.\n   */\n  function getTokenLocksCount(address _holder) internal constant returns (uint256 index) {\n    return locks[_holder].length;\n  }\n\n  /**\n   * @dev Modifier that throws if `_value` amount of tokens can't be transferred.\n   * @param _sender address the address of the sender\n   * @param _value uint the amount of tokens intended to be transferred\n   */\n  modifier canTransfer(address _sender, uint256 _value) {\n    uint256 transferableTokensAmt = transferableTokens(_sender);\n    require (_value <= transferableTokensAmt);\n    // delete locks if all locks are cleared\n    if (transferableTokensAmt == balanceOf(_sender) && getTokenLocksCount(_sender)>0) {\n      delete locks[_sender];\n    }\n    _;\n  }\n}\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n    event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n    function burn(uint256 _value) public {\n        require(_value <= balances[msg.sender]);\n        // no need to require value <= totalSupply, since that would imply the\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        Burn(burner, _value);\n    }\n}\n\ncontract REIDAOBurnableToken is BurnableToken {\n\n  mapping (address => bool) public hostedWallets;\n\n  /**\n   * @dev burns tokens, can only be done by hosted wallets\n   * @param _value uint256 the amount of tokens to be burned\n   */\n  function burn(uint256 _value) public hostedWalletsOnly {\n    return super.burn(_value);\n  }\n\n  /**\n   * @dev adds hosted wallet\n   * @param _wallet address the address to be added\n   */\n  function addHostedWallet(address _wallet) public {\n    hostedWallets[_wallet] = true;\n  }\n\n  /**\n   * @dev removes hosted wallet\n   * @param _wallet address the address to be removed\n   */\n  function removeHostedWallet(address _wallet) public {\n    hostedWallets[_wallet] = false;\n  }\n\n  /**\n   * @dev checks if sender is hosted wallets\n   */\n  modifier hostedWalletsOnly {\n    require(hostedWallets[msg.sender]==true);\n    _;\n  }\n}\n\ncontract REIDAOMintableBurnableLockableToken is REIDAOMintableLockableToken, REIDAOBurnableToken {\n\n  /**\n   * @dev adds hosted wallet, can only be done by owners.\n   * @param _wallet address the address to be added\n   */\n  function addHostedWallet(address _wallet) public ownerOnly {\n    return super.addHostedWallet(_wallet);\n  }\n\n  /**\n   * @dev removes hosted wallet, can only be done by owners.\n   * @param _wallet address the address to be removed\n   */\n  function removeHostedWallet(address _wallet) public ownerOnly {\n    return super.removeHostedWallet(_wallet);\n  }\n}\n\ncontract CrowdvillaTokenSale is Owners(true) {\n  using SafeMath for uint256;\n  //TODO use safemath for all\n\n  uint public totalFund;\n  uint public uniqueContributors;\n  uint public currentStretchGoal;\n  uint public minContribution;\n  uint public crvPerEth;\n  uint public reiPerEth;\n  uint public mgmtFeePercentage;\n  uint public saleEndBlock;\n  uint public totalReferralMultisig;\n  uint[] public stretchGoals;\n\n  address public deployer;\n  address public opsAdmin;\n  address public crowdvillaWallet;\n  address public reidaoWallet;\n  address public crvTokenAddr;\n  address public crpTokenAddr;\n  address public reiTokenAddr;\n  mapping (address => Whitelist) public whitelist;\n  mapping (bytes32 => address) public referralMultisig;\n  mapping (uint => mapping (uint => uint)) public contributionsPerStretchGoal; //earlyRegistrant => stretch-goals => value\n  mapping (address => uint) public contributionsPerAddress;\n  mapping (address => mapping (uint => uint)) public contributions;\n  mapping (address => uint) public contributorIndex;\n  mapping (uint => address) public reversedContributorIndex;\n  mapping (address => bool) public tokensCollected;\n  mapping (bytes32 => uint) public referralContribution;\n\n  event Contribute(uint blkNo, uint blkTs, address indexed contributor, address indexed tokensale, uint amount, bytes32 referralCode);\n  event Whitelisted(uint blkNo, uint blkTs, address indexed contributor, bool isEarlyRegistrant, bytes32 referralCode);\n  event WhitelistChanged(address indexed _old, address indexed _new);\n\n  enum State { TokenSale, End, Collection }\n  State public state;\n\n  REIDAOMintableBurnableLockableToken crvToken;\n  REIDAOMintableBurnableLockableToken crpToken;\n  REIDAOMintableToken reiToken;\n\n  struct Whitelist {\n    bool whitelisted;\n    bool isEarlyRegistrant;\n    bytes32 referralCode;\n  }\n\n  /**\n   * @dev initializes contract\n   * @param _stretchGoal1 uint the stretch goal 1 amount in ETH\n   * @param _stretchGoal2 uint the stretch goal 2 amount in ETH\n   * @param _stretchGoal3 uint the stretch goal 3 amount in ETH\n   * @param _opsAdmin address the address of operation admin\n   * @param _crowdvillaWallet address the address of Crowdvilla's wallet\n   * @param _reidaoWallet address the address of REIDAO's wallet\n   * @param _crvTokenAddr address the address of CRVToken contract\n   * @param _crpTokenAddr address the address of CRPToken contract\n   * @param _reiTokenAddr address the address of REIToken contract\n   */\n  function CrowdvillaTokenSale(\n      uint _stretchGoal1,\n      uint _stretchGoal2,\n      uint _stretchGoal3,\n      address _opsAdmin,\n      address _crowdvillaWallet,\n      address _reidaoWallet,\n      address _crvTokenAddr,\n      address _crpTokenAddr,\n      address _reiTokenAddr) public {\n    deployer = msg.sender;\n    state = State.TokenSale;\n\n    opsAdmin = address(_opsAdmin);\n    crowdvillaWallet = address(_crowdvillaWallet);\n    reidaoWallet = address(_reidaoWallet);\n    crvTokenAddr = address(_crvTokenAddr);\n    crpTokenAddr = address(_crpTokenAddr);\n    reiTokenAddr = address(_reiTokenAddr);\n    crvToken = REIDAOMintableBurnableLockableToken(crvTokenAddr);\n    crpToken = REIDAOMintableBurnableLockableToken(crpTokenAddr);\n    reiToken = REIDAOMintableToken(reiTokenAddr);\n\n    minContribution = 1 ether;\n    crvPerEth = 400 * (10**crvToken.decimals());\n    reiPerEth = 5 * (10**reiToken.decimals());\n    mgmtFeePercentage = 20;\n    saleEndBlock = 5280000; //appox end of Mar 2018\n    stretchGoals = [_stretchGoal1 * 1 ether, _stretchGoal2 * 1 ether, _stretchGoal3 * 1 ether];\n  }\n\n\n  // public - START ------------------------------------------------------------\n  /**\n   * @dev accepts ether, records contributions, and splits payment if referral code exists.\n   *   contributor must be whitelisted, and sends the min ETH required.\n   */\n  function () public payable {\n    if (msg.value>0) {\n      // for accepting fund\n      require(isInWhitelist(msg.sender));\n      require(msg.value >= minContribution);\n      require(state == State.TokenSale);\n      require(block.number < saleEndBlock);\n      require(currentStretchGoal < stretchGoals.length);\n\n      totalFund = totalFund.add(msg.value);\n\n      uint earlyRegistrantIndex = 0;\n      if (whitelist[msg.sender].isEarlyRegistrant) {\n        earlyRegistrantIndex = 1;\n      }\n\n      contributions[msg.sender][currentStretchGoal] = contributions[msg.sender][currentStretchGoal].add(msg.value);\n\n      contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal] = contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal].add(msg.value);\n      contributionsPerAddress[msg.sender] = contributionsPerAddress[msg.sender].add(msg.value);\n      bytes32 referralCode = whitelist[msg.sender].referralCode;\n      referralContribution[referralCode] = referralContribution[referralCode].add(msg.value);\n      logContributeEvent(msg.sender, msg.value, referralCode);\n\n      if (referralCode == bytes32(0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563)) {\n        //no referral code\n        crowdvillaWallet.transfer(msg.value);\n      } else {\n        //referral code exist, sending 99% to our wallet. 1% to multisig with arbiter\n        uint crowdvillaAmount = (msg.value.mul(99)).div(100);\n        crowdvillaWallet.transfer(crowdvillaAmount);\n        referralMultisig[referralCode].transfer(msg.value.sub(crowdvillaAmount));\n      }\n\n      // to increase the currentStrechGoal targetted if the current one has been reached.\n      //  also safe-guard if multiple stretch goals reached with a single contribution.\n      // to end the token sale if it has reached the last stretch goal.\n      for (uint currGoal = currentStretchGoal; currGoal < stretchGoals.length; currGoal++) {\n        if (totalFund >= stretchGoals[currGoal] && currentStretchGoal != stretchGoals.length) {\n          currentStretchGoal++;\n        }\n      }\n\n      if (contributorIndex[msg.sender]==0) {\n        uniqueContributors++;\n        contributorIndex[msg.sender] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = msg.sender;\n      }\n    } else {\n      // for tokens collection\n      require(state == State.Collection);\n      require(!tokensCollected[msg.sender]);\n      uint promisedCRVToken = getPromisedCRVTokenAmount(msg.sender);\n      require(promisedCRVToken>0);\n      require(crvToken.mint(msg.sender, promisedCRVToken));\n      require(crpToken.mint(msg.sender, promisedCRVToken));\n      require(reiToken.mint(msg.sender, getPromisedREITokenAmount(msg.sender)));\n      tokensCollected[msg.sender] = true;\n    }\n  }\n\n  /**\n   * @dev calculates the amount of CRV tokens allocated to `_contributor`, with\n   *   stretch goal calculation.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedCRVTokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n\n    uint earlyRegistrantBonus = 0;\n    if (whitelist[_contributor].isEarlyRegistrant)\n      earlyRegistrantBonus = 1;\n\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val += (contributions[_contributor][i] * crvPerEth * (100 + ((currentStretchGoal-i + earlyRegistrantBonus) * 10))/100) / 1 ether;\n    }\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to `_contributor. 5 REI per ETH.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedREITokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n    uint totalEthContributions;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      totalEthContributions = totalEthContributions.add(contributions[_contributor][i]);\n    }\n    val = (totalEthContributions.mul(reiPerEth)).div(1 ether);\n\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to REIDAO\n   */\n  function getREIDAODistributionTokenAmount() public constant returns (uint) {\n    //contributionsPerStretchGoal index 0 is for non-earlyRegistrant\n    //contributionsPerStretchGoal index 1 is for earlyRegistrant\n    uint val;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val += (contributionsPerStretchGoal[0][i] * crvPerEth * (100 + ((currentStretchGoal-i) * 10))/100) / 1 ether;\n    }\n    for (i=0; i<=currentStretchGoal; i++) {\n      val += (contributionsPerStretchGoal[1][i] * crvPerEth * (100 + ((currentStretchGoal-i + 1) * 10))/100) / 1 ether;\n    }\n    uint total = (val.mul(100)).div(100 - mgmtFeePercentage);\n    val = total.sub(val);\n    return val;\n  }\n\n  /**\n   * @dev Checks if `_contributor` is in the whitelist.\n   * @param _contributor address The address of contributor.\n   */\n  function isInWhitelist(address _contributor) public constant returns (bool) {\n    return (whitelist[_contributor].whitelisted == true);\n  }\n  // public - END --------------------------------------------------------------\n\n\n  // ownerOnly - START ---------------------------------------------------------\n  /**\n   * @dev collects tokens distribution allocated to REIDAO\n   */\n  function collectREIDAODistribution() public ownerOnly {\n    require(!tokensCollected[reidaoWallet]);\n    uint tokenAmount = getREIDAODistributionTokenAmount();\n    require(crvToken.mint(reidaoWallet, tokenAmount));\n    require(crpToken.mint(reidaoWallet, tokenAmount));\n    tokensCollected[reidaoWallet] = true;\n  }\n\n  /**\n   * @dev updates sale end block\n   * @param _saleEndBlock uint block number denotes end of sale\n   */\n  function updateSaleEndBlock(uint _saleEndBlock) public ownerOnly {\n    saleEndBlock = _saleEndBlock;\n  }\n\n  /**\n   * @dev ends token sale\n   */\n  function endTokenSale() public ownerOnly {\n    setEndState();\n  }\n\n  /**\n   * @dev sets state as Collection\n   */\n  function startCollection() public ownerOnly {\n    state = State.Collection;\n  }\n\n  /**\n   * @dev Allows owners to update `_opsAdmin` as new opsAdmin.\n   * @param _opsAdmin address The address of new opsAdmin.\n   */\n  function updateOpsAdmin(address _opsAdmin) public ownerOnly {\n    opsAdmin = _opsAdmin;\n  }\n\n  /**\n   * @dev Allows authorized signatories to update contributor address.\n   * @param _old address the old contributor address.\n   * @param _new address the new contributor address.\n   */\n  function updateContributorAddress(address _old, address _new) public ownerOnly {\n    require (state != State.Collection);\n    whitelist[_new] = Whitelist(whitelist[_old].whitelisted, whitelist[_old].isEarlyRegistrant, whitelist[_old].referralCode);\n    uint currentContribution;\n\n    bool contributionFound;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      currentContribution = contributions[_old][i];\n      if (currentContribution > 0) {\n        contributions[_old][i] = 0;\n        contributions[_new][i] += currentContribution;\n        contributionsPerAddress[_old] -= currentContribution;\n        contributionsPerAddress[_new] += currentContribution;\n        logContributeEvent(_new, currentContribution, whitelist[_old].referralCode);\n\n        contributionFound = true;\n      }\n    }\n    removeFromWhitelist(_old);\n\n    if (contributionFound) {\n      if (contributorIndex[_new]==0) {\n        uniqueContributors++;\n        contributorIndex[_new] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = _new;\n      }\n    }\n    WhitelistChanged(_old, _new);\n  }\n  // ownerOnly - END -----------------------------------------------------------\n\n\n  // opsAdmin - START ----------------------------------------------------------\n  /**\n   * @dev Allows opsAdmin to add `_contributor` to the whitelist.\n   * @param _contributor address The address of contributor.\n   * @param _earlyRegistrant bool If contributor is early registrant (registered before public sale).\n   * @param _referralCode bytes32 The referral code. Empty String if not provided.\n   */\n  function addToWhitelist(address _contributor, bool _earlyRegistrant, bytes32 _referralCode) public opsAdminOnly {\n    whitelist[_contributor] = Whitelist(true, _earlyRegistrant, keccak256(_referralCode));\n    Whitelisted(block.number, block.timestamp, _contributor, _earlyRegistrant, keccak256(_referralCode));\n  }\n\n  /**\n   * @dev Allows opsAdmin to register `_multisigAddr` as multisig wallet address for referral code `_referralCode`.\n   * @param _referralCode bytes32 The referral code. Should not be empty since it should have value.\n   * @param _multisigAddr address The address of multisig wallet.\n   */\n  function registerReferralMultisig(bytes32 _referralCode, address _multisigAddr) public opsAdminOnly {\n    referralMultisig[keccak256(_referralCode)] = _multisigAddr;\n    totalReferralMultisig++;\n  }\n  // opsAdmin - END ------------------------------------------------------------\n\n\n  // internal - START ----------------------------------------------------------\n  /**\n   * @dev sets state as End\n   */\n  function setEndState() internal {\n    state = State.End;\n  }\n\n  /**\n   * @dev Allows authorized signatories to remove `_contributor` from the whitelist.\n   * @param _contributor address address of contributor.\n   */\n  function removeFromWhitelist(address _contributor) internal {\n    whitelist[_contributor].whitelisted = false;\n    whitelist[_contributor].isEarlyRegistrant = false;\n  }\n\n  /**\n   * @dev logs contribution event\n   * @param _contributor address address of contributor\n   * @param _amount uint contribution amount\n   * @param _referralCode bytes32 referral code from the contribution. Empty string if none.\n   */\n  function logContributeEvent(address _contributor, uint _amount, bytes32 _referralCode) internal {\n    Contribute(block.number, block.timestamp, _contributor, this, _amount, _referralCode);\n  }\n  // internal - END ------------------------------------------------------------\n\n\n  // modifier - START ----------------------------------------------------------\n  /**\n   * @dev throws if sender is not opsAdmin.\n   */\n  modifier opsAdminOnly {\n    require(msg.sender == opsAdmin);\n    _;\n  }\n  // modifier - END ------------------------------------------------------------\n}\n", "commit_id": "b59922fc135c93b0bd5c6d697b22ef0a47d6de1a"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.18;\n\nimport './math/SafeMath.sol';\nimport \"./tokens/REIDAOMintableBurnableLockableToken.sol\";\nimport \"./tokens/REIDAOMintableToken.sol\";\n\ncontract CrowdvillaTokenSale is Owners(true) {\n  using SafeMath for uint256;\n  //TODO use safemath for all\n\n  uint public totalFund;\n  uint public uniqueContributors;\n  uint public currentStretchGoal;\n  uint public minContribution;\n  uint public crvPerEth;\n  uint public reiPerEth;\n  uint public mgmtFeePercentage;\n  uint public saleEndBlock;\n  uint public totalReferralMultisig;\n  uint[] public stretchGoals;\n\n  address public deployer;\n  address public opsAdmin;\n  address public crowdvillaWallet;\n  address public reidaoWallet;\n  address public crvTokenAddr;\n  address public crpTokenAddr;\n  address public reiTokenAddr;\n  mapping (address => Whitelist) public whitelist;\n  mapping (bytes32 => address) public referralMultisig;\n  mapping (uint => mapping (uint => uint)) public contributionsPerStretchGoal; //earlyRegistrant => stretch-goals => value\n  mapping (address => uint) public contributionsPerAddress;\n  mapping (address => mapping (uint => uint)) public contributions;\n  mapping (address => uint) public contributorIndex;\n  mapping (uint => address) public reversedContributorIndex;\n  mapping (address => bool) public tokensCollected;\n  mapping (bytes32 => uint) public referralContribution;\n\n  event Contribute(uint blkNo, uint blkTs, address indexed contributor, address indexed tokensale, uint amount, bytes32 referralCode);\n  event Whitelisted(uint blkNo, uint blkTs, address indexed contributor, bool isEarlyRegistrant, bytes32 referralCode);\n  event WhitelistChanged(address indexed _old, address indexed _new);\n\n  enum State { TokenSale, End, Collection }\n  State public state;\n\n  REIDAOMintableBurnableLockableToken crvToken;\n  REIDAOMintableBurnableLockableToken crpToken;\n  REIDAOMintableToken reiToken;\n\n  struct Whitelist {\n    bool whitelisted;\n    bool isEarlyRegistrant;\n    bytes32 referralCode;\n  }\n\n  /**\n   * @dev initializes contract\n   * @param _stretchGoal1 uint the stretch goal 1 amount in ETH\n   * @param _stretchGoal2 uint the stretch goal 2 amount in ETH\n   * @param _stretchGoal3 uint the stretch goal 3 amount in ETH\n   * @param _opsAdmin address the address of operation admin\n   * @param _crowdvillaWallet address the address of Crowdvilla's wallet\n   * @param _reidaoWallet address the address of REIDAO's wallet\n   * @param _crvTokenAddr address the address of CRVToken contract\n   * @param _crpTokenAddr address the address of CRPToken contract\n   * @param _reiTokenAddr address the address of REIToken contract\n   */\n  function CrowdvillaTokenSale(\n      uint _stretchGoal1,\n      uint _stretchGoal2,\n      uint _stretchGoal3,\n      address _opsAdmin,\n      address _crowdvillaWallet,\n      address _reidaoWallet,\n      address _crvTokenAddr,\n      address _crpTokenAddr,\n      address _reiTokenAddr) public {\n    deployer = msg.sender;\n    state = State.TokenSale;\n\n    opsAdmin = address(_opsAdmin);\n    crowdvillaWallet = address(_crowdvillaWallet);\n    reidaoWallet = address(_reidaoWallet);\n    crvTokenAddr = address(_crvTokenAddr);\n    crpTokenAddr = address(_crpTokenAddr);\n    reiTokenAddr = address(_reiTokenAddr);\n    crvToken = REIDAOMintableBurnableLockableToken(crvTokenAddr);\n    crpToken = REIDAOMintableBurnableLockableToken(crpTokenAddr);\n    reiToken = REIDAOMintableToken(reiTokenAddr);\n\n    minContribution = 1 ether;\n    crvPerEth = 400 * (10**crvToken.decimals());\n    reiPerEth = 5 * (10**reiToken.decimals());\n    mgmtFeePercentage = 20;\n    saleEndBlock = 5280000; //appox end of Mar 2018\n    stretchGoals = [_stretchGoal1 * 1 ether, _stretchGoal2 * 1 ether, _stretchGoal3 * 1 ether];\n  }\n\n\n  // public - START ------------------------------------------------------------\n  /**\n   * @dev accepts ether, records contributions, and splits payment if referral code exists.\n   *   contributor must be whitelisted, and sends the min ETH required.\n   */\n  function () public payable {\n    if (msg.value>0) {\n      // for accepting fund\n      require(isInWhitelist(msg.sender));\n      require(msg.value >= minContribution);\n      require(state == State.TokenSale);\n      require(block.number < saleEndBlock);\n      require(currentStretchGoal < stretchGoals.length);\n\n      totalFund = totalFund.add(msg.value);\n\n      uint earlyRegistrantIndex = 0;\n      if (whitelist[msg.sender].isEarlyRegistrant) {\n        earlyRegistrantIndex = 1;\n      }\n\n      contributions[msg.sender][currentStretchGoal] = contributions[msg.sender][currentStretchGoal].add(msg.value);\n\n      contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal] = contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal].add(msg.value);\n      contributionsPerAddress[msg.sender] = contributionsPerAddress[msg.sender].add(msg.value);\n      bytes32 referralCode = whitelist[msg.sender].referralCode;\n      referralContribution[referralCode] = referralContribution[referralCode].add(msg.value);\n      logContributeEvent(msg.sender, msg.value, referralCode);\n\n      if (referralCode == bytes32(0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563)) {\n        //no referral code\n        crowdvillaWallet.transfer(msg.value);\n      } else {\n        //referral code exist, sending 99% to our wallet. 1% to multisig with arbiter\n        uint crowdvillaAmount = (msg.value.mul(99)).div(100);\n        crowdvillaWallet.transfer(crowdvillaAmount);\n        referralMultisig[referralCode].transfer(msg.value.sub(crowdvillaAmount));\n      }\n\n      // to increase the currentStrechGoal targetted if the current one has been reached.\n      //  also safe-guard if multiple stretch goals reached with a single contribution.\n      // to end the token sale if it has reached the last stretch goal.\n      for (uint currGoal = currentStretchGoal; currGoal < stretchGoals.length; currGoal++) {\n        if (totalFund >= stretchGoals[currGoal] && currentStretchGoal != stretchGoals.length) {\n          currentStretchGoal++;\n        }\n      }\n\n      if (contributorIndex[msg.sender]==0) {\n        uniqueContributors++;\n        contributorIndex[msg.sender] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = msg.sender;\n      }\n    } else {\n      // for tokens collection\n      require(state == State.Collection);\n      require(!tokensCollected[msg.sender]);\n      uint promisedCRVToken = getPromisedCRVTokenAmount(msg.sender);\n      require(promisedCRVToken>0);\n      require(crvToken.mint(msg.sender, promisedCRVToken));\n      require(crpToken.mint(msg.sender, promisedCRVToken));\n      require(reiToken.mint(msg.sender, getPromisedREITokenAmount(msg.sender)));\n      tokensCollected[msg.sender] = true;\n    }\n  }\n\n  /**\n   * @dev calculates the amount of CRV tokens allocated to `_contributor`, with\n   *   stretch goal calculation.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedCRVTokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n\n    uint earlyRegistrantBonus = 0;\n    if (whitelist[_contributor].isEarlyRegistrant)\n      earlyRegistrantBonus = 1;\n\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val = val.add((contributions[_contributor][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i).mul(earlyRegistrantBonus)).mul(10)).add(100)).div(100)).div(1 ether));\n    }\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to `_contributor. 5 REI per ETH.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedREITokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n    uint totalEthContributions;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      totalEthContributions = totalEthContributions.add(contributions[_contributor][i]);\n    }\n    val = (totalEthContributions.mul(reiPerEth)).div(1 ether);\n\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to REIDAO\n   */\n  function getREIDAODistributionTokenAmount() public constant returns (uint) {\n    //contributionsPerStretchGoal index 0 is for non-earlyRegistrant\n    //contributionsPerStretchGoal index 1 is for earlyRegistrant\n    uint val;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val = val.add((contributionsPerStretchGoal[0][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i)).mul(10)).add(100)).div(100)).div(1 ether));\n    }\n    for (i=0; i<=currentStretchGoal; i++) {\n      val = val.add((contributionsPerStretchGoal[1][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i).add(1)).mul(10)).add(100)).div(100)).div(1 ether));\n    }\n    uint total = (val.mul(100)).div(100 - mgmtFeePercentage);\n    val = total.sub(val);\n    return val;\n  }\n\n  /**\n   * @dev Checks if `_contributor` is in the whitelist.\n   * @param _contributor address The address of contributor.\n   */\n  function isInWhitelist(address _contributor) public constant returns (bool) {\n    return (whitelist[_contributor].whitelisted == true);\n  }\n  // public - END --------------------------------------------------------------\n\n\n  // ownerOnly - START ---------------------------------------------------------\n  /**\n   * @dev collects tokens distribution allocated to REIDAO\n   */\n  function collectREIDAODistribution() public ownerOnly {\n    require(!tokensCollected[reidaoWallet]);\n    uint tokenAmount = getREIDAODistributionTokenAmount();\n    require(crvToken.mint(reidaoWallet, tokenAmount));\n    require(crpToken.mint(reidaoWallet, tokenAmount));\n    tokensCollected[reidaoWallet] = true;\n  }\n\n  /**\n   * @dev updates sale end block\n   * @param _saleEndBlock uint block number denotes end of sale\n   */\n  function updateSaleEndBlock(uint _saleEndBlock) public ownerOnly {\n    saleEndBlock = _saleEndBlock;\n  }\n\n  /**\n   * @dev ends token sale\n   */\n  function endTokenSale() public ownerOnly {\n    setEndState();\n  }\n\n  /**\n   * @dev sets state as Collection\n   */\n  function startCollection() public ownerOnly {\n    state = State.Collection;\n  }\n\n  /**\n   * @dev Allows owners to update `_opsAdmin` as new opsAdmin.\n   * @param _opsAdmin address The address of new opsAdmin.\n   */\n  function updateOpsAdmin(address _opsAdmin) public ownerOnly {\n    opsAdmin = _opsAdmin;\n  }\n\n  /**\n   * @dev Allows authorized signatories to update contributor address.\n   * @param _old address the old contributor address.\n   * @param _new address the new contributor address.\n   */\n  function updateContributorAddress(address _old, address _new) public ownerOnly {\n    require (state != State.Collection);\n    whitelist[_new] = Whitelist(whitelist[_old].whitelisted, whitelist[_old].isEarlyRegistrant, whitelist[_old].referralCode);\n    uint currentContribution;\n\n    bool contributionFound;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      currentContribution = contributions[_old][i];\n      if (currentContribution > 0) {\n        contributions[_old][i] = 0;\n        contributions[_new][i] += currentContribution;\n        contributionsPerAddress[_old] -= currentContribution;\n        contributionsPerAddress[_new] += currentContribution;\n        logContributeEvent(_new, currentContribution, whitelist[_old].referralCode);\n\n        contributionFound = true;\n      }\n    }\n    removeFromWhitelist(_old);\n\n    if (contributionFound) {\n      if (contributorIndex[_new]==0) {\n        uniqueContributors++;\n        contributorIndex[_new] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = _new;\n      }\n    }\n    WhitelistChanged(_old, _new);\n  }\n  // ownerOnly - END -----------------------------------------------------------\n\n\n  // opsAdmin - START ----------------------------------------------------------\n  /**\n   * @dev Allows opsAdmin to add `_contributor` to the whitelist.\n   * @param _contributor address The address of contributor.\n   * @param _earlyRegistrant bool If contributor is early registrant (registered before public sale).\n   * @param _referralCode bytes32 The referral code. Empty String if not provided.\n   */\n  function addToWhitelist(address _contributor, bool _earlyRegistrant, bytes32 _referralCode) public opsAdminOnly {\n    whitelist[_contributor] = Whitelist(true, _earlyRegistrant, keccak256(_referralCode));\n    Whitelisted(block.number, block.timestamp, _contributor, _earlyRegistrant, keccak256(_referralCode));\n  }\n\n  /**\n   * @dev Allows opsAdmin to register `_multisigAddr` as multisig wallet address for referral code `_referralCode`.\n   * @param _referralCode bytes32 The referral code. Should not be empty since it should have value.\n   * @param _multisigAddr address The address of multisig wallet.\n   */\n  function registerReferralMultisig(bytes32 _referralCode, address _multisigAddr) public opsAdminOnly {\n    referralMultisig[keccak256(_referralCode)] = _multisigAddr;\n    totalReferralMultisig++;\n  }\n  // opsAdmin - END ------------------------------------------------------------\n\n\n  // internal - START ----------------------------------------------------------\n  /**\n   * @dev sets state as End\n   */\n  function setEndState() internal {\n    state = State.End;\n  }\n\n  /**\n   * @dev Allows authorized signatories to remove `_contributor` from the whitelist.\n   * @param _contributor address address of contributor.\n   */\n  function removeFromWhitelist(address _contributor) internal {\n    whitelist[_contributor].whitelisted = false;\n    whitelist[_contributor].isEarlyRegistrant = false;\n  }\n\n  /**\n   * @dev logs contribution event\n   * @param _contributor address address of contributor\n   * @param _amount uint contribution amount\n   * @param _referralCode bytes32 referral code from the contribution. Empty string if none.\n   */\n  function logContributeEvent(address _contributor, uint _amount, bytes32 _referralCode) internal {\n    Contribute(block.number, block.timestamp, _contributor, this, _amount, _referralCode);\n  }\n  // internal - END ------------------------------------------------------------\n\n\n  // modifier - START ----------------------------------------------------------\n  /**\n   * @dev throws if sender is not opsAdmin.\n   */\n  modifier opsAdminOnly {\n    require(msg.sender == opsAdmin);\n    _;\n  }\n  // modifier - END ------------------------------------------------------------\n}\n", "flattened_code": "pragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\n\npragma solidity ^0.4.18;\n\n\npragma solidity ^0.4.18;\n\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n   * @dev Fix for the ERC20 short address attack.\n   */\n  modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length == size + 4);\n    _;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\npragma solidity ^0.4.18;\n\n\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public onlyPayloadSize(2 * 32) returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   */\n  function increaseApproval(address _spender, uint _addedValue) public onlyPayloadSize(2 * 32) returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  function decreaseApproval(address _spender, uint _subtractedValue) public onlyPayloadSize(2 * 32) returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\npragma solidity ^0.4.18;\n\ncontract Owners {\n\n  mapping (address => bool) public owners;\n  uint public ownersCount;\n  uint public minOwnersRequired = 2;\n\n  event OwnerAdded(address indexed owner);\n  event OwnerRemoved(address indexed owner);\n\n  /**\n   * @dev initializes contract\n   * @param withDeployer bool indicates whether deployer is part of owners\n   */\n  function Owners(bool withDeployer) public {\n    if (withDeployer) {\n      ownersCount++;\n      owners[msg.sender] = true;\n    }\n    owners[0x23B599A0949C6147E05C267909C16506C7eFF229] = true;\n    owners[0x286A70B3E938FCa244208a78B1823938E8e5C174] = true;\n    ownersCount = ownersCount + 2;\n  }\n\n  /**\n   * @dev adds owner, can only by done by owners only\n   * @param _address address the address to be added\n   */\n  function addOwner(address _address) public ownerOnly {\n    owners[_address] = true;\n    ownersCount++;\n    OwnerAdded(_address);\n  }\n\n  /**\n   * @dev removes owner, can only by done by owners only\n   * @param _address address the address to be removed\n   */\n  function removeOwner(address _address) public ownerOnly notOwnerItself(_address) minOwners {\n    owners[_address] = false;\n    OwnerRemoved(_address);\n  }\n\n  /**\n   * @dev checks if sender is owner\n   */\n  modifier ownerOnly {\n    require(owners[msg.sender]);\n    _;\n  }\n\n  modifier notOwnerItself(address _owner) {\n    require(msg.sender != _owner);\n    _;\n  }\n\n  modifier minOwners {\n    require(ownersCount > minOwnersRequired);\n    _;\n  }\n\n}\n\n\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\n\ncontract MintableToken is StandardToken, Owners(true) {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n  event MintStarted();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(address _to, uint256 _amount) ownerOnly canMint onlyPayloadSize(2 * 32) public returns (bool) {\n    totalSupply = totalSupply.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    Mint(_to, _amount);\n    Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() ownerOnly canMint public returns (bool) {\n    mintingFinished = true;\n    MintFinished();\n    return true;\n  }\n\n  /**\n   * @dev Function to start minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function startMinting() ownerOnly public returns (bool) {\n    mintingFinished = false;\n    MintStarted();\n    return true;\n  }\n}\n\ncontract REIDAOMintableToken is MintableToken {\n\n  uint public decimals = 8;\n\n  bool public tradingStarted = false;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) public canTrade returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint _value) public canTrade returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  /**\n   * @dev modifier that throws if trading has not started yet\n   */\n  modifier canTrade() {\n    require(tradingStarted);\n    _;\n  }\n\n  /**\n   * @dev Allows the owner to enable the trading. Done only once.\n   */\n  function startTrading() public ownerOnly {\n    tradingStarted = true;\n  }\n}\n\ncontract REIDAOMintableLockableToken is REIDAOMintableToken {\n\n  struct TokenLock {\n    uint256 value;\n    uint lockedUntil;\n  }\n\n  mapping (address => TokenLock[]) public locks;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) public canTransfer(msg.sender, _value) returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint _value) public canTransfer(msg.sender, _value) returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  /**\n   * @dev Allows authorized callers to lock `_value` tokens belong to `_to` until timestamp `_lockUntil`.\n   * This function can be called independently of transferAndLockTokens(), hence the double checking of timestamp.\n   * @param _to address The address to be locked.\n   * @param _value uint The amout of tokens to be locked.\n   * @param _lockUntil uint The UNIX timestamp tokens are locked until.\n   */\n  function lockTokens(address _to, uint256 _value, uint256 _lockUntil) public ownerOnly {\n    require(_value <= balanceOf(_to));\n    require(_lockUntil > now);\n    locks[_to].push(TokenLock(_value, _lockUntil));\n  }\n\n  /**\n   * @dev Allows authorized callers to mint `_value` tokens for `_to`, and lock them until timestamp `_lockUntil`.\n   * @param _to address The address to which tokens to be minted and locked.\n   * @param _value uint The amout of tokens to be minted and locked.\n   * @param _lockUntil uint The UNIX timestamp tokens are locked until.\n   */\n  function mintAndLockTokens(address _to, uint256 _value, uint256 _lockUntil) public ownerOnly {\n    require(_lockUntil > now);\n    mint(_to, _value);\n    lockTokens(_to, _value, _lockUntil);\n  }\n\n  /**\n   * @dev Checks the amount of transferable tokens belongs to `_holder`.\n   * @param _holder address The address to be checked.\n   */\n  function transferableTokens(address _holder) public constant returns (uint256) {\n    uint256 lockedTokens = getLockedTokens(_holder);\n    if (lockedTokens==0) {\n      return balanceOf(_holder);\n    } else {\n      return balanceOf(_holder).sub(lockedTokens);\n    }\n  }\n\n  /**\n   * @dev Retrieves the amount of locked tokens `_holder` has.\n   * @param _holder address The address to be checked.\n   */\n  function getLockedTokens(address _holder) public constant returns (uint256) {\n    uint256 numLocks = getTokenLocksCount(_holder);\n\n    // shortcut for holder without locks\n    if (numLocks == 0) return 0;\n\n    // Iterate through all the locks the holder has\n    uint256 lockedTokens = 0;\n    for (uint256 i = 0; i < numLocks; i++) {\n      if (locks[_holder][i].lockedUntil >= now) {\n        lockedTokens = lockedTokens.add(locks[_holder][i].value);\n      }\n    }\n\n    return lockedTokens;\n  }\n\n  /**\n   * @dev Retrieves the number of token locks `_holder` has.\n   * @param _holder address The address the token locks belongs to.\n   * @return A uint256 representing the total number of locks.\n   */\n  function getTokenLocksCount(address _holder) internal constant returns (uint256 index) {\n    return locks[_holder].length;\n  }\n\n  /**\n   * @dev Modifier that throws if `_value` amount of tokens can't be transferred.\n   * @param _sender address the address of the sender\n   * @param _value uint the amount of tokens intended to be transferred\n   */\n  modifier canTransfer(address _sender, uint256 _value) {\n    uint256 transferableTokensAmt = transferableTokens(_sender);\n    require (_value <= transferableTokensAmt);\n    // delete locks if all locks are cleared\n    if (transferableTokensAmt == balanceOf(_sender) && getTokenLocksCount(_sender)>0) {\n      delete locks[_sender];\n    }\n    _;\n  }\n}\npragma solidity ^0.4.18;\n\npragma solidity ^0.4.18;\n\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract BurnableToken is BasicToken {\n\n    event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n    function burn(uint256 _value) public {\n        require(_value <= balances[msg.sender]);\n        // no need to require value <= totalSupply, since that would imply the\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n        address burner = msg.sender;\n        balances[burner] = balances[burner].sub(_value);\n        totalSupply = totalSupply.sub(_value);\n        Burn(burner, _value);\n    }\n}\n\ncontract REIDAOBurnableToken is BurnableToken {\n\n  mapping (address => bool) public hostedWallets;\n\n  /**\n   * @dev burns tokens, can only be done by hosted wallets\n   * @param _value uint256 the amount of tokens to be burned\n   */\n  function burn(uint256 _value) public hostedWalletsOnly {\n    return super.burn(_value);\n  }\n\n  /**\n   * @dev adds hosted wallet\n   * @param _wallet address the address to be added\n   */\n  function addHostedWallet(address _wallet) public {\n    hostedWallets[_wallet] = true;\n  }\n\n  /**\n   * @dev removes hosted wallet\n   * @param _wallet address the address to be removed\n   */\n  function removeHostedWallet(address _wallet) public {\n    hostedWallets[_wallet] = false;\n  }\n\n  /**\n   * @dev checks if sender is hosted wallets\n   */\n  modifier hostedWalletsOnly {\n    require(hostedWallets[msg.sender]==true);\n    _;\n  }\n}\n\ncontract REIDAOMintableBurnableLockableToken is REIDAOMintableLockableToken, REIDAOBurnableToken {\n\n  /**\n   * @dev adds hosted wallet, can only be done by owners.\n   * @param _wallet address the address to be added\n   */\n  function addHostedWallet(address _wallet) public ownerOnly {\n    return super.addHostedWallet(_wallet);\n  }\n\n  /**\n   * @dev removes hosted wallet, can only be done by owners.\n   * @param _wallet address the address to be removed\n   */\n  function removeHostedWallet(address _wallet) public ownerOnly {\n    return super.removeHostedWallet(_wallet);\n  }\n}\n\ncontract CrowdvillaTokenSale is Owners(true) {\n  using SafeMath for uint256;\n  //TODO use safemath for all\n\n  uint public totalFund;\n  uint public uniqueContributors;\n  uint public currentStretchGoal;\n  uint public minContribution;\n  uint public crvPerEth;\n  uint public reiPerEth;\n  uint public mgmtFeePercentage;\n  uint public saleEndBlock;\n  uint public totalReferralMultisig;\n  uint[] public stretchGoals;\n\n  address public deployer;\n  address public opsAdmin;\n  address public crowdvillaWallet;\n  address public reidaoWallet;\n  address public crvTokenAddr;\n  address public crpTokenAddr;\n  address public reiTokenAddr;\n  mapping (address => Whitelist) public whitelist;\n  mapping (bytes32 => address) public referralMultisig;\n  mapping (uint => mapping (uint => uint)) public contributionsPerStretchGoal; //earlyRegistrant => stretch-goals => value\n  mapping (address => uint) public contributionsPerAddress;\n  mapping (address => mapping (uint => uint)) public contributions;\n  mapping (address => uint) public contributorIndex;\n  mapping (uint => address) public reversedContributorIndex;\n  mapping (address => bool) public tokensCollected;\n  mapping (bytes32 => uint) public referralContribution;\n\n  event Contribute(uint blkNo, uint blkTs, address indexed contributor, address indexed tokensale, uint amount, bytes32 referralCode);\n  event Whitelisted(uint blkNo, uint blkTs, address indexed contributor, bool isEarlyRegistrant, bytes32 referralCode);\n  event WhitelistChanged(address indexed _old, address indexed _new);\n\n  enum State { TokenSale, End, Collection }\n  State public state;\n\n  REIDAOMintableBurnableLockableToken crvToken;\n  REIDAOMintableBurnableLockableToken crpToken;\n  REIDAOMintableToken reiToken;\n\n  struct Whitelist {\n    bool whitelisted;\n    bool isEarlyRegistrant;\n    bytes32 referralCode;\n  }\n\n  /**\n   * @dev initializes contract\n   * @param _stretchGoal1 uint the stretch goal 1 amount in ETH\n   * @param _stretchGoal2 uint the stretch goal 2 amount in ETH\n   * @param _stretchGoal3 uint the stretch goal 3 amount in ETH\n   * @param _opsAdmin address the address of operation admin\n   * @param _crowdvillaWallet address the address of Crowdvilla's wallet\n   * @param _reidaoWallet address the address of REIDAO's wallet\n   * @param _crvTokenAddr address the address of CRVToken contract\n   * @param _crpTokenAddr address the address of CRPToken contract\n   * @param _reiTokenAddr address the address of REIToken contract\n   */\n  function CrowdvillaTokenSale(\n      uint _stretchGoal1,\n      uint _stretchGoal2,\n      uint _stretchGoal3,\n      address _opsAdmin,\n      address _crowdvillaWallet,\n      address _reidaoWallet,\n      address _crvTokenAddr,\n      address _crpTokenAddr,\n      address _reiTokenAddr) public {\n    deployer = msg.sender;\n    state = State.TokenSale;\n\n    opsAdmin = address(_opsAdmin);\n    crowdvillaWallet = address(_crowdvillaWallet);\n    reidaoWallet = address(_reidaoWallet);\n    crvTokenAddr = address(_crvTokenAddr);\n    crpTokenAddr = address(_crpTokenAddr);\n    reiTokenAddr = address(_reiTokenAddr);\n    crvToken = REIDAOMintableBurnableLockableToken(crvTokenAddr);\n    crpToken = REIDAOMintableBurnableLockableToken(crpTokenAddr);\n    reiToken = REIDAOMintableToken(reiTokenAddr);\n\n    minContribution = 1 ether;\n    crvPerEth = 400 * (10**crvToken.decimals());\n    reiPerEth = 5 * (10**reiToken.decimals());\n    mgmtFeePercentage = 20;\n    saleEndBlock = 5280000; //appox end of Mar 2018\n    stretchGoals = [_stretchGoal1 * 1 ether, _stretchGoal2 * 1 ether, _stretchGoal3 * 1 ether];\n  }\n\n\n  // public - START ------------------------------------------------------------\n  /**\n   * @dev accepts ether, records contributions, and splits payment if referral code exists.\n   *   contributor must be whitelisted, and sends the min ETH required.\n   */\n  function () public payable {\n    if (msg.value>0) {\n      // for accepting fund\n      require(isInWhitelist(msg.sender));\n      require(msg.value >= minContribution);\n      require(state == State.TokenSale);\n      require(block.number < saleEndBlock);\n      require(currentStretchGoal < stretchGoals.length);\n\n      totalFund = totalFund.add(msg.value);\n\n      uint earlyRegistrantIndex = 0;\n      if (whitelist[msg.sender].isEarlyRegistrant) {\n        earlyRegistrantIndex = 1;\n      }\n\n      contributions[msg.sender][currentStretchGoal] = contributions[msg.sender][currentStretchGoal].add(msg.value);\n\n      contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal] = contributionsPerStretchGoal[earlyRegistrantIndex][currentStretchGoal].add(msg.value);\n      contributionsPerAddress[msg.sender] = contributionsPerAddress[msg.sender].add(msg.value);\n      bytes32 referralCode = whitelist[msg.sender].referralCode;\n      referralContribution[referralCode] = referralContribution[referralCode].add(msg.value);\n      logContributeEvent(msg.sender, msg.value, referralCode);\n\n      if (referralCode == bytes32(0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563)) {\n        //no referral code\n        crowdvillaWallet.transfer(msg.value);\n      } else {\n        //referral code exist, sending 99% to our wallet. 1% to multisig with arbiter\n        uint crowdvillaAmount = (msg.value.mul(99)).div(100);\n        crowdvillaWallet.transfer(crowdvillaAmount);\n        referralMultisig[referralCode].transfer(msg.value.sub(crowdvillaAmount));\n      }\n\n      // to increase the currentStrechGoal targetted if the current one has been reached.\n      //  also safe-guard if multiple stretch goals reached with a single contribution.\n      // to end the token sale if it has reached the last stretch goal.\n      for (uint currGoal = currentStretchGoal; currGoal < stretchGoals.length; currGoal++) {\n        if (totalFund >= stretchGoals[currGoal] && currentStretchGoal != stretchGoals.length) {\n          currentStretchGoal++;\n        }\n      }\n\n      if (contributorIndex[msg.sender]==0) {\n        uniqueContributors++;\n        contributorIndex[msg.sender] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = msg.sender;\n      }\n    } else {\n      // for tokens collection\n      require(state == State.Collection);\n      require(!tokensCollected[msg.sender]);\n      uint promisedCRVToken = getPromisedCRVTokenAmount(msg.sender);\n      require(promisedCRVToken>0);\n      require(crvToken.mint(msg.sender, promisedCRVToken));\n      require(crpToken.mint(msg.sender, promisedCRVToken));\n      require(reiToken.mint(msg.sender, getPromisedREITokenAmount(msg.sender)));\n      tokensCollected[msg.sender] = true;\n    }\n  }\n\n  /**\n   * @dev calculates the amount of CRV tokens allocated to `_contributor`, with\n   *   stretch goal calculation.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedCRVTokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n\n    uint earlyRegistrantBonus = 0;\n    if (whitelist[_contributor].isEarlyRegistrant)\n      earlyRegistrantBonus = 1;\n\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val = val.add((contributions[_contributor][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i).mul(earlyRegistrantBonus)).mul(10)).add(100)).div(100)).div(1 ether));\n    }\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to `_contributor. 5 REI per ETH.\n   * @param _contributor address the address of contributor\n   */\n  function getPromisedREITokenAmount(address _contributor) public constant returns (uint) {\n    uint val;\n    uint totalEthContributions;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      totalEthContributions = totalEthContributions.add(contributions[_contributor][i]);\n    }\n    val = (totalEthContributions.mul(reiPerEth)).div(1 ether);\n\n    return val;\n  }\n\n  /**\n   * @dev calculates the amount of tokens allocated to REIDAO\n   */\n  function getREIDAODistributionTokenAmount() public constant returns (uint) {\n    //contributionsPerStretchGoal index 0 is for non-earlyRegistrant\n    //contributionsPerStretchGoal index 1 is for earlyRegistrant\n    uint val;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      val = val.add((contributionsPerStretchGoal[0][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i)).mul(10)).add(100)).div(100)).div(1 ether));\n    }\n    for (i=0; i<=currentStretchGoal; i++) {\n      val = val.add((contributionsPerStretchGoal[1][i].mul(crvPerEth).mul(((currentStretchGoal.sub(i).add(1)).mul(10)).add(100)).div(100)).div(1 ether));\n    }\n    uint total = (val.mul(100)).div(100 - mgmtFeePercentage);\n    val = total.sub(val);\n    return val;\n  }\n\n  /**\n   * @dev Checks if `_contributor` is in the whitelist.\n   * @param _contributor address The address of contributor.\n   */\n  function isInWhitelist(address _contributor) public constant returns (bool) {\n    return (whitelist[_contributor].whitelisted == true);\n  }\n  // public - END --------------------------------------------------------------\n\n\n  // ownerOnly - START ---------------------------------------------------------\n  /**\n   * @dev collects tokens distribution allocated to REIDAO\n   */\n  function collectREIDAODistribution() public ownerOnly {\n    require(!tokensCollected[reidaoWallet]);\n    uint tokenAmount = getREIDAODistributionTokenAmount();\n    require(crvToken.mint(reidaoWallet, tokenAmount));\n    require(crpToken.mint(reidaoWallet, tokenAmount));\n    tokensCollected[reidaoWallet] = true;\n  }\n\n  /**\n   * @dev updates sale end block\n   * @param _saleEndBlock uint block number denotes end of sale\n   */\n  function updateSaleEndBlock(uint _saleEndBlock) public ownerOnly {\n    saleEndBlock = _saleEndBlock;\n  }\n\n  /**\n   * @dev ends token sale\n   */\n  function endTokenSale() public ownerOnly {\n    setEndState();\n  }\n\n  /**\n   * @dev sets state as Collection\n   */\n  function startCollection() public ownerOnly {\n    state = State.Collection;\n  }\n\n  /**\n   * @dev Allows owners to update `_opsAdmin` as new opsAdmin.\n   * @param _opsAdmin address The address of new opsAdmin.\n   */\n  function updateOpsAdmin(address _opsAdmin) public ownerOnly {\n    opsAdmin = _opsAdmin;\n  }\n\n  /**\n   * @dev Allows authorized signatories to update contributor address.\n   * @param _old address the old contributor address.\n   * @param _new address the new contributor address.\n   */\n  function updateContributorAddress(address _old, address _new) public ownerOnly {\n    require (state != State.Collection);\n    whitelist[_new] = Whitelist(whitelist[_old].whitelisted, whitelist[_old].isEarlyRegistrant, whitelist[_old].referralCode);\n    uint currentContribution;\n\n    bool contributionFound;\n    for (uint i=0; i<=currentStretchGoal; i++) {\n      currentContribution = contributions[_old][i];\n      if (currentContribution > 0) {\n        contributions[_old][i] = 0;\n        contributions[_new][i] += currentContribution;\n        contributionsPerAddress[_old] -= currentContribution;\n        contributionsPerAddress[_new] += currentContribution;\n        logContributeEvent(_new, currentContribution, whitelist[_old].referralCode);\n\n        contributionFound = true;\n      }\n    }\n    removeFromWhitelist(_old);\n\n    if (contributionFound) {\n      if (contributorIndex[_new]==0) {\n        uniqueContributors++;\n        contributorIndex[_new] = uniqueContributors;\n        reversedContributorIndex[uniqueContributors] = _new;\n      }\n    }\n    WhitelistChanged(_old, _new);\n  }\n  // ownerOnly - END -----------------------------------------------------------\n\n\n  // opsAdmin - START ----------------------------------------------------------\n  /**\n   * @dev Allows opsAdmin to add `_contributor` to the whitelist.\n   * @param _contributor address The address of contributor.\n   * @param _earlyRegistrant bool If contributor is early registrant (registered before public sale).\n   * @param _referralCode bytes32 The referral code. Empty String if not provided.\n   */\n  function addToWhitelist(address _contributor, bool _earlyRegistrant, bytes32 _referralCode) public opsAdminOnly {\n    whitelist[_contributor] = Whitelist(true, _earlyRegistrant, keccak256(_referralCode));\n    Whitelisted(block.number, block.timestamp, _contributor, _earlyRegistrant, keccak256(_referralCode));\n  }\n\n  /**\n   * @dev Allows opsAdmin to register `_multisigAddr` as multisig wallet address for referral code `_referralCode`.\n   * @param _referralCode bytes32 The referral code. Should not be empty since it should have value.\n   * @param _multisigAddr address The address of multisig wallet.\n   */\n  function registerReferralMultisig(bytes32 _referralCode, address _multisigAddr) public opsAdminOnly {\n    referralMultisig[keccak256(_referralCode)] = _multisigAddr;\n    totalReferralMultisig++;\n  }\n  // opsAdmin - END ------------------------------------------------------------\n\n\n  // internal - START ----------------------------------------------------------\n  /**\n   * @dev sets state as End\n   */\n  function setEndState() internal {\n    state = State.End;\n  }\n\n  /**\n   * @dev Allows authorized signatories to remove `_contributor` from the whitelist.\n   * @param _contributor address address of contributor.\n   */\n  function removeFromWhitelist(address _contributor) internal {\n    whitelist[_contributor].whitelisted = false;\n    whitelist[_contributor].isEarlyRegistrant = false;\n  }\n\n  /**\n   * @dev logs contribution event\n   * @param _contributor address address of contributor\n   * @param _amount uint contribution amount\n   * @param _referralCode bytes32 referral code from the contribution. Empty string if none.\n   */\n  function logContributeEvent(address _contributor, uint _amount, bytes32 _referralCode) internal {\n    Contribute(block.number, block.timestamp, _contributor, this, _amount, _referralCode);\n  }\n  // internal - END ------------------------------------------------------------\n\n\n  // modifier - START ----------------------------------------------------------\n  /**\n   * @dev throws if sender is not opsAdmin.\n   */\n  modifier opsAdminOnly {\n    require(msg.sender == opsAdmin);\n    _;\n  }\n  // modifier - END ------------------------------------------------------------\n}\n", "commit_id": "d4bd83385452ceeeac7596c6d02b321f7bd20ffb"}}