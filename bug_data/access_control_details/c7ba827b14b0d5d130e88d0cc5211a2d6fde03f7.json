{"filename": "contracts/AccessControl.sol", "patch": "@@ -287,7 +287,7 @@ contract AccessControl {\n     function accessControl(string memory _resource, string memory _action) public returns (string memory) {\n         address subject = msg.sender;\n         require (\n-            mc.getTimeofUnblock(subject) >= block.timestamp,\n+            mc.getTimeofUnblocked(subject) < block.timestamp,\n             \"access error: Device is still blocked!\"\n         );\n         \n@@ -430,7 +430,7 @@ abstract contract ReputationA {\n \n \n abstract contract ManagementA {\n-    function getTimeofUnblock(address _device)  public virtual returns (uint256);\n+    function getTimeofUnblocked(address _device)  public virtual returns (uint256);\n \n     function getFixedAttribute (\n         address _device, ", "project_link": "https://github.com/shuzang/BBRAC/commit/c7ba827b14b0d5d130e88d0cc5211a2d6fde03f7", "bug_version": {"raw_code": "// SPDX-License-Identifier:MIT\npragma solidity >0.6.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract AccessControl {\n    address public manager;\n    ReputationA public rc;\n    ManagementA public mc;\n\n    event ReturnAccessResult (\n        address indexed from,\n        bool result,\n        string msg,\n        uint256 time\n    );\n\n    struct AttriValue {\n        bool isValued;\n        string value;\n    }\n\n    struct PolicyItem {\n        //for one (resource, action) pair;\n        string attrOwner; // attribute of this policyItem belong to, subject or resources\n        string attrName; // attribute name\n        string operator; // Conditions operator that policyItem used\n        string attrValue; // Conditions that policyItem should meet\n        uint importance; // Importance of this policy item, it will be submit to rc for calculating reputation hhen it is not 0\n    }\n    \n    struct Environment {\n        uint256 minInterval; // minimum allowable interval (in seconds) between two successive requests\n        uint256 threshold; // threshold on NoFR, above which a misbehavior is suspected\n        string algorithm; // determine the result when rules conflict, denyoverries and allowoverrides\n    }\n   \n    struct BehaviorItem {\n        uint256 ToLR; //Time of Last Request\n        uint256 NoFR; //Number of frequent Requests in a short period of time\n    }\n\n    Environment public evAttr = Environment(100, 2, \"denyoverries\");\n\n    // mapping subjcetAddress => BehaviorCriteria for behavior check\n    mapping(address => BehaviorItem) internal behaviors;\n    \n    // mapping (resource, attributeName) => attributeValue for define and search resource attribute\n    mapping(string => mapping(string => AttriValue)) internal resources;\n    // mapping (resource, action) =>PolicyCriteria for policy check\n    mapping(string => mapping(string => PolicyItem[])) internal policies;\n\n    /// @dev Set contract deployer as manager, set management and reputation contract address\n    constructor(address _mc, address _rc, address _manager) {\n        manager = _manager;\n        mc = ManagementA(_mc);\n        rc = ReputationA(_rc);\n    }\n    \n    function updateEnviroment(uint256 _minInterval, uint256 _threshold, string memory _algorithm) public {\n        require(\n            msg.sender == manager,\n            \"updateEnviroment error: Only acc manager can update environment value!\"\n        );\n        evAttr.minInterval = _minInterval;\n        evAttr.threshold = _threshold;\n        evAttr.algorithm = _algorithm;\n    }\n    \n    /// @dev updateSCAddr update management contract or reputation contract address\n    function updateSCAddr(string memory scType, address _scAddress) public {\n        require(\n            msg.sender == manager,\n            \"updateSCAddr error: Only acc manager can update mc or rc address!\"\n        );\n        require(\n            stringCompare(scType, \"mc\") || stringCompare(scType, \"rc\"),\n            \"updateSCAddr error: Updatable contract type can only be rc or mc!\"\n        );\n        if (stringCompare(scType, \"mc\")) {\n            mc = ManagementA(_scAddress);\n        } else {\n            rc = ReputationA(_scAddress);\n        }\n    }\n    \n    /// @dev updateManager update device manager, after that only new manager can operate this access control contract\n    function updateManager(address _manager) public {\n        require(\n            msg.sender == manager,\n            \"updateManager error: Only management contract can update manager address!\"\n        );\n        manager = _manager;\n        rc.reputationCompute(msg.sender, false, 2, \"Device manager update\", block.timestamp);\n    }\n    \n\n    /// @dev addResourceAttr add resource attribute\n    function addResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addResourceAttr error: Caller is not manager!\");\n        require(\n            !resources[_resource][_attrName].isValued,\n            \"addResourceAttr error: Resource attribute had been setted, pleased call resourceAttrUpdate!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        resources[_resource][_attrName].isValued = true;\n        rc.reputationCompute(msg.sender, false, 1, \"Resource attribute add\", block.timestamp);\n    }\n\n    /// @dev updateResourceAttr update resource attribute\n    function updateResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"updateResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"updateResourceAttr error: Resource attribute not exist, pleased first call addResourceAttr!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        rc.reputationCompute(msg.sender, false, 2, \"Resource attribute update\", block.timestamp);\n    }\n\n    /// @dev getResourceAttr get resource attribute\n    function getResourceAttr(\n        string memory _resource, \n        string memory _attrName\n    )\n        public\n        view\n        returns (\n            string memory _attrValue\n        ) \n    {\n        require(\n            resources[_resource][_attrName].isValued,\n            \"getResourceAttr error: Resource attribute not exist!\"\n        );\n        _attrValue = resources[_resource][_attrName].value;\n    }\n\n    /// @dev deleteResourceAttr delete the resource attribute\n    function deleteResourceAttr(\n        string memory _resource,\n        string memory _attrName\n    ) \n        public \n    {\n        require(msg.sender == manager, \"deleteResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"deleteResourceAttr error: Resource attribute not exist, don't need delete!\"\n        );\n        delete resources[_resource][_attrName];\n        rc.reputationCompute(msg.sender, false, 3, \"Resource attribute delete\", block.timestamp);\n    }\n\n    /// @dev addPolicy add a policy\n    ///   @notice We can't judge whether the added policy is unique, so there are security risks here\n    function addPolicy(\n        string memory _resource,\n        string memory _action,\n        string memory _attrOwner,\n        string memory _attrName,\n        string memory _operator,\n        string memory _attrValue,\n        uint _importance\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addPolicy error: Caller is not manager!\");\n        policies[_resource][_action].push(\n            PolicyItem(_attrOwner, _attrName, _operator, _attrValue, _importance)\n        );\n        rc.reputationCompute(msg.sender, false, 1, \"Policy add\", block.timestamp);\n    }\n\n    /// @dev getPolicy get the policy associate with specified resource and action\n    function getPolicy(\n        string memory _resource,\n        string memory _action\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicy error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            result[i] = PolicyItem(\n                policies[_resource][_action][i].attrOwner,\n                policies[_resource][_action][i].attrName,\n                policies[_resource][_action][i].operator,\n                policies[_resource][_action][i].attrValue,\n                policies[_resource][_action][i].importance\n            );\n        }\n        return result;\n    }\n    \n    /// @dev getPolicyItem get the policy item associate with specified attribute name\n    function getPolicyItem(\n        string memory _resource,\n        string memory _action,\n        string memory _attrName\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        uint num = 0;\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                result[num] = PolicyItem(\n                    policies[_resource][_action][i].attrOwner,\n                    _attrName,\n                    policies[_resource][_action][i].operator,\n                    policies[_resource][_action][i].attrValue,\n                    policies[_resource][_action][i].importance\n                );\n                num++;\n            }\n        }\n        return result;\n    }\n    \n    /// @dev deletePolicy delete the policy associate with resource and specified action\n    function deletePolicy(string memory _resource, string memory _action) public {\n        require(msg.sender == manager, \"deletePolicy error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicy error: There is no policy for this resource and action at this time!\"\n        );\n        delete policies[_resource][_action];\n        rc.reputationCompute(msg.sender, false, 3, \"Policy delete\", block.timestamp);\n    }\n    \n    /// @dev deletePolicyItem delete the policy item associate with specified attribute name\n    function deletePolicyItem(string memory _resource, string memory _action, string memory _attrName) public {\n        require(msg.sender == manager, \"deletePolicyItem error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                delete policies[_resource][_action][i];\n            }\n        }\n        rc.reputationCompute(msg.sender, false, 3, \"Policy item delete\", block.timestamp);\n    }\n\n    /// @dev stringToUint is a utility fucntion used for convert number string to uint\n    function stringToUint(string memory s) public pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        uint256 i;\n        result = 0;\n        for (i = 0; i < b.length; i++) {\n            uint8 c = uint8(b[i]);\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n\n    /// @dev accessControl is core fucntion\n    function accessControl(string memory _resource, string memory _action) public returns (string memory) {\n        address subject = msg.sender;\n        require (\n            mc.getTimeofUnblock(subject) >= block.timestamp,\n            \"access error: Device is still blocked!\"\n        );\n        \n        PolicyItem memory current;\n        string memory _attrValue; \n        \n        bool policycheck;\n        bool behaviorcheck;\n        uint8 errcode;\n        bool[2] memory result; // result[0] record if a rule in policy match, result[1] record if a rule not match\n        string memory finalResult;\n        \n        // unblocked state\n        if ((block.timestamp - behaviors[subject].ToLR) <= evAttr.minInterval) {\n            behaviors[subject].NoFR++;\n            if (behaviors[subject].NoFR >= evAttr.threshold) {\n                behaviorcheck = true;\n            }\n        } else {\n            behaviors[subject].NoFR = 0;\n        } \n\n        // check policies\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            current.attrOwner = policies[_resource][_action][i].attrOwner;\n            current.attrName = policies[_resource][_action][i].attrName;\n            current.operator = policies[_resource][_action][i].operator;\n            current.attrValue = policies[_resource][_action][i].attrValue;\n\n            if (stringCompare(current.attrOwner,\"subject\")) {\n                if (stringCompare(current.attrName, \"deviceID\") || stringCompare(current.attrName, \"deviceType\") || stringCompare(current.attrName, \"deviceRole\")) {\n                    _attrValue = mc.getFixedAttribute(subject, current.attrName);\n                } else {\n                    _attrValue = mc.getCustomedAttribute(subject, current.attrName);\n                }\n            } else {\n                _attrValue = resources[_resource][current.attrName].value;\n            }\n\n            if (stringCompare(current.operator,\">\") && (stringToUint(_attrValue) <= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"<\") && (stringToUint(_attrValue) >= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"=\") && (!stringCompare(_attrValue,current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            \n            if (result[1] && policies[_resource][_action][i].importance != 0) {\n                errcode = 4;\n            }\n        }\n\n        // determine policy check result when rules conflict\n        if (stringCompare(evAttr.algorithm, \"denyoverrides\") && result[1]) {\n            policycheck = true;\n        }\n        if (stringCompare(evAttr.algorithm, \"allowoverrides\") && result[0]) {\n            policycheck = false;\n        }\n        \n        if (policycheck && !behaviorcheck && errcode == 0) errcode = 1; // Static check failed!\n        if (!policycheck && behaviorcheck) errcode = 2; // Misbehavior detected!\n        if (policycheck && behaviorcheck) errcode = 3; // Static check failed and Misbehavior detected\n        \n        behaviors[subject].ToLR = block.timestamp;\n        // determine final result\n        if (policycheck || behaviorcheck) {\n            finalResult = \"deny\";\n        } else if (result[0] || result[1]) {\n            finalResult = \"allow\";\n        } else {\n            finalResult = \"NotDefine\";\n        }\n        \n        if (errcode == 0) {\n            rc.reputationCompute(subject, false, 4, \"Access authorized\", block.timestamp);\n            emit ReturnAccessResult(subject, true, \"Access authorized\", block.timestamp);\n        }\n        \n        if (errcode == 1) {\n            rc.reputationCompute(subject, true, 1, \"Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Too frequent access\", block.timestamp);\n        }\n        \n        if (errcode == 2) {\n            rc.reputationCompute(subject, true, 2, \"Policy check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed\", block.timestamp);\n        }\n        \n        if (errcode == 3) {\n            rc.reputationCompute(subject, true, 3, \"Policy check failed and Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed and Too frequent access\", block.timestamp);\n        }\n        if (errcode == 4) {\n            rc.reputationCompute(subject, true, 4, \"Importance check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Importance check failed\", block.timestamp);\n        }\n        return finalResult;\n    }\n\n    function deleteACC() public {\n        require(msg.sender == manager, \"Caller is not manager!\");\n        selfdestruct(msg.sender);\n    }\n\n    /// @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption\n    function stringCompare(string memory a, string memory b) public pure returns (bool) {\n        bytes memory _a = bytes(a);\n        bytes memory _b = bytes(b);\n        if (_a.length != _b.length) {\n            return false;\n        } else {\n            if (_a.length == 1) {\n                return _a[0] == _b[0];\n            } else {\n                return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n            }\n        }\n    }\n}\n\n\nabstract contract ReputationA {\n    function reputationCompute(\n        address _subject, \n        bool _ismisbehavior,\n        uint8 _behaviorID,\n        string memory _behavior,\n        uint256  _time\n    ) virtual public;\n}\n\n\nabstract contract ManagementA {\n    function getTimeofUnblock(address _device)  public virtual returns (uint256);\n\n    function getFixedAttribute (\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n    \n    function getCustomedAttribute(\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier:MIT\npragma solidity >0.6.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract AccessControl {\n    address public manager;\n    ReputationA public rc;\n    ManagementA public mc;\n\n    event ReturnAccessResult (\n        address indexed from,\n        bool result,\n        string msg,\n        uint256 time\n    );\n\n    struct AttriValue {\n        bool isValued;\n        string value;\n    }\n\n    struct PolicyItem {\n        //for one (resource, action) pair;\n        string attrOwner; // attribute of this policyItem belong to, subject or resources\n        string attrName; // attribute name\n        string operator; // Conditions operator that policyItem used\n        string attrValue; // Conditions that policyItem should meet\n        uint importance; // Importance of this policy item, it will be submit to rc for calculating reputation hhen it is not 0\n    }\n    \n    struct Environment {\n        uint256 minInterval; // minimum allowable interval (in seconds) between two successive requests\n        uint256 threshold; // threshold on NoFR, above which a misbehavior is suspected\n        string algorithm; // determine the result when rules conflict, denyoverries and allowoverrides\n    }\n   \n    struct BehaviorItem {\n        uint256 ToLR; //Time of Last Request\n        uint256 NoFR; //Number of frequent Requests in a short period of time\n    }\n\n    Environment public evAttr = Environment(100, 2, \"denyoverries\");\n\n    // mapping subjcetAddress => BehaviorCriteria for behavior check\n    mapping(address => BehaviorItem) internal behaviors;\n    \n    // mapping (resource, attributeName) => attributeValue for define and search resource attribute\n    mapping(string => mapping(string => AttriValue)) internal resources;\n    // mapping (resource, action) =>PolicyCriteria for policy check\n    mapping(string => mapping(string => PolicyItem[])) internal policies;\n\n    /// @dev Set contract deployer as manager, set management and reputation contract address\n    constructor(address _mc, address _rc, address _manager) {\n        manager = _manager;\n        mc = ManagementA(_mc);\n        rc = ReputationA(_rc);\n    }\n    \n    function updateEnviroment(uint256 _minInterval, uint256 _threshold, string memory _algorithm) public {\n        require(\n            msg.sender == manager,\n            \"updateEnviroment error: Only acc manager can update environment value!\"\n        );\n        evAttr.minInterval = _minInterval;\n        evAttr.threshold = _threshold;\n        evAttr.algorithm = _algorithm;\n    }\n    \n    /// @dev updateSCAddr update management contract or reputation contract address\n    function updateSCAddr(string memory scType, address _scAddress) public {\n        require(\n            msg.sender == manager,\n            \"updateSCAddr error: Only acc manager can update mc or rc address!\"\n        );\n        require(\n            stringCompare(scType, \"mc\") || stringCompare(scType, \"rc\"),\n            \"updateSCAddr error: Updatable contract type can only be rc or mc!\"\n        );\n        if (stringCompare(scType, \"mc\")) {\n            mc = ManagementA(_scAddress);\n        } else {\n            rc = ReputationA(_scAddress);\n        }\n    }\n    \n    /// @dev updateManager update device manager, after that only new manager can operate this access control contract\n    function updateManager(address _manager) public {\n        require(\n            msg.sender == manager,\n            \"updateManager error: Only management contract can update manager address!\"\n        );\n        manager = _manager;\n        rc.reputationCompute(msg.sender, false, 2, \"Device manager update\", block.timestamp);\n    }\n    \n\n    /// @dev addResourceAttr add resource attribute\n    function addResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addResourceAttr error: Caller is not manager!\");\n        require(\n            !resources[_resource][_attrName].isValued,\n            \"addResourceAttr error: Resource attribute had been setted, pleased call resourceAttrUpdate!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        resources[_resource][_attrName].isValued = true;\n        rc.reputationCompute(msg.sender, false, 1, \"Resource attribute add\", block.timestamp);\n    }\n\n    /// @dev updateResourceAttr update resource attribute\n    function updateResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"updateResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"updateResourceAttr error: Resource attribute not exist, pleased first call addResourceAttr!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        rc.reputationCompute(msg.sender, false, 2, \"Resource attribute update\", block.timestamp);\n    }\n\n    /// @dev getResourceAttr get resource attribute\n    function getResourceAttr(\n        string memory _resource, \n        string memory _attrName\n    )\n        public\n        view\n        returns (\n            string memory _attrValue\n        ) \n    {\n        require(\n            resources[_resource][_attrName].isValued,\n            \"getResourceAttr error: Resource attribute not exist!\"\n        );\n        _attrValue = resources[_resource][_attrName].value;\n    }\n\n    /// @dev deleteResourceAttr delete the resource attribute\n    function deleteResourceAttr(\n        string memory _resource,\n        string memory _attrName\n    ) \n        public \n    {\n        require(msg.sender == manager, \"deleteResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"deleteResourceAttr error: Resource attribute not exist, don't need delete!\"\n        );\n        delete resources[_resource][_attrName];\n        rc.reputationCompute(msg.sender, false, 3, \"Resource attribute delete\", block.timestamp);\n    }\n\n    /// @dev addPolicy add a policy\n    ///   @notice We can't judge whether the added policy is unique, so there are security risks here\n    function addPolicy(\n        string memory _resource,\n        string memory _action,\n        string memory _attrOwner,\n        string memory _attrName,\n        string memory _operator,\n        string memory _attrValue,\n        uint _importance\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addPolicy error: Caller is not manager!\");\n        policies[_resource][_action].push(\n            PolicyItem(_attrOwner, _attrName, _operator, _attrValue, _importance)\n        );\n        rc.reputationCompute(msg.sender, false, 1, \"Policy add\", block.timestamp);\n    }\n\n    /// @dev getPolicy get the policy associate with specified resource and action\n    function getPolicy(\n        string memory _resource,\n        string memory _action\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicy error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            result[i] = PolicyItem(\n                policies[_resource][_action][i].attrOwner,\n                policies[_resource][_action][i].attrName,\n                policies[_resource][_action][i].operator,\n                policies[_resource][_action][i].attrValue,\n                policies[_resource][_action][i].importance\n            );\n        }\n        return result;\n    }\n    \n    /// @dev getPolicyItem get the policy item associate with specified attribute name\n    function getPolicyItem(\n        string memory _resource,\n        string memory _action,\n        string memory _attrName\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        uint num = 0;\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                result[num] = PolicyItem(\n                    policies[_resource][_action][i].attrOwner,\n                    _attrName,\n                    policies[_resource][_action][i].operator,\n                    policies[_resource][_action][i].attrValue,\n                    policies[_resource][_action][i].importance\n                );\n                num++;\n            }\n        }\n        return result;\n    }\n    \n    /// @dev deletePolicy delete the policy associate with resource and specified action\n    function deletePolicy(string memory _resource, string memory _action) public {\n        require(msg.sender == manager, \"deletePolicy error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicy error: There is no policy for this resource and action at this time!\"\n        );\n        delete policies[_resource][_action];\n        rc.reputationCompute(msg.sender, false, 3, \"Policy delete\", block.timestamp);\n    }\n    \n    /// @dev deletePolicyItem delete the policy item associate with specified attribute name\n    function deletePolicyItem(string memory _resource, string memory _action, string memory _attrName) public {\n        require(msg.sender == manager, \"deletePolicyItem error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                delete policies[_resource][_action][i];\n            }\n        }\n        rc.reputationCompute(msg.sender, false, 3, \"Policy item delete\", block.timestamp);\n    }\n\n    /// @dev stringToUint is a utility fucntion used for convert number string to uint\n    function stringToUint(string memory s) public pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        uint256 i;\n        result = 0;\n        for (i = 0; i < b.length; i++) {\n            uint8 c = uint8(b[i]);\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n\n    /// @dev accessControl is core fucntion\n    function accessControl(string memory _resource, string memory _action) public returns (string memory) {\n        address subject = msg.sender;\n        require (\n            mc.getTimeofUnblock(subject) >= block.timestamp,\n            \"access error: Device is still blocked!\"\n        );\n        \n        PolicyItem memory current;\n        string memory _attrValue; \n        \n        bool policycheck;\n        bool behaviorcheck;\n        uint8 errcode;\n        bool[2] memory result; // result[0] record if a rule in policy match, result[1] record if a rule not match\n        string memory finalResult;\n        \n        // unblocked state\n        if ((block.timestamp - behaviors[subject].ToLR) <= evAttr.minInterval) {\n            behaviors[subject].NoFR++;\n            if (behaviors[subject].NoFR >= evAttr.threshold) {\n                behaviorcheck = true;\n            }\n        } else {\n            behaviors[subject].NoFR = 0;\n        } \n\n        // check policies\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            current.attrOwner = policies[_resource][_action][i].attrOwner;\n            current.attrName = policies[_resource][_action][i].attrName;\n            current.operator = policies[_resource][_action][i].operator;\n            current.attrValue = policies[_resource][_action][i].attrValue;\n\n            if (stringCompare(current.attrOwner,\"subject\")) {\n                if (stringCompare(current.attrName, \"deviceID\") || stringCompare(current.attrName, \"deviceType\") || stringCompare(current.attrName, \"deviceRole\")) {\n                    _attrValue = mc.getFixedAttribute(subject, current.attrName);\n                } else {\n                    _attrValue = mc.getCustomedAttribute(subject, current.attrName);\n                }\n            } else {\n                _attrValue = resources[_resource][current.attrName].value;\n            }\n\n            if (stringCompare(current.operator,\">\") && (stringToUint(_attrValue) <= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"<\") && (stringToUint(_attrValue) >= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"=\") && (!stringCompare(_attrValue,current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            \n            if (result[1] && policies[_resource][_action][i].importance != 0) {\n                errcode = 4;\n            }\n        }\n\n        // determine policy check result when rules conflict\n        if (stringCompare(evAttr.algorithm, \"denyoverrides\") && result[1]) {\n            policycheck = true;\n        }\n        if (stringCompare(evAttr.algorithm, \"allowoverrides\") && result[0]) {\n            policycheck = false;\n        }\n        \n        if (policycheck && !behaviorcheck && errcode == 0) errcode = 1; // Static check failed!\n        if (!policycheck && behaviorcheck) errcode = 2; // Misbehavior detected!\n        if (policycheck && behaviorcheck) errcode = 3; // Static check failed and Misbehavior detected\n        \n        behaviors[subject].ToLR = block.timestamp;\n        // determine final result\n        if (policycheck || behaviorcheck) {\n            finalResult = \"deny\";\n        } else if (result[0] || result[1]) {\n            finalResult = \"allow\";\n        } else {\n            finalResult = \"NotDefine\";\n        }\n        \n        if (errcode == 0) {\n            rc.reputationCompute(subject, false, 4, \"Access authorized\", block.timestamp);\n            emit ReturnAccessResult(subject, true, \"Access authorized\", block.timestamp);\n        }\n        \n        if (errcode == 1) {\n            rc.reputationCompute(subject, true, 1, \"Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Too frequent access\", block.timestamp);\n        }\n        \n        if (errcode == 2) {\n            rc.reputationCompute(subject, true, 2, \"Policy check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed\", block.timestamp);\n        }\n        \n        if (errcode == 3) {\n            rc.reputationCompute(subject, true, 3, \"Policy check failed and Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed and Too frequent access\", block.timestamp);\n        }\n        if (errcode == 4) {\n            rc.reputationCompute(subject, true, 4, \"Importance check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Importance check failed\", block.timestamp);\n        }\n        return finalResult;\n    }\n\n    function deleteACC() public {\n        require(msg.sender == manager, \"Caller is not manager!\");\n        selfdestruct(msg.sender);\n    }\n\n    /// @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption\n    function stringCompare(string memory a, string memory b) public pure returns (bool) {\n        bytes memory _a = bytes(a);\n        bytes memory _b = bytes(b);\n        if (_a.length != _b.length) {\n            return false;\n        } else {\n            if (_a.length == 1) {\n                return _a[0] == _b[0];\n            } else {\n                return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n            }\n        }\n    }\n}\n\n\nabstract contract ReputationA {\n    function reputationCompute(\n        address _subject, \n        bool _ismisbehavior,\n        uint8 _behaviorID,\n        string memory _behavior,\n        uint256  _time\n    ) virtual public;\n}\n\n\nabstract contract ManagementA {\n    function getTimeofUnblock(address _device)  public virtual returns (uint256);\n\n    function getFixedAttribute (\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n    \n    function getCustomedAttribute(\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n}\n", "commit_id": "d6ee9c65dcecb24b85b295c01332959368ef628e"}, "fixed_version": {"raw_code": "// SPDX-License-Identifier:MIT\npragma solidity >0.6.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract AccessControl {\n    address public manager;\n    ReputationA public rc;\n    ManagementA public mc;\n\n    event ReturnAccessResult (\n        address indexed from,\n        bool result,\n        string msg,\n        uint256 time\n    );\n\n    struct AttriValue {\n        bool isValued;\n        string value;\n    }\n\n    struct PolicyItem {\n        //for one (resource, action) pair;\n        string attrOwner; // attribute of this policyItem belong to, subject or resources\n        string attrName; // attribute name\n        string operator; // Conditions operator that policyItem used\n        string attrValue; // Conditions that policyItem should meet\n        uint importance; // Importance of this policy item, it will be submit to rc for calculating reputation hhen it is not 0\n    }\n    \n    struct Environment {\n        uint256 minInterval; // minimum allowable interval (in seconds) between two successive requests\n        uint256 threshold; // threshold on NoFR, above which a misbehavior is suspected\n        string algorithm; // determine the result when rules conflict, denyoverries and allowoverrides\n    }\n   \n    struct BehaviorItem {\n        uint256 ToLR; //Time of Last Request\n        uint256 NoFR; //Number of frequent Requests in a short period of time\n    }\n\n    Environment public evAttr = Environment(100, 2, \"denyoverries\");\n\n    // mapping subjcetAddress => BehaviorCriteria for behavior check\n    mapping(address => BehaviorItem) internal behaviors;\n    \n    // mapping (resource, attributeName) => attributeValue for define and search resource attribute\n    mapping(string => mapping(string => AttriValue)) internal resources;\n    // mapping (resource, action) =>PolicyCriteria for policy check\n    mapping(string => mapping(string => PolicyItem[])) internal policies;\n\n    /// @dev Set contract deployer as manager, set management and reputation contract address\n    constructor(address _mc, address _rc, address _manager) {\n        manager = _manager;\n        mc = ManagementA(_mc);\n        rc = ReputationA(_rc);\n    }\n    \n    function updateEnviroment(uint256 _minInterval, uint256 _threshold, string memory _algorithm) public {\n        require(\n            msg.sender == manager,\n            \"updateEnviroment error: Only acc manager can update environment value!\"\n        );\n        evAttr.minInterval = _minInterval;\n        evAttr.threshold = _threshold;\n        evAttr.algorithm = _algorithm;\n    }\n    \n    /// @dev updateSCAddr update management contract or reputation contract address\n    function updateSCAddr(string memory scType, address _scAddress) public {\n        require(\n            msg.sender == manager,\n            \"updateSCAddr error: Only acc manager can update mc or rc address!\"\n        );\n        require(\n            stringCompare(scType, \"mc\") || stringCompare(scType, \"rc\"),\n            \"updateSCAddr error: Updatable contract type can only be rc or mc!\"\n        );\n        if (stringCompare(scType, \"mc\")) {\n            mc = ManagementA(_scAddress);\n        } else {\n            rc = ReputationA(_scAddress);\n        }\n    }\n    \n    /// @dev updateManager update device manager, after that only new manager can operate this access control contract\n    function updateManager(address _manager) public {\n        require(\n            msg.sender == manager,\n            \"updateManager error: Only management contract can update manager address!\"\n        );\n        manager = _manager;\n        rc.reputationCompute(msg.sender, false, 2, \"Device manager update\", block.timestamp);\n    }\n    \n\n    /// @dev addResourceAttr add resource attribute\n    function addResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addResourceAttr error: Caller is not manager!\");\n        require(\n            !resources[_resource][_attrName].isValued,\n            \"addResourceAttr error: Resource attribute had been setted, pleased call resourceAttrUpdate!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        resources[_resource][_attrName].isValued = true;\n        rc.reputationCompute(msg.sender, false, 1, \"Resource attribute add\", block.timestamp);\n    }\n\n    /// @dev updateResourceAttr update resource attribute\n    function updateResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"updateResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"updateResourceAttr error: Resource attribute not exist, pleased first call addResourceAttr!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        rc.reputationCompute(msg.sender, false, 2, \"Resource attribute update\", block.timestamp);\n    }\n\n    /// @dev getResourceAttr get resource attribute\n    function getResourceAttr(\n        string memory _resource, \n        string memory _attrName\n    )\n        public\n        view\n        returns (\n            string memory _attrValue\n        ) \n    {\n        require(\n            resources[_resource][_attrName].isValued,\n            \"getResourceAttr error: Resource attribute not exist!\"\n        );\n        _attrValue = resources[_resource][_attrName].value;\n    }\n\n    /// @dev deleteResourceAttr delete the resource attribute\n    function deleteResourceAttr(\n        string memory _resource,\n        string memory _attrName\n    ) \n        public \n    {\n        require(msg.sender == manager, \"deleteResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"deleteResourceAttr error: Resource attribute not exist, don't need delete!\"\n        );\n        delete resources[_resource][_attrName];\n        rc.reputationCompute(msg.sender, false, 3, \"Resource attribute delete\", block.timestamp);\n    }\n\n    /// @dev addPolicy add a policy\n    ///   @notice We can't judge whether the added policy is unique, so there are security risks here\n    function addPolicy(\n        string memory _resource,\n        string memory _action,\n        string memory _attrOwner,\n        string memory _attrName,\n        string memory _operator,\n        string memory _attrValue,\n        uint _importance\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addPolicy error: Caller is not manager!\");\n        policies[_resource][_action].push(\n            PolicyItem(_attrOwner, _attrName, _operator, _attrValue, _importance)\n        );\n        rc.reputationCompute(msg.sender, false, 1, \"Policy add\", block.timestamp);\n    }\n\n    /// @dev getPolicy get the policy associate with specified resource and action\n    function getPolicy(\n        string memory _resource,\n        string memory _action\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicy error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            result[i] = PolicyItem(\n                policies[_resource][_action][i].attrOwner,\n                policies[_resource][_action][i].attrName,\n                policies[_resource][_action][i].operator,\n                policies[_resource][_action][i].attrValue,\n                policies[_resource][_action][i].importance\n            );\n        }\n        return result;\n    }\n    \n    /// @dev getPolicyItem get the policy item associate with specified attribute name\n    function getPolicyItem(\n        string memory _resource,\n        string memory _action,\n        string memory _attrName\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        uint num = 0;\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                result[num] = PolicyItem(\n                    policies[_resource][_action][i].attrOwner,\n                    _attrName,\n                    policies[_resource][_action][i].operator,\n                    policies[_resource][_action][i].attrValue,\n                    policies[_resource][_action][i].importance\n                );\n                num++;\n            }\n        }\n        return result;\n    }\n    \n    /// @dev deletePolicy delete the policy associate with resource and specified action\n    function deletePolicy(string memory _resource, string memory _action) public {\n        require(msg.sender == manager, \"deletePolicy error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicy error: There is no policy for this resource and action at this time!\"\n        );\n        delete policies[_resource][_action];\n        rc.reputationCompute(msg.sender, false, 3, \"Policy delete\", block.timestamp);\n    }\n    \n    /// @dev deletePolicyItem delete the policy item associate with specified attribute name\n    function deletePolicyItem(string memory _resource, string memory _action, string memory _attrName) public {\n        require(msg.sender == manager, \"deletePolicyItem error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                delete policies[_resource][_action][i];\n            }\n        }\n        rc.reputationCompute(msg.sender, false, 3, \"Policy item delete\", block.timestamp);\n    }\n\n    /// @dev stringToUint is a utility fucntion used for convert number string to uint\n    function stringToUint(string memory s) public pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        uint256 i;\n        result = 0;\n        for (i = 0; i < b.length; i++) {\n            uint8 c = uint8(b[i]);\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n\n    /// @dev accessControl is core fucntion\n    function accessControl(string memory _resource, string memory _action) public returns (string memory) {\n        address subject = msg.sender;\n        require (\n            mc.getTimeofUnblocked(subject) < block.timestamp,\n            \"access error: Device is still blocked!\"\n        );\n        \n        PolicyItem memory current;\n        string memory _attrValue; \n        \n        bool policycheck;\n        bool behaviorcheck;\n        uint8 errcode;\n        bool[2] memory result; // result[0] record if a rule in policy match, result[1] record if a rule not match\n        string memory finalResult;\n        \n        // unblocked state\n        if ((block.timestamp - behaviors[subject].ToLR) <= evAttr.minInterval) {\n            behaviors[subject].NoFR++;\n            if (behaviors[subject].NoFR >= evAttr.threshold) {\n                behaviorcheck = true;\n            }\n        } else {\n            behaviors[subject].NoFR = 0;\n        } \n\n        // check policies\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            current.attrOwner = policies[_resource][_action][i].attrOwner;\n            current.attrName = policies[_resource][_action][i].attrName;\n            current.operator = policies[_resource][_action][i].operator;\n            current.attrValue = policies[_resource][_action][i].attrValue;\n\n            if (stringCompare(current.attrOwner,\"subject\")) {\n                if (stringCompare(current.attrName, \"deviceID\") || stringCompare(current.attrName, \"deviceType\") || stringCompare(current.attrName, \"deviceRole\")) {\n                    _attrValue = mc.getFixedAttribute(subject, current.attrName);\n                } else {\n                    _attrValue = mc.getCustomedAttribute(subject, current.attrName);\n                }\n            } else {\n                _attrValue = resources[_resource][current.attrName].value;\n            }\n\n            if (stringCompare(current.operator,\">\") && (stringToUint(_attrValue) <= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"<\") && (stringToUint(_attrValue) >= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"=\") && (!stringCompare(_attrValue,current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            \n            if (result[1] && policies[_resource][_action][i].importance != 0) {\n                errcode = 4;\n            }\n        }\n\n        // determine policy check result when rules conflict\n        if (stringCompare(evAttr.algorithm, \"denyoverrides\") && result[1]) {\n            policycheck = true;\n        }\n        if (stringCompare(evAttr.algorithm, \"allowoverrides\") && result[0]) {\n            policycheck = false;\n        }\n        \n        if (policycheck && !behaviorcheck && errcode == 0) errcode = 1; // Static check failed!\n        if (!policycheck && behaviorcheck) errcode = 2; // Misbehavior detected!\n        if (policycheck && behaviorcheck) errcode = 3; // Static check failed and Misbehavior detected\n        \n        behaviors[subject].ToLR = block.timestamp;\n        // determine final result\n        if (policycheck || behaviorcheck) {\n            finalResult = \"deny\";\n        } else if (result[0] || result[1]) {\n            finalResult = \"allow\";\n        } else {\n            finalResult = \"NotDefine\";\n        }\n        \n        if (errcode == 0) {\n            rc.reputationCompute(subject, false, 4, \"Access authorized\", block.timestamp);\n            emit ReturnAccessResult(subject, true, \"Access authorized\", block.timestamp);\n        }\n        \n        if (errcode == 1) {\n            rc.reputationCompute(subject, true, 1, \"Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Too frequent access\", block.timestamp);\n        }\n        \n        if (errcode == 2) {\n            rc.reputationCompute(subject, true, 2, \"Policy check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed\", block.timestamp);\n        }\n        \n        if (errcode == 3) {\n            rc.reputationCompute(subject, true, 3, \"Policy check failed and Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed and Too frequent access\", block.timestamp);\n        }\n        if (errcode == 4) {\n            rc.reputationCompute(subject, true, 4, \"Importance check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Importance check failed\", block.timestamp);\n        }\n        return finalResult;\n    }\n\n    function deleteACC() public {\n        require(msg.sender == manager, \"Caller is not manager!\");\n        selfdestruct(msg.sender);\n    }\n\n    /// @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption\n    function stringCompare(string memory a, string memory b) public pure returns (bool) {\n        bytes memory _a = bytes(a);\n        bytes memory _b = bytes(b);\n        if (_a.length != _b.length) {\n            return false;\n        } else {\n            if (_a.length == 1) {\n                return _a[0] == _b[0];\n            } else {\n                return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n            }\n        }\n    }\n}\n\n\nabstract contract ReputationA {\n    function reputationCompute(\n        address _subject, \n        bool _ismisbehavior,\n        uint8 _behaviorID,\n        string memory _behavior,\n        uint256  _time\n    ) virtual public;\n}\n\n\nabstract contract ManagementA {\n    function getTimeofUnblocked(address _device)  public virtual returns (uint256);\n\n    function getFixedAttribute (\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n    \n    function getCustomedAttribute(\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n}\n", "flattened_code": "// IGNORE_LICENSE-Identifier:MIT\npragma solidity >0.6.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\ncontract AccessControl {\n    address public manager;\n    ReputationA public rc;\n    ManagementA public mc;\n\n    event ReturnAccessResult (\n        address indexed from,\n        bool result,\n        string msg,\n        uint256 time\n    );\n\n    struct AttriValue {\n        bool isValued;\n        string value;\n    }\n\n    struct PolicyItem {\n        //for one (resource, action) pair;\n        string attrOwner; // attribute of this policyItem belong to, subject or resources\n        string attrName; // attribute name\n        string operator; // Conditions operator that policyItem used\n        string attrValue; // Conditions that policyItem should meet\n        uint importance; // Importance of this policy item, it will be submit to rc for calculating reputation hhen it is not 0\n    }\n    \n    struct Environment {\n        uint256 minInterval; // minimum allowable interval (in seconds) between two successive requests\n        uint256 threshold; // threshold on NoFR, above which a misbehavior is suspected\n        string algorithm; // determine the result when rules conflict, denyoverries and allowoverrides\n    }\n   \n    struct BehaviorItem {\n        uint256 ToLR; //Time of Last Request\n        uint256 NoFR; //Number of frequent Requests in a short period of time\n    }\n\n    Environment public evAttr = Environment(100, 2, \"denyoverries\");\n\n    // mapping subjcetAddress => BehaviorCriteria for behavior check\n    mapping(address => BehaviorItem) internal behaviors;\n    \n    // mapping (resource, attributeName) => attributeValue for define and search resource attribute\n    mapping(string => mapping(string => AttriValue)) internal resources;\n    // mapping (resource, action) =>PolicyCriteria for policy check\n    mapping(string => mapping(string => PolicyItem[])) internal policies;\n\n    /// @dev Set contract deployer as manager, set management and reputation contract address\n    constructor(address _mc, address _rc, address _manager) {\n        manager = _manager;\n        mc = ManagementA(_mc);\n        rc = ReputationA(_rc);\n    }\n    \n    function updateEnviroment(uint256 _minInterval, uint256 _threshold, string memory _algorithm) public {\n        require(\n            msg.sender == manager,\n            \"updateEnviroment error: Only acc manager can update environment value!\"\n        );\n        evAttr.minInterval = _minInterval;\n        evAttr.threshold = _threshold;\n        evAttr.algorithm = _algorithm;\n    }\n    \n    /// @dev updateSCAddr update management contract or reputation contract address\n    function updateSCAddr(string memory scType, address _scAddress) public {\n        require(\n            msg.sender == manager,\n            \"updateSCAddr error: Only acc manager can update mc or rc address!\"\n        );\n        require(\n            stringCompare(scType, \"mc\") || stringCompare(scType, \"rc\"),\n            \"updateSCAddr error: Updatable contract type can only be rc or mc!\"\n        );\n        if (stringCompare(scType, \"mc\")) {\n            mc = ManagementA(_scAddress);\n        } else {\n            rc = ReputationA(_scAddress);\n        }\n    }\n    \n    /// @dev updateManager update device manager, after that only new manager can operate this access control contract\n    function updateManager(address _manager) public {\n        require(\n            msg.sender == manager,\n            \"updateManager error: Only management contract can update manager address!\"\n        );\n        manager = _manager;\n        rc.reputationCompute(msg.sender, false, 2, \"Device manager update\", block.timestamp);\n    }\n    \n\n    /// @dev addResourceAttr add resource attribute\n    function addResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addResourceAttr error: Caller is not manager!\");\n        require(\n            !resources[_resource][_attrName].isValued,\n            \"addResourceAttr error: Resource attribute had been setted, pleased call resourceAttrUpdate!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        resources[_resource][_attrName].isValued = true;\n        rc.reputationCompute(msg.sender, false, 1, \"Resource attribute add\", block.timestamp);\n    }\n\n    /// @dev updateResourceAttr update resource attribute\n    function updateResourceAttr(\n        string memory _resource,\n        string memory _attrName,\n        string memory _attrValue\n    ) \n        public \n    {\n        require(msg.sender == manager, \"updateResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"updateResourceAttr error: Resource attribute not exist, pleased first call addResourceAttr!\"\n        );\n        resources[_resource][_attrName].value = _attrValue;\n        rc.reputationCompute(msg.sender, false, 2, \"Resource attribute update\", block.timestamp);\n    }\n\n    /// @dev getResourceAttr get resource attribute\n    function getResourceAttr(\n        string memory _resource, \n        string memory _attrName\n    )\n        public\n        view\n        returns (\n            string memory _attrValue\n        ) \n    {\n        require(\n            resources[_resource][_attrName].isValued,\n            \"getResourceAttr error: Resource attribute not exist!\"\n        );\n        _attrValue = resources[_resource][_attrName].value;\n    }\n\n    /// @dev deleteResourceAttr delete the resource attribute\n    function deleteResourceAttr(\n        string memory _resource,\n        string memory _attrName\n    ) \n        public \n    {\n        require(msg.sender == manager, \"deleteResourceAttr error: Caller is not manager!\");\n        require(\n            resources[_resource][_attrName].isValued,\n            \"deleteResourceAttr error: Resource attribute not exist, don't need delete!\"\n        );\n        delete resources[_resource][_attrName];\n        rc.reputationCompute(msg.sender, false, 3, \"Resource attribute delete\", block.timestamp);\n    }\n\n    /// @dev addPolicy add a policy\n    ///   @notice We can't judge whether the added policy is unique, so there are security risks here\n    function addPolicy(\n        string memory _resource,\n        string memory _action,\n        string memory _attrOwner,\n        string memory _attrName,\n        string memory _operator,\n        string memory _attrValue,\n        uint _importance\n    ) \n        public \n    {\n        require(msg.sender == manager, \"addPolicy error: Caller is not manager!\");\n        policies[_resource][_action].push(\n            PolicyItem(_attrOwner, _attrName, _operator, _attrValue, _importance)\n        );\n        rc.reputationCompute(msg.sender, false, 1, \"Policy add\", block.timestamp);\n    }\n\n    /// @dev getPolicy get the policy associate with specified resource and action\n    function getPolicy(\n        string memory _resource,\n        string memory _action\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicy error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            result[i] = PolicyItem(\n                policies[_resource][_action][i].attrOwner,\n                policies[_resource][_action][i].attrName,\n                policies[_resource][_action][i].operator,\n                policies[_resource][_action][i].attrValue,\n                policies[_resource][_action][i].importance\n            );\n        }\n        return result;\n    }\n    \n    /// @dev getPolicyItem get the policy item associate with specified attribute name\n    function getPolicyItem(\n        string memory _resource,\n        string memory _action,\n        string memory _attrName\n    ) \n        public \n        view \n        returns (\n            PolicyItem[] memory\n        ) \n    {\n        require(\n            policies[_resource][_action].length != 0, \n            \"getPolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        PolicyItem[] memory result = new PolicyItem[](policies[_resource][_action].length);\n        uint num = 0;\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                result[num] = PolicyItem(\n                    policies[_resource][_action][i].attrOwner,\n                    _attrName,\n                    policies[_resource][_action][i].operator,\n                    policies[_resource][_action][i].attrValue,\n                    policies[_resource][_action][i].importance\n                );\n                num++;\n            }\n        }\n        return result;\n    }\n    \n    /// @dev deletePolicy delete the policy associate with resource and specified action\n    function deletePolicy(string memory _resource, string memory _action) public {\n        require(msg.sender == manager, \"deletePolicy error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicy error: There is no policy for this resource and action at this time!\"\n        );\n        delete policies[_resource][_action];\n        rc.reputationCompute(msg.sender, false, 3, \"Policy delete\", block.timestamp);\n    }\n    \n    /// @dev deletePolicyItem delete the policy item associate with specified attribute name\n    function deletePolicyItem(string memory _resource, string memory _action, string memory _attrName) public {\n        require(msg.sender == manager, \"deletePolicyItem error: Caller is not manager!\");\n        require(\n            policies[_resource][_action].length != 0, \n            \"deletePolicyItem error: There is no policy for this resource and action at this time!\"\n        );\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            if (stringCompare(policies[_resource][_action][i].attrName, _attrName)) {\n                delete policies[_resource][_action][i];\n            }\n        }\n        rc.reputationCompute(msg.sender, false, 3, \"Policy item delete\", block.timestamp);\n    }\n\n    /// @dev stringToUint is a utility fucntion used for convert number string to uint\n    function stringToUint(string memory s) public pure returns (uint256 result) {\n        bytes memory b = bytes(s);\n        uint256 i;\n        result = 0;\n        for (i = 0; i < b.length; i++) {\n            uint8 c = uint8(b[i]);\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n    }\n\n    /// @dev accessControl is core fucntion\n    function accessControl(string memory _resource, string memory _action) public returns (string memory) {\n        address subject = msg.sender;\n        require (\n            mc.getTimeofUnblocked(subject) < block.timestamp,\n            \"access error: Device is still blocked!\"\n        );\n        \n        PolicyItem memory current;\n        string memory _attrValue; \n        \n        bool policycheck;\n        bool behaviorcheck;\n        uint8 errcode;\n        bool[2] memory result; // result[0] record if a rule in policy match, result[1] record if a rule not match\n        string memory finalResult;\n        \n        // unblocked state\n        if ((block.timestamp - behaviors[subject].ToLR) <= evAttr.minInterval) {\n            behaviors[subject].NoFR++;\n            if (behaviors[subject].NoFR >= evAttr.threshold) {\n                behaviorcheck = true;\n            }\n        } else {\n            behaviors[subject].NoFR = 0;\n        } \n\n        // check policies\n        for (uint256 i = 0; i < policies[_resource][_action].length; i++) {\n            current.attrOwner = policies[_resource][_action][i].attrOwner;\n            current.attrName = policies[_resource][_action][i].attrName;\n            current.operator = policies[_resource][_action][i].operator;\n            current.attrValue = policies[_resource][_action][i].attrValue;\n\n            if (stringCompare(current.attrOwner,\"subject\")) {\n                if (stringCompare(current.attrName, \"deviceID\") || stringCompare(current.attrName, \"deviceType\") || stringCompare(current.attrName, \"deviceRole\")) {\n                    _attrValue = mc.getFixedAttribute(subject, current.attrName);\n                } else {\n                    _attrValue = mc.getCustomedAttribute(subject, current.attrName);\n                }\n            } else {\n                _attrValue = resources[_resource][current.attrName].value;\n            }\n\n            if (stringCompare(current.operator,\">\") && (stringToUint(_attrValue) <= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"<\") && (stringToUint(_attrValue) >= stringToUint(current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            if (stringCompare(current.operator,\"=\") && (!stringCompare(_attrValue,current.attrValue))) {\n                result[1] = true;\n            } else {\n                result[0] = true;\n            }\n            \n            if (result[1] && policies[_resource][_action][i].importance != 0) {\n                errcode = 4;\n            }\n        }\n\n        // determine policy check result when rules conflict\n        if (stringCompare(evAttr.algorithm, \"denyoverrides\") && result[1]) {\n            policycheck = true;\n        }\n        if (stringCompare(evAttr.algorithm, \"allowoverrides\") && result[0]) {\n            policycheck = false;\n        }\n        \n        if (policycheck && !behaviorcheck && errcode == 0) errcode = 1; // Static check failed!\n        if (!policycheck && behaviorcheck) errcode = 2; // Misbehavior detected!\n        if (policycheck && behaviorcheck) errcode = 3; // Static check failed and Misbehavior detected\n        \n        behaviors[subject].ToLR = block.timestamp;\n        // determine final result\n        if (policycheck || behaviorcheck) {\n            finalResult = \"deny\";\n        } else if (result[0] || result[1]) {\n            finalResult = \"allow\";\n        } else {\n            finalResult = \"NotDefine\";\n        }\n        \n        if (errcode == 0) {\n            rc.reputationCompute(subject, false, 4, \"Access authorized\", block.timestamp);\n            emit ReturnAccessResult(subject, true, \"Access authorized\", block.timestamp);\n        }\n        \n        if (errcode == 1) {\n            rc.reputationCompute(subject, true, 1, \"Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Too frequent access\", block.timestamp);\n        }\n        \n        if (errcode == 2) {\n            rc.reputationCompute(subject, true, 2, \"Policy check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed\", block.timestamp);\n        }\n        \n        if (errcode == 3) {\n            rc.reputationCompute(subject, true, 3, \"Policy check failed and Too frequent access\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Policy check failed and Too frequent access\", block.timestamp);\n        }\n        if (errcode == 4) {\n            rc.reputationCompute(subject, true, 4, \"Importance check failed\", block.timestamp);\n            emit ReturnAccessResult(subject, false, \"Importance check failed\", block.timestamp);\n        }\n        return finalResult;\n    }\n\n    function deleteACC() public {\n        require(msg.sender == manager, \"Caller is not manager!\");\n        selfdestruct(msg.sender);\n    }\n\n    /// @dev stringCompare determine whether the strings are equal, using length + hash comparson to reduce gas consumption\n    function stringCompare(string memory a, string memory b) public pure returns (bool) {\n        bytes memory _a = bytes(a);\n        bytes memory _b = bytes(b);\n        if (_a.length != _b.length) {\n            return false;\n        } else {\n            if (_a.length == 1) {\n                return _a[0] == _b[0];\n            } else {\n                return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\n            }\n        }\n    }\n}\n\n\nabstract contract ReputationA {\n    function reputationCompute(\n        address _subject, \n        bool _ismisbehavior,\n        uint8 _behaviorID,\n        string memory _behavior,\n        uint256  _time\n    ) virtual public;\n}\n\n\nabstract contract ManagementA {\n    function getTimeofUnblocked(address _device)  public virtual returns (uint256);\n\n    function getFixedAttribute (\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n    \n    function getCustomedAttribute(\n        address _device, \n        string memory _attrName\n    ) public view virtual returns (string memory _attrValue);\n}\n", "commit_id": "c7ba827b14b0d5d130e88d0cc5211a2d6fde03f7"}}