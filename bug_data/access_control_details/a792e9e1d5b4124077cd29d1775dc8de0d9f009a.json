{"filename": "contracts/ethereum/Nebula/Nebula.sol", "patch": "@@ -90,29 +90,20 @@ contract Nebula {\n        rounds[newRound] = true;\r\n     }\r\n     \r\n-    function validateDataProvider() internal view returns(bool) {\r\n-        for(uint i = 0; i < oracles.length; i++) {\r\n-            if (oracles[i] == msg.sender) {\r\n-                return true;\r\n-            }\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n     function sendValueToSubByte(bytes memory value, uint256 pulseId, bytes32 subId) public {\r\n-        require(validateDataProvider(), \"caller is not one of the oracles\");\r\n+        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\r\n         sendValueToSub(pulseId, subId);\r\n         ISubscriberBytes(subscriptions[subId].contractAddress).attachValue(value);\r\n     }\r\n \r\n     function sendValueToSubInt(int64 value, uint256 pulseId, bytes32 subId) public {\r\n-        require(validateDataProvider(), \"caller is not one of the oracles\");\r\n+        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\r\n         sendValueToSub(pulseId, subId);\r\n         ISubscriberInt(subscriptions[subId].contractAddress).attachValue(value);\r\n     }\r\n \r\n     function sendValueToSubString(string memory value, uint256 pulseId, bytes32 subId) public {\r\n-        require(validateDataProvider(), \"caller is not one of the oracles\");\r\n+        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\r\n         sendValueToSub(pulseId, subId);\r\n         ISubscriberString(subscriptions[subId].contractAddress).attachValue(value);\r\n     }\r", "project_link": "https://github.com/Graviton-One/gravity-core/commit/c00672372d02c57786e2f4bfa6f8d0a21738a9b1", "bug_version": {"raw_code": "pragma solidity <=0.7.0;\n\nimport \"../Gravity/Gravity.sol\";\nimport \"../libs/Queue.sol\";\nimport \"./NModels.sol\";\nimport \"../interfaces/ISubscriberBytes.sol\";\nimport \"../interfaces/ISubscriberInt.sol\";\nimport \"../interfaces/ISubscriberString.sol\";\n\n\ncontract Nebula {\n    event NewPulse(uint256 pulseId, uint256 height, bytes32 dataHash);\n    event NewSubscriber(bytes32 id);\n\n    mapping(uint256=>bool) public rounds;\n\n    QueueLib.Queue public oracleQueue;\n    QueueLib.Queue public subscriptionsQueue;\n    QueueLib.Queue public pulseQueue;\n\n    address[] public oracles;\n    uint256 public bftValue;\n    address public gravityContract;\n    NModels.DataType public dataType;\n\n    bytes32[] public subscriptionIds;\n    uint256 public lastPulseId;\n    mapping(bytes32 => NModels.Subscription) public subscriptions;\n    mapping(uint256 => NModels.Pulse) public pulses;\n    mapping(uint256 => mapping(bytes32 => bool)) public isPulseSubSent;\n\n    constructor(NModels.DataType newDataType, address newGravityContract, address[] memory newOracle, uint256 newBftValue) public {\n        dataType = newDataType;\n        oracles = newOracle;\n        bftValue = newBftValue;\n        gravityContract = newGravityContract;\n    }\n    \n    receive() external payable { } \n\n    //----------------------------------public getters--------------------------------------------------------------\n\n    function getOracles() public view returns(address[] memory) {\n        return oracles;\n    }\n\n    function getSubscribersIds() public view returns(bytes32[] memory) {\n        return subscriptionIds;\n    }\n\n    function hashNewOracles(address[] memory newOracles) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newOracles.length; i++) {\n            data = abi.encodePacked(data, newOracles[i]);\n        }\n\n        return keccak256(data);\n    }\n\n    //----------------------------------public setters--------------------------------------------------------------\n\n    function sendHashValue(bytes32 dataHash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n        uint256 count = 0;\n\n        for(uint i = 0; i < oracles.length; i++) {\n            count += ecrecover(dataHash,\n                v[i], r[i], s[i]) == oracles[i] ? 1 : 0;\n        }\n\n        require(count >= bftValue, \"invalid bft count\");\n        \n        uint256 newPulseId = lastPulseId + 1;\n        pulses[newPulseId] = NModels.Pulse(dataHash, block.number);\n\n        emit NewPulse(newPulseId, block.number, dataHash);\n        lastPulseId = newPulseId;\n    }\n\n    function updateOracles(address[] memory newOracles, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 newRound) public {\n        uint256 count = 0;\n        bytes32 dataHash = hashNewOracles(newOracles);\n        address[] memory consuls = Gravity(gravityContract).getConsuls();\n\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n       oracles = newOracles;\n       rounds[newRound] = true;\n    }\n    \n    function validateDataProvider() internal view returns(bool) {\n        for(uint i = 0; i < oracles.length; i++) {\n            if (oracles[i] == msg.sender) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sendValueToSubByte(bytes memory value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberBytes(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubInt(int64 value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberInt(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubString(string memory value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberString(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    //----------------------------------internals---------------------------------------------------------------------\n\n    function sendValueToSub(uint256 pulseId, bytes32 subId) internal {\n        require(isPulseSubSent[pulseId][subId] == false, \"sub sent\");\n\n        isPulseSubSent[pulseId][subId] = true;\n    }\n    \n    function subscribe(address payable contractAddress, uint8 minConfirmations, uint256 reward) public {\n        bytes32 id = keccak256(abi.encodePacked(abi.encodePacked(msg.sig, msg.sender, contractAddress, minConfirmations)));\n        require(subscriptions[id].owner == address(0x00), \"rq exists\");\n        subscriptions[id] = NModels.Subscription(msg.sender, contractAddress, minConfirmations, reward);\n        QueueLib.push(subscriptionsQueue, id);\n        subscriptionIds.push(id);\n        emit NewSubscriber(id);\n    }\n}\n", "flattened_code": "pragma solidity <=0.7.0;\n\npragma solidity <=0.7.0;\n\ncontract Gravity {\n    mapping(uint256=>address[]) public rounds;\n    uint256 public bftValue;\n    uint256 public lastRound;\n\n    constructor(address[] memory consuls, uint256 newBftValue) public {\n        rounds[0] = consuls;\n        bftValue = newBftValue;\n    }\n\n    function getConsuls() external view returns(address[] memory) {\n        return rounds[lastRound];\n    }\n\n    function getConsulsByRoundId(uint256 roundId) external view returns(address[] memory) {\n        return rounds[roundId];\n    }\n\n    function updateConsuls(address[] memory newConsuls, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 roundId) public {\n        uint256 count = 0;\n\n        require(roundId > lastRound, \"round less last round\");\n\n        bytes32 dataHash = hashNewConsuls(newConsuls, roundId);\n\n        address[] memory consuls = rounds[lastRound];\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n        rounds[roundId] = newConsuls;\n        lastRound = roundId;\n    }\n\n    function hashNewConsuls(address[] memory newConsuls, uint256 roundId) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newConsuls.length; i++) {\n            data = abi.encodePacked(data, newConsuls[i]);\n        }\n        \n\n        return keccak256(abi.encodePacked(data, roundId));\n    }\n\n}\npragma solidity <=0.7;\n\nlibrary QueueLib {\n    struct Queue {\n        bytes32 first;\n        bytes32 last;\n        mapping(bytes32 => bytes32) nextElement;\n        mapping(bytes32 => bytes32) prevElement;\n    }\n\n    function drop(Queue storage queue, bytes32 rqHash) public {\n        bytes32 prevElement = queue.prevElement[rqHash];\n        bytes32 nextElement = queue.nextElement[rqHash];\n\n        if (prevElement != bytes32(0)) {\n            queue.nextElement[prevElement] = nextElement;\n        } else {\n            queue.first = nextElement;\n        }\n\n        if (nextElement != bytes32(0)) {\n            queue.prevElement[nextElement] = prevElement;\n        } else {\n            queue.last = prevElement;\n        }\n    }\n\n    // function next(Queue storage queue, bytes32 startRqHash) public view returns(bytes32) {\n    //     if (startRqHash == 0x000)\n    //         return queue.first;\n    //     else {\n    //         return queue.nextElement[startRqHash];\n    //     }\n    // }\n\n    function push(Queue storage queue, bytes32 elementHash) public {\n        if (queue.first == 0x000) {\n            queue.first = elementHash;\n            queue.last = elementHash;\n        } else {\n            queue.nextElement[queue.last] = elementHash;\n            queue.prevElement[elementHash] = queue.last;\n            queue.nextElement[elementHash] = bytes32(0);\n            queue.last = elementHash;\n        }\n    }\n}\npragma solidity <=0.7.0;\n\nlibrary NModels {\n    uint8 constant oracleCountInEpoch = 5;\n\n    enum DataType {\n        Int64,\n        String,\n        Bytes\n    }\n\n    struct Subscription {\n        address owner;\n        address payable contractAddress;\n        uint8 minConfirmations;\n        uint256 reward;\n    }\n\n    struct Pulse {\n        bytes32 dataHash;\n        uint256 height;\n    }\n\n    struct Oracle {\n        address owner;\n        bool isOnline;\n        bytes32 idInQueue;\n    }\n}\npragma solidity <=0.7.0;\n\ninterface ISubscriberBytes {\n    function attachValue(bytes calldata value) external;\n}\npragma solidity <=0.7.0;\n\ninterface ISubscriberInt {\n    function attachValue(int64 value) external;\n}\npragma solidity <=0.7.0;\n\ninterface ISubscriberString {\n    function attachValue(string calldata value) external;\n}\n\n\ncontract Nebula {\n    event NewPulse(uint256 pulseId, uint256 height, bytes32 dataHash);\n    event NewSubscriber(bytes32 id);\n\n    mapping(uint256=>bool) public rounds;\n\n    QueueLib.Queue public oracleQueue;\n    QueueLib.Queue public subscriptionsQueue;\n    QueueLib.Queue public pulseQueue;\n\n    address[] public oracles;\n    uint256 public bftValue;\n    address public gravityContract;\n    NModels.DataType public dataType;\n\n    bytes32[] public subscriptionIds;\n    uint256 public lastPulseId;\n    mapping(bytes32 => NModels.Subscription) public subscriptions;\n    mapping(uint256 => NModels.Pulse) public pulses;\n    mapping(uint256 => mapping(bytes32 => bool)) public isPulseSubSent;\n\n    constructor(NModels.DataType newDataType, address newGravityContract, address[] memory newOracle, uint256 newBftValue) public {\n        dataType = newDataType;\n        oracles = newOracle;\n        bftValue = newBftValue;\n        gravityContract = newGravityContract;\n    }\n    \n    receive() external payable { } \n\n    //----------------------------------public getters--------------------------------------------------------------\n\n    function getOracles() public view returns(address[] memory) {\n        return oracles;\n    }\n\n    function getSubscribersIds() public view returns(bytes32[] memory) {\n        return subscriptionIds;\n    }\n\n    function hashNewOracles(address[] memory newOracles) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newOracles.length; i++) {\n            data = abi.encodePacked(data, newOracles[i]);\n        }\n\n        return keccak256(data);\n    }\n\n    //----------------------------------public setters--------------------------------------------------------------\n\n    function sendHashValue(bytes32 dataHash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n        uint256 count = 0;\n\n        for(uint i = 0; i < oracles.length; i++) {\n            count += ecrecover(dataHash,\n                v[i], r[i], s[i]) == oracles[i] ? 1 : 0;\n        }\n\n        require(count >= bftValue, \"invalid bft count\");\n        \n        uint256 newPulseId = lastPulseId + 1;\n        pulses[newPulseId] = NModels.Pulse(dataHash, block.number);\n\n        emit NewPulse(newPulseId, block.number, dataHash);\n        lastPulseId = newPulseId;\n    }\n\n    function updateOracles(address[] memory newOracles, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 newRound) public {\n        uint256 count = 0;\n        bytes32 dataHash = hashNewOracles(newOracles);\n        address[] memory consuls = Gravity(gravityContract).getConsuls();\n\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n       oracles = newOracles;\n       rounds[newRound] = true;\n    }\n    \n    function validateDataProvider() internal view returns(bool) {\n        for(uint i = 0; i < oracles.length; i++) {\n            if (oracles[i] == msg.sender) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function sendValueToSubByte(bytes memory value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberBytes(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubInt(int64 value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberInt(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubString(string memory value, uint256 pulseId, bytes32 subId) public {\n        require(validateDataProvider(), \"caller is not one of the oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberString(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    //----------------------------------internals---------------------------------------------------------------------\n\n    function sendValueToSub(uint256 pulseId, bytes32 subId) internal {\n        require(isPulseSubSent[pulseId][subId] == false, \"sub sent\");\n\n        isPulseSubSent[pulseId][subId] = true;\n    }\n    \n    function subscribe(address payable contractAddress, uint8 minConfirmations, uint256 reward) public {\n        bytes32 id = keccak256(abi.encodePacked(abi.encodePacked(msg.sig, msg.sender, contractAddress, minConfirmations)));\n        require(subscriptions[id].owner == address(0x00), \"rq exists\");\n        subscriptions[id] = NModels.Subscription(msg.sender, contractAddress, minConfirmations, reward);\n        QueueLib.push(subscriptionsQueue, id);\n        subscriptionIds.push(id);\n        emit NewSubscriber(id);\n    }\n}\n", "commit_id": "a792e9e1d5b4124077cd29d1775dc8de0d9f009a"}, "fixed_version": {"raw_code": "pragma solidity <=0.7.0;\n\nimport \"../Gravity/Gravity.sol\";\nimport \"../libs/Queue.sol\";\nimport \"./NModels.sol\";\nimport \"../interfaces/ISubscriberBytes.sol\";\nimport \"../interfaces/ISubscriberInt.sol\";\nimport \"../interfaces/ISubscriberString.sol\";\n\n\ncontract Nebula {\n    event NewPulse(uint256 pulseId, uint256 height, bytes32 dataHash);\n    event NewSubscriber(bytes32 id);\n\n    mapping(uint256=>bool) public rounds;\n\n    QueueLib.Queue public oracleQueue;\n    QueueLib.Queue public subscriptionsQueue;\n    QueueLib.Queue public pulseQueue;\n\n    address[] public oracles;\n    uint256 public bftValue;\n    address public gravityContract;\n    NModels.DataType public dataType;\n\n    bytes32[] public subscriptionIds;\n    uint256 public lastPulseId;\n    mapping(bytes32 => NModels.Subscription) public subscriptions;\n    mapping(uint256 => NModels.Pulse) public pulses;\n    mapping(uint256 => mapping(bytes32 => bool)) public isPulseSubSent;\n\n    constructor(NModels.DataType newDataType, address newGravityContract, address[] memory newOracle, uint256 newBftValue) public {\n        dataType = newDataType;\n        oracles = newOracle;\n        bftValue = newBftValue;\n        gravityContract = newGravityContract;\n    }\n    \n    receive() external payable { } \n\n    //----------------------------------public getters--------------------------------------------------------------\n\n    function getOracles() public view returns(address[] memory) {\n        return oracles;\n    }\n\n    function getSubscribersIds() public view returns(bytes32[] memory) {\n        return subscriptionIds;\n    }\n\n    function hashNewOracles(address[] memory newOracles) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newOracles.length; i++) {\n            data = abi.encodePacked(data, newOracles[i]);\n        }\n\n        return keccak256(data);\n    }\n\n    //----------------------------------public setters--------------------------------------------------------------\n\n    function sendHashValue(bytes32 dataHash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n        uint256 count = 0;\n\n        for(uint i = 0; i < oracles.length; i++) {\n            count += ecrecover(dataHash,\n                v[i], r[i], s[i]) == oracles[i] ? 1 : 0;\n        }\n\n        require(count >= bftValue, \"invalid bft count\");\n        \n        uint256 newPulseId = lastPulseId + 1;\n        pulses[newPulseId] = NModels.Pulse(dataHash, block.number);\n\n        emit NewPulse(newPulseId, block.number, dataHash);\n        lastPulseId = newPulseId;\n    }\n\n    function updateOracles(address[] memory newOracles, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 newRound) public {\n        uint256 count = 0;\n        bytes32 dataHash = hashNewOracles(newOracles);\n        address[] memory consuls = Gravity(gravityContract).getConsuls();\n\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n       oracles = newOracles;\n       rounds[newRound] = true;\n    }\n    \n    function sendValueToSubByte(bytes memory value, uint256 pulseId, bytes32 subId) public {\n        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberBytes(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubInt(int64 value, uint256 pulseId, bytes32 subId) public {\n        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberInt(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubString(string memory value, uint256 pulseId, bytes32 subId) public {\n        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberString(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    //----------------------------------internals---------------------------------------------------------------------\n\n    function sendValueToSub(uint256 pulseId, bytes32 subId) internal {\n        require(isPulseSubSent[pulseId][subId] == false, \"sub sent\");\n\n        isPulseSubSent[pulseId][subId] = true;\n    }\n    \n    function subscribe(address payable contractAddress, uint8 minConfirmations, uint256 reward) public {\n        bytes32 id = keccak256(abi.encodePacked(abi.encodePacked(msg.sig, msg.sender, contractAddress, minConfirmations)));\n        require(subscriptions[id].owner == address(0x00), \"rq exists\");\n        subscriptions[id] = NModels.Subscription(msg.sender, contractAddress, minConfirmations, reward);\n        QueueLib.push(subscriptionsQueue, id);\n        subscriptionIds.push(id);\n        emit NewSubscriber(id);\n    }\n}\n", "flattened_code": "pragma solidity <=0.7.0;\n\npragma solidity <=0.7.0;\n\ncontract Gravity {\n    mapping(uint256=>address[]) public rounds;\n    uint256 public bftValue;\n    uint256 public lastRound;\n\n    constructor(address[] memory consuls, uint256 newBftValue) public {\n        rounds[0] = consuls;\n        bftValue = newBftValue;\n    }\n\n    function getConsuls() external view returns(address[] memory) {\n        return rounds[lastRound];\n    }\n\n    function getConsulsByRoundId(uint256 roundId) external view returns(address[] memory) {\n        return rounds[roundId];\n    }\n\n    function updateConsuls(address[] memory newConsuls, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 roundId) public {\n        uint256 count = 0;\n\n        require(roundId > lastRound, \"round less last round\");\n\n        bytes32 dataHash = hashNewConsuls(newConsuls, roundId);\n\n        address[] memory consuls = rounds[lastRound];\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n        rounds[roundId] = newConsuls;\n        lastRound = roundId;\n    }\n\n    function hashNewConsuls(address[] memory newConsuls, uint256 roundId) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newConsuls.length; i++) {\n            data = abi.encodePacked(data, newConsuls[i]);\n        }\n        \n\n        return keccak256(abi.encodePacked(data, roundId));\n    }\n\n}\npragma solidity <=0.7;\n\nlibrary QueueLib {\n    struct Queue {\n        bytes32 first;\n        bytes32 last;\n        mapping(bytes32 => bytes32) nextElement;\n        mapping(bytes32 => bytes32) prevElement;\n    }\n\n    function drop(Queue storage queue, bytes32 rqHash) public {\n        bytes32 prevElement = queue.prevElement[rqHash];\n        bytes32 nextElement = queue.nextElement[rqHash];\n\n        if (prevElement != bytes32(0)) {\n            queue.nextElement[prevElement] = nextElement;\n        } else {\n            queue.first = nextElement;\n        }\n\n        if (nextElement != bytes32(0)) {\n            queue.prevElement[nextElement] = prevElement;\n        } else {\n            queue.last = prevElement;\n        }\n    }\n\n    // function next(Queue storage queue, bytes32 startRqHash) public view returns(bytes32) {\n    //     if (startRqHash == 0x000)\n    //         return queue.first;\n    //     else {\n    //         return queue.nextElement[startRqHash];\n    //     }\n    // }\n\n    function push(Queue storage queue, bytes32 elementHash) public {\n        if (queue.first == 0x000) {\n            queue.first = elementHash;\n            queue.last = elementHash;\n        } else {\n            queue.nextElement[queue.last] = elementHash;\n            queue.prevElement[elementHash] = queue.last;\n            queue.nextElement[elementHash] = bytes32(0);\n            queue.last = elementHash;\n        }\n    }\n}\npragma solidity <=0.7.0;\n\nlibrary NModels {\n    uint8 constant oracleCountInEpoch = 5;\n\n    enum DataType {\n        Int64,\n        String,\n        Bytes\n    }\n\n    struct Subscription {\n        address owner;\n        address payable contractAddress;\n        uint8 minConfirmations;\n        uint256 reward;\n    }\n\n    struct Pulse {\n        bytes32 dataHash;\n        uint256 height;\n    }\n\n    struct Oracle {\n        address owner;\n        bool isOnline;\n        bytes32 idInQueue;\n    }\n}\npragma solidity <=0.7.0;\n\ninterface ISubscriberBytes {\n    function attachValue(bytes calldata value) external;\n}\npragma solidity <=0.7.0;\n\ninterface ISubscriberInt {\n    function attachValue(int64 value) external;\n}\npragma solidity <=0.7.0;\n\ninterface ISubscriberString {\n    function attachValue(string calldata value) external;\n}\n\n\ncontract Nebula {\n    event NewPulse(uint256 pulseId, uint256 height, bytes32 dataHash);\n    event NewSubscriber(bytes32 id);\n\n    mapping(uint256=>bool) public rounds;\n\n    QueueLib.Queue public oracleQueue;\n    QueueLib.Queue public subscriptionsQueue;\n    QueueLib.Queue public pulseQueue;\n\n    address[] public oracles;\n    uint256 public bftValue;\n    address public gravityContract;\n    NModels.DataType public dataType;\n\n    bytes32[] public subscriptionIds;\n    uint256 public lastPulseId;\n    mapping(bytes32 => NModels.Subscription) public subscriptions;\n    mapping(uint256 => NModels.Pulse) public pulses;\n    mapping(uint256 => mapping(bytes32 => bool)) public isPulseSubSent;\n\n    constructor(NModels.DataType newDataType, address newGravityContract, address[] memory newOracle, uint256 newBftValue) public {\n        dataType = newDataType;\n        oracles = newOracle;\n        bftValue = newBftValue;\n        gravityContract = newGravityContract;\n    }\n    \n    receive() external payable { } \n\n    //----------------------------------public getters--------------------------------------------------------------\n\n    function getOracles() public view returns(address[] memory) {\n        return oracles;\n    }\n\n    function getSubscribersIds() public view returns(bytes32[] memory) {\n        return subscriptionIds;\n    }\n\n    function hashNewOracles(address[] memory newOracles) public pure returns(bytes32) {\n        bytes memory data;\n        for(uint i = 0; i < newOracles.length; i++) {\n            data = abi.encodePacked(data, newOracles[i]);\n        }\n\n        return keccak256(data);\n    }\n\n    //----------------------------------public setters--------------------------------------------------------------\n\n    function sendHashValue(bytes32 dataHash, uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n        uint256 count = 0;\n\n        for(uint i = 0; i < oracles.length; i++) {\n            count += ecrecover(dataHash,\n                v[i], r[i], s[i]) == oracles[i] ? 1 : 0;\n        }\n\n        require(count >= bftValue, \"invalid bft count\");\n        \n        uint256 newPulseId = lastPulseId + 1;\n        pulses[newPulseId] = NModels.Pulse(dataHash, block.number);\n\n        emit NewPulse(newPulseId, block.number, dataHash);\n        lastPulseId = newPulseId;\n    }\n\n    function updateOracles(address[] memory newOracles, uint8[] memory v, bytes32[] memory r, bytes32[] memory s, uint256 newRound) public {\n        uint256 count = 0;\n        bytes32 dataHash = hashNewOracles(newOracles);\n        address[] memory consuls = Gravity(gravityContract).getConsuls();\n\n        for(uint i = 0; i < consuls.length; i++) {\n            count += ecrecover(dataHash, v[i], r[i], s[i]) == consuls[i] ? 1 : 0;\n        }\n        require(count >= bftValue, \"invalid bft count\");\n\n       oracles = newOracles;\n       rounds[newRound] = true;\n    }\n    \n    function sendValueToSubByte(bytes memory value, uint256 pulseId, bytes32 subId) public {\n        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberBytes(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubInt(int64 value, uint256 pulseId, bytes32 subId) public {\n        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberInt(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    function sendValueToSubString(string memory value, uint256 pulseId, bytes32 subId) public {\n        require(keccak256(abi.encodePacked(value)) == pulses[pulseId].dataHash, \"value was not approved by oracles\");\n        sendValueToSub(pulseId, subId);\n        ISubscriberString(subscriptions[subId].contractAddress).attachValue(value);\n    }\n\n    //----------------------------------internals---------------------------------------------------------------------\n\n    function sendValueToSub(uint256 pulseId, bytes32 subId) internal {\n        require(isPulseSubSent[pulseId][subId] == false, \"sub sent\");\n\n        isPulseSubSent[pulseId][subId] = true;\n    }\n    \n    function subscribe(address payable contractAddress, uint8 minConfirmations, uint256 reward) public {\n        bytes32 id = keccak256(abi.encodePacked(abi.encodePacked(msg.sig, msg.sender, contractAddress, minConfirmations)));\n        require(subscriptions[id].owner == address(0x00), \"rq exists\");\n        subscriptions[id] = NModels.Subscription(msg.sender, contractAddress, minConfirmations, reward);\n        QueueLib.push(subscriptionsQueue, id);\n        subscriptionIds.push(id);\n        emit NewSubscriber(id);\n    }\n}\n", "commit_id": "c00672372d02c57786e2f4bfa6f8d0a21738a9b1"}, "solc_version": "0.7.0", "packages": {"name": "gravity-core", "version": "1.0.0", "main": "index.js", "repository": "https://github.com/Graviton-One/gravity-core", "devDependencies": {"@nomiclabs/hardhat-ethers": "^2.0.2", "@nomiclabs/hardhat-waffle": "^2.0.1", "@types/chai": "^4.2.18", "@types/mocha": "^8.2.2", "@types/node": "^15.0.2", "chai": "^4.3.4", "ethereum-waffle": "^3.3.0", "ethers": "^5.1.4", "hardhat": "^2.2.1", "solidity-coverage": "^0.7.16", "ts-node": "^10.0.0", "typescript": "^4.2.4"}, "dependencies": {"@typechain/ethers-v5": "^7.0.1", "@typechain/hardhat": "^2.0.2", "@types/chai-as-promised": "^7.1.4", "chai-as-promised": "^7.1.1", "typechain": "^5.0.0"}, "scripts": {"compile": "hardhat compile", "test": "hardhat test", "coverage": "hardhat coverage"}}}