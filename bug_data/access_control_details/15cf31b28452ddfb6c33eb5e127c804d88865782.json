{"filename": "contracts/NodeStorage.sol", "patch": "@@ -61,7 +61,7 @@ contract NodeStorage {\n         return indexOf[calculateKey(_enodeId, _ip, _port)] != 0;\n     }\n \n-    function add(string memory _enodeId, string memory _ip, uint16 _port) public returns (bool) {\n+    function add(string memory _enodeId, string memory _ip, uint16 _port) public onlyLatestVersion returns (bool) {\n         uint256 key = calculateKey(_enodeId, _ip, _port);\n         if (indexOf[key] == 0) {\n             indexOf[key] = allowlist.push(enode(_enodeId, _ip, _port));\n@@ -70,7 +70,7 @@ contract NodeStorage {\n         return false;\n     }\n \n-    function remove(string memory _enodeId, string memory _ip, uint16 _port) public returns (bool) {\n+    function remove(string memory _enodeId, string memory _ip, uint16 _port) public onlyLatestVersion returns (bool) {\n         uint256 key = calculateKey(_enodeId, _ip, _port);\n         uint256 index = indexOf[key];\n ", "project_link": "https://github.com/albert0-hernandez/permissioning-smart-contracts/commit/15cf31b28452ddfb6c33eb5e127c804d88865782", "bug_version": {"raw_code": "pragma solidity 0.5.9;\n\nimport \"./Admin.sol\";\nimport \"./NodeIngress.sol\";\n\n\ncontract NodeStorage {\n    event VersionChange(\n        address oldAddress,\n        address newAddress\n    );\n    // initialize this to the deployer of this contract\n    address private latestVersion = msg.sender;\n    address private owner = msg.sender;\n\n    NodeIngress private ingressContract;\n\n\n\n    // struct size = 82 bytes\n    struct enode {\n        string enodeId;\n        string ip;\n        uint16 port;\n    }\n\n    enode[] public allowlist;\n    mapping (uint256 => uint256) private indexOf; //1-based indexing. 0 means non-existent\n\n    constructor (NodeIngress _ingressContract) public {\n        ingressContract = _ingressContract;\n    }\n\n    modifier onlyLatestVersion() {\n        require(msg.sender == latestVersion, \"only the latestVersion can modify the list\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (address(0) == address(ingressContract)) {\n            require(msg.sender == owner, \"only owner permitted since ingressContract is explicitly set to zero\");\n        } else {\n            address adminContractAddress = ingressContract.getContractAddress(ingressContract.ADMIN_CONTRACT());\n\n            require(adminContractAddress != address(0), \"Ingress contract must have Admin contract registered\");\n            require(Admin(adminContractAddress).isAuthorized(msg.sender), \"Sender not authorized\");\n        }\n        _;\n    }\n\n    function upgradeVersion(address _newVersion) public onlyAdmin {\n        emit VersionChange(latestVersion, _newVersion);\n        latestVersion = _newVersion;\n    }\n\n    function size() public view returns (uint256) {\n        return allowlist.length;\n    }\n\n    function exists(string memory _enodeId, string memory _ip, uint16 _port) public view returns (bool) {\n        return indexOf[calculateKey(_enodeId, _ip, _port)] != 0;\n    }\n\n    function add(string memory _enodeId, string memory _ip, uint16 _port) public returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        if (indexOf[key] == 0) {\n            indexOf[key] = allowlist.push(enode(_enodeId, _ip, _port));\n            return true;\n        }\n        return false;\n    }\n\n    function remove(string memory _enodeId, string memory _ip, uint16 _port) public returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        uint256 index = indexOf[key];\n\n        if (index > 0 && index <= allowlist.length) { //1 based indexing\n            //move last item into index being vacated (unless we are dealing with last index)\n            if (index != allowlist.length) {\n                enode memory lastEnode = allowlist[allowlist.length - 1];\n                allowlist[index - 1] = lastEnode;\n                indexOf[calculateKey(lastEnode.enodeId, lastEnode.ip, lastEnode.port)] = index;\n            }\n\n            //shrink array\n            allowlist.length -= 1; // mythx-disable-line SWC-101\n            indexOf[key] = 0;\n            return true;\n        }\n\n        return false;\n    }\n\n    function getByIndex(uint index) external view returns (string memory enodeId, string memory ip, uint16 port) {\n        if (index >= 0 && index < size()) {\n            enode memory item = allowlist[index];\n            return (item.enodeId, item.ip, item.port);\n        }\n    }\n\n    function calculateKey(string memory _enodeId, string memory _ip, uint16 _port) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(_enodeId, _ip, _port)));\n    }\n}", "flattened_code": "pragma solidity 0.5.9;\n\npragma solidity 0.5.9;\n\npragma solidity 0.5.9;\n\ninterface AdminProxy {\n    function isAuthorized(address source) external view returns (bool);\n}\npragma solidity 0.5.9;\n\n\n\ncontract AdminList {\n    event AdminAdded(\n        bool adminAdded,\n        address account,\n        string message\n    );\n\n    event AdminRemoved(\n        bool adminRemoved,\n        address account\n    );\n\n    address[] public allowlist;\n    mapping (address => uint256) private indexOf; //1 based indexing. 0 means non-existent\n\n    function size() internal view returns (uint256) {\n        return allowlist.length;\n    }\n\n    function exists(address _account) internal view returns (bool) {\n        return indexOf[_account] != 0;\n    }\n\n    function add(address _account) internal returns (bool) {\n        if (indexOf[_account] == 0) {\n            indexOf[_account] = allowlist.push(_account);\n            return true;\n        }\n        return false;\n    }\n\n    function addAll(address[] memory accounts) internal returns (bool) {\n        bool allAdded = true;\n        for (uint i = 0; i<accounts.length; i++) {\n            if (msg.sender == accounts[i]) {\n                emit AdminAdded(false, accounts[i], \"Adding own account as Admin is not permitted\");\n                allAdded = allAdded && false;\n            } else if (exists(accounts[i])) {\n                emit AdminAdded(false, accounts[i], \"Account is already an Admin\");\n                allAdded = allAdded && false;\n            }  else {\n                bool result = add(accounts[i]);\n                string memory message = result ? \"Admin account added successfully\" : \"Account is already an Admin\";\n                emit AdminAdded(result, accounts[i], message);\n                allAdded = allAdded && result;\n            }\n        }\n\n        return allAdded;\n    }\n\n    function remove(address _account) internal returns (bool) {\n        uint256 index = indexOf[_account];\n        if (index > 0 && index <= allowlist.length) { //1-based indexing\n            //move last address into index being vacated (unless we are dealing with last index)\n            if (index != allowlist.length) {\n                address lastAccount = allowlist[allowlist.length - 1];\n                allowlist[index - 1] = lastAccount;\n                indexOf[lastAccount] = index;\n            }\n\n            //shrink array\n            allowlist.length -= 1; // mythx-disable-line SWC-101\n            indexOf[_account] = 0;\n            return true;\n        }\n        return false;\n    }\n}\n\n\ncontract Admin is AdminProxy, AdminList {\n    modifier onlyAdmin() {\n        require(isAuthorized(msg.sender), \"Sender not authorized\");\n        _;\n    }\n\n    modifier notSelf(address _address) {\n        require(msg.sender != _address, \"Cannot invoke method with own account as parameter\");\n        _;\n    }\n\n    constructor() public {\n        add(msg.sender);\n    }\n\n    function isAuthorized(address _address) public view returns (bool) {\n        return exists(_address);\n    }\n\n    function addAdmin(address _address) external onlyAdmin returns (bool) {\n        if (msg.sender == _address) {\n            emit AdminAdded(false, _address, \"Adding own account as Admin is not permitted\");\n            return false;\n        } else {\n            bool result = add(_address);\n            string memory message = result ? \"Admin account added successfully\" : \"Account is already an Admin\";\n            emit AdminAdded(result, _address, message);\n            return result;\n        }\n    }\n\n    function removeAdmin(address _address) external onlyAdmin notSelf(_address) returns (bool) {\n        bool removed = remove(_address);\n        emit AdminRemoved(removed, _address);\n        return removed;\n    }\n\n    function getAdmins() external view returns (address[] memory){\n        return allowlist; // mythx-disable-line SWC-128\n    }\n\n    function addAdmins(address[] calldata accounts) external onlyAdmin returns (bool) {\n        return addAll(accounts);\n    }\n}\npragma solidity 0.5.9;\n\npragma solidity 0.5.9;\n\ninterface NodeRulesProxy {\n    function connectionAllowed(\n        string calldata enodeId,\n        string calldata enodeHost,\n        uint16 enodePort\n    ) external view returns (bool);\n}\npragma solidity 0.5.9;\n\n\n\ncontract Ingress {\n    // Contract keys\n    bytes32 public RULES_CONTRACT = 0x72756c6573000000000000000000000000000000000000000000000000000000; // \"rules\"\n    bytes32 public ADMIN_CONTRACT = 0x61646d696e697374726174696f6e000000000000000000000000000000000000; // \"administration\"\n\n    // Registry mapping indexing\n    mapping(bytes32 => address) internal registry;\n\n    bytes32[] internal contractKeys;\n    mapping (bytes32 => uint256) internal indexOf; //1 based indexing. 0 means non-existent\n\n    event RegistryUpdated(\n        address contractAddress,\n        bytes32 contractName\n    );\n\n    function getContractAddress(bytes32 name) public view returns(address) {\n        require(name > 0, \"Contract name must not be empty.\");\n        return registry[name];\n    }\n\n    function getSize() external view returns (uint256) {\n        return contractKeys.length;\n    }\n\n    function isAuthorized(address account) public view returns(bool) {\n        if (registry[ADMIN_CONTRACT] == address(0)) {\n            return true;\n        } else {\n            return AdminProxy(registry[ADMIN_CONTRACT]).isAuthorized(account);\n        }\n    }\n\n    function setContractAddress(bytes32 name, address addr) external returns (bool) {\n        require(name > 0, \"Contract name must not be empty.\");\n        require(addr != address(0), \"Contract address must not be zero.\");\n        require(isAuthorized(msg.sender), \"Not authorized to update contract registry.\");\n\n        if (indexOf[name] == 0) {\n            indexOf[name] = contractKeys.push(name);\n        }\n\n        registry[name] = addr;\n\n        emit RegistryUpdated(addr, name);\n\n        return true;\n    }\n\n    function removeContract(bytes32 _name) external returns(bool) {\n        require(_name > 0, \"Contract name must not be empty.\");\n        require(contractKeys.length > 0, \"Must have at least one registered contract to execute delete operation.\");\n        require(isAuthorized(msg.sender), \"Not authorized to update contract registry.\");\n\n        uint256 index = indexOf[_name];\n        if (index > 0 && index <= contractKeys.length) { //1-based indexing\n            //move last address into index being vacated (unless we are dealing with last index)\n            if (index != contractKeys.length) {\n                bytes32 lastKey = contractKeys[contractKeys.length - 1];\n                contractKeys[index - 1] = lastKey;\n                indexOf[lastKey] = index;\n            }\n\n            //shrink contract keys array\n            contractKeys.pop();\n            indexOf[_name] = 0;\n            registry[_name] = address(0);\n            emit RegistryUpdated(address(0), _name);\n            return true;\n        }\n        return false;\n    }\n\n    function getAllContractKeys() external view returns(bytes32[] memory) {\n        return contractKeys; // mythx-disable-line SWC-128\n    }\n}\n\n\ncontract NodeIngress is Ingress {\n    // version of this contract: semver eg 1.2.14 represented like 001002014\n    uint private version = 1000000;\n\n    event NodePermissionsUpdated(\n        bool addsRestrictions\n    );\n\n    function getContractVersion() external view returns(uint) {\n        return version;\n    }\n\n    function emitRulesChangeEvent(bool addsRestrictions) external {\n        require(registry[RULES_CONTRACT] == msg.sender, \"Only Rules contract can trigger Rules change events\");\n        emit NodePermissionsUpdated(addsRestrictions);\n    }\n\n    function connectionAllowed(\n        string calldata enodeId,\n        string calldata enodeHost,\n        uint16 enodePort\n    ) external view returns (bool) {\n        if(getContractAddress(RULES_CONTRACT) == address(0)) {\n            return false;\n        }\n\n        return NodeRulesProxy(registry[RULES_CONTRACT]).connectionAllowed(\n            enodeId,\n            enodeHost,\n            enodePort\n        );\n    }\n}\n\n\ncontract NodeStorage {\n    event VersionChange(\n        address oldAddress,\n        address newAddress\n    );\n    // initialize this to the deployer of this contract\n    address private latestVersion = msg.sender;\n    address private owner = msg.sender;\n\n    NodeIngress private ingressContract;\n\n\n\n    // struct size = 82 bytes\n    struct enode {\n        string enodeId;\n        string ip;\n        uint16 port;\n    }\n\n    enode[] public allowlist;\n    mapping (uint256 => uint256) private indexOf; //1-based indexing. 0 means non-existent\n\n    constructor (NodeIngress _ingressContract) public {\n        ingressContract = _ingressContract;\n    }\n\n    modifier onlyLatestVersion() {\n        require(msg.sender == latestVersion, \"only the latestVersion can modify the list\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (address(0) == address(ingressContract)) {\n            require(msg.sender == owner, \"only owner permitted since ingressContract is explicitly set to zero\");\n        } else {\n            address adminContractAddress = ingressContract.getContractAddress(ingressContract.ADMIN_CONTRACT());\n\n            require(adminContractAddress != address(0), \"Ingress contract must have Admin contract registered\");\n            require(Admin(adminContractAddress).isAuthorized(msg.sender), \"Sender not authorized\");\n        }\n        _;\n    }\n\n    function upgradeVersion(address _newVersion) public onlyAdmin {\n        emit VersionChange(latestVersion, _newVersion);\n        latestVersion = _newVersion;\n    }\n\n    function size() public view returns (uint256) {\n        return allowlist.length;\n    }\n\n    function exists(string memory _enodeId, string memory _ip, uint16 _port) public view returns (bool) {\n        return indexOf[calculateKey(_enodeId, _ip, _port)] != 0;\n    }\n\n    function add(string memory _enodeId, string memory _ip, uint16 _port) public returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        if (indexOf[key] == 0) {\n            indexOf[key] = allowlist.push(enode(_enodeId, _ip, _port));\n            return true;\n        }\n        return false;\n    }\n\n    function remove(string memory _enodeId, string memory _ip, uint16 _port) public returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        uint256 index = indexOf[key];\n\n        if (index > 0 && index <= allowlist.length) { //1 based indexing\n            //move last item into index being vacated (unless we are dealing with last index)\n            if (index != allowlist.length) {\n                enode memory lastEnode = allowlist[allowlist.length - 1];\n                allowlist[index - 1] = lastEnode;\n                indexOf[calculateKey(lastEnode.enodeId, lastEnode.ip, lastEnode.port)] = index;\n            }\n\n            //shrink array\n            allowlist.length -= 1; // mythx-disable-line SWC-101\n            indexOf[key] = 0;\n            return true;\n        }\n\n        return false;\n    }\n\n    function getByIndex(uint index) external view returns (string memory enodeId, string memory ip, uint16 port) {\n        if (index >= 0 && index < size()) {\n            enode memory item = allowlist[index];\n            return (item.enodeId, item.ip, item.port);\n        }\n    }\n\n    function calculateKey(string memory _enodeId, string memory _ip, uint16 _port) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(_enodeId, _ip, _port)));\n    }\n}\n", "commit_id": "be8f6f34ab3d2d7cbb7e966161d862ce4fa8493d"}, "fixed_version": {"raw_code": "pragma solidity 0.5.9;\n\nimport \"./Admin.sol\";\nimport \"./NodeIngress.sol\";\n\n\ncontract NodeStorage {\n    event VersionChange(\n        address oldAddress,\n        address newAddress\n    );\n    // initialize this to the deployer of this contract\n    address private latestVersion = msg.sender;\n    address private owner = msg.sender;\n\n    NodeIngress private ingressContract;\n\n\n\n    // struct size = 82 bytes\n    struct enode {\n        string enodeId;\n        string ip;\n        uint16 port;\n    }\n\n    enode[] public allowlist;\n    mapping (uint256 => uint256) private indexOf; //1-based indexing. 0 means non-existent\n\n    constructor (NodeIngress _ingressContract) public {\n        ingressContract = _ingressContract;\n    }\n\n    modifier onlyLatestVersion() {\n        require(msg.sender == latestVersion, \"only the latestVersion can modify the list\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (address(0) == address(ingressContract)) {\n            require(msg.sender == owner, \"only owner permitted since ingressContract is explicitly set to zero\");\n        } else {\n            address adminContractAddress = ingressContract.getContractAddress(ingressContract.ADMIN_CONTRACT());\n\n            require(adminContractAddress != address(0), \"Ingress contract must have Admin contract registered\");\n            require(Admin(adminContractAddress).isAuthorized(msg.sender), \"Sender not authorized\");\n        }\n        _;\n    }\n\n    function upgradeVersion(address _newVersion) public onlyAdmin {\n        emit VersionChange(latestVersion, _newVersion);\n        latestVersion = _newVersion;\n    }\n\n    function size() public view returns (uint256) {\n        return allowlist.length;\n    }\n\n    function exists(string memory _enodeId, string memory _ip, uint16 _port) public view returns (bool) {\n        return indexOf[calculateKey(_enodeId, _ip, _port)] != 0;\n    }\n\n    function add(string memory _enodeId, string memory _ip, uint16 _port) public onlyLatestVersion returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        if (indexOf[key] == 0) {\n            indexOf[key] = allowlist.push(enode(_enodeId, _ip, _port));\n            return true;\n        }\n        return false;\n    }\n\n    function remove(string memory _enodeId, string memory _ip, uint16 _port) public onlyLatestVersion returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        uint256 index = indexOf[key];\n\n        if (index > 0 && index <= allowlist.length) { //1 based indexing\n            //move last item into index being vacated (unless we are dealing with last index)\n            if (index != allowlist.length) {\n                enode memory lastEnode = allowlist[allowlist.length - 1];\n                allowlist[index - 1] = lastEnode;\n                indexOf[calculateKey(lastEnode.enodeId, lastEnode.ip, lastEnode.port)] = index;\n            }\n\n            //shrink array\n            allowlist.length -= 1; // mythx-disable-line SWC-101\n            indexOf[key] = 0;\n            return true;\n        }\n\n        return false;\n    }\n\n    function getByIndex(uint index) external view returns (string memory enodeId, string memory ip, uint16 port) {\n        if (index >= 0 && index < size()) {\n            enode memory item = allowlist[index];\n            return (item.enodeId, item.ip, item.port);\n        }\n    }\n\n    function calculateKey(string memory _enodeId, string memory _ip, uint16 _port) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(_enodeId, _ip, _port)));\n    }\n}", "flattened_code": "pragma solidity 0.5.9;\n\npragma solidity 0.5.9;\n\npragma solidity 0.5.9;\n\ninterface AdminProxy {\n    function isAuthorized(address source) external view returns (bool);\n}\npragma solidity 0.5.9;\n\n\n\ncontract AdminList {\n    event AdminAdded(\n        bool adminAdded,\n        address account,\n        string message\n    );\n\n    event AdminRemoved(\n        bool adminRemoved,\n        address account\n    );\n\n    address[] public allowlist;\n    mapping (address => uint256) private indexOf; //1 based indexing. 0 means non-existent\n\n    function size() internal view returns (uint256) {\n        return allowlist.length;\n    }\n\n    function exists(address _account) internal view returns (bool) {\n        return indexOf[_account] != 0;\n    }\n\n    function add(address _account) internal returns (bool) {\n        if (indexOf[_account] == 0) {\n            indexOf[_account] = allowlist.push(_account);\n            return true;\n        }\n        return false;\n    }\n\n    function addAll(address[] memory accounts) internal returns (bool) {\n        bool allAdded = true;\n        for (uint i = 0; i<accounts.length; i++) {\n            if (msg.sender == accounts[i]) {\n                emit AdminAdded(false, accounts[i], \"Adding own account as Admin is not permitted\");\n                allAdded = allAdded && false;\n            } else if (exists(accounts[i])) {\n                emit AdminAdded(false, accounts[i], \"Account is already an Admin\");\n                allAdded = allAdded && false;\n            }  else {\n                bool result = add(accounts[i]);\n                string memory message = result ? \"Admin account added successfully\" : \"Account is already an Admin\";\n                emit AdminAdded(result, accounts[i], message);\n                allAdded = allAdded && result;\n            }\n        }\n\n        return allAdded;\n    }\n\n    function remove(address _account) internal returns (bool) {\n        uint256 index = indexOf[_account];\n        if (index > 0 && index <= allowlist.length) { //1-based indexing\n            //move last address into index being vacated (unless we are dealing with last index)\n            if (index != allowlist.length) {\n                address lastAccount = allowlist[allowlist.length - 1];\n                allowlist[index - 1] = lastAccount;\n                indexOf[lastAccount] = index;\n            }\n\n            //shrink array\n            allowlist.length -= 1; // mythx-disable-line SWC-101\n            indexOf[_account] = 0;\n            return true;\n        }\n        return false;\n    }\n}\n\n\ncontract Admin is AdminProxy, AdminList {\n    modifier onlyAdmin() {\n        require(isAuthorized(msg.sender), \"Sender not authorized\");\n        _;\n    }\n\n    modifier notSelf(address _address) {\n        require(msg.sender != _address, \"Cannot invoke method with own account as parameter\");\n        _;\n    }\n\n    constructor() public {\n        add(msg.sender);\n    }\n\n    function isAuthorized(address _address) public view returns (bool) {\n        return exists(_address);\n    }\n\n    function addAdmin(address _address) external onlyAdmin returns (bool) {\n        if (msg.sender == _address) {\n            emit AdminAdded(false, _address, \"Adding own account as Admin is not permitted\");\n            return false;\n        } else {\n            bool result = add(_address);\n            string memory message = result ? \"Admin account added successfully\" : \"Account is already an Admin\";\n            emit AdminAdded(result, _address, message);\n            return result;\n        }\n    }\n\n    function removeAdmin(address _address) external onlyAdmin notSelf(_address) returns (bool) {\n        bool removed = remove(_address);\n        emit AdminRemoved(removed, _address);\n        return removed;\n    }\n\n    function getAdmins() external view returns (address[] memory){\n        return allowlist; // mythx-disable-line SWC-128\n    }\n\n    function addAdmins(address[] calldata accounts) external onlyAdmin returns (bool) {\n        return addAll(accounts);\n    }\n}\npragma solidity 0.5.9;\n\npragma solidity 0.5.9;\n\ninterface NodeRulesProxy {\n    function connectionAllowed(\n        string calldata enodeId,\n        string calldata enodeHost,\n        uint16 enodePort\n    ) external view returns (bool);\n}\npragma solidity 0.5.9;\n\n\n\ncontract Ingress {\n    // Contract keys\n    bytes32 public RULES_CONTRACT = 0x72756c6573000000000000000000000000000000000000000000000000000000; // \"rules\"\n    bytes32 public ADMIN_CONTRACT = 0x61646d696e697374726174696f6e000000000000000000000000000000000000; // \"administration\"\n\n    // Registry mapping indexing\n    mapping(bytes32 => address) internal registry;\n\n    bytes32[] internal contractKeys;\n    mapping (bytes32 => uint256) internal indexOf; //1 based indexing. 0 means non-existent\n\n    event RegistryUpdated(\n        address contractAddress,\n        bytes32 contractName\n    );\n\n    function getContractAddress(bytes32 name) public view returns(address) {\n        require(name > 0, \"Contract name must not be empty.\");\n        return registry[name];\n    }\n\n    function getSize() external view returns (uint256) {\n        return contractKeys.length;\n    }\n\n    function isAuthorized(address account) public view returns(bool) {\n        if (registry[ADMIN_CONTRACT] == address(0)) {\n            return true;\n        } else {\n            return AdminProxy(registry[ADMIN_CONTRACT]).isAuthorized(account);\n        }\n    }\n\n    function setContractAddress(bytes32 name, address addr) external returns (bool) {\n        require(name > 0, \"Contract name must not be empty.\");\n        require(addr != address(0), \"Contract address must not be zero.\");\n        require(isAuthorized(msg.sender), \"Not authorized to update contract registry.\");\n\n        if (indexOf[name] == 0) {\n            indexOf[name] = contractKeys.push(name);\n        }\n\n        registry[name] = addr;\n\n        emit RegistryUpdated(addr, name);\n\n        return true;\n    }\n\n    function removeContract(bytes32 _name) external returns(bool) {\n        require(_name > 0, \"Contract name must not be empty.\");\n        require(contractKeys.length > 0, \"Must have at least one registered contract to execute delete operation.\");\n        require(isAuthorized(msg.sender), \"Not authorized to update contract registry.\");\n\n        uint256 index = indexOf[_name];\n        if (index > 0 && index <= contractKeys.length) { //1-based indexing\n            //move last address into index being vacated (unless we are dealing with last index)\n            if (index != contractKeys.length) {\n                bytes32 lastKey = contractKeys[contractKeys.length - 1];\n                contractKeys[index - 1] = lastKey;\n                indexOf[lastKey] = index;\n            }\n\n            //shrink contract keys array\n            contractKeys.pop();\n            indexOf[_name] = 0;\n            registry[_name] = address(0);\n            emit RegistryUpdated(address(0), _name);\n            return true;\n        }\n        return false;\n    }\n\n    function getAllContractKeys() external view returns(bytes32[] memory) {\n        return contractKeys; // mythx-disable-line SWC-128\n    }\n}\n\n\ncontract NodeIngress is Ingress {\n    // version of this contract: semver eg 1.2.14 represented like 001002014\n    uint private version = 1000000;\n\n    event NodePermissionsUpdated(\n        bool addsRestrictions\n    );\n\n    function getContractVersion() external view returns(uint) {\n        return version;\n    }\n\n    function emitRulesChangeEvent(bool addsRestrictions) external {\n        require(registry[RULES_CONTRACT] == msg.sender, \"Only Rules contract can trigger Rules change events\");\n        emit NodePermissionsUpdated(addsRestrictions);\n    }\n\n    function connectionAllowed(\n        string calldata enodeId,\n        string calldata enodeHost,\n        uint16 enodePort\n    ) external view returns (bool) {\n        if(getContractAddress(RULES_CONTRACT) == address(0)) {\n            return false;\n        }\n\n        return NodeRulesProxy(registry[RULES_CONTRACT]).connectionAllowed(\n            enodeId,\n            enodeHost,\n            enodePort\n        );\n    }\n}\n\n\ncontract NodeStorage {\n    event VersionChange(\n        address oldAddress,\n        address newAddress\n    );\n    // initialize this to the deployer of this contract\n    address private latestVersion = msg.sender;\n    address private owner = msg.sender;\n\n    NodeIngress private ingressContract;\n\n\n\n    // struct size = 82 bytes\n    struct enode {\n        string enodeId;\n        string ip;\n        uint16 port;\n    }\n\n    enode[] public allowlist;\n    mapping (uint256 => uint256) private indexOf; //1-based indexing. 0 means non-existent\n\n    constructor (NodeIngress _ingressContract) public {\n        ingressContract = _ingressContract;\n    }\n\n    modifier onlyLatestVersion() {\n        require(msg.sender == latestVersion, \"only the latestVersion can modify the list\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        if (address(0) == address(ingressContract)) {\n            require(msg.sender == owner, \"only owner permitted since ingressContract is explicitly set to zero\");\n        } else {\n            address adminContractAddress = ingressContract.getContractAddress(ingressContract.ADMIN_CONTRACT());\n\n            require(adminContractAddress != address(0), \"Ingress contract must have Admin contract registered\");\n            require(Admin(adminContractAddress).isAuthorized(msg.sender), \"Sender not authorized\");\n        }\n        _;\n    }\n\n    function upgradeVersion(address _newVersion) public onlyAdmin {\n        emit VersionChange(latestVersion, _newVersion);\n        latestVersion = _newVersion;\n    }\n\n    function size() public view returns (uint256) {\n        return allowlist.length;\n    }\n\n    function exists(string memory _enodeId, string memory _ip, uint16 _port) public view returns (bool) {\n        return indexOf[calculateKey(_enodeId, _ip, _port)] != 0;\n    }\n\n    function add(string memory _enodeId, string memory _ip, uint16 _port) public onlyLatestVersion returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        if (indexOf[key] == 0) {\n            indexOf[key] = allowlist.push(enode(_enodeId, _ip, _port));\n            return true;\n        }\n        return false;\n    }\n\n    function remove(string memory _enodeId, string memory _ip, uint16 _port) public onlyLatestVersion returns (bool) {\n        uint256 key = calculateKey(_enodeId, _ip, _port);\n        uint256 index = indexOf[key];\n\n        if (index > 0 && index <= allowlist.length) { //1 based indexing\n            //move last item into index being vacated (unless we are dealing with last index)\n            if (index != allowlist.length) {\n                enode memory lastEnode = allowlist[allowlist.length - 1];\n                allowlist[index - 1] = lastEnode;\n                indexOf[calculateKey(lastEnode.enodeId, lastEnode.ip, lastEnode.port)] = index;\n            }\n\n            //shrink array\n            allowlist.length -= 1; // mythx-disable-line SWC-101\n            indexOf[key] = 0;\n            return true;\n        }\n\n        return false;\n    }\n\n    function getByIndex(uint index) external view returns (string memory enodeId, string memory ip, uint16 port) {\n        if (index >= 0 && index < size()) {\n            enode memory item = allowlist[index];\n            return (item.enodeId, item.ip, item.port);\n        }\n    }\n\n    function calculateKey(string memory _enodeId, string memory _ip, uint16 _port) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(_enodeId, _ip, _port)));\n    }\n}\n", "commit_id": "15cf31b28452ddfb6c33eb5e127c804d88865782"}}