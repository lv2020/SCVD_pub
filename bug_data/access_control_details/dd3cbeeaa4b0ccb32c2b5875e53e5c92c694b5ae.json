{"filename": "contracts/LemoCoin.sol", "patch": "@@ -200,7 +200,7 @@ contract FreezerAuthority is DSAuthority {\n \n     function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n         // freezer can call setFreezing, transferAndFreezing\n-        if (isFreezer(caller) && sig == setFreezingSig || sig == transferAndFreezingSig) {\n+        if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) {\n             return true;\n         } else {\n             return false;", "project_link": "https://github.com/LemoFoundationLtd/lemo-contracts/commit/dd3cbeeaa4b0ccb32c2b5875e53e5c92c694b5ae", "bug_version": {"raw_code": "pragma solidity ^0.4.23;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n    public\n    auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n    public\n    auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed sig,\n        address  indexed guy,\n        bytes32  indexed foo,\n        bytes32  indexed bar,\n        uint wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n\n    function start() public auth note {\n        stopped = false;\n    }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n}\n\ncontract ERC20 {\n    /// @return total amount of tokens\n    function totalSupply() constant public returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant public returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract Coin is ERC20, DSStop {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 internal c_totalSupply;\n    mapping(address => uint256) internal c_balances;\n    mapping(address => mapping(address => uint256)) internal c_approvals;\n\n    function init(uint256 token_supply, string token_name, string token_symbol) internal {\n        c_balances[msg.sender] = token_supply;\n        c_totalSupply = token_supply;\n        name = token_name;\n        symbol = token_symbol;\n    }\n\n    function() public {\n        assert(false);\n    }\n\n    function setName(string _name) auth public {\n        name = _name;\n    }\n\n    function totalSupply() constant public returns (uint256) {\n        return c_totalSupply;\n    }\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return c_balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public stoppable returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n\n        c_approvals[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return c_approvals[_owner][_spender];\n    }\n}\n\ncontract FreezerAuthority is DSAuthority {\n    address[] internal c_freezers;\n    // sha3(\"setFreezing(address,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);\n    // sha3(\"transferAndFreezing(address,uint256,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);\n\n    function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n        // freezer can call setFreezing, transferAndFreezing\n        if (isFreezer(caller) && sig == setFreezingSig || sig == transferAndFreezingSig) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function addFreezer(address freezer) public {\n        int i = indexOf(c_freezers, freezer);\n        if (i < 0) {\n            c_freezers.push(freezer);\n        }\n    }\n\n    function removeFreezer(address freezer) public {\n        int index = indexOf(c_freezers, freezer);\n        if (index >= 0) {\n            uint i = uint(index);\n            while (i < c_freezers.length - 1) {\n                c_freezers[i] = c_freezers[i + 1];\n            }\n            c_freezers.length--;\n        }\n    }\n\n    /** Finds the index of a given value in an array. */\n    function indexOf(address[] values, address value) internal pure returns (int) {\n        uint i = 0;\n        while (i < values.length) {\n            if (values[i] == value) {\n                return int(i);\n            }\n            i++;\n        }\n        return int(- 1);\n    }\n\n    function isFreezer(address addr) public constant returns (bool) {\n        return indexOf(c_freezers, addr) >= 0;\n    }\n}\n\ncontract LemoCoin is Coin, DSMath {\n    // freezing struct\n    struct FreezingNode {\n        uint end_stamp;\n        uint num_lemos;\n        uint8 freezing_type;\n    }\n\n    // freezing account list\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n\n    constructor(uint256 token_supply, string token_name, string token_symbol) public {\n        init(token_supply, token_name, token_symbol);\n        setAuthority(new FreezerAuthority());\n    }\n\n    function addFreezer(address freezer) auth public {\n        FreezerAuthority(authority).addFreezer(freezer);\n    }\n\n    function removeFreezer(address freezer) auth public {\n        FreezerAuthority(authority).removeFreezer(freezer);\n    }\n\n    event ClearExpiredFreezingEvent(address indexed addr);\n    event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lemos, uint8 indexed freezing_type);\n\n    function clearExpiredFreezing(address addr) public {\n        FreezingNode[] storage nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n\n        // find first expired index\n        uint left = 0;\n        while (left < length) {\n            // not freezing any more\n            if (nodes[left].end_stamp <= block.timestamp) {\n                break;\n            }\n            left++;\n        }\n\n        // next frozen index\n        uint right = left + 1;\n        while (left < length && right < length) {\n            // still freezing\n            if (nodes[right].end_stamp > block.timestamp) {\n                nodes[left] = nodes[right];\n                left++;\n            }\n            right++;\n        }\n        if (length != left) {\n            nodes.length = left;\n            emit ClearExpiredFreezingEvent(addr);\n        }\n    }\n\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n        uint total_lemos = balanceOf(addr);\n\n        for (uint i = 0; i < length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_lemos = sub(total_lemos, nodes[i].num_lemos);\n            }\n        }\n\n        return total_lemos;\n    }\n\n    function freezingBalanceNumberOf(address addr) constant public returns (uint) {\n        return c_freezing_list[addr].length;\n    }\n\n    function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));\n    }\n\n    function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {\n        require(block.timestamp < end_stamp);\n        // uint never less than 0. The negative number will become to a big positive number\n        require(num_lemos < c_totalSupply);\n        clearExpiredFreezing(addr);\n        uint valid_balance = validBalanceOf(addr);\n        require(valid_balance >= num_lemos);\n\n        FreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);\n        c_freezing_list[addr].push(node);\n\n        emit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);\n    }\n\n    function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(freeze_amount <= _value);\n\n        transfer(_to, _value);\n        setFreezing(_to, end_stamp, freeze_amount, freezing_type);\n\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        clearExpiredFreezing(msg.sender);\n        uint from_lemos = validBalanceOf(msg.sender);\n\n        require(from_lemos >= _value);\n\n        c_balances[msg.sender] = sub(c_balances[msg.sender], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(c_approvals[_from][msg.sender] >= _value);\n\n        clearExpiredFreezing(_from);\n        uint from_lemos = validBalanceOf(_from);\n\n        require(from_lemos >= _value);\n\n        c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);\n        c_balances[_from] = sub(c_balances[_from], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n    public\n    auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n    public\n    auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed sig,\n        address  indexed guy,\n        bytes32  indexed foo,\n        bytes32  indexed bar,\n        uint wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n\n    function start() public auth note {\n        stopped = false;\n    }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n}\n\ncontract ERC20 {\n    /// @return total amount of tokens\n    function totalSupply() constant public returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant public returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract Coin is ERC20, DSStop {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 internal c_totalSupply;\n    mapping(address => uint256) internal c_balances;\n    mapping(address => mapping(address => uint256)) internal c_approvals;\n\n    function init(uint256 token_supply, string token_name, string token_symbol) internal {\n        c_balances[msg.sender] = token_supply;\n        c_totalSupply = token_supply;\n        name = token_name;\n        symbol = token_symbol;\n    }\n\n    function() public {\n        assert(false);\n    }\n\n    function setName(string _name) auth public {\n        name = _name;\n    }\n\n    function totalSupply() constant public returns (uint256) {\n        return c_totalSupply;\n    }\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return c_balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public stoppable returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n\n        c_approvals[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return c_approvals[_owner][_spender];\n    }\n}\n\ncontract FreezerAuthority is DSAuthority {\n    address[] internal c_freezers;\n    // sha3(\"setFreezing(address,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);\n    // sha3(\"transferAndFreezing(address,uint256,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);\n\n    function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n        // freezer can call setFreezing, transferAndFreezing\n        if (isFreezer(caller) && sig == setFreezingSig || sig == transferAndFreezingSig) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function addFreezer(address freezer) public {\n        int i = indexOf(c_freezers, freezer);\n        if (i < 0) {\n            c_freezers.push(freezer);\n        }\n    }\n\n    function removeFreezer(address freezer) public {\n        int index = indexOf(c_freezers, freezer);\n        if (index >= 0) {\n            uint i = uint(index);\n            while (i < c_freezers.length - 1) {\n                c_freezers[i] = c_freezers[i + 1];\n            }\n            c_freezers.length--;\n        }\n    }\n\n    /** Finds the index of a given value in an array. */\n    function indexOf(address[] values, address value) internal pure returns (int) {\n        uint i = 0;\n        while (i < values.length) {\n            if (values[i] == value) {\n                return int(i);\n            }\n            i++;\n        }\n        return int(- 1);\n    }\n\n    function isFreezer(address addr) public constant returns (bool) {\n        return indexOf(c_freezers, addr) >= 0;\n    }\n}\n\ncontract LemoCoin is Coin, DSMath {\n    // freezing struct\n    struct FreezingNode {\n        uint end_stamp;\n        uint num_lemos;\n        uint8 freezing_type;\n    }\n\n    // freezing account list\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n\n    constructor(uint256 token_supply, string token_name, string token_symbol) public {\n        init(token_supply, token_name, token_symbol);\n        setAuthority(new FreezerAuthority());\n    }\n\n    function addFreezer(address freezer) auth public {\n        FreezerAuthority(authority).addFreezer(freezer);\n    }\n\n    function removeFreezer(address freezer) auth public {\n        FreezerAuthority(authority).removeFreezer(freezer);\n    }\n\n    event ClearExpiredFreezingEvent(address indexed addr);\n    event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lemos, uint8 indexed freezing_type);\n\n    function clearExpiredFreezing(address addr) public {\n        FreezingNode[] storage nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n\n        // find first expired index\n        uint left = 0;\n        while (left < length) {\n            // not freezing any more\n            if (nodes[left].end_stamp <= block.timestamp) {\n                break;\n            }\n            left++;\n        }\n\n        // next frozen index\n        uint right = left + 1;\n        while (left < length && right < length) {\n            // still freezing\n            if (nodes[right].end_stamp > block.timestamp) {\n                nodes[left] = nodes[right];\n                left++;\n            }\n            right++;\n        }\n        if (length != left) {\n            nodes.length = left;\n            emit ClearExpiredFreezingEvent(addr);\n        }\n    }\n\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n        uint total_lemos = balanceOf(addr);\n\n        for (uint i = 0; i < length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_lemos = sub(total_lemos, nodes[i].num_lemos);\n            }\n        }\n\n        return total_lemos;\n    }\n\n    function freezingBalanceNumberOf(address addr) constant public returns (uint) {\n        return c_freezing_list[addr].length;\n    }\n\n    function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));\n    }\n\n    function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {\n        require(block.timestamp < end_stamp);\n        // uint never less than 0. The negative number will become to a big positive number\n        require(num_lemos < c_totalSupply);\n        clearExpiredFreezing(addr);\n        uint valid_balance = validBalanceOf(addr);\n        require(valid_balance >= num_lemos);\n\n        FreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);\n        c_freezing_list[addr].push(node);\n\n        emit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);\n    }\n\n    function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(freeze_amount <= _value);\n\n        transfer(_to, _value);\n        setFreezing(_to, end_stamp, freeze_amount, freezing_type);\n\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        clearExpiredFreezing(msg.sender);\n        uint from_lemos = validBalanceOf(msg.sender);\n\n        require(from_lemos >= _value);\n\n        c_balances[msg.sender] = sub(c_balances[msg.sender], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(c_approvals[_from][msg.sender] >= _value);\n\n        clearExpiredFreezing(_from);\n        uint from_lemos = validBalanceOf(_from);\n\n        require(from_lemos >= _value);\n\n        c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);\n        c_balances[_from] = sub(c_balances[_from], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n", "commit_id": "ac184a8466538ad9e960faaa8b6e48d27ebed48b"}, "fixed_version": {"raw_code": "pragma solidity ^0.4.23;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n    public\n    auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n    public\n    auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed sig,\n        address  indexed guy,\n        bytes32  indexed foo,\n        bytes32  indexed bar,\n        uint wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n\n    function start() public auth note {\n        stopped = false;\n    }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n}\n\ncontract ERC20 {\n    /// @return total amount of tokens\n    function totalSupply() constant public returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant public returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract Coin is ERC20, DSStop {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 internal c_totalSupply;\n    mapping(address => uint256) internal c_balances;\n    mapping(address => mapping(address => uint256)) internal c_approvals;\n\n    function init(uint256 token_supply, string token_name, string token_symbol) internal {\n        c_balances[msg.sender] = token_supply;\n        c_totalSupply = token_supply;\n        name = token_name;\n        symbol = token_symbol;\n    }\n\n    function() public {\n        assert(false);\n    }\n\n    function setName(string _name) auth public {\n        name = _name;\n    }\n\n    function totalSupply() constant public returns (uint256) {\n        return c_totalSupply;\n    }\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return c_balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public stoppable returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n\n        c_approvals[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return c_approvals[_owner][_spender];\n    }\n}\n\ncontract FreezerAuthority is DSAuthority {\n    address[] internal c_freezers;\n    // sha3(\"setFreezing(address,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);\n    // sha3(\"transferAndFreezing(address,uint256,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);\n\n    function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n        // freezer can call setFreezing, transferAndFreezing\n        if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function addFreezer(address freezer) public {\n        int i = indexOf(c_freezers, freezer);\n        if (i < 0) {\n            c_freezers.push(freezer);\n        }\n    }\n\n    function removeFreezer(address freezer) public {\n        int index = indexOf(c_freezers, freezer);\n        if (index >= 0) {\n            uint i = uint(index);\n            while (i < c_freezers.length - 1) {\n                c_freezers[i] = c_freezers[i + 1];\n            }\n            c_freezers.length--;\n        }\n    }\n\n    /** Finds the index of a given value in an array. */\n    function indexOf(address[] values, address value) internal pure returns (int) {\n        uint i = 0;\n        while (i < values.length) {\n            if (values[i] == value) {\n                return int(i);\n            }\n            i++;\n        }\n        return int(- 1);\n    }\n\n    function isFreezer(address addr) public constant returns (bool) {\n        return indexOf(c_freezers, addr) >= 0;\n    }\n}\n\ncontract LemoCoin is Coin, DSMath {\n    // freezing struct\n    struct FreezingNode {\n        uint end_stamp;\n        uint num_lemos;\n        uint8 freezing_type;\n    }\n\n    // freezing account list\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n\n    constructor(uint256 token_supply, string token_name, string token_symbol) public {\n        init(token_supply, token_name, token_symbol);\n        setAuthority(new FreezerAuthority());\n    }\n\n    function addFreezer(address freezer) auth public {\n        FreezerAuthority(authority).addFreezer(freezer);\n    }\n\n    function removeFreezer(address freezer) auth public {\n        FreezerAuthority(authority).removeFreezer(freezer);\n    }\n\n    event ClearExpiredFreezingEvent(address indexed addr);\n    event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lemos, uint8 indexed freezing_type);\n\n    function clearExpiredFreezing(address addr) public {\n        FreezingNode[] storage nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n\n        // find first expired index\n        uint left = 0;\n        while (left < length) {\n            // not freezing any more\n            if (nodes[left].end_stamp <= block.timestamp) {\n                break;\n            }\n            left++;\n        }\n\n        // next frozen index\n        uint right = left + 1;\n        while (left < length && right < length) {\n            // still freezing\n            if (nodes[right].end_stamp > block.timestamp) {\n                nodes[left] = nodes[right];\n                left++;\n            }\n            right++;\n        }\n        if (length != left) {\n            nodes.length = left;\n            emit ClearExpiredFreezingEvent(addr);\n        }\n    }\n\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n        uint total_lemos = balanceOf(addr);\n\n        for (uint i = 0; i < length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_lemos = sub(total_lemos, nodes[i].num_lemos);\n            }\n        }\n\n        return total_lemos;\n    }\n\n    function freezingBalanceNumberOf(address addr) constant public returns (uint) {\n        return c_freezing_list[addr].length;\n    }\n\n    function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));\n    }\n\n    function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {\n        require(block.timestamp < end_stamp);\n        // uint never less than 0. The negative number will become to a big positive number\n        require(num_lemos < c_totalSupply);\n        clearExpiredFreezing(addr);\n        uint valid_balance = validBalanceOf(addr);\n        require(valid_balance >= num_lemos);\n\n        FreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);\n        c_freezing_list[addr].push(node);\n\n        emit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);\n    }\n\n    function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(freeze_amount <= _value);\n\n        transfer(_to, _value);\n        setFreezing(_to, end_stamp, freeze_amount, freezing_type);\n\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        clearExpiredFreezing(msg.sender);\n        uint from_lemos = validBalanceOf(msg.sender);\n\n        require(from_lemos >= _value);\n\n        c_balances[msg.sender] = sub(c_balances[msg.sender], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(c_approvals[_from][msg.sender] >= _value);\n\n        clearExpiredFreezing(_from);\n        uint from_lemos = validBalanceOf(_from);\n\n        require(from_lemos >= _value);\n\n        c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);\n        c_balances[_from] = sub(c_balances[_from], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n", "flattened_code": "pragma solidity ^0.4.23;\n\ncontract DSAuthority {\n    function canCall(\n        address src, address dst, bytes4 sig\n    ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n    event LogSetAuthority (address indexed authority);\n    event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n    DSAuthority  public  authority;\n    address      public  owner;\n\n    constructor() public {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_)\n    public\n    auth\n    {\n        owner = owner_;\n        emit LogSetOwner(owner);\n    }\n\n    function setAuthority(DSAuthority authority_)\n    public\n    auth\n    {\n        authority = authority_;\n        emit LogSetAuthority(authority);\n    }\n\n    modifier auth {\n        require(isAuthorized(msg.sender, msg.sig));\n        _;\n    }\n\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n        if (src == address(this)) {\n            return true;\n        } else if (src == owner) {\n            return true;\n        } else if (authority == DSAuthority(0)) {\n            return false;\n        } else {\n            return authority.canCall(src, this, sig);\n        }\n    }\n}\n\ncontract DSNote {\n    event LogNote(\n        bytes4   indexed sig,\n        address  indexed guy,\n        bytes32  indexed foo,\n        bytes32  indexed bar,\n        uint wad,\n        bytes fax\n    ) anonymous;\n\n    modifier note {\n        bytes32 foo;\n        bytes32 bar;\n\n        assembly {\n            foo := calldataload(4)\n            bar := calldataload(36)\n        }\n\n        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n\n        _;\n    }\n}\n\ncontract DSStop is DSNote, DSAuth {\n    bool public stopped;\n\n    modifier stoppable {\n        require(!stopped);\n        _;\n    }\n    function stop() public auth note {\n        stopped = true;\n    }\n\n    function start() public auth note {\n        stopped = false;\n    }\n}\n\ncontract DSMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x);\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x);\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x);\n    }\n}\n\ncontract ERC20 {\n    /// @return total amount of tokens\n    function totalSupply() constant public returns (uint256 supply);\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant public returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\ncontract Coin is ERC20, DSStop {\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 internal c_totalSupply;\n    mapping(address => uint256) internal c_balances;\n    mapping(address => mapping(address => uint256)) internal c_approvals;\n\n    function init(uint256 token_supply, string token_name, string token_symbol) internal {\n        c_balances[msg.sender] = token_supply;\n        c_totalSupply = token_supply;\n        name = token_name;\n        symbol = token_symbol;\n    }\n\n    function() public {\n        assert(false);\n    }\n\n    function setName(string _name) auth public {\n        name = _name;\n    }\n\n    function totalSupply() constant public returns (uint256) {\n        return c_totalSupply;\n    }\n\n    function balanceOf(address _owner) constant public returns (uint256) {\n        return c_balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public stoppable returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n\n        c_approvals[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant public returns (uint256) {\n        return c_approvals[_owner][_spender];\n    }\n}\n\ncontract FreezerAuthority is DSAuthority {\n    address[] internal c_freezers;\n    // sha3(\"setFreezing(address,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant setFreezingSig = bytes4(0x51c3b8a6);\n    // sha3(\"transferAndFreezing(address,uint256,uint256,uint256,uint8)\").slice(0,10)\n    bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6);\n\n    function canCall(address caller, address, bytes4 sig) public view returns (bool) {\n        // freezer can call setFreezing, transferAndFreezing\n        if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function addFreezer(address freezer) public {\n        int i = indexOf(c_freezers, freezer);\n        if (i < 0) {\n            c_freezers.push(freezer);\n        }\n    }\n\n    function removeFreezer(address freezer) public {\n        int index = indexOf(c_freezers, freezer);\n        if (index >= 0) {\n            uint i = uint(index);\n            while (i < c_freezers.length - 1) {\n                c_freezers[i] = c_freezers[i + 1];\n            }\n            c_freezers.length--;\n        }\n    }\n\n    /** Finds the index of a given value in an array. */\n    function indexOf(address[] values, address value) internal pure returns (int) {\n        uint i = 0;\n        while (i < values.length) {\n            if (values[i] == value) {\n                return int(i);\n            }\n            i++;\n        }\n        return int(- 1);\n    }\n\n    function isFreezer(address addr) public constant returns (bool) {\n        return indexOf(c_freezers, addr) >= 0;\n    }\n}\n\ncontract LemoCoin is Coin, DSMath {\n    // freezing struct\n    struct FreezingNode {\n        uint end_stamp;\n        uint num_lemos;\n        uint8 freezing_type;\n    }\n\n    // freezing account list\n    mapping(address => FreezingNode[]) internal c_freezing_list;\n\n    constructor(uint256 token_supply, string token_name, string token_symbol) public {\n        init(token_supply, token_name, token_symbol);\n        setAuthority(new FreezerAuthority());\n    }\n\n    function addFreezer(address freezer) auth public {\n        FreezerAuthority(authority).addFreezer(freezer);\n    }\n\n    function removeFreezer(address freezer) auth public {\n        FreezerAuthority(authority).removeFreezer(freezer);\n    }\n\n    event ClearExpiredFreezingEvent(address indexed addr);\n    event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lemos, uint8 indexed freezing_type);\n\n    function clearExpiredFreezing(address addr) public {\n        FreezingNode[] storage nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n\n        // find first expired index\n        uint left = 0;\n        while (left < length) {\n            // not freezing any more\n            if (nodes[left].end_stamp <= block.timestamp) {\n                break;\n            }\n            left++;\n        }\n\n        // next frozen index\n        uint right = left + 1;\n        while (left < length && right < length) {\n            // still freezing\n            if (nodes[right].end_stamp > block.timestamp) {\n                nodes[left] = nodes[right];\n                left++;\n            }\n            right++;\n        }\n        if (length != left) {\n            nodes.length = left;\n            emit ClearExpiredFreezingEvent(addr);\n        }\n    }\n\n    function validBalanceOf(address addr) constant public returns (uint) {\n        FreezingNode[] memory nodes = c_freezing_list[addr];\n        uint length = nodes.length;\n        uint total_lemos = balanceOf(addr);\n\n        for (uint i = 0; i < length; ++i) {\n            if (nodes[i].end_stamp > block.timestamp) {\n                total_lemos = sub(total_lemos, nodes[i].num_lemos);\n            }\n        }\n\n        return total_lemos;\n    }\n\n    function freezingBalanceNumberOf(address addr) constant public returns (uint) {\n        return c_freezing_list[addr].length;\n    }\n\n    function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) {\n        return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lemos, uint8(c_freezing_list[addr][index].freezing_type));\n    }\n\n    function setFreezing(address addr, uint end_stamp, uint num_lemos, uint8 freezing_type) auth stoppable public {\n        require(block.timestamp < end_stamp);\n        // uint never less than 0. The negative number will become to a big positive number\n        require(num_lemos < c_totalSupply);\n        clearExpiredFreezing(addr);\n        uint valid_balance = validBalanceOf(addr);\n        require(valid_balance >= num_lemos);\n\n        FreezingNode memory node = FreezingNode(end_stamp, num_lemos, freezing_type);\n        c_freezing_list[addr].push(node);\n\n        emit SetFreezingEvent(addr, end_stamp, num_lemos, freezing_type);\n    }\n\n    function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(freeze_amount <= _value);\n\n        transfer(_to, _value);\n        setFreezing(_to, end_stamp, freeze_amount, freezing_type);\n\n        return true;\n    }\n\n    function transfer(address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        clearExpiredFreezing(msg.sender);\n        uint from_lemos = validBalanceOf(msg.sender);\n\n        require(from_lemos >= _value);\n\n        c_balances[msg.sender] = sub(c_balances[msg.sender], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) {\n        // uint never less than 0. The negative number will become to a big positive number\n        require(_value < c_totalSupply);\n        require(c_approvals[_from][msg.sender] >= _value);\n\n        clearExpiredFreezing(_from);\n        uint from_lemos = validBalanceOf(_from);\n\n        require(from_lemos >= _value);\n\n        c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value);\n        c_balances[_from] = sub(c_balances[_from], _value);\n        c_balances[_to] = add(c_balances[_to], _value);\n\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}\n", "commit_id": "dd3cbeeaa4b0ccb32c2b5875e53e5c92c694b5ae"}}