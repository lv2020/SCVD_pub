{"filename": "contracts/Tree.sol", "patch": "@@ -12,7 +12,6 @@ contract Tree{\n     bytes8[3] mtypes = [ bytes8(\"Node\"), bytes8(\"Section\"), bytes8(\"Index\")]; //Increase type to match structure types\n     enum ltypes {Node,Section,Index} //Increase type to match structure types\n \n-\n     uint parent_max_size = 10; //Max size for all parents equaling Max nodes = parent_max_size^(max_depth-1)\n \n     function TreeContract(){\n@@ -125,7 +124,7 @@ contract Tree{\n           return results;\n     }\n \n-    function removeSection(bytes32 index_id,bytes32 section_id) idNotEmpty(section_id){\n+    function removeSection(bytes32 index_id,bytes32 section_id) internal idNotEmpty(section_id){\n       assert(getParent(section_id) == index_id);\n       TreeLib.Index storage index = indexes[index_id];\n       delete(parent_child_lookup[section_id]);\n@@ -144,19 +143,19 @@ contract Tree{\n       removeSection(index_id,section_id);\n     }\n \n-    function generateSection() returns (bytes32 section_id){\n+    function generateSection() internal constant returns (bytes32 section_id){\n       uint i = 0;\n       while(childExists(sha3(block.difficulty+i,block.number+i,block.timestamp+1))){\n         i++;\n       }\n       return sha3(block.difficulty+i,block.number+i,block.timestamp+1);\n     }\n \n-    function newIndex(bytes32 index_id)idNotEmpty(index_id){\n+    function newIndex(bytes32 index_id) internal idNotEmpty(index_id){\n         indexes[index_id] = TreeLib.newIndex(index_id,parent_max_size);\n     }\n \n-    function insertSection(bytes32 parent_id) returns(bytes32){\n+    function insertSection(bytes32 parent_id) internal returns(bytes32){\n         //Create new index, if it does not exist\n         if(!indexExists(parent_id))\n           newIndex(parent_id);", "project_link": "https://github.com/adibas03/solidity-data-tree/commit/5d1fbeb098196f0e6f14b7b6a79d445d2199583a", "bug_version": {"raw_code": "pragma solidity^0.4.11;\n\nimport \"../libraries/TreeLib.sol\";\n\ncontract Tree{\n\n    mapping(bytes32=>TreeLib.Index) indexes;//Or a single index, based on how you want to arange your indexes\n    mapping(bytes32=>bytes32) parent_child_lookup;\n\n    uint max_depth=2; // Maxdepth of the tree; advised 5\n    uint mtypes_count=3;//Count of mtypes,available structure types from the lib\n    bytes8[3] mtypes = [ bytes8(\"Node\"), bytes8(\"Section\"), bytes8(\"Index\")]; //Increase type to match structure types\n    enum ltypes {Node,Section,Index} //Increase type to match structure types\n\n\n    uint parent_max_size = 10; //Max size for all parents equaling Max nodes = parent_max_size^(max_depth-1)\n\n    function TreeContract(){\n    }\n\n    function indexExists(bytes32 index_id) constant returns (bool){\n        return (indexes[index_id].id == index_id);\n    }\n\n    function childExists(bytes32 child_id) constant returns(bool){\n        return (getParent(child_id) != 0x0);\n    }\n\n    function nodeExists(bytes32 index_id,bytes32 node_id) constant returns(bool){\n        if(childExists(node_id) ){\n          return getHeirachy(node_id)[1] == index_id;\n        }\n        return false;\n    }\n\n    function getParent(bytes32 child_id) constant returns(bytes32){\n        return parent_child_lookup[child_id];\n    }\n\n    function getHeirachy(bytes32 child_id) constant returns (bytes32[2] memory search_up /*should match (max_depth)*/){\n        bytes32 main_index_id;\n\n        //Fetch the node's parent\n        main_index_id = getParent(child_id);\n        search_up[0] = main_index_id;\n\n        uint i = 1;\n        while((main_index_id = getParent(main_index_id)) != 0x0){\n        search_up[i] = main_index_id;\n        i++;\n        }\n    }\n\n    function nextSection(bytes32 index_id) internal constant returns (bytes32 id){\n      //get the next available section in the index\n      TreeLib.Index storage index = indexes[index_id];\n      id = indexes[index_id].root;\n      while(true){\n        if(index.children[id].size+1 > index.maxsize && index.children[id].id != 0x0){\n          id = index.children[id].right;\n          continue;\n        }\n        else break;\n      }\n      return id;\n    }\n\n    function getSection(bytes32 section_id) internal constant returns(TreeLib.Section storage sector){\n        bytes32[2] memory search_up; //size should match (max_depth)\n        search_up = getHeirachy(section_id);\n\n        //GenecricTree.SubSection storage subsector; //Only enabled if max_dept >2\n        //Structure based on sector parent being index\n        if(search_up.length>0){\n          sector = indexes[search_up[0]].children[section_id];\n        }\n    }\n\n    function getIndex(bytes32 index_id)constant returns(uint mtype,uint size, uint maxsize, bytes32 id, bytes32 root, bytes32 last){\n\n        TreeLib.Index memory index = indexes[index_id];\n        return (index.mtype,index.size,index.maxsize,index.id,index.root,index.last);\n    }\n\n    function getNode(bytes32 node_id) constant returns (bytes32 id,bytes32 left,bytes32 right,bytes32 parent,bytes32 data){\n        //set returns based on nature of base node\n        //require(child_type_lookup[node_id] == ltypes.Node);\n        return TreeLib.getNode(getSection(getParent(node_id)),node_id);\n    }\n\n    function getNodesBatch(bytes32 index_id,bytes32 last_node_id) constant returns (bytes32[5][5] results) {\n          TreeLib.Index storage index = indexes[index_id];\n\n          //throw if empty\n          require(index.size>0);\n\n          if(last_node_id == 0x0)last_node_id = index.children[index.root].root;\n          else last_node_id = index.children[getParent(last_node_id)].children[last_node_id].right;\n\n          bytes32 section_id = getParent(last_node_id);\n          TreeLib.Section storage sector = index.children[section_id];\n\n          uint r = 0;\n\n          while(r<5 && last_node_id!=0x0){\n           results[0][r]= sector.children[last_node_id].id;\n           results[1][r]= sector.children[last_node_id].left;\n           results[2][r]= sector.children[last_node_id].right;\n           results[3][r]= sector.children[last_node_id].parent;\n           results[4][r]= sector.children[last_node_id].data;\n           r++;\n\n           if(sector.children[last_node_id].right == 0x0){\n             if(sector.right != 0x0){\n               sector = index.children[sector.right];\n               last_node_id = sector.root;\n               continue;\n             }\n           break;\n           }\n           else {\n             last_node_id = sector.children[last_node_id].right;}\n          }\n\n          return results;\n    }\n\n    function removeSection(bytes32 index_id,bytes32 section_id) idNotEmpty(section_id){\n      assert(getParent(section_id) == index_id);\n      TreeLib.Index storage index = indexes[index_id];\n      delete(parent_child_lookup[section_id]);\n      TreeLib.removeSection(index,section_id);\n    }\n\n    function removeNode(bytes32 index_id,bytes32 node_id) idNotEmpty(node_id){\n      bytes32 section_id = getParent(node_id);\n      assert(getParent(section_id) == index_id);\n      TreeLib.Section storage sector = getSection(section_id);\n\n      delete(parent_child_lookup[node_id]);\n      TreeLib.removeNode(sector,node_id);\n\n      if(sector.size == 0)\n      removeSection(index_id,section_id);\n    }\n\n    function generateSection() returns (bytes32 section_id){\n      uint i = 0;\n      while(childExists(sha3(block.difficulty+i,block.number+i,block.timestamp+1))){\n        i++;\n      }\n      return sha3(block.difficulty+i,block.number+i,block.timestamp+1);\n    }\n\n    function newIndex(bytes32 index_id)idNotEmpty(index_id){\n        indexes[index_id] = TreeLib.newIndex(index_id,parent_max_size);\n    }\n\n    function insertSection(bytes32 parent_id) returns(bytes32){\n        //Create new index, if it does not exist\n        if(!indexExists(parent_id))\n          newIndex(parent_id);\n\n        bytes32 section_id = generateSection();\n\n        //Parent is an Index, store as child of index\n        TreeLib.Index storage index = indexes[parent_id];\n        parent_child_lookup[section_id] =  parent_id;\n        TreeLib.insertSection(index,section_id);\n        return section_id;\n    }\n\n    function insertNode(bytes32 index_id, bytes32 node_id, bytes32 data){\n        //Ensure index and node are not empty\n        require(index_id!= 0x0 && node_id != 0x0);\n\n        //Create new index, if it does not exist\n        if(!indexExists(index_id))\n          newIndex(index_id);\n\n        //check to see the next available sector\n        bytes32 section_id = nextSection(index_id);\n        if(section_id == 0x0)\n          section_id = insertSection(index_id);\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNode(getSection(section_id),node_id,data);\n    }\n\n    function insertNodeBatch(bytes32 index_id, bytes32[2][5] data){\n      require(index_id!= 0x0);\n\n      //Create new index, if it does not exist\n      if(!indexExists(index_id))\n        newIndex(index_id);\n\n      //check to see the next available sector\n      bytes32 section_id = nextSection(index_id);\n      if(section_id == 0x0)\n        section_id = insertSection(index_id);\n      uint to_fill = indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n\n      for(uint d=0;d<data.length;d++){\n        bytes32 node_id = data[d][0];\n        bytes32 node_data = data[d][1];\n        //Ensure index and node are not empty\n        if(node_id == 0x0)\n        continue;\n\n        //Generate new sector if exceeded\n        if(to_fill < d+1){\n          section_id = nextSection(index_id);\n          if(section_id == 0x0)\n            section_id = insertSection(index_id);\n          to_fill += indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n        }\n\n        bytes32 right = 0x0;\n        bytes32 left = 0x0;\n        if(d==0){\n          TreeLib.Section storage sector = getSection(section_id);\n          left = sector.last;\n          sector.children[left].right = node_id;\n        }\n        else{\n          left = data[d-1][0];\n        }\n        if(data.length>d+1)\n          right = data[d+1][0];\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNodeBatch(getSection(section_id),left,right,node_id,node_data);\n      }\n    }\n\n    modifier idNotEmpty(bytes32 id){\n        require(id != 0x0);\n        _;\n    }\n\n\n}\n", "flattened_code": "pragma solidity^0.4.11;\n\npragma solidity ^0.4.11;\n\nlibrary TreeLib{\n\n    /* Base structures, members can be combined to create the right structure\n\n    struct Base{ //Base members required by all structures\n        bytes32 id;//Id of the structure\n        uint mtype;//Type of structure [ increses from 0 for the base structure (main nodes) ]\n    }\n\n    struct Sibling{ //members for structures which have siblings\n        bytes32 left; //Id to sibling on the left\n        bytes32 right; //Id to sibling on the right\n    }\n\n    struct Group{ //members for structures which are parents\n        uint size; //Total number of children\n        uint maxsize; //Max allowed number of children\n        bytes32 root; //Id for the first child\n        bytes32 last; //Id for the last child\n        mapping(bytes32=>Base) children //List of children, type of child has to be a valid type to work\n    }\n\n    struct Child{ //members for structure which have parents\n        bytes32 parent;//Id of the parent\n    }\n\n    struct Content{ //Actual data members\n        bytes32 data;//Actual data being saved, could be changed to desired type\n    }\n    */\n\n    struct Node{ //The base structure\n        uint mtype;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 parent;\n        bytes32 data;\n    }\n\n    struct Section{ //The structure having Nodes as its children\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 root;\n        bytes32 last;\n        bytes32 parent;\n        mapping(bytes32=>Node) children;\n    }\n\n    /*\n    //Only enabled if max_dept >2\n    struct SubSection{ //The intermediarry structure, multiple layers can exist under one Index\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 parent;\n        mapping(bytes32=>Section) children; //Can either be SubSections or Sections\n    }\n\n    //Only enabled if max_dept >3\n    struct SupSection{ //The intermediarry structure, multiple layers can exist under one Index\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 parent;\n        mapping(bytes32=>SubSection) children; //Can either be SubSections or Sections\n    }\n\n    //Add more types as necessary based on Max depth\n    */\n\n    struct Index{ //The highest structure\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 root;\n        bytes32 last;\n        mapping(bytes32=>Section) children;\n    }\n\n\n    function getNode(Section storage sector, bytes32 node_id) constant returns (bytes32 id,bytes32 left,bytes32 right,bytes32 parent,bytes32 data){\n        //set returns based on nature of base node\n        //set correct type of parent of Node as designed\n\n        return (sector.children[node_id].id,sector.children[node_id].left,sector.children[node_id].right,sector.children[node_id].parent,sector.children[node_id].data);\n    }\n\n    function removeSection(Index storage index,bytes32 section_id) internal {\n      require(index.children[section_id].id == section_id);\n      Section storage sector = index.children[section_id];\n\n      index.children[sector.left].right = sector.right;\n      if(index.root == section_id)\n      index.root = sector.right;\n\n      index.children[sector.right].left = sector.left;\n      if(index.last == section_id)\n      index.last = sector.left;\n\n      delete(index.children[section_id]);\n      if(index.size>0)\n      index.size--;\n    }\n\n    function removeNode(Section storage sector,bytes32 node_id){\n      require(sector.children[node_id].id == node_id);\n      Node storage node = sector.children[node_id];\n\n      sector.children[node.left].right = node.right;\n      if(sector.root == node_id)\n      sector.root = node.right;\n\n      sector.children[node.right].left = node.left;\n      if(sector.last == node_id)\n      sector.last = node.left;\n\n      delete(sector.children[node_id]);\n      if(sector.size>0)\n      sector.size--;\n    }\n\n    function newIndex(bytes32 index_id,uint maxsize) internal returns(Index memory) {\n        return Index(2,0,maxsize,index_id,0x0,0x0); //Update \"2\" to match ltype index for structure\n    }\n\n    function newSection(bytes32 section_id,bytes32 left_id,bytes32 parent_id,uint maxsize) internal returns(Section memory section) {\n        return Section(1,0,maxsize,section_id,left_id,0x0,0x0,0x0,parent_id);//Update \"1\" to match ltype index for structure\n    }\n\n    function newNode(bytes32 node_id ,bytes32 left_id,bytes32 right_id,bytes32 parent_id,bytes32 data) internal returns(Node memory node) {\n        return Node(0,node_id,left_id,right_id,parent_id,data);//Update initial \"0\" to match ltype index for structure\n    }\n\n    function insertSection(Index storage index,bytes32 section_id) internal { //Create correspondong insert functions for other intermediate types\n        require(index.size < index.maxsize);\n\n        if(index.size < 1){\n            index.root = section_id;\n        }\n        else{\n            index.children[index.last].right = section_id;\n        }\n        index.children[section_id] = newSection(section_id,index.last,index.id,index.maxsize);\n        index.last = section_id;\n        index.size ++;\n    }\n\n    function insertNode(Section storage sector,bytes32 node_id,bytes32 data) internal {\n        require(sector.size < sector.maxsize);\n\n\n        if(sector.size < 1){\n            sector.root = node_id;\n        }\n        else{\n            sector.children[sector.last].right = node_id;\n        }\n\n        sector.children[node_id] = newNode(node_id,sector.last,0x0,sector.id,data);\n        sector.last = node_id;\n        sector.size ++;\n    }\n\n    function insertNodeBatch(Section storage sector,bytes32 left,bytes32 right,bytes32 node_id,bytes32 data) internal {\n\n        if(sector.size < 1){\n            sector.root = node_id;\n        }\n\n        sector.children[node_id] = newNode(node_id,left,right,sector.id,data);\n        sector.last = node_id;\n        sector.size ++;\n    }\n\n}\n\ncontract Tree{\n\n    mapping(bytes32=>TreeLib.Index) indexes;//Or a single index, based on how you want to arange your indexes\n    mapping(bytes32=>bytes32) parent_child_lookup;\n\n    uint max_depth=2; // Maxdepth of the tree; advised 5\n    uint mtypes_count=3;//Count of mtypes,available structure types from the lib\n    bytes8[3] mtypes = [ bytes8(\"Node\"), bytes8(\"Section\"), bytes8(\"Index\")]; //Increase type to match structure types\n    enum ltypes {Node,Section,Index} //Increase type to match structure types\n\n\n    uint parent_max_size = 10; //Max size for all parents equaling Max nodes = parent_max_size^(max_depth-1)\n\n    function TreeContract(){\n    }\n\n    function indexExists(bytes32 index_id) constant returns (bool){\n        return (indexes[index_id].id == index_id);\n    }\n\n    function childExists(bytes32 child_id) constant returns(bool){\n        return (getParent(child_id) != 0x0);\n    }\n\n    function nodeExists(bytes32 index_id,bytes32 node_id) constant returns(bool){\n        if(childExists(node_id) ){\n          return getHeirachy(node_id)[1] == index_id;\n        }\n        return false;\n    }\n\n    function getParent(bytes32 child_id) constant returns(bytes32){\n        return parent_child_lookup[child_id];\n    }\n\n    function getHeirachy(bytes32 child_id) constant returns (bytes32[2] memory search_up /*should match (max_depth)*/){\n        bytes32 main_index_id;\n\n        //Fetch the node's parent\n        main_index_id = getParent(child_id);\n        search_up[0] = main_index_id;\n\n        uint i = 1;\n        while((main_index_id = getParent(main_index_id)) != 0x0){\n        search_up[i] = main_index_id;\n        i++;\n        }\n    }\n\n    function nextSection(bytes32 index_id) internal constant returns (bytes32 id){\n      //get the next available section in the index\n      TreeLib.Index storage index = indexes[index_id];\n      id = indexes[index_id].root;\n      while(true){\n        if(index.children[id].size+1 > index.maxsize && index.children[id].id != 0x0){\n          id = index.children[id].right;\n          continue;\n        }\n        else break;\n      }\n      return id;\n    }\n\n    function getSection(bytes32 section_id) internal constant returns(TreeLib.Section storage sector){\n        bytes32[2] memory search_up; //size should match (max_depth)\n        search_up = getHeirachy(section_id);\n\n        //GenecricTree.SubSection storage subsector; //Only enabled if max_dept >2\n        //Structure based on sector parent being index\n        if(search_up.length>0){\n          sector = indexes[search_up[0]].children[section_id];\n        }\n    }\n\n    function getIndex(bytes32 index_id)constant returns(uint mtype,uint size, uint maxsize, bytes32 id, bytes32 root, bytes32 last){\n\n        TreeLib.Index memory index = indexes[index_id];\n        return (index.mtype,index.size,index.maxsize,index.id,index.root,index.last);\n    }\n\n    function getNode(bytes32 node_id) constant returns (bytes32 id,bytes32 left,bytes32 right,bytes32 parent,bytes32 data){\n        //set returns based on nature of base node\n        //require(child_type_lookup[node_id] == ltypes.Node);\n        return TreeLib.getNode(getSection(getParent(node_id)),node_id);\n    }\n\n    function getNodesBatch(bytes32 index_id,bytes32 last_node_id) constant returns (bytes32[5][5] results) {\n          TreeLib.Index storage index = indexes[index_id];\n\n          //throw if empty\n          require(index.size>0);\n\n          if(last_node_id == 0x0)last_node_id = index.children[index.root].root;\n          else last_node_id = index.children[getParent(last_node_id)].children[last_node_id].right;\n\n          bytes32 section_id = getParent(last_node_id);\n          TreeLib.Section storage sector = index.children[section_id];\n\n          uint r = 0;\n\n          while(r<5 && last_node_id!=0x0){\n           results[0][r]= sector.children[last_node_id].id;\n           results[1][r]= sector.children[last_node_id].left;\n           results[2][r]= sector.children[last_node_id].right;\n           results[3][r]= sector.children[last_node_id].parent;\n           results[4][r]= sector.children[last_node_id].data;\n           r++;\n\n           if(sector.children[last_node_id].right == 0x0){\n             if(sector.right != 0x0){\n               sector = index.children[sector.right];\n               last_node_id = sector.root;\n               continue;\n             }\n           break;\n           }\n           else {\n             last_node_id = sector.children[last_node_id].right;}\n          }\n\n          return results;\n    }\n\n    function removeSection(bytes32 index_id,bytes32 section_id) idNotEmpty(section_id){\n      assert(getParent(section_id) == index_id);\n      TreeLib.Index storage index = indexes[index_id];\n      delete(parent_child_lookup[section_id]);\n      TreeLib.removeSection(index,section_id);\n    }\n\n    function removeNode(bytes32 index_id,bytes32 node_id) idNotEmpty(node_id){\n      bytes32 section_id = getParent(node_id);\n      assert(getParent(section_id) == index_id);\n      TreeLib.Section storage sector = getSection(section_id);\n\n      delete(parent_child_lookup[node_id]);\n      TreeLib.removeNode(sector,node_id);\n\n      if(sector.size == 0)\n      removeSection(index_id,section_id);\n    }\n\n    function generateSection() returns (bytes32 section_id){\n      uint i = 0;\n      while(childExists(sha3(block.difficulty+i,block.number+i,block.timestamp+1))){\n        i++;\n      }\n      return sha3(block.difficulty+i,block.number+i,block.timestamp+1);\n    }\n\n    function newIndex(bytes32 index_id)idNotEmpty(index_id){\n        indexes[index_id] = TreeLib.newIndex(index_id,parent_max_size);\n    }\n\n    function insertSection(bytes32 parent_id) returns(bytes32){\n        //Create new index, if it does not exist\n        if(!indexExists(parent_id))\n          newIndex(parent_id);\n\n        bytes32 section_id = generateSection();\n\n        //Parent is an Index, store as child of index\n        TreeLib.Index storage index = indexes[parent_id];\n        parent_child_lookup[section_id] =  parent_id;\n        TreeLib.insertSection(index,section_id);\n        return section_id;\n    }\n\n    function insertNode(bytes32 index_id, bytes32 node_id, bytes32 data){\n        //Ensure index and node are not empty\n        require(index_id!= 0x0 && node_id != 0x0);\n\n        //Create new index, if it does not exist\n        if(!indexExists(index_id))\n          newIndex(index_id);\n\n        //check to see the next available sector\n        bytes32 section_id = nextSection(index_id);\n        if(section_id == 0x0)\n          section_id = insertSection(index_id);\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNode(getSection(section_id),node_id,data);\n    }\n\n    function insertNodeBatch(bytes32 index_id, bytes32[2][5] data){\n      require(index_id!= 0x0);\n\n      //Create new index, if it does not exist\n      if(!indexExists(index_id))\n        newIndex(index_id);\n\n      //check to see the next available sector\n      bytes32 section_id = nextSection(index_id);\n      if(section_id == 0x0)\n        section_id = insertSection(index_id);\n      uint to_fill = indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n\n      for(uint d=0;d<data.length;d++){\n        bytes32 node_id = data[d][0];\n        bytes32 node_data = data[d][1];\n        //Ensure index and node are not empty\n        if(node_id == 0x0)\n        continue;\n\n        //Generate new sector if exceeded\n        if(to_fill < d+1){\n          section_id = nextSection(index_id);\n          if(section_id == 0x0)\n            section_id = insertSection(index_id);\n          to_fill += indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n        }\n\n        bytes32 right = 0x0;\n        bytes32 left = 0x0;\n        if(d==0){\n          TreeLib.Section storage sector = getSection(section_id);\n          left = sector.last;\n          sector.children[left].right = node_id;\n        }\n        else{\n          left = data[d-1][0];\n        }\n        if(data.length>d+1)\n          right = data[d+1][0];\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNodeBatch(getSection(section_id),left,right,node_id,node_data);\n      }\n    }\n\n    modifier idNotEmpty(bytes32 id){\n        require(id != 0x0);\n        _;\n    }\n\n\n}\n", "commit_id": "facf7591596defe1f720ee429e1a03d0dbdb4675"}, "fixed_version": {"raw_code": "pragma solidity^0.4.11;\n\nimport \"../libraries/TreeLib.sol\";\n\ncontract Tree{\n\n    mapping(bytes32=>TreeLib.Index) indexes;//Or a single index, based on how you want to arange your indexes\n    mapping(bytes32=>bytes32) parent_child_lookup;\n\n    uint max_depth=2; // Maxdepth of the tree; advised 5\n    uint mtypes_count=3;//Count of mtypes,available structure types from the lib\n    bytes8[3] mtypes = [ bytes8(\"Node\"), bytes8(\"Section\"), bytes8(\"Index\")]; //Increase type to match structure types\n    enum ltypes {Node,Section,Index} //Increase type to match structure types\n\n    uint parent_max_size = 10; //Max size for all parents equaling Max nodes = parent_max_size^(max_depth-1)\n\n    function TreeContract(){\n    }\n\n    function indexExists(bytes32 index_id) constant returns (bool){\n        return (indexes[index_id].id == index_id);\n    }\n\n    function childExists(bytes32 child_id) constant returns(bool){\n        return (getParent(child_id) != 0x0);\n    }\n\n    function nodeExists(bytes32 index_id,bytes32 node_id) constant returns(bool){\n        if(childExists(node_id) ){\n          return getHeirachy(node_id)[1] == index_id;\n        }\n        return false;\n    }\n\n    function getParent(bytes32 child_id) constant returns(bytes32){\n        return parent_child_lookup[child_id];\n    }\n\n    function getHeirachy(bytes32 child_id) constant returns (bytes32[2] memory search_up /*should match (max_depth)*/){\n        bytes32 main_index_id;\n\n        //Fetch the node's parent\n        main_index_id = getParent(child_id);\n        search_up[0] = main_index_id;\n\n        uint i = 1;\n        while((main_index_id = getParent(main_index_id)) != 0x0){\n        search_up[i] = main_index_id;\n        i++;\n        }\n    }\n\n    function nextSection(bytes32 index_id) internal constant returns (bytes32 id){\n      //get the next available section in the index\n      TreeLib.Index storage index = indexes[index_id];\n      id = indexes[index_id].root;\n      while(true){\n        if(index.children[id].size+1 > index.maxsize && index.children[id].id != 0x0){\n          id = index.children[id].right;\n          continue;\n        }\n        else break;\n      }\n      return id;\n    }\n\n    function getSection(bytes32 section_id) internal constant returns(TreeLib.Section storage sector){\n        bytes32[2] memory search_up; //size should match (max_depth)\n        search_up = getHeirachy(section_id);\n\n        //GenecricTree.SubSection storage subsector; //Only enabled if max_dept >2\n        //Structure based on sector parent being index\n        if(search_up.length>0){\n          sector = indexes[search_up[0]].children[section_id];\n        }\n    }\n\n    function getIndex(bytes32 index_id)constant returns(uint mtype,uint size, uint maxsize, bytes32 id, bytes32 root, bytes32 last){\n\n        TreeLib.Index memory index = indexes[index_id];\n        return (index.mtype,index.size,index.maxsize,index.id,index.root,index.last);\n    }\n\n    function getNode(bytes32 node_id) constant returns (bytes32 id,bytes32 left,bytes32 right,bytes32 parent,bytes32 data){\n        //set returns based on nature of base node\n        //require(child_type_lookup[node_id] == ltypes.Node);\n        return TreeLib.getNode(getSection(getParent(node_id)),node_id);\n    }\n\n    function getNodesBatch(bytes32 index_id,bytes32 last_node_id) constant returns (bytes32[5][5] results) {\n          TreeLib.Index storage index = indexes[index_id];\n\n          //throw if empty\n          require(index.size>0);\n\n          if(last_node_id == 0x0)last_node_id = index.children[index.root].root;\n          else last_node_id = index.children[getParent(last_node_id)].children[last_node_id].right;\n\n          bytes32 section_id = getParent(last_node_id);\n          TreeLib.Section storage sector = index.children[section_id];\n\n          uint r = 0;\n\n          while(r<5 && last_node_id!=0x0){\n           results[0][r]= sector.children[last_node_id].id;\n           results[1][r]= sector.children[last_node_id].left;\n           results[2][r]= sector.children[last_node_id].right;\n           results[3][r]= sector.children[last_node_id].parent;\n           results[4][r]= sector.children[last_node_id].data;\n           r++;\n\n           if(sector.children[last_node_id].right == 0x0){\n             if(sector.right != 0x0){\n               sector = index.children[sector.right];\n               last_node_id = sector.root;\n               continue;\n             }\n           break;\n           }\n           else {\n             last_node_id = sector.children[last_node_id].right;}\n          }\n\n          return results;\n    }\n\n    function removeSection(bytes32 index_id,bytes32 section_id) internal idNotEmpty(section_id){\n      assert(getParent(section_id) == index_id);\n      TreeLib.Index storage index = indexes[index_id];\n      delete(parent_child_lookup[section_id]);\n      TreeLib.removeSection(index,section_id);\n    }\n\n    function removeNode(bytes32 index_id,bytes32 node_id) idNotEmpty(node_id){\n      bytes32 section_id = getParent(node_id);\n      assert(getParent(section_id) == index_id);\n      TreeLib.Section storage sector = getSection(section_id);\n\n      delete(parent_child_lookup[node_id]);\n      TreeLib.removeNode(sector,node_id);\n\n      if(sector.size == 0)\n      removeSection(index_id,section_id);\n    }\n\n    function generateSection() internal constant returns (bytes32 section_id){\n      uint i = 0;\n      while(childExists(sha3(block.difficulty+i,block.number+i,block.timestamp+1))){\n        i++;\n      }\n      return sha3(block.difficulty+i,block.number+i,block.timestamp+1);\n    }\n\n    function newIndex(bytes32 index_id) internal idNotEmpty(index_id){\n        indexes[index_id] = TreeLib.newIndex(index_id,parent_max_size);\n    }\n\n    function insertSection(bytes32 parent_id) internal returns(bytes32){\n        //Create new index, if it does not exist\n        if(!indexExists(parent_id))\n          newIndex(parent_id);\n\n        bytes32 section_id = generateSection();\n\n        //Parent is an Index, store as child of index\n        TreeLib.Index storage index = indexes[parent_id];\n        parent_child_lookup[section_id] =  parent_id;\n        TreeLib.insertSection(index,section_id);\n        return section_id;\n    }\n\n    function insertNode(bytes32 index_id, bytes32 node_id, bytes32 data){\n        //Ensure index and node are not empty\n        require(index_id!= 0x0 && node_id != 0x0);\n\n        //Create new index, if it does not exist\n        if(!indexExists(index_id))\n          newIndex(index_id);\n\n        //check to see the next available sector\n        bytes32 section_id = nextSection(index_id);\n        if(section_id == 0x0)\n          section_id = insertSection(index_id);\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNode(getSection(section_id),node_id,data);\n    }\n\n    function insertNodeBatch(bytes32 index_id, bytes32[2][5] data){\n      require(index_id!= 0x0);\n\n      //Create new index, if it does not exist\n      if(!indexExists(index_id))\n        newIndex(index_id);\n\n      //check to see the next available sector\n      bytes32 section_id = nextSection(index_id);\n      if(section_id == 0x0)\n        section_id = insertSection(index_id);\n      uint to_fill = indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n\n      for(uint d=0;d<data.length;d++){\n        bytes32 node_id = data[d][0];\n        bytes32 node_data = data[d][1];\n        //Ensure index and node are not empty\n        if(node_id == 0x0)\n        continue;\n\n        //Generate new sector if exceeded\n        if(to_fill < d+1){\n          section_id = nextSection(index_id);\n          if(section_id == 0x0)\n            section_id = insertSection(index_id);\n          to_fill += indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n        }\n\n        bytes32 right = 0x0;\n        bytes32 left = 0x0;\n        if(d==0){\n          TreeLib.Section storage sector = getSection(section_id);\n          left = sector.last;\n          sector.children[left].right = node_id;\n        }\n        else{\n          left = data[d-1][0];\n        }\n        if(data.length>d+1)\n          right = data[d+1][0];\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNodeBatch(getSection(section_id),left,right,node_id,node_data);\n      }\n    }\n\n    modifier idNotEmpty(bytes32 id){\n        require(id != 0x0);\n        _;\n    }\n\n\n}\n", "flattened_code": "pragma solidity^0.4.11;\n\npragma solidity ^0.4.11;\n\nlibrary TreeLib{\n\n    /* Base structures, members can be combined to create the right structure\n\n    struct Base{ //Base members required by all structures\n        bytes32 id;//Id of the structure\n        uint mtype;//Type of structure [ increses from 0 for the base structure (main nodes) ]\n    }\n\n    struct Sibling{ //members for structures which have siblings\n        bytes32 left; //Id to sibling on the left\n        bytes32 right; //Id to sibling on the right\n    }\n\n    struct Group{ //members for structures which are parents\n        uint size; //Total number of children\n        uint maxsize; //Max allowed number of children\n        bytes32 root; //Id for the first child\n        bytes32 last; //Id for the last child\n        mapping(bytes32=>Base) children //List of children, type of child has to be a valid type to work\n    }\n\n    struct Child{ //members for structure which have parents\n        bytes32 parent;//Id of the parent\n    }\n\n    struct Content{ //Actual data members\n        bytes32 data;//Actual data being saved, could be changed to desired type\n    }\n    */\n\n    struct Node{ //The base structure\n        uint mtype;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 parent;\n        bytes32 data;\n    }\n\n    struct Section{ //The structure having Nodes as its children\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 root;\n        bytes32 last;\n        bytes32 parent;\n        mapping(bytes32=>Node) children;\n    }\n\n    /*\n    //Only enabled if max_dept >2\n    struct SubSection{ //The intermediarry structure, multiple layers can exist under one Index\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 parent;\n        mapping(bytes32=>Section) children; //Can either be SubSections or Sections\n    }\n\n    //Only enabled if max_dept >3\n    struct SupSection{ //The intermediarry structure, multiple layers can exist under one Index\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 left;\n        bytes32 right;\n        bytes32 parent;\n        mapping(bytes32=>SubSection) children; //Can either be SubSections or Sections\n    }\n\n    //Add more types as necessary based on Max depth\n    */\n\n    struct Index{ //The highest structure\n        uint mtype;\n        uint size;\n        uint maxsize;\n        bytes32 id;\n        bytes32 root;\n        bytes32 last;\n        mapping(bytes32=>Section) children;\n    }\n\n\n    function getNode(Section storage sector, bytes32 node_id) constant returns (bytes32 id,bytes32 left,bytes32 right,bytes32 parent,bytes32 data){\n        //set returns based on nature of base node\n        //set correct type of parent of Node as designed\n\n        return (sector.children[node_id].id,sector.children[node_id].left,sector.children[node_id].right,sector.children[node_id].parent,sector.children[node_id].data);\n    }\n\n    function removeSection(Index storage index,bytes32 section_id) internal {\n      require(index.children[section_id].id == section_id);\n      Section storage sector = index.children[section_id];\n\n      index.children[sector.left].right = sector.right;\n      if(index.root == section_id)\n      index.root = sector.right;\n\n      index.children[sector.right].left = sector.left;\n      if(index.last == section_id)\n      index.last = sector.left;\n\n      delete(index.children[section_id]);\n      if(index.size>0)\n      index.size--;\n    }\n\n    function removeNode(Section storage sector,bytes32 node_id){\n      require(sector.children[node_id].id == node_id);\n      Node storage node = sector.children[node_id];\n\n      sector.children[node.left].right = node.right;\n      if(sector.root == node_id)\n      sector.root = node.right;\n\n      sector.children[node.right].left = node.left;\n      if(sector.last == node_id)\n      sector.last = node.left;\n\n      delete(sector.children[node_id]);\n      if(sector.size>0)\n      sector.size--;\n    }\n\n    function newIndex(bytes32 index_id,uint maxsize) internal returns(Index memory) {\n        return Index(2,0,maxsize,index_id,0x0,0x0); //Update \"2\" to match ltype index for structure\n    }\n\n    function newSection(bytes32 section_id,bytes32 left_id,bytes32 parent_id,uint maxsize) internal returns(Section memory section) {\n        return Section(1,0,maxsize,section_id,left_id,0x0,0x0,0x0,parent_id);//Update \"1\" to match ltype index for structure\n    }\n\n    function newNode(bytes32 node_id ,bytes32 left_id,bytes32 right_id,bytes32 parent_id,bytes32 data) internal returns(Node memory node) {\n        return Node(0,node_id,left_id,right_id,parent_id,data);//Update initial \"0\" to match ltype index for structure\n    }\n\n    function insertSection(Index storage index,bytes32 section_id) internal { //Create correspondong insert functions for other intermediate types\n        require(index.size < index.maxsize);\n\n        if(index.size < 1){\n            index.root = section_id;\n        }\n        else{\n            index.children[index.last].right = section_id;\n        }\n        index.children[section_id] = newSection(section_id,index.last,index.id,index.maxsize);\n        index.last = section_id;\n        index.size ++;\n    }\n\n    function insertNode(Section storage sector,bytes32 node_id,bytes32 data) internal {\n        require(sector.size < sector.maxsize);\n\n\n        if(sector.size < 1){\n            sector.root = node_id;\n        }\n        else{\n            sector.children[sector.last].right = node_id;\n        }\n\n        sector.children[node_id] = newNode(node_id,sector.last,0x0,sector.id,data);\n        sector.last = node_id;\n        sector.size ++;\n    }\n\n    function insertNodeBatch(Section storage sector,bytes32 left,bytes32 right,bytes32 node_id,bytes32 data) internal {\n\n        if(sector.size < 1){\n            sector.root = node_id;\n        }\n\n        sector.children[node_id] = newNode(node_id,left,right,sector.id,data);\n        sector.last = node_id;\n        sector.size ++;\n    }\n\n}\n\ncontract Tree{\n\n    mapping(bytes32=>TreeLib.Index) indexes;//Or a single index, based on how you want to arange your indexes\n    mapping(bytes32=>bytes32) parent_child_lookup;\n\n    uint max_depth=2; // Maxdepth of the tree; advised 5\n    uint mtypes_count=3;//Count of mtypes,available structure types from the lib\n    bytes8[3] mtypes = [ bytes8(\"Node\"), bytes8(\"Section\"), bytes8(\"Index\")]; //Increase type to match structure types\n    enum ltypes {Node,Section,Index} //Increase type to match structure types\n\n    uint parent_max_size = 10; //Max size for all parents equaling Max nodes = parent_max_size^(max_depth-1)\n\n    function TreeContract(){\n    }\n\n    function indexExists(bytes32 index_id) constant returns (bool){\n        return (indexes[index_id].id == index_id);\n    }\n\n    function childExists(bytes32 child_id) constant returns(bool){\n        return (getParent(child_id) != 0x0);\n    }\n\n    function nodeExists(bytes32 index_id,bytes32 node_id) constant returns(bool){\n        if(childExists(node_id) ){\n          return getHeirachy(node_id)[1] == index_id;\n        }\n        return false;\n    }\n\n    function getParent(bytes32 child_id) constant returns(bytes32){\n        return parent_child_lookup[child_id];\n    }\n\n    function getHeirachy(bytes32 child_id) constant returns (bytes32[2] memory search_up /*should match (max_depth)*/){\n        bytes32 main_index_id;\n\n        //Fetch the node's parent\n        main_index_id = getParent(child_id);\n        search_up[0] = main_index_id;\n\n        uint i = 1;\n        while((main_index_id = getParent(main_index_id)) != 0x0){\n        search_up[i] = main_index_id;\n        i++;\n        }\n    }\n\n    function nextSection(bytes32 index_id) internal constant returns (bytes32 id){\n      //get the next available section in the index\n      TreeLib.Index storage index = indexes[index_id];\n      id = indexes[index_id].root;\n      while(true){\n        if(index.children[id].size+1 > index.maxsize && index.children[id].id != 0x0){\n          id = index.children[id].right;\n          continue;\n        }\n        else break;\n      }\n      return id;\n    }\n\n    function getSection(bytes32 section_id) internal constant returns(TreeLib.Section storage sector){\n        bytes32[2] memory search_up; //size should match (max_depth)\n        search_up = getHeirachy(section_id);\n\n        //GenecricTree.SubSection storage subsector; //Only enabled if max_dept >2\n        //Structure based on sector parent being index\n        if(search_up.length>0){\n          sector = indexes[search_up[0]].children[section_id];\n        }\n    }\n\n    function getIndex(bytes32 index_id)constant returns(uint mtype,uint size, uint maxsize, bytes32 id, bytes32 root, bytes32 last){\n\n        TreeLib.Index memory index = indexes[index_id];\n        return (index.mtype,index.size,index.maxsize,index.id,index.root,index.last);\n    }\n\n    function getNode(bytes32 node_id) constant returns (bytes32 id,bytes32 left,bytes32 right,bytes32 parent,bytes32 data){\n        //set returns based on nature of base node\n        //require(child_type_lookup[node_id] == ltypes.Node);\n        return TreeLib.getNode(getSection(getParent(node_id)),node_id);\n    }\n\n    function getNodesBatch(bytes32 index_id,bytes32 last_node_id) constant returns (bytes32[5][5] results) {\n          TreeLib.Index storage index = indexes[index_id];\n\n          //throw if empty\n          require(index.size>0);\n\n          if(last_node_id == 0x0)last_node_id = index.children[index.root].root;\n          else last_node_id = index.children[getParent(last_node_id)].children[last_node_id].right;\n\n          bytes32 section_id = getParent(last_node_id);\n          TreeLib.Section storage sector = index.children[section_id];\n\n          uint r = 0;\n\n          while(r<5 && last_node_id!=0x0){\n           results[0][r]= sector.children[last_node_id].id;\n           results[1][r]= sector.children[last_node_id].left;\n           results[2][r]= sector.children[last_node_id].right;\n           results[3][r]= sector.children[last_node_id].parent;\n           results[4][r]= sector.children[last_node_id].data;\n           r++;\n\n           if(sector.children[last_node_id].right == 0x0){\n             if(sector.right != 0x0){\n               sector = index.children[sector.right];\n               last_node_id = sector.root;\n               continue;\n             }\n           break;\n           }\n           else {\n             last_node_id = sector.children[last_node_id].right;}\n          }\n\n          return results;\n    }\n\n    function removeSection(bytes32 index_id,bytes32 section_id) internal idNotEmpty(section_id){\n      assert(getParent(section_id) == index_id);\n      TreeLib.Index storage index = indexes[index_id];\n      delete(parent_child_lookup[section_id]);\n      TreeLib.removeSection(index,section_id);\n    }\n\n    function removeNode(bytes32 index_id,bytes32 node_id) idNotEmpty(node_id){\n      bytes32 section_id = getParent(node_id);\n      assert(getParent(section_id) == index_id);\n      TreeLib.Section storage sector = getSection(section_id);\n\n      delete(parent_child_lookup[node_id]);\n      TreeLib.removeNode(sector,node_id);\n\n      if(sector.size == 0)\n      removeSection(index_id,section_id);\n    }\n\n    function generateSection() internal constant returns (bytes32 section_id){\n      uint i = 0;\n      while(childExists(sha3(block.difficulty+i,block.number+i,block.timestamp+1))){\n        i++;\n      }\n      return sha3(block.difficulty+i,block.number+i,block.timestamp+1);\n    }\n\n    function newIndex(bytes32 index_id) internal idNotEmpty(index_id){\n        indexes[index_id] = TreeLib.newIndex(index_id,parent_max_size);\n    }\n\n    function insertSection(bytes32 parent_id) internal returns(bytes32){\n        //Create new index, if it does not exist\n        if(!indexExists(parent_id))\n          newIndex(parent_id);\n\n        bytes32 section_id = generateSection();\n\n        //Parent is an Index, store as child of index\n        TreeLib.Index storage index = indexes[parent_id];\n        parent_child_lookup[section_id] =  parent_id;\n        TreeLib.insertSection(index,section_id);\n        return section_id;\n    }\n\n    function insertNode(bytes32 index_id, bytes32 node_id, bytes32 data){\n        //Ensure index and node are not empty\n        require(index_id!= 0x0 && node_id != 0x0);\n\n        //Create new index, if it does not exist\n        if(!indexExists(index_id))\n          newIndex(index_id);\n\n        //check to see the next available sector\n        bytes32 section_id = nextSection(index_id);\n        if(section_id == 0x0)\n          section_id = insertSection(index_id);\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNode(getSection(section_id),node_id,data);\n    }\n\n    function insertNodeBatch(bytes32 index_id, bytes32[2][5] data){\n      require(index_id!= 0x0);\n\n      //Create new index, if it does not exist\n      if(!indexExists(index_id))\n        newIndex(index_id);\n\n      //check to see the next available sector\n      bytes32 section_id = nextSection(index_id);\n      if(section_id == 0x0)\n        section_id = insertSection(index_id);\n      uint to_fill = indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n\n      for(uint d=0;d<data.length;d++){\n        bytes32 node_id = data[d][0];\n        bytes32 node_data = data[d][1];\n        //Ensure index and node are not empty\n        if(node_id == 0x0)\n        continue;\n\n        //Generate new sector if exceeded\n        if(to_fill < d+1){\n          section_id = nextSection(index_id);\n          if(section_id == 0x0)\n            section_id = insertSection(index_id);\n          to_fill += indexes[index_id].children[section_id].maxsize - indexes[index_id].children[section_id].size;\n        }\n\n        bytes32 right = 0x0;\n        bytes32 left = 0x0;\n        if(d==0){\n          TreeLib.Section storage sector = getSection(section_id);\n          left = sector.last;\n          sector.children[left].right = node_id;\n        }\n        else{\n          left = data[d-1][0];\n        }\n        if(data.length>d+1)\n          right = data[d+1][0];\n\n        parent_child_lookup[node_id] =  section_id;\n        TreeLib.insertNodeBatch(getSection(section_id),left,right,node_id,node_data);\n      }\n    }\n\n    modifier idNotEmpty(bytes32 id){\n        require(id != 0x0);\n        _;\n    }\n\n\n}\n", "commit_id": "5d1fbeb098196f0e6f14b7b6a79d445d2199583a"}}