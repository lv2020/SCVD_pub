{"filename": "contracts/VoterV2.sol", "patch": "@@ -16,13 +16,6 @@ contract VoterV2 is IVoter {\n         _;\n     }\n \n-    address public admin;\n-\n-    modifier isAdmin() {\n-        require(msg.sender == admin, \"Caller is not admin\");\n-        _;\n-    }\n-\n     address public balanceKeeper;\n \n     uint public totalRounds;\n@@ -50,11 +43,9 @@ contract VoterV2 is IVoter {\n     event CheckVoteBalances(address indexed checker, address indexed user, uint newBalance);\n     event FinalizeRound(address indexed owner, uint roundId);\n     event SetOwner(address ownerOld, address ownerNew);\n-    event SetAdmin(address adminOld, address adminNew);\n \n     constructor(address _owner, address _balanceKeeper) {\n         owner = _owner;\n-        admin = _owner;\n         balanceKeeper = _balanceKeeper;\n     }\n \n@@ -121,13 +112,7 @@ contract VoterV2 is IVoter {\n         emit SetOwner(ownerOld, _owner);\n     }\n \n-    function setAdmin(address _admin) public isAdmin {\n-        address adminOld = admin;\n-        admin = _admin;\n-        emit SetAdmin(adminOld, _admin);\n-    }\n-\n-    function startRound(string memory name, string[] memory options) public isAdmin {\n+    function startRound(string memory name, string[] memory options) public isOwner {\n         _roundName[totalRounds] = name;\n         _roundOptions[totalRounds] = options;\n         _votesForOption[totalRounds] = new uint[](options.length);\n@@ -246,7 +231,7 @@ contract VoterV2 is IVoter {\n     }\n \n     // move roundId from activeRounds to pastRounds\n-    function finalizeRound(uint roundId) public isAdmin {\n+    function finalizeRound(uint roundId) public isOwner {\n         uint[] memory filteredRounds = new uint[](activeRounds.length-1);\n         uint j = 0;\n         for (uint i = 0; i < activeRounds.length; i++) {", "project_link": "https://github.com/Graviton-One/graviton-contracts/commit/d51138e0fecacd2e0d1a85ef0b9cbed2725a0156", "bug_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interfaces/IBalanceKeeperV2.sol\";\nimport \"./interfaces/IVoter.sol\";\n\n/// @title VoterV2\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ncontract VoterV2 is IVoter {\n\n    address public owner;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    address public admin;\n\n    modifier isAdmin() {\n        require(msg.sender == admin, \"Caller is not admin\");\n        _;\n    }\n\n    address public balanceKeeper;\n\n    uint public totalRounds;\n    uint[] public activeRounds;\n    uint[] public pastRounds;\n    mapping(uint => string) internal _roundName;\n    mapping(uint => string[]) internal _roundOptions;\n\n    mapping(uint => uint[]) internal _votesForOption;\n\n    mapping(uint => mapping(address => uint)) internal _votesInRoundByUser;\n    mapping(uint => mapping(address => uint[])) internal _votesForOptionByUser;\n\n    mapping(uint => mapping(address => bool)) internal _userVotedInRound;\n    mapping(uint => mapping(uint => mapping(address => bool))) internal _userVotedForOption;\n\n    mapping(uint => uint) internal _totalUsersInRound;\n    mapping(uint => mapping(uint => uint)) internal _totalUsersForOption;\n\n    mapping(address => bool) public canCheck;\n\n    event CastVotes(address indexed voter, uint indexed roundId);\n    event StartRound(address indexed owner, uint totalRounds, string name, string[] options);\n    event SetCanCheck(address indexed owner, address indexed checker, bool indexed newBool);\n    event CheckVoteBalances(address indexed checker, address indexed user, uint newBalance);\n    event FinalizeRound(address indexed owner, uint roundId);\n    event SetOwner(address ownerOld, address ownerNew);\n    event SetAdmin(address adminOld, address adminNew);\n\n    constructor(address _owner, address _balanceKeeper) {\n        owner = _owner;\n        admin = _owner;\n        balanceKeeper = _balanceKeeper;\n    }\n\n    // getter functions with parameter names\n    function roundName(uint roundId) public view returns (string memory) {\n        return _roundName[roundId];\n    }\n    function roundOptions(uint roundId, uint optionId) public view returns (string memory) {\n        return _roundOptions[roundId][optionId];\n    }\n    function votesForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _votesForOption[roundId][optionId];\n    }\n    function votesInRoundByUser(uint roundId, address user) public view returns (uint) {\n        return _votesInRoundByUser[roundId][user];\n    }\n    function votesForOptionByUser(uint roundId, address user, uint optionId) public view returns (uint) {\n        return _votesForOptionByUser[roundId][user][optionId];\n    }\n    function userVotedInRound(uint roundId, address user) public view returns (bool) {\n        return _userVotedInRound[roundId][user];\n    }\n    function userVotedForOption(uint roundId, uint optionId, address user) public view returns (bool) {\n        return _userVotedForOption[roundId][optionId][user];\n    }\n    function totalUsersInRound(uint roundId) public view returns (uint) {\n        return _totalUsersInRound[roundId];\n    }\n    function totalUsersForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _totalUsersForOption[roundId][optionId];\n    }\n\n    // sum of all votes in a round\n    function votesInRound(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint optionId = 0; optionId < _votesForOption[roundId].length; optionId++) {\n            sum += _votesForOption[roundId][optionId];\n        }\n        return sum;\n    }\n\n    // number of \u0441urrently active rounds\n    function totalActiveRounds() public view returns (uint) {\n        return activeRounds.length;\n    }\n\n    // number of finalized past rounds\n    function totalPastRounds() public view returns (uint) {\n        return pastRounds.length;\n    }\n\n    // number of options in a round\n    function totalRoundOptions(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint i = 0; i < _roundOptions[roundId].length; i++) {\n            sum ++;\n        }\n        return sum;\n    }\n\n    function setOwner(address _owner) public isOwner {\n        address ownerOld = owner;\n        owner = _owner;\n        emit SetOwner(ownerOld, _owner);\n    }\n\n    function setAdmin(address _admin) public isAdmin {\n        address adminOld = admin;\n        admin = _admin;\n        emit SetAdmin(adminOld, _admin);\n    }\n\n    function startRound(string memory name, string[] memory options) public isAdmin {\n        _roundName[totalRounds] = name;\n        _roundOptions[totalRounds] = options;\n        _votesForOption[totalRounds] = new uint[](options.length);\n        activeRounds.push(totalRounds);\n        totalRounds++;\n        emit StartRound(msg.sender, totalRounds, name, options);\n    }\n\n    function isActiveRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isPastRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < pastRounds.length; i++) {\n            if (pastRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function castVotes(uint roundId, uint[] memory votes) public {\n\n        // fail if roundId is not an active vote\n        require(isActiveRound(roundId), \"roundId is not an active vote\");\n\n        // fail if votes doesn't match number of options in roundId\n        require(votes.length == _roundOptions[roundId].length, \"number of votes doesn't match number of options\");\n\n        // fail if balance of sender is smaller than the sum of votes\n        uint sum;\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n            sum += votes[optionId];\n        }\n        require(IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender)) >= sum, \"balance is smaller than the sum of votes\");\n\n        // if msg.sender already voted in roundId, erase their previous votes\n        if (_votesInRoundByUser[roundId][msg.sender] != 0) {\n            uint[] memory oldVotes = _votesForOptionByUser[roundId][msg.sender];\n            for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n                _votesForOption[roundId][optionId] -= oldVotes[optionId];\n            }\n        }\n\n        // update sender's votes\n        _votesForOptionByUser[roundId][msg.sender] = votes;\n\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n\n            if (!_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] != 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = true;\n                _totalUsersForOption[roundId][optionId]++;\n            }\n\n            if (_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] == 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = false;\n                _totalUsersForOption[roundId][optionId]--;\n            }\n\n            _votesForOption[roundId][optionId] += votes[optionId];\n        }\n\n        _votesInRoundByUser[roundId][msg.sender] = sum;\n\n        if (!_userVotedInRound[roundId][msg.sender] && sum != 0) {\n            _userVotedInRound[roundId][msg.sender] = true;\n            _totalUsersInRound[roundId]++;\n        }\n        if (_userVotedInRound[roundId][msg.sender] && sum == 0) {\n            _userVotedInRound[roundId][msg.sender] = false;\n            _totalUsersInRound[roundId]--;\n        }\n\n        emit CastVotes(msg.sender, roundId);\n    }\n\n    // allow/forbid oracle to check votes\n    function setCanCheck(address checker, bool _canCheck) public isOwner {\n        canCheck[checker] = _canCheck;\n        emit SetCanCheck(msg.sender, checker, canCheck[checker]);\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalance(uint roundId, address user, uint newBalance) internal {\n        // return if newBalance is still larger than the number of votes\n        // return if user didn't vote\n        if (newBalance > _votesInRoundByUser[roundId][user] ||\n            _votesInRoundByUser[roundId][user] == 0) {\n            return;\n        }\n        uint[] storage oldVotes = _votesForOptionByUser[roundId][user];\n        uint newSum;\n        for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n            uint oldVoteBalance = oldVotes[optionId];\n            uint newVoteBalance = oldVoteBalance * newBalance / _votesInRoundByUser[roundId][user];\n            _votesForOption[roundId][optionId] -= (oldVoteBalance - newVoteBalance);\n            _votesForOptionByUser[roundId][user][optionId] = newVoteBalance;\n            newSum += newVoteBalance;\n        }\n        _votesInRoundByUser[roundId][user] = newSum;\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalances(address user) public override {\n        require(canCheck[msg.sender], \"sender is not allowed to check balances\");\n        uint newBalance = IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender));\n        for(uint i = 0; i < activeRounds.length; i++) {\n            checkVoteBalance(activeRounds[i], user, newBalance);\n        }\n        emit CheckVoteBalances(msg.sender, user, newBalance);\n    }\n\n    // move roundId from activeRounds to pastRounds\n    function finalizeRound(uint roundId) public isAdmin {\n        uint[] memory filteredRounds = new uint[](activeRounds.length-1);\n        uint j = 0;\n        for (uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                continue;\n            }\n            filteredRounds[j] = activeRounds[i];\n            j++;\n        }\n        activeRounds = filteredRounds;\n        pastRounds.push(roundId);\n        emit FinalizeRound(msg.sender, roundId);\n    }\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.8.0;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBalanceKeeperV2 {\n    function userChainById\n        (uint userId)\n        external view returns (string memory);\n    function userAddressById\n        (uint userId)\n        external view returns (bytes calldata);\n    function userChainAddressById\n        (uint userId)\n        external view returns (string calldata, bytes calldata);\n    function userIdByChainAddress\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external view returns (uint);\n    function isKnownUser\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external view returns (bool);\n    function isKnownUser\n        (uint userId)\n        external view returns (bool);\n    function totalUsers() external view returns (uint);\n    function balance\n        (uint userId)\n        external view returns (uint);\n    function balance\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external view returns (uint);\n    function totalBalance() external view returns (uint);\n    function open\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external;\n    function add\n        (uint userId,\n         uint amount)\n        external;\n    function add\n        (string calldata userChain,\n         bytes calldata userAddress,\n         uint amount)\n        external;\n    function subtract\n        (uint userId,\n         uint amount)\n        external;\n    function subtract\n        (string calldata userChain,\n         bytes calldata userAddress,\n         uint amount)\n        external;\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IVoter {\n    function checkVoteBalances(address user) external;\n}\n\n/// @title VoterV2\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ncontract VoterV2 is IVoter {\n\n    address public owner;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    address public admin;\n\n    modifier isAdmin() {\n        require(msg.sender == admin, \"Caller is not admin\");\n        _;\n    }\n\n    address public balanceKeeper;\n\n    uint public totalRounds;\n    uint[] public activeRounds;\n    uint[] public pastRounds;\n    mapping(uint => string) internal _roundName;\n    mapping(uint => string[]) internal _roundOptions;\n\n    mapping(uint => uint[]) internal _votesForOption;\n\n    mapping(uint => mapping(address => uint)) internal _votesInRoundByUser;\n    mapping(uint => mapping(address => uint[])) internal _votesForOptionByUser;\n\n    mapping(uint => mapping(address => bool)) internal _userVotedInRound;\n    mapping(uint => mapping(uint => mapping(address => bool))) internal _userVotedForOption;\n\n    mapping(uint => uint) internal _totalUsersInRound;\n    mapping(uint => mapping(uint => uint)) internal _totalUsersForOption;\n\n    mapping(address => bool) public canCheck;\n\n    event CastVotes(address indexed voter, uint indexed roundId);\n    event StartRound(address indexed owner, uint totalRounds, string name, string[] options);\n    event SetCanCheck(address indexed owner, address indexed checker, bool indexed newBool);\n    event CheckVoteBalances(address indexed checker, address indexed user, uint newBalance);\n    event FinalizeRound(address indexed owner, uint roundId);\n    event SetOwner(address ownerOld, address ownerNew);\n    event SetAdmin(address adminOld, address adminNew);\n\n    constructor(address _owner, address _balanceKeeper) {\n        owner = _owner;\n        admin = _owner;\n        balanceKeeper = _balanceKeeper;\n    }\n\n    // getter functions with parameter names\n    function roundName(uint roundId) public view returns (string memory) {\n        return _roundName[roundId];\n    }\n    function roundOptions(uint roundId, uint optionId) public view returns (string memory) {\n        return _roundOptions[roundId][optionId];\n    }\n    function votesForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _votesForOption[roundId][optionId];\n    }\n    function votesInRoundByUser(uint roundId, address user) public view returns (uint) {\n        return _votesInRoundByUser[roundId][user];\n    }\n    function votesForOptionByUser(uint roundId, address user, uint optionId) public view returns (uint) {\n        return _votesForOptionByUser[roundId][user][optionId];\n    }\n    function userVotedInRound(uint roundId, address user) public view returns (bool) {\n        return _userVotedInRound[roundId][user];\n    }\n    function userVotedForOption(uint roundId, uint optionId, address user) public view returns (bool) {\n        return _userVotedForOption[roundId][optionId][user];\n    }\n    function totalUsersInRound(uint roundId) public view returns (uint) {\n        return _totalUsersInRound[roundId];\n    }\n    function totalUsersForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _totalUsersForOption[roundId][optionId];\n    }\n\n    // sum of all votes in a round\n    function votesInRound(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint optionId = 0; optionId < _votesForOption[roundId].length; optionId++) {\n            sum += _votesForOption[roundId][optionId];\n        }\n        return sum;\n    }\n\n    // number of \u0441urrently active rounds\n    function totalActiveRounds() public view returns (uint) {\n        return activeRounds.length;\n    }\n\n    // number of finalized past rounds\n    function totalPastRounds() public view returns (uint) {\n        return pastRounds.length;\n    }\n\n    // number of options in a round\n    function totalRoundOptions(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint i = 0; i < _roundOptions[roundId].length; i++) {\n            sum ++;\n        }\n        return sum;\n    }\n\n    function setOwner(address _owner) public isOwner {\n        address ownerOld = owner;\n        owner = _owner;\n        emit SetOwner(ownerOld, _owner);\n    }\n\n    function setAdmin(address _admin) public isAdmin {\n        address adminOld = admin;\n        admin = _admin;\n        emit SetAdmin(adminOld, _admin);\n    }\n\n    function startRound(string memory name, string[] memory options) public isAdmin {\n        _roundName[totalRounds] = name;\n        _roundOptions[totalRounds] = options;\n        _votesForOption[totalRounds] = new uint[](options.length);\n        activeRounds.push(totalRounds);\n        totalRounds++;\n        emit StartRound(msg.sender, totalRounds, name, options);\n    }\n\n    function isActiveRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isPastRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < pastRounds.length; i++) {\n            if (pastRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function castVotes(uint roundId, uint[] memory votes) public {\n\n        // fail if roundId is not an active vote\n        require(isActiveRound(roundId), \"roundId is not an active vote\");\n\n        // fail if votes doesn't match number of options in roundId\n        require(votes.length == _roundOptions[roundId].length, \"number of votes doesn't match number of options\");\n\n        // fail if balance of sender is smaller than the sum of votes\n        uint sum;\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n            sum += votes[optionId];\n        }\n        require(IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender)) >= sum, \"balance is smaller than the sum of votes\");\n\n        // if msg.sender already voted in roundId, erase their previous votes\n        if (_votesInRoundByUser[roundId][msg.sender] != 0) {\n            uint[] memory oldVotes = _votesForOptionByUser[roundId][msg.sender];\n            for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n                _votesForOption[roundId][optionId] -= oldVotes[optionId];\n            }\n        }\n\n        // update sender's votes\n        _votesForOptionByUser[roundId][msg.sender] = votes;\n\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n\n            if (!_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] != 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = true;\n                _totalUsersForOption[roundId][optionId]++;\n            }\n\n            if (_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] == 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = false;\n                _totalUsersForOption[roundId][optionId]--;\n            }\n\n            _votesForOption[roundId][optionId] += votes[optionId];\n        }\n\n        _votesInRoundByUser[roundId][msg.sender] = sum;\n\n        if (!_userVotedInRound[roundId][msg.sender] && sum != 0) {\n            _userVotedInRound[roundId][msg.sender] = true;\n            _totalUsersInRound[roundId]++;\n        }\n        if (_userVotedInRound[roundId][msg.sender] && sum == 0) {\n            _userVotedInRound[roundId][msg.sender] = false;\n            _totalUsersInRound[roundId]--;\n        }\n\n        emit CastVotes(msg.sender, roundId);\n    }\n\n    // allow/forbid oracle to check votes\n    function setCanCheck(address checker, bool _canCheck) public isOwner {\n        canCheck[checker] = _canCheck;\n        emit SetCanCheck(msg.sender, checker, canCheck[checker]);\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalance(uint roundId, address user, uint newBalance) internal {\n        // return if newBalance is still larger than the number of votes\n        // return if user didn't vote\n        if (newBalance > _votesInRoundByUser[roundId][user] ||\n            _votesInRoundByUser[roundId][user] == 0) {\n            return;\n        }\n        uint[] storage oldVotes = _votesForOptionByUser[roundId][user];\n        uint newSum;\n        for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n            uint oldVoteBalance = oldVotes[optionId];\n            uint newVoteBalance = oldVoteBalance * newBalance / _votesInRoundByUser[roundId][user];\n            _votesForOption[roundId][optionId] -= (oldVoteBalance - newVoteBalance);\n            _votesForOptionByUser[roundId][user][optionId] = newVoteBalance;\n            newSum += newVoteBalance;\n        }\n        _votesInRoundByUser[roundId][user] = newSum;\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalances(address user) public override {\n        require(canCheck[msg.sender], \"sender is not allowed to check balances\");\n        uint newBalance = IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender));\n        for(uint i = 0; i < activeRounds.length; i++) {\n            checkVoteBalance(activeRounds[i], user, newBalance);\n        }\n        emit CheckVoteBalances(msg.sender, user, newBalance);\n    }\n\n    // move roundId from activeRounds to pastRounds\n    function finalizeRound(uint roundId) public isAdmin {\n        uint[] memory filteredRounds = new uint[](activeRounds.length-1);\n        uint j = 0;\n        for (uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                continue;\n            }\n            filteredRounds[j] = activeRounds[i];\n            j++;\n        }\n        activeRounds = filteredRounds;\n        pastRounds.push(roundId);\n        emit FinalizeRound(msg.sender, roundId);\n    }\n}\n", "commit_id": "3c5d7d4f47107b35ff85c29e38306450bd1c43eb"}, "fixed_version": {"raw_code": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interfaces/IBalanceKeeperV2.sol\";\nimport \"./interfaces/IVoter.sol\";\n\n/// @title VoterV2\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ncontract VoterV2 is IVoter {\n\n    address public owner;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    address public balanceKeeper;\n\n    uint public totalRounds;\n    uint[] public activeRounds;\n    uint[] public pastRounds;\n    mapping(uint => string) internal _roundName;\n    mapping(uint => string[]) internal _roundOptions;\n\n    mapping(uint => uint[]) internal _votesForOption;\n\n    mapping(uint => mapping(address => uint)) internal _votesInRoundByUser;\n    mapping(uint => mapping(address => uint[])) internal _votesForOptionByUser;\n\n    mapping(uint => mapping(address => bool)) internal _userVotedInRound;\n    mapping(uint => mapping(uint => mapping(address => bool))) internal _userVotedForOption;\n\n    mapping(uint => uint) internal _totalUsersInRound;\n    mapping(uint => mapping(uint => uint)) internal _totalUsersForOption;\n\n    mapping(address => bool) public canCheck;\n\n    event CastVotes(address indexed voter, uint indexed roundId);\n    event StartRound(address indexed owner, uint totalRounds, string name, string[] options);\n    event SetCanCheck(address indexed owner, address indexed checker, bool indexed newBool);\n    event CheckVoteBalances(address indexed checker, address indexed user, uint newBalance);\n    event FinalizeRound(address indexed owner, uint roundId);\n    event SetOwner(address ownerOld, address ownerNew);\n\n    constructor(address _owner, address _balanceKeeper) {\n        owner = _owner;\n        balanceKeeper = _balanceKeeper;\n    }\n\n    // getter functions with parameter names\n    function roundName(uint roundId) public view returns (string memory) {\n        return _roundName[roundId];\n    }\n    function roundOptions(uint roundId, uint optionId) public view returns (string memory) {\n        return _roundOptions[roundId][optionId];\n    }\n    function votesForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _votesForOption[roundId][optionId];\n    }\n    function votesInRoundByUser(uint roundId, address user) public view returns (uint) {\n        return _votesInRoundByUser[roundId][user];\n    }\n    function votesForOptionByUser(uint roundId, address user, uint optionId) public view returns (uint) {\n        return _votesForOptionByUser[roundId][user][optionId];\n    }\n    function userVotedInRound(uint roundId, address user) public view returns (bool) {\n        return _userVotedInRound[roundId][user];\n    }\n    function userVotedForOption(uint roundId, uint optionId, address user) public view returns (bool) {\n        return _userVotedForOption[roundId][optionId][user];\n    }\n    function totalUsersInRound(uint roundId) public view returns (uint) {\n        return _totalUsersInRound[roundId];\n    }\n    function totalUsersForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _totalUsersForOption[roundId][optionId];\n    }\n\n    // sum of all votes in a round\n    function votesInRound(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint optionId = 0; optionId < _votesForOption[roundId].length; optionId++) {\n            sum += _votesForOption[roundId][optionId];\n        }\n        return sum;\n    }\n\n    // number of \u0441urrently active rounds\n    function totalActiveRounds() public view returns (uint) {\n        return activeRounds.length;\n    }\n\n    // number of finalized past rounds\n    function totalPastRounds() public view returns (uint) {\n        return pastRounds.length;\n    }\n\n    // number of options in a round\n    function totalRoundOptions(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint i = 0; i < _roundOptions[roundId].length; i++) {\n            sum ++;\n        }\n        return sum;\n    }\n\n    function setOwner(address _owner) public isOwner {\n        address ownerOld = owner;\n        owner = _owner;\n        emit SetOwner(ownerOld, _owner);\n    }\n\n    function startRound(string memory name, string[] memory options) public isOwner {\n        _roundName[totalRounds] = name;\n        _roundOptions[totalRounds] = options;\n        _votesForOption[totalRounds] = new uint[](options.length);\n        activeRounds.push(totalRounds);\n        totalRounds++;\n        emit StartRound(msg.sender, totalRounds, name, options);\n    }\n\n    function isActiveRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isPastRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < pastRounds.length; i++) {\n            if (pastRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function castVotes(uint roundId, uint[] memory votes) public {\n\n        // fail if roundId is not an active vote\n        require(isActiveRound(roundId), \"roundId is not an active vote\");\n\n        // fail if votes doesn't match number of options in roundId\n        require(votes.length == _roundOptions[roundId].length, \"number of votes doesn't match number of options\");\n\n        // fail if balance of sender is smaller than the sum of votes\n        uint sum;\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n            sum += votes[optionId];\n        }\n        require(IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender)) >= sum, \"balance is smaller than the sum of votes\");\n\n        // if msg.sender already voted in roundId, erase their previous votes\n        if (_votesInRoundByUser[roundId][msg.sender] != 0) {\n            uint[] memory oldVotes = _votesForOptionByUser[roundId][msg.sender];\n            for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n                _votesForOption[roundId][optionId] -= oldVotes[optionId];\n            }\n        }\n\n        // update sender's votes\n        _votesForOptionByUser[roundId][msg.sender] = votes;\n\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n\n            if (!_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] != 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = true;\n                _totalUsersForOption[roundId][optionId]++;\n            }\n\n            if (_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] == 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = false;\n                _totalUsersForOption[roundId][optionId]--;\n            }\n\n            _votesForOption[roundId][optionId] += votes[optionId];\n        }\n\n        _votesInRoundByUser[roundId][msg.sender] = sum;\n\n        if (!_userVotedInRound[roundId][msg.sender] && sum != 0) {\n            _userVotedInRound[roundId][msg.sender] = true;\n            _totalUsersInRound[roundId]++;\n        }\n        if (_userVotedInRound[roundId][msg.sender] && sum == 0) {\n            _userVotedInRound[roundId][msg.sender] = false;\n            _totalUsersInRound[roundId]--;\n        }\n\n        emit CastVotes(msg.sender, roundId);\n    }\n\n    // allow/forbid oracle to check votes\n    function setCanCheck(address checker, bool _canCheck) public isOwner {\n        canCheck[checker] = _canCheck;\n        emit SetCanCheck(msg.sender, checker, canCheck[checker]);\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalance(uint roundId, address user, uint newBalance) internal {\n        // return if newBalance is still larger than the number of votes\n        // return if user didn't vote\n        if (newBalance > _votesInRoundByUser[roundId][user] ||\n            _votesInRoundByUser[roundId][user] == 0) {\n            return;\n        }\n        uint[] storage oldVotes = _votesForOptionByUser[roundId][user];\n        uint newSum;\n        for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n            uint oldVoteBalance = oldVotes[optionId];\n            uint newVoteBalance = oldVoteBalance * newBalance / _votesInRoundByUser[roundId][user];\n            _votesForOption[roundId][optionId] -= (oldVoteBalance - newVoteBalance);\n            _votesForOptionByUser[roundId][user][optionId] = newVoteBalance;\n            newSum += newVoteBalance;\n        }\n        _votesInRoundByUser[roundId][user] = newSum;\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalances(address user) public override {\n        require(canCheck[msg.sender], \"sender is not allowed to check balances\");\n        uint newBalance = IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender));\n        for(uint i = 0; i < activeRounds.length; i++) {\n            checkVoteBalance(activeRounds[i], user, newBalance);\n        }\n        emit CheckVoteBalances(msg.sender, user, newBalance);\n    }\n\n    // move roundId from activeRounds to pastRounds\n    function finalizeRound(uint roundId) public isOwner {\n        uint[] memory filteredRounds = new uint[](activeRounds.length-1);\n        uint j = 0;\n        for (uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                continue;\n            }\n            filteredRounds[j] = activeRounds[i];\n            j++;\n        }\n        activeRounds = filteredRounds;\n        pastRounds.push(roundId);\n        emit FinalizeRound(msg.sender, roundId);\n    }\n}\n", "flattened_code": "//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.8.0;\n\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBalanceKeeperV2 {\n    function userChainById\n        (uint userId)\n        external view returns (string memory);\n    function userAddressById\n        (uint userId)\n        external view returns (bytes calldata);\n    function userChainAddressById\n        (uint userId)\n        external view returns (string calldata, bytes calldata);\n    function userIdByChainAddress\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external view returns (uint);\n    function isKnownUser\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external view returns (bool);\n    function isKnownUser\n        (uint userId)\n        external view returns (bool);\n    function totalUsers() external view returns (uint);\n    function balance\n        (uint userId)\n        external view returns (uint);\n    function balance\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external view returns (uint);\n    function totalBalance() external view returns (uint);\n    function open\n        (string calldata userChain,\n         bytes calldata userAddress)\n        external;\n    function add\n        (uint userId,\n         uint amount)\n        external;\n    function add\n        (string calldata userChain,\n         bytes calldata userAddress,\n         uint amount)\n        external;\n    function subtract\n        (uint userId,\n         uint amount)\n        external;\n    function subtract\n        (string calldata userChain,\n         bytes calldata userAddress,\n         uint amount)\n        external;\n}\n//IGNORE_LICENSE-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IVoter {\n    function checkVoteBalances(address user) external;\n}\n\n/// @title VoterV2\n/// @author Artemij Artamonov - <array.clean@gmail.com>\n/// @author Anton Davydov - <fetsorn@gmail.com>\ncontract VoterV2 is IVoter {\n\n    address public owner;\n\n    modifier isOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    address public balanceKeeper;\n\n    uint public totalRounds;\n    uint[] public activeRounds;\n    uint[] public pastRounds;\n    mapping(uint => string) internal _roundName;\n    mapping(uint => string[]) internal _roundOptions;\n\n    mapping(uint => uint[]) internal _votesForOption;\n\n    mapping(uint => mapping(address => uint)) internal _votesInRoundByUser;\n    mapping(uint => mapping(address => uint[])) internal _votesForOptionByUser;\n\n    mapping(uint => mapping(address => bool)) internal _userVotedInRound;\n    mapping(uint => mapping(uint => mapping(address => bool))) internal _userVotedForOption;\n\n    mapping(uint => uint) internal _totalUsersInRound;\n    mapping(uint => mapping(uint => uint)) internal _totalUsersForOption;\n\n    mapping(address => bool) public canCheck;\n\n    event CastVotes(address indexed voter, uint indexed roundId);\n    event StartRound(address indexed owner, uint totalRounds, string name, string[] options);\n    event SetCanCheck(address indexed owner, address indexed checker, bool indexed newBool);\n    event CheckVoteBalances(address indexed checker, address indexed user, uint newBalance);\n    event FinalizeRound(address indexed owner, uint roundId);\n    event SetOwner(address ownerOld, address ownerNew);\n\n    constructor(address _owner, address _balanceKeeper) {\n        owner = _owner;\n        balanceKeeper = _balanceKeeper;\n    }\n\n    // getter functions with parameter names\n    function roundName(uint roundId) public view returns (string memory) {\n        return _roundName[roundId];\n    }\n    function roundOptions(uint roundId, uint optionId) public view returns (string memory) {\n        return _roundOptions[roundId][optionId];\n    }\n    function votesForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _votesForOption[roundId][optionId];\n    }\n    function votesInRoundByUser(uint roundId, address user) public view returns (uint) {\n        return _votesInRoundByUser[roundId][user];\n    }\n    function votesForOptionByUser(uint roundId, address user, uint optionId) public view returns (uint) {\n        return _votesForOptionByUser[roundId][user][optionId];\n    }\n    function userVotedInRound(uint roundId, address user) public view returns (bool) {\n        return _userVotedInRound[roundId][user];\n    }\n    function userVotedForOption(uint roundId, uint optionId, address user) public view returns (bool) {\n        return _userVotedForOption[roundId][optionId][user];\n    }\n    function totalUsersInRound(uint roundId) public view returns (uint) {\n        return _totalUsersInRound[roundId];\n    }\n    function totalUsersForOption(uint roundId, uint optionId) public view returns (uint) {\n        return _totalUsersForOption[roundId][optionId];\n    }\n\n    // sum of all votes in a round\n    function votesInRound(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint optionId = 0; optionId < _votesForOption[roundId].length; optionId++) {\n            sum += _votesForOption[roundId][optionId];\n        }\n        return sum;\n    }\n\n    // number of \u0441urrently active rounds\n    function totalActiveRounds() public view returns (uint) {\n        return activeRounds.length;\n    }\n\n    // number of finalized past rounds\n    function totalPastRounds() public view returns (uint) {\n        return pastRounds.length;\n    }\n\n    // number of options in a round\n    function totalRoundOptions(uint roundId) public view returns (uint) {\n        uint sum;\n        for (uint i = 0; i < _roundOptions[roundId].length; i++) {\n            sum ++;\n        }\n        return sum;\n    }\n\n    function setOwner(address _owner) public isOwner {\n        address ownerOld = owner;\n        owner = _owner;\n        emit SetOwner(ownerOld, _owner);\n    }\n\n    function startRound(string memory name, string[] memory options) public isOwner {\n        _roundName[totalRounds] = name;\n        _roundOptions[totalRounds] = options;\n        _votesForOption[totalRounds] = new uint[](options.length);\n        activeRounds.push(totalRounds);\n        totalRounds++;\n        emit StartRound(msg.sender, totalRounds, name, options);\n    }\n\n    function isActiveRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function isPastRound(uint roundId) public view returns (bool) {\n        for(uint i = 0; i < pastRounds.length; i++) {\n            if (pastRounds[i] == roundId) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function castVotes(uint roundId, uint[] memory votes) public {\n\n        // fail if roundId is not an active vote\n        require(isActiveRound(roundId), \"roundId is not an active vote\");\n\n        // fail if votes doesn't match number of options in roundId\n        require(votes.length == _roundOptions[roundId].length, \"number of votes doesn't match number of options\");\n\n        // fail if balance of sender is smaller than the sum of votes\n        uint sum;\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n            sum += votes[optionId];\n        }\n        require(IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender)) >= sum, \"balance is smaller than the sum of votes\");\n\n        // if msg.sender already voted in roundId, erase their previous votes\n        if (_votesInRoundByUser[roundId][msg.sender] != 0) {\n            uint[] memory oldVotes = _votesForOptionByUser[roundId][msg.sender];\n            for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n                _votesForOption[roundId][optionId] -= oldVotes[optionId];\n            }\n        }\n\n        // update sender's votes\n        _votesForOptionByUser[roundId][msg.sender] = votes;\n\n        for (uint optionId = 0; optionId < votes.length; optionId++) {\n\n            if (!_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] != 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = true;\n                _totalUsersForOption[roundId][optionId]++;\n            }\n\n            if (_userVotedForOption[roundId][optionId][msg.sender] && votes[optionId] == 0) {\n                _userVotedForOption[roundId][optionId][msg.sender] = false;\n                _totalUsersForOption[roundId][optionId]--;\n            }\n\n            _votesForOption[roundId][optionId] += votes[optionId];\n        }\n\n        _votesInRoundByUser[roundId][msg.sender] = sum;\n\n        if (!_userVotedInRound[roundId][msg.sender] && sum != 0) {\n            _userVotedInRound[roundId][msg.sender] = true;\n            _totalUsersInRound[roundId]++;\n        }\n        if (_userVotedInRound[roundId][msg.sender] && sum == 0) {\n            _userVotedInRound[roundId][msg.sender] = false;\n            _totalUsersInRound[roundId]--;\n        }\n\n        emit CastVotes(msg.sender, roundId);\n    }\n\n    // allow/forbid oracle to check votes\n    function setCanCheck(address checker, bool _canCheck) public isOwner {\n        canCheck[checker] = _canCheck;\n        emit SetCanCheck(msg.sender, checker, canCheck[checker]);\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalance(uint roundId, address user, uint newBalance) internal {\n        // return if newBalance is still larger than the number of votes\n        // return if user didn't vote\n        if (newBalance > _votesInRoundByUser[roundId][user] ||\n            _votesInRoundByUser[roundId][user] == 0) {\n            return;\n        }\n        uint[] storage oldVotes = _votesForOptionByUser[roundId][user];\n        uint newSum;\n        for (uint optionId = 0; optionId < oldVotes.length; optionId++) {\n            uint oldVoteBalance = oldVotes[optionId];\n            uint newVoteBalance = oldVoteBalance * newBalance / _votesInRoundByUser[roundId][user];\n            _votesForOption[roundId][optionId] -= (oldVoteBalance - newVoteBalance);\n            _votesForOptionByUser[roundId][user][optionId] = newVoteBalance;\n            newSum += newVoteBalance;\n        }\n        _votesInRoundByUser[roundId][user] = newSum;\n    }\n\n    // decrease votes when the balance is depleted, preserve proportions\n    function checkVoteBalances(address user) public override {\n        require(canCheck[msg.sender], \"sender is not allowed to check balances\");\n        uint newBalance = IBalanceKeeperV2(balanceKeeper).balance(\"EVM\", abi.encodePacked(msg.sender));\n        for(uint i = 0; i < activeRounds.length; i++) {\n            checkVoteBalance(activeRounds[i], user, newBalance);\n        }\n        emit CheckVoteBalances(msg.sender, user, newBalance);\n    }\n\n    // move roundId from activeRounds to pastRounds\n    function finalizeRound(uint roundId) public isOwner {\n        uint[] memory filteredRounds = new uint[](activeRounds.length-1);\n        uint j = 0;\n        for (uint i = 0; i < activeRounds.length; i++) {\n            if (activeRounds[i] == roundId) {\n                continue;\n            }\n            filteredRounds[j] = activeRounds[i];\n            j++;\n        }\n        activeRounds = filteredRounds;\n        pastRounds.push(roundId);\n        emit FinalizeRound(msg.sender, roundId);\n    }\n}\n", "commit_id": "d51138e0fecacd2e0d1a85ef0b9cbed2725a0156"}}